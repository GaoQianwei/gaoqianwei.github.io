<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>近期说明</title>
    <url>/2021/04/10/top%EF%BC%9A%E8%AF%B4%E6%98%8E/</url>
    <content><![CDATA[<p>&ensp;&ensp;介绍一些博客较大的变化（增删改查）以及其它说明。</p>
<span id="more"></span>

<h3 id="2021年5月7日"><a href="#2021年5月7日" class="headerlink" title="2021年5月7日"></a>2021年5月7日</h3><p>&ensp;&ensp;&ensp;&ensp;增加了一些有关二叉树的算法题，不再像链表题那样一个题一篇博客，而是一类题一篇博客；同时由于在学习<code>Shell</code>，所以还增加了两篇和<code>Shell</code>相关的博客。</p>
<h3 id="2021年5月1日"><a href="#2021年5月1日" class="headerlink" title="2021年5月1日"></a>2021年5月1日</h3><p>&ensp;&ensp;&ensp;&ensp;为这个小破站添加了友情链接，主要是收藏自己喜欢的学习网站和好友的博客；同时在侧边栏添加了一个粒子时钟，方便查看时间。</p>
<h3 id="2021年4月29日"><a href="#2021年4月29日" class="headerlink" title="2021年4月29日"></a>2021年4月29日</h3><p>    增添了大量有关链表算法题的文章，都是自己以前写的，今天整理出来了。其它的内容，趁着五一假期，会陆续发布。</p>
]]></content>
  </entry>
  <entry>
    <title>构建二叉树</title>
    <url>/2021/05/07/%E4%BA%8C%E5%8F%89%E6%A0%91%EF%BC%9A%E6%9E%84%E5%BB%BA%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
    <content><![CDATA[<p>    构建二叉树的方式多种多样，可以从前序与中序遍历序列构造二叉树、从中序与后序遍历序列构造二叉树，还可以从有序数组和链表中构建二叉树。掌握构建的前提是理解遍历二叉树和二叉树的结构。</p>
<span id="more"></span>

<h3 id="105-从前序与中序遍历序列构造二叉树"><a href="#105-从前序与中序遍历序列构造二叉树" class="headerlink" title="105. 从前序与中序遍历序列构造二叉树"></a><a href="https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/">105. 从前序与中序遍历序列构造二叉树</a></h3><p>    根据一棵树的前序遍历与中序遍历构造二叉树。</p>
<p>    **注意:**你可以假设树中没有重复的元素。</p>
<p>    例如，给出</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">前序遍历 preorder &#x3D; [3,9,20,15,7]</span><br><span class="line">中序遍历 inorder &#x3D; [9,3,15,20,7]</span><br></pre></td></tr></table></figure>

<p>    返回如下的二叉树：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">  3</span><br><span class="line"> &#x2F; \</span><br><span class="line">9  20</span><br><span class="line">  &#x2F;  \</span><br><span class="line"> 15   7</span><br></pre></td></tr></table></figure>

<p><strong>思路与代码</strong>：</p>
<p>    首先要知道一个结论，前序/后序+中序序列可以唯一确定一棵二叉树，所以自然而然可以用来建树。</p>
<p>    看一下前序和中序有什么特点，前序<code>1,2,4,7,3,5,6,8</code> ，中序<code>4,7,2,1,5,3,8,6</code>；</p>
<p>    有如下特征：</p>
<ol>
<li> 前序中左起第一位<code>1</code>肯定是根结点，我们可以据此找到中序中根结点的位置<code>rootin</code>；</li>
<li> 中序中根结点左边就是左子树结点，右边就是右子树结点，即<code>[左子树结点，根结点，右子树结点]</code>，我们就可以得出左子树结点个数为<code>int left = rootin - leftin;</code>；</li>
<li> 前序中结点分布应该是：<code>[根结点，左子树结点，右子树结点]</code>；</li>
<li> 根据前一步确定的左子树个数，可以确定前序中左子树结点和右子树结点的范围；</li>
<li>如果我们要前序遍历生成二叉树的话，下一层递归应该是：<ul>
<li>  左子树：<code>root-&gt;left = pre_order(前序序列，前序左子树范围，中序序列，中序左子树范围);</code>；</li>
<li>  右子树：<code>root-&gt;right = pre_order(前序序列，前序右子树范围，中序序列，中序右子树范围);</code>。</li>
</ul>
</li>
<li> 每一层递归都要返回当前根结点<code>root</code>；</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">buildTree</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; preorder, vector&lt;<span class="keyword">int</span>&gt;&amp; inorder)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">help</span>(preorder, <span class="number">0</span>, preorder.<span class="built_in">size</span>() - <span class="number">1</span>, </span><br><span class="line">                    inorder, <span class="number">0</span>, inorder.<span class="built_in">size</span>() - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">TreeNode* <span class="title">help</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; preorder, <span class="keyword">int</span> low1, <span class="keyword">int</span> high1, </span></span></span><br><span class="line"><span class="function"><span class="params">                    vector&lt;<span class="keyword">int</span>&gt;&amp; inorder, <span class="keyword">int</span> low2, <span class="keyword">int</span> high2)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(low1 &gt; high1 || low2 &gt; high2)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> root = preorder.<span class="built_in">at</span>(low1);</span><br><span class="line">        <span class="keyword">int</span> mid = low2;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = low2; i &lt;= high2; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(inorder.<span class="built_in">at</span>(i) == root)</span><br><span class="line">            &#123;</span><br><span class="line">                mid = i;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        TreeNode* rootPtr = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(root);</span><br><span class="line"></span><br><span class="line">        rootPtr-&gt;left = <span class="built_in">help</span>(preorder, low1 + <span class="number">1</span>, low1 + mid - low2,</span><br><span class="line">                            inorder, low2, mid - <span class="number">1</span>);</span><br><span class="line">        rootPtr-&gt;right = <span class="built_in">help</span>(preorder, low1 + mid - low2 +<span class="number">1</span>, high1,</span><br><span class="line">                            inorder, mid + <span class="number">1</span>, high2);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> rootPtr;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h3 id="106-从中序与后序遍历序列构造二叉树"><a href="#106-从中序与后序遍历序列构造二叉树" class="headerlink" title="106. 从中序与后序遍历序列构造二叉树"></a><a href="https://leetcode-cn.com/problems/construct-binary-tree-from-inorder-and-postorder-traversal/">106. 从中序与后序遍历序列构造二叉树</a></h3><p>    根据一棵树的中序遍历与后序遍历构造二叉树。</p>
<p>    **注意:**你可以假设树中没有重复的元素。</p>
<p>    例如，给出</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">中序遍历 inorder &#x3D; [9,3,15,20,7]</span><br><span class="line">后序遍历 postorder &#x3D; [9,15,7,20,3]</span><br></pre></td></tr></table></figure>

<p>    返回如下的二叉树：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">  3</span><br><span class="line"> &#x2F; \</span><br><span class="line">9  20</span><br><span class="line">  &#x2F;  \</span><br><span class="line"> 15   7</span><br></pre></td></tr></table></figure>

<p><strong>思路与代码</strong>：</p>
<p>    首先要知道一个结论，前序/后序+中序序列可以唯一确定一棵二叉树，所以自然而然可以用来建树。</p>
<p>    看一下中序和后序有什么特点，中序<code>[9,3,15,20,7]</code> ，后序<code>[9,15,7,20,3]</code>；</p>
<p>    有如下特征：</p>
<ol>
<li> 后序中右起第一位<code>3</code>肯定是根结点，我们可以据此找到中序中根结点的位置<code>rootin</code>；</li>
<li> 中序中根结点左边就是左子树结点，右边就是右子树结点，即<code>[左子树结点，根结点，右子树结点]</code>，我们就可以得出左子树结点个数为<code>int left = rootin - leftin;</code>；</li>
<li> 后序中结点分布应该是：<code>[左子树结点，右子树结点，根结点]</code>；</li>
<li> 根据前一步确定的左子树个数，可以确定后序中左子树结点和右子树结点的范围；</li>
<li>如果我们要前序遍历生成二叉树的话，下一层递归应该是：<ul>
<li>  左子树：<code>root-&gt;left = pre_order(中序序列，中序左子树范围，后序序列，后序左子树范围);</code>；</li>
<li>  右子树：<code>root-&gt;right = pre_order(中序序列，中序右子树范围，后序序列，后序右子树范围);</code>。</li>
</ul>
</li>
<li> 每一层递归都要返回当前根结点<code>root</code>；</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">buildTree</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; inorder, vector&lt;<span class="keyword">int</span>&gt;&amp; postorder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">help</span>(inorder, <span class="number">0</span>, inorder.<span class="built_in">size</span>() - <span class="number">1</span>,</span><br><span class="line">                    postorder, <span class="number">0</span>, postorder.<span class="built_in">size</span>() - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">TreeNode* <span class="title">help</span><span class="params">(<span class="keyword">const</span> vector&lt;<span class="keyword">int</span>&gt;&amp; inorder, <span class="keyword">int</span> low1, <span class="keyword">int</span> high1,</span></span></span><br><span class="line"><span class="function"><span class="params">                   <span class="keyword">const</span> vector&lt;<span class="keyword">int</span>&gt;&amp; postorder, <span class="keyword">int</span> low2, <span class="keyword">int</span> high2)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(low1 &gt;high1 || low2 &gt; high2)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> rootVal = postorder.<span class="built_in">at</span>(high2);</span><br><span class="line">        <span class="keyword">int</span> mid = low1;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = low1; i &lt;= high1; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(inorder.<span class="built_in">at</span>(i) == rootVal)</span><br><span class="line">            &#123;</span><br><span class="line">                mid = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        TreeNode* root = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(rootVal);</span><br><span class="line"></span><br><span class="line">        root-&gt;left = <span class="built_in">help</span>(inorder, low1, mid - <span class="number">1</span>, </span><br><span class="line">                          postorder, low2, low2 + mid - low1 - <span class="number">1</span>);</span><br><span class="line">        root-&gt;right = <span class="built_in">help</span>(inorder, mid + <span class="number">1</span>, high1,</span><br><span class="line">                           postorder, low2 + mid - low1, high2 - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="108-将有序数组转换为二叉搜索树"><a href="#108-将有序数组转换为二叉搜索树" class="headerlink" title="108. 将有序数组转换为二叉搜索树"></a><a href="https://leetcode-cn.com/problems/convert-sorted-array-to-binary-search-tree/">108. 将有序数组转换为二叉搜索树</a></h3><p>    给你一个整数数组 <code>nums</code> ，其中元素已经按 <strong>升序</strong> 排列，请你将其转换为一棵 <strong>高度平衡</strong> 二叉搜索树。</p>
<p>    <strong>高度平衡</strong> 二叉树是一棵满足「每个节点的左右两个子树的高度差的绝对值不超过 1 」的二叉树。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：nums &#x3D; [-10,-3,0,5,9]</span><br><span class="line">输出：[0,-3,9,-10,null,5]</span><br><span class="line">        0</span><br><span class="line">       &#x2F; \</span><br><span class="line">     -3   9</span><br><span class="line">    &#x2F;    &#x2F;</span><br><span class="line">  10    5</span><br><span class="line">解释：[0,-10,5,null,-3,null,9] 也将被视为正确答案：</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：nums &#x3D; [1,3]</span><br><span class="line">输出：[3,1]</span><br><span class="line">   3   1</span><br><span class="line">  &#x2F;     \</span><br><span class="line"> 1       3</span><br><span class="line">解释：[1,3] 和 [3,1] 都是高度平衡二叉搜索树。</span><br></pre></td></tr></table></figure>

<p> <strong>提示：</strong></p>
<ul>
<li>  <code>1 &lt;= nums.length &lt;= 104</code></li>
<li>  <code>-104 &lt;= nums[i] &lt;= 104</code></li>
<li>  <code>nums</code> 按 <strong>严格递增</strong> 顺序排列</li>
</ul>
<p><strong>思路与代码</strong>：</p>
<p>    数组的中间节点即为当前”root”</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">sortedArrayToBST</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">help</span>(nums, <span class="number">0</span>, nums.<span class="built_in">size</span>() - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">TreeNode* <span class="title">help</span><span class="params">(<span class="keyword">const</span> vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(low &gt; high)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> mid = (low + high + <span class="number">1</span>) / <span class="number">2</span> ;</span><br><span class="line"></span><br><span class="line">        TreeNode* root = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(nums.<span class="built_in">at</span>(mid));</span><br><span class="line"></span><br><span class="line">        root-&gt;left = <span class="built_in">help</span>(nums, low, mid - <span class="number">1</span>);</span><br><span class="line">        root-&gt;right = <span class="built_in">help</span>(nums, mid + <span class="number">1</span>, high);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h3 id="109-有序链表转换二叉搜索树"><a href="#109-有序链表转换二叉搜索树" class="headerlink" title="109. 有序链表转换二叉搜索树"></a><a href="https://leetcode-cn.com/problems/convert-sorted-list-to-binary-search-tree/">109. 有序链表转换二叉搜索树</a></h3><p>    给定一个单链表，其中的元素按升序排序，将其转换为高度平衡的二叉搜索树。</p>
<p>    本题中，一个高度平衡二叉树是指一个二叉树<em>每个节点</em> 的左右两个子树的高度差的绝对值不超过 1。</p>
<p><strong>示例:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">给定的有序链表： [-10, -3, 0, 5, 9],</span><br><span class="line"></span><br><span class="line">一个可能的答案是：[0, -3, 9, -10, null, 5], 它可以表示下面这个高度平衡二叉搜索树：</span><br><span class="line"></span><br><span class="line">      0</span><br><span class="line">     &#x2F; \</span><br><span class="line">   -3   9</span><br><span class="line">   &#x2F;   &#x2F;</span><br><span class="line"> -10  5</span><br></pre></td></tr></table></figure>

<p><strong>思路与代码</strong>：</p>
<p>    还是找中间节点</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">sortedListToBST</span><span class="params">(ListNode* head)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">       </span><br><span class="line">        <span class="keyword">if</span>(!head)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(head-&gt;next == <span class="literal">nullptr</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">TreeNode</span>(head-&gt;val);</span><br><span class="line">    </span><br><span class="line">        <span class="comment">//双指针，找中点</span></span><br><span class="line">        ListNode* pre = head;</span><br><span class="line">        ListNode* p = head-&gt;next;</span><br><span class="line">        ListNode* q = p-&gt;next;        </span><br><span class="line">        <span class="keyword">while</span>(q != <span class="literal">nullptr</span> &amp;&amp; q-&gt;next != <span class="literal">nullptr</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            pre = pre-&gt;next;</span><br><span class="line">            p = pre-&gt;next;</span><br><span class="line">            q = q-&gt;next-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        pre-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">        TreeNode* root = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(p-&gt;val); </span><br><span class="line">        root-&gt;left = <span class="built_in">sortedListToBST</span>(head);</span><br><span class="line">        root-&gt;right = <span class="built_in">sortedListToBST</span>(p-&gt;next);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h3 id="654-最大二叉树"><a href="#654-最大二叉树" class="headerlink" title="654. 最大二叉树"></a><a href="https://leetcode-cn.com/problems/maximum-binary-tree/">654. 最大二叉树</a></h3><p>    给定一个不含重复元素的整数数组 <code>nums</code> 。一个以此数组直接递归构建的 <strong>最大二叉树</strong> 定义如下：</p>
<ol>
<li> 二叉树的根是数组 <code>nums</code> 中的最大元素。</li>
<li> 左子树是通过数组中 <strong>最大值左边部分</strong> 递归构造出的最大二叉树。</li>
<li> 右子树是通过数组中 <strong>最大值右边部分</strong> 递归构造出的最大二叉树。</li>
</ol>
<p>返回有给定数组 <code>nums</code> 构建的 <strong>最大二叉树</strong> 。 </p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：nums &#x3D; [3,2,1,6,0,5]</span><br><span class="line">输出：[6,3,5,null,2,0,null,null,1]</span><br><span class="line">            6</span><br><span class="line">          &#x2F;   \</span><br><span class="line">        3       5</span><br><span class="line">         \    &#x2F;</span><br><span class="line">          2  0</span><br><span class="line">           \</span><br><span class="line">            1</span><br><span class="line">解释：递归调用如下所示：</span><br><span class="line">- [3,2,1,6,0,5] 中的最大值是 6 ，左边部分是 [3,2,1] ，右边部分是 [0,5] 。</span><br><span class="line">    - [3,2,1] 中的最大值是 3 ，左边部分是 [] ，右边部分是 [2,1] 。</span><br><span class="line">        - 空数组，无子节点。</span><br><span class="line">        - [2,1] 中的最大值是 2 ，左边部分是 [] ，右边部分是 [1] 。</span><br><span class="line">            - 空数组，无子节点。</span><br><span class="line">            - 只有一个元素，所以子节点是一个值为 1 的节点。</span><br><span class="line">    - [0,5] 中的最大值是 5 ，左边部分是 [0] ，右边部分是 [] 。</span><br><span class="line">        - 只有一个元素，所以子节点是一个值为 0 的节点。</span><br><span class="line">        - 空数组，无子节点。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：nums &#x3D; [3,2,1]</span><br><span class="line">输出：[3,null,2,null,1]</span><br><span class="line">    3</span><br><span class="line">     \</span><br><span class="line">      2</span><br><span class="line">       \</span><br><span class="line">        1 </span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li>  <code>1 &lt;= nums.length &lt;= 1000</code></li>
<li>  <code>0 &lt;= nums[i] &lt;= 1000</code></li>
<li>  <code>nums</code> 中的所有整数 <strong>互不相同</strong></li>
</ul>
<p>代码</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">constructMaximumBinaryTree</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="built_in">build</span>(nums, <span class="number">0</span>, nums.<span class="built_in">size</span>() - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">TreeNode* <span class="title">build</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(low &gt; high)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">-1</span>, MAX = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = low; i &lt;= high; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(nums.<span class="built_in">at</span>(i) &gt;= MAX)</span><br><span class="line">            &#123;</span><br><span class="line">                MAX = nums.<span class="built_in">at</span>(i);</span><br><span class="line">                index = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        TreeNode* root = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(MAX);</span><br><span class="line">        <span class="comment">//TreeNode* root = &amp;rootNode;</span></span><br><span class="line"></span><br><span class="line">        root-&gt;left = <span class="built_in">build</span>(nums, low, index<span class="number">-1</span>);</span><br><span class="line">        root-&gt;right = <span class="built_in">build</span>(nums, index+<span class="number">1</span>, high);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><a href="https://mp.weixin.qq.com/s?__biz=MzAxODQxMDM0Mw==&mid=2247487270&idx=1&sn=2f7ad74aabc88b53d94012ceccbe51be&chksm=9bd7f12eaca078384733168971147866c140496cb257946f8170f05e46d16099f3eef98d39d9&scene=21#wechat_redirect">东哥手把手帮你刷通二叉树|第二期 (qq.com)</a></p>
]]></content>
      <categories>
        <category>算法</category>
        <category>二叉树</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>leetcode</tag>
        <tag>二叉树</tag>
      </tags>
  </entry>
  <entry>
    <title>二叉树的遍历模板</title>
    <url>/2021/05/07/%E4%BA%8C%E5%8F%89%E6%A0%91%EF%BC%9A%E4%BA%8C%E5%8F%89%E6%A0%91%E9%81%8D%E5%8E%86%E6%A8%A1%E6%9D%BF/</url>
    <content><![CDATA[<p>&ensp;&ensp;&ensp;&ensp;总结的二叉树的遍历模板，其中前、中、后序遍历采用递归形式，层序遍历采用迭代。</p>
<span id="more"></span>

<h3 id="前序遍历模板"><a href="#前序遍历模板" class="headerlink" title="前序遍历模板"></a>前序遍历模板</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">traverse</span><span class="params">(TreeNode* root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//to do sth</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">traverse</span>(root-&gt;left)</span><br><span class="line">    <span class="built_in">traverse</span>(root-&gt;right)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="中序遍历模板"><a href="#中序遍历模板" class="headerlink" title="中序遍历模板"></a>中序遍历模板</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">traverse</span><span class="params">(TreeNode* root)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">traverse</span>(root-&gt;left)</span><br><span class="line">         </span><br><span class="line">    <span class="comment">//to do sth</span></span><br><span class="line">        </span><br><span class="line">    <span class="built_in">traverse</span>(root-&gt;right)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="后序遍历模板"><a href="#后序遍历模板" class="headerlink" title="后序遍历模板"></a>后序遍历模板</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">traverse</span><span class="params">(TreeNode* root)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="built_in">traverse</span>(root-&gt;left)</span><br><span class="line">    <span class="built_in">traverse</span>(root-&gt;right)</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//to do sth</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="层序遍历模板"><a href="#层序遍历模板" class="headerlink" title="层序遍历模板"></a>层序遍历模板</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">traverse</span><span class="params">(TreeNode* root)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!root) <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">// 初始化队列，将 root 加入队列</span></span><br><span class="line">    queue&lt;TreeNode*&gt; que;</span><br><span class="line">    que.<span class="built_in">push</span>(root);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!que.<span class="built_in">empty</span>()) </span><br><span class="line">    &#123;</span><br><span class="line">        TreeNode* cur = que.<span class="built_in">front</span>();</span><br><span class="line">        que.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//to do sth</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (cur-&gt;left) </span><br><span class="line">        	que.<span class="built_in">offer</span>(cur-&gt;left);        </span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (cur.right) </span><br><span class="line">            que.<span class="built_in">offer</span>(cur-&gt;right);</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="搜索二叉树的遍历模板"><a href="#搜索二叉树的遍历模板" class="headerlink" title="搜索二叉树的遍历模板"></a>搜索二叉树的遍历模板</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BST</span><span class="params">(TreeNode* root, <span class="keyword">int</span> target)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root-&gt;val == target)</span><br><span class="line">        <span class="comment">// 找到目标，做点什么</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (root-&gt;val &lt; target) </span><br><span class="line">        <span class="built_in">BST</span>(root-&gt;right, target);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (root-&gt;val &gt; target)</span><br><span class="line">        <span class="built_in">BST</span>(root.left, target);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法</category>
        <category>二叉树</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>leetcode</tag>
        <tag>二叉树</tag>
      </tags>
  </entry>
  <entry>
    <title>遍历二叉树的几个算法题</title>
    <url>/2021/05/07/%E4%BA%8C%E5%8F%89%E6%A0%91%EF%BC%9A%E9%81%8D%E5%8E%86%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%87%A0%E4%B8%AA%E7%AE%97%E6%B3%95%E9%A2%98/</url>
    <content><![CDATA[<p>&ensp;&ensp;&ensp;&ensp;对于二叉树的遍历模板，运用到实际题目中才能熟练掌握其精髓，下面是以前做过的相关算法题，现在整理了出来。</p>
<span id="more"></span>

<h4 id="98-验证二叉搜索树"><a href="#98-验证二叉搜索树" class="headerlink" title="98. 验证二叉搜索树"></a><a href="https://leetcode-cn.com/problems/validate-binary-search-tree/">98. 验证二叉搜索树</a></h4><p>&ensp;&ensp;&ensp;&ensp;给定一个二叉树，判断其是否是一个有效的二叉搜索树。</p>
<p>&ensp;&ensp;&ensp;&ensp;假设一个二叉搜索树具有如下特征：</p>
<ul>
<li>  节点的左子树只包含<strong>小于</strong>当前节点的数。</li>
<li>  节点的右子树只包含<strong>大于</strong>当前节点的数。</li>
<li>  所有左子树和右子树自身必须也是二叉搜索树。</li>
</ul>
<p><strong>示例 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入:</span><br><span class="line">    2</span><br><span class="line">   &#x2F; \</span><br><span class="line">  1   3</span><br><span class="line">输出: true</span><br></pre></td></tr></table></figure>

<p><strong>示例 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入:</span><br><span class="line">    5</span><br><span class="line">   &#x2F; \</span><br><span class="line">  1   4</span><br><span class="line">     &#x2F; \</span><br><span class="line">    3   6</span><br><span class="line">输出: false</span><br><span class="line">解释: 输入为: [5,1,4,null,null,3,6]。</span><br><span class="line">     根节点的值为 5 ，但是其右子节点值为 4 。</span><br></pre></td></tr></table></figure>

<p><strong>思路与代码</strong>：</p>
<p>&ensp;&ensp;&ensp;&ensp;遍历每个节点，记录好它的边界值，比如对于<code>root</code>的左子节点，它的最大值小于<code>root-&gt;val</code>，对于<code>root</code>的右子节点，它的最小值大于<code>root-&gt;val</code>。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isValidBST</span><span class="params">(TreeNode* root)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">isValidBST</span>(root, <span class="literal">nullptr</span>, <span class="literal">nullptr</span>);</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">//min, max 负责记录边界值</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isValidBST</span><span class="params">(TreeNode* root, TreeNode* min, TreeNode* max)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(min != <span class="literal">nullptr</span> &amp;&amp; root-&gt;val &lt;= min-&gt;val)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(max != <span class="literal">nullptr</span> &amp;&amp; root-&gt;val &gt;= max-&gt;val)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">isValidBST</span>(root-&gt;left, min, root)</span><br><span class="line">                &amp;&amp; <span class="built_in">isValidBST</span>(root-&gt;right, root, max);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h4 id="102-二叉树的层序遍历"><a href="#102-二叉树的层序遍历" class="headerlink" title="102. 二叉树的层序遍历"></a><a href="https://leetcode-cn.com/problems/binary-tree-level-order-traversal/">102. 二叉树的层序遍历</a></h4><p>&ensp;&ensp;&ensp;&ensp;给你一个二叉树，请你返回其按 <strong>层序遍历</strong> 得到的节点值。 （即逐层地，从左到右访问所有节点）。</p>
<p><strong>示例：</strong><br>&ensp;&ensp;&ensp;&ensp;二叉树：<code>[3,9,20,null,null,15,7]</code>,</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">  3</span><br><span class="line"> &#x2F; \</span><br><span class="line">9  20</span><br><span class="line">  &#x2F;  \</span><br><span class="line"> 15   7</span><br></pre></td></tr></table></figure>

<p>&ensp;&ensp;&ensp;&ensp;返回其层序遍历结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[</span><br><span class="line">  [3],</span><br><span class="line">  [9,20],</span><br><span class="line">  [15,7]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p>&ensp;&ensp;&ensp;&ensp;思路与代码：有递归和迭代两种。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">levelOrder</span>(TreeNode* root) </span><br><span class="line">    &#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; ans;</span><br><span class="line">        <span class="built_in">pre</span>(root, <span class="number">0</span>, ans);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">pre</span><span class="params">(TreeNode* root, <span class="keyword">int</span> depth, vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; &amp;ans)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="comment">//先序遍历，遍历过程中记录层数</span></span><br><span class="line">        <span class="keyword">if</span> (depth &gt;= ans.<span class="built_in">size</span>())</span><br><span class="line">            ans.<span class="built_in">push_back</span>(vector&lt;<span class="keyword">int</span>&gt; &#123;&#125;);</span><br><span class="line">        ans[depth].<span class="built_in">push_back</span>(root-&gt;val);</span><br><span class="line">        <span class="built_in">pre</span>(root-&gt;left, depth + <span class="number">1</span>, ans);</span><br><span class="line">        <span class="built_in">pre</span>(root-&gt;right, depth + <span class="number">1</span>, ans);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>&ensp;&ensp;&ensp;&ensp;另一解法</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">levelOrder</span>(TreeNode* root) </span><br><span class="line">    &#123;</span><br><span class="line">        queue&lt;TreeNode*&gt; que;</span><br><span class="line">        que.<span class="built_in">push</span>(root);</span><br><span class="line">        vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">        <span class="keyword">while</span> (que.<span class="built_in">size</span>() != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> size = que.<span class="built_in">size</span>();</span><br><span class="line">            vector&lt;<span class="keyword">int</span>&gt; level;</span><br><span class="line">            <span class="keyword">while</span> (size --) &#123;</span><br><span class="line">                TreeNode* cur = que.<span class="built_in">front</span>();</span><br><span class="line">                que.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="keyword">if</span> (!cur) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                level.<span class="built_in">push_back</span>(cur-&gt;val);</span><br><span class="line">                que.<span class="built_in">push</span>(cur-&gt;left);</span><br><span class="line">                que.<span class="built_in">push</span>(cur-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (level.<span class="built_in">size</span>() != <span class="number">0</span>) &#123;</span><br><span class="line">                res.<span class="built_in">push_back</span>(level);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h4 id="230-二叉搜索树中第K小的元素"><a href="#230-二叉搜索树中第K小的元素" class="headerlink" title="230. 二叉搜索树中第K小的元素"></a><a href="https://leetcode-cn.com/problems/kth-smallest-element-in-a-bst/">230. 二叉搜索树中第K小的元素</a></h4><p>&ensp;&ensp;&ensp;&ensp;给定一个二叉搜索树的根节点 <code>root</code> ，和一个整数 <code>k</code> ，请你设计一个算法查找其中第 <code>k</code> 个最小元素（从 1 开始计数）。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">    3</span><br><span class="line">   &#x2F; \</span><br><span class="line">  1   4</span><br><span class="line">   \   </span><br><span class="line">    2   </span><br><span class="line">输入：root &#x3D; [3,1,4,null,2], k &#x3D; 1</span><br><span class="line">输出：1</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">        5</span><br><span class="line">       &#x2F; \</span><br><span class="line">      3   6</span><br><span class="line">     &#x2F; \  </span><br><span class="line">    2   4 </span><br><span class="line">   &#x2F;</span><br><span class="line">  1 </span><br><span class="line">输入：root &#x3D; [5,3,6,2,4,null,null,1], k &#x3D; 3</span><br><span class="line">输出：3</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li>  树中的节点数为 <code>n</code> 。</li>
<li>  <code>1 &lt;= k &lt;= n &lt;= 104</code></li>
<li>  <code>0 &lt;= Node.val &lt;= 104</code></li>
</ul>
<p><strong>进阶：</strong>如果二叉搜索树经常被修改（插入/删除操作）并且你需要频繁地查找第 <code>k</code> 小的值，你将如何优化算法？</p>
<p><strong>思路与代码</strong>：</p>
<p>&ensp;&ensp;&ensp;&ensp;BST的中序遍历为升序数组，所以一边中序遍历一边记录已查找的个数即可。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> rank = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">traves</span><span class="params">(TreeNode* root, <span class="keyword">int</span> k)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">traves</span>(root-&gt;left, k);</span><br><span class="line"></span><br><span class="line">        ++rank;</span><br><span class="line">        <span class="keyword">if</span>(rank == k)</span><br><span class="line">        &#123;</span><br><span class="line">            res = root-&gt;val;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;           </span><br><span class="line"></span><br><span class="line">        <span class="built_in">traves</span>(root-&gt;right, k);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">kthSmallest</span><span class="params">(TreeNode* root, <span class="keyword">int</span> k)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">traves</span>(root,k);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="236-二叉树的最近公共祖先"><a href="#236-二叉树的最近公共祖先" class="headerlink" title="236. 二叉树的最近公共祖先"></a><a href="https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-tree/">236. 二叉树的最近公共祖先</a></h4><p>    给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。</p>
<p>    最近公共祖先的定义为：“对于有根树 T 的两个节点 p、q，最近公共祖先表示为一个节点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（<strong>一个节点也可以是它自己的祖先</strong>）。” </p>
<p><strong>示例 1：</strong></p>
<p><img src="/2021/05/07/%E4%BA%8C%E5%8F%89%E6%A0%91%EF%BC%9A%E9%81%8D%E5%8E%86%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%87%A0%E4%B8%AA%E7%AE%97%E6%B3%95%E9%A2%98/1.png" alt="img"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：root &#x3D; [3,5,1,6,2,0,8,null,null,7,4], p &#x3D; 5, q &#x3D; 1</span><br><span class="line">输出：3</span><br><span class="line">解释：节点 5 和节点 1 的最近公共祖先是节点 3 。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<p><img src="/2021/05/07/%E4%BA%8C%E5%8F%89%E6%A0%91%EF%BC%9A%E9%81%8D%E5%8E%86%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%87%A0%E4%B8%AA%E7%AE%97%E6%B3%95%E9%A2%98/2.png" alt="img"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：root &#x3D; [3,5,1,6,2,0,8,null,null,7,4], p &#x3D; 5, q &#x3D; 4</span><br><span class="line">输出：5</span><br><span class="line">解释：节点 5 和节点 4 的最近公共祖先是节点 5 。因为根据定义最近公共祖先节点可以为节点本身。</span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：root &#x3D; [1,2], p &#x3D; 1, q &#x3D; 2</span><br><span class="line">输出：1</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li>  树中节点数目在范围 <code>[2, 105]</code> 内。</li>
<li>  <code>-109 &lt;= Node.val &lt;= 109</code></li>
<li>  所有 <code>Node.val</code> <code>互不相同</code> 。</li>
<li>  <code>p != q</code></li>
<li>  <code>p</code> 和 <code>q</code> 均存在于给定的二叉树中。</li>
</ul>
<p><strong>思路与代码</strong>：</p>
<p>    递归思想, 对以root为根的(子)树进行查找p和q, 如果root == null || p || q 直接返回root，表示对于当前树的查找已经完毕, 否则对左右子树进行查找, 根据左右子树的返回值判断:</p>
<ul>
<li>  左右子树的返回值都不为<code>nullptr</code>，由于值唯一左右子树的返回值就是<code>p</code>和<code>q</code>, 此时<code>root</code>为LCA</li>
<li>  左右子树返回值只有一个不为<code>nullptr</code>, 说明只有<code>p</code>和<code>q</code>存在与左或右子树中, 最先找到的那个节点为LCA</li>
<li>  左右子树返回值均为<code>nullptr</code>, <code>p</code>和<code>q</code>均不在树中, 返回<code>nullptr</code></li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">lowestCommonAncestor</span><span class="params">(TreeNode* root, TreeNode* p, TreeNode* q)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">if</span>(root == p || root == q)</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line"></span><br><span class="line">        TreeNode* left = <span class="built_in">lowestCommonAncestor</span>(root-&gt;left, p, q);</span><br><span class="line">        TreeNode* right = <span class="built_in">lowestCommonAncestor</span>(root-&gt;right, p, q);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(left != <span class="literal">nullptr</span> &amp;&amp; right != <span class="literal">nullptr</span>)</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        <span class="keyword">if</span>(left == <span class="literal">nullptr</span> &amp;&amp; right == <span class="literal">nullptr</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">return</span> left == <span class="literal">nullptr</span> ? right : left;          </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h4 id="538-把二叉搜索树转换为累加树"><a href="#538-把二叉搜索树转换为累加树" class="headerlink" title="538. 把二叉搜索树转换为累加树"></a><a href="https://leetcode-cn.com/problems/convert-bst-to-greater-tree/">538. 把二叉搜索树转换为累加树</a></h4><p>&ensp;&ensp;&ensp;&ensp;给出二叉 <strong>搜索</strong> 树的根节点，该树的节点值各不相同，请你将其转换为累加树（Greater Sum Tree），使每个节点 <code>node</code> 的新值等于原树中大于或等于 <code>node.val</code> 的值之和。</p>
<p>&ensp;&ensp;&ensp;&ensp;提醒一下，二叉搜索树满足下列约束条件：</p>
<ul>
<li>  节点的左子树仅包含键 <strong>小于</strong> 节点键的节点。</li>
<li>  节点的右子树仅包含键 <strong>大于</strong> 节点键的节点。</li>
<li>  左右子树也必须是二叉搜索树。</li>
</ul>
<p><strong>示例 1：</strong></p>
<p><strong><img src="/2021/05/07/%E4%BA%8C%E5%8F%89%E6%A0%91%EF%BC%9A%E9%81%8D%E5%8E%86%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%87%A0%E4%B8%AA%E7%AE%97%E6%B3%95%E9%A2%98/3.png" alt="img" style="zoom:33%;"></strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：[4,1,6,0,2,5,7,null,null,null,3,null,null,null,8]</span><br><span class="line">输出：[30,36,21,36,35,26,15,null,null,null,33,null,null,null,8]</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：root &#x3D; [0,null,1]</span><br><span class="line">输出：[1,null,1]</span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：root &#x3D; [1,0,2]</span><br><span class="line">输出：[3,3,2]</span><br></pre></td></tr></table></figure>

<p><strong>示例 4：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：root &#x3D; [3,2,4,1]</span><br><span class="line">输出：[7,9,4,10]</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li>  树中的节点数介于 <code>0</code> 和 <code>104</code> 之间。</li>
<li>  每个节点的值介于 <code>-104</code> 和 <code>104</code> 之间。</li>
<li>  树中的所有值 <strong>互不相同</strong> 。</li>
<li>  给定的树为二叉搜索树</li>
</ul>
<p><strong>思路与代码</strong>：</p>
<p>&ensp;&ensp;&ensp;&ensp;这不就是中序遍历中，每一个节点的值加上后面所有结点的值的遍历结果吗？为了方便累加，我们改变中序遍历的顺序，先遍历右子树，再遍历左子树。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="function">TreeNode* <span class="title">convertBST</span><span class="params">(TreeNode* root)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="built_in">travers</span>(root);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">travers</span><span class="params">(TreeNode* root)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="built_in">travers</span>(root-&gt;right);</span><br><span class="line"></span><br><span class="line">        sum += root-&gt;val;</span><br><span class="line">        root-&gt;val = sum;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">travers</span>(root-&gt;left);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h4 id="652-寻找重复的子树"><a href="#652-寻找重复的子树" class="headerlink" title="652. 寻找重复的子树"></a><a href="https://leetcode-cn.com/problems/find-duplicate-subtrees/">652. 寻找重复的子树</a></h4><p>&ensp;&ensp;&ensp;&ensp;给定一棵二叉树，返回所有重复的子树。对于同一类的重复子树，你只需要返回其中任意<strong>一棵</strong>的根结点即可。</p>
<p>&ensp;&ensp;&ensp;&ensp;两棵树重复是指它们具有相同的结构以及相同的结点值。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">    1</span><br><span class="line">   &#x2F; \</span><br><span class="line">  2   3</span><br><span class="line"> &#x2F;   &#x2F; \</span><br><span class="line">4   2   4</span><br><span class="line">   &#x2F;</span><br><span class="line">  4</span><br></pre></td></tr></table></figure>

<p>下面是两个重复的子树：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">  2</span><br><span class="line"> &#x2F;</span><br><span class="line">4</span><br></pre></td></tr></table></figure>

<p>和</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">4</span><br></pre></td></tr></table></figure>

<p>&ensp;&ensp;&ensp;&ensp;因此，你需要以列表的形式返回上述重复子树的根结点。</p>
<p><strong>思路与代码</strong>：</p>
<p>&ensp;&ensp;&ensp;&ensp;采用将二叉树序列化的形式，建立哈希表，统计每次出现的次数，添加到结果集当中。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;TreeNode*&gt; <span class="title">findDuplicateSubtrees</span><span class="params">(TreeNode* root)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">          vector&lt;TreeNode*&gt; result;</span><br><span class="line">          unordered_map&lt;string,<span class="keyword">int</span>&gt; mp;</span><br><span class="line">          <span class="built_in">helper</span>(root, result, mp);</span><br><span class="line"></span><br><span class="line">          <span class="keyword">return</span> result;  </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">string <span class="title">helper</span><span class="params">(TreeNode* root, </span></span></span><br><span class="line"><span class="function"><span class="params">                vector&lt;TreeNode*&gt; &amp;result, </span></span></span><br><span class="line"><span class="function"><span class="params">                unordered_map&lt;string,<span class="keyword">int</span>&gt; &amp;mp)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root)</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;#&quot;</span>;</span><br><span class="line"></span><br><span class="line">        string str = <span class="built_in">helper</span>(root-&gt;left, result, mp) + <span class="string">&quot;,&quot;</span> + </span><br><span class="line">                     <span class="built_in">helper</span>(root-&gt;right, result, mp) + <span class="string">&quot;,&quot;</span> + </span><br><span class="line">                     <span class="built_in">to_string</span>(root-&gt;val);</span><br><span class="line">                     </span><br><span class="line">        <span class="keyword">if</span>(mp[str] == <span class="number">1</span>)</span><br><span class="line">            result.<span class="built_in">push_back</span>(root);</span><br><span class="line">        mp[str]++;</span><br><span class="line">        <span class="keyword">return</span> str;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="700-二叉搜索树中的搜索"><a href="#700-二叉搜索树中的搜索" class="headerlink" title="700. 二叉搜索树中的搜索"></a><a href="https://leetcode-cn.com/problems/search-in-a-binary-search-tree/">700. 二叉搜索树中的搜索</a></h4><p>&ensp;&ensp;&ensp;&ensp;给定二叉搜索树（BST）的根节点和一个值。 你需要在BST中找到节点值等于给定值的节点。 返回以该节点为根的子树。 如果节点不存在，则返回 NULL。</p>
<p>&ensp;&ensp;&ensp;&ensp;例如，</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">给定二叉搜索树:</span><br><span class="line"></span><br><span class="line">        4</span><br><span class="line">       &#x2F; \</span><br><span class="line">      2   7</span><br><span class="line">     &#x2F; \</span><br><span class="line">    1   3</span><br><span class="line"></span><br><span class="line">和值: 2</span><br></pre></td></tr></table></figure>

<p>&ensp;&ensp;&ensp;&ensp;你应该返回如下子树:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">  2     </span><br><span class="line"> &#x2F; \   </span><br><span class="line">1   3</span><br></pre></td></tr></table></figure>

<p>&ensp;&ensp;&ensp;&ensp;在上述示例中，如果要找的值是 <code>5</code>，但因为没有节点值为 <code>5</code>，我们应该返回 <code>NULL</code>。</p>
<p><strong>思路与代码</strong>：</p>
<p>&ensp;&ensp;&ensp;&ensp;没什么好说的，直接遍历即可。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">searchBST</span><span class="params">(TreeNode* root, <span class="keyword">int</span> val)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">if</span>(val &gt; root-&gt;val)</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">searchBST</span>(root-&gt;right, val);</span><br><span class="line">        <span class="keyword">if</span>(val &lt; root-&gt;val)</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">searchBST</span>(root-&gt;left, val);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="701-二叉搜索树中的插入操作"><a href="#701-二叉搜索树中的插入操作" class="headerlink" title="701. 二叉搜索树中的插入操作"></a><a href="https://leetcode-cn.com/problems/insert-into-a-binary-search-tree/">701. 二叉搜索树中的插入操作</a></h4><p>&ensp;&ensp;&ensp;&ensp;给定二叉搜索树（BST）的根节点和要插入树中的值，将值插入二叉搜索树。 返回插入后二叉搜索树的根节点。 输入数据 <strong>保证</strong> ，新值和原始二叉搜索树中的任意节点值都不同。</p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>注意</strong>，可能存在多种有效的插入方式，只要树在插入后仍保持为二叉搜索树即可。 你可以返回 <strong>任意有效的结果</strong> 。</p>
<p><strong>示例 1：</strong></p>
<img src="/2021/05/07/%E4%BA%8C%E5%8F%89%E6%A0%91%EF%BC%9A%E9%81%8D%E5%8E%86%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%87%A0%E4%B8%AA%E7%AE%97%E6%B3%95%E9%A2%98/4.jpg" alt="img" style="zoom:50%;">

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：root &#x3D; [4,2,7,1,3], val &#x3D; 5</span><br><span class="line">输出：[4,2,7,1,3,5]</span><br><span class="line">解释：另一个满足题目要求可以通过的树是：</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：root &#x3D; [40,20,60,10,30,50,70], val &#x3D; 25</span><br><span class="line">输出：[40,20,60,10,30,50,70,null,null,25]</span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：root &#x3D; [4,2,7,1,3,null,null,null,null,null,null], val &#x3D; 5</span><br><span class="line">输出：[4,2,7,1,3,5]</span><br></pre></td></tr></table></figure>

<p> <strong>提示：</strong></p>
<ul>
<li>  给定的树上的节点数介于 <code>0</code> 和 <code>10^4</code> 之间</li>
<li>  每个节点都有一个唯一整数值，取值范围从 <code>0</code> 到 <code>10^8</code></li>
<li>  <code>-10^8 &lt;= val &lt;= 10^8</code></li>
<li>  新值和原始二叉搜索树中的任意节点值都不同</li>
</ul>
<p><strong>思路与代码</strong>：</p>
<p>&ensp;&ensp;&ensp;&ensp;遍历找到合适的位置，再插入。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">insertIntoBST</span><span class="params">(TreeNode* root, <span class="keyword">int</span> val)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">TreeNode</span>(val);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(val &gt; root-&gt;val)</span><br><span class="line">            root-&gt;right = <span class="built_in">insertIntoBST</span>(root-&gt;right, val);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            root-&gt;left = <span class="built_in">insertIntoBST</span>(root-&gt;left, val);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="450-删除二叉搜索树中的节点"><a href="#450-删除二叉搜索树中的节点" class="headerlink" title="450. 删除二叉搜索树中的节点"></a><a href="https://leetcode-cn.com/problems/delete-node-in-a-bst/">450. 删除二叉搜索树中的节点</a></h4><p>&ensp;&ensp;&ensp;&ensp;给定一个二叉搜索树的根节点 <strong>root</strong> 和一个值 <strong>key</strong>，删除二叉搜索树中的 <strong>key</strong> 对应的节点，并保证二叉搜索树的性质不变。返回二叉搜索树（有可能被更新）的根节点的引用。</p>
<p>&ensp;&ensp;&ensp;&ensp;一般来说，删除节点可分为两个步骤：</p>
<ol>
<li> 首先找到需要删除的节点；</li>
<li> 如果找到了，删除它。</li>
</ol>
<p><strong>说明：</strong> 要求算法时间复杂度为 O(h)，h 为树的高度。</p>
<p><strong>示例:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">root &#x3D; [5,3,6,2,4,null,7]</span><br><span class="line">key &#x3D; 3</span><br><span class="line"></span><br><span class="line">    5</span><br><span class="line">   &#x2F; \</span><br><span class="line">  3   6</span><br><span class="line"> &#x2F; \   \</span><br><span class="line">2   4   7</span><br><span class="line"></span><br><span class="line">给定需要删除的节点值是 3，所以我们首先找到 3 这个节点，然后删除它。</span><br><span class="line"></span><br><span class="line">一个正确的答案是 [5,4,6,2,null,null,7], 如下图所示。</span><br><span class="line"></span><br><span class="line">    5</span><br><span class="line">   &#x2F; \</span><br><span class="line">  4   6</span><br><span class="line"> &#x2F;     \</span><br><span class="line">2       7</span><br><span class="line"></span><br><span class="line">另一个正确答案是 [5,2,6,null,4,null,7]。</span><br><span class="line"></span><br><span class="line">    5</span><br><span class="line">   &#x2F; \</span><br><span class="line">  2   6</span><br><span class="line">   \   \</span><br><span class="line">    4   7</span><br></pre></td></tr></table></figure>

<p><strong>思路与代码</strong>：</p>
<p>&ensp;&ensp;&ensp;&ensp;要删除的节点<code>A</code>有三种情况：</p>
<p>&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;<code>A</code>恰好是末端节点，两个子节点都为空，那么它可以当场去世了。</p>
<p>&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;<code>A</code>只有一个非空子节点，那么它要让这个孩子接替自己的位置。</p>
<p>&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;<code>A</code>有两个子节点，麻烦了，为了不破坏 BST 的性质，<code>A</code>必须找到左子树中最大的那个节点，或者右子树中最小的那个节点来接替自己。我采用第二种方式。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">getMin</span><span class="params">(TreeNode* root)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(root-&gt;left)</span><br><span class="line">            root = root-&gt;left;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">TreeNode* <span class="title">deleteNode</span><span class="params">(TreeNode* root, <span class="keyword">int</span> key)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">if</span>(key &gt; root-&gt;val)</span><br><span class="line">            root-&gt;right = <span class="built_in">deleteNode</span>(root-&gt;right, key);</span><br><span class="line">        <span class="keyword">if</span>(key &lt; root-&gt;val)</span><br><span class="line">            root-&gt;left = <span class="built_in">deleteNode</span>(root-&gt;left, key);</span><br><span class="line">        <span class="keyword">if</span>(key == root-&gt;val)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(!root-&gt;left) <span class="keyword">return</span> root-&gt;right;</span><br><span class="line">            <span class="keyword">if</span>(!root-&gt;right) <span class="keyword">return</span> root-&gt;left;</span><br><span class="line"></span><br><span class="line">            TreeNode* minNode = <span class="built_in">getMin</span>(root-&gt;right);</span><br><span class="line">            root-&gt;val = minNode-&gt;val;</span><br><span class="line">            root-&gt;right = <span class="built_in">deleteNode</span>(root-&gt;right, minNode-&gt;val);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><a href="https://mp.weixin.qq.com/s?__biz=MzAxODQxMDM0Mw==&mid=2247488128&idx=2&sn=b8fb3fd2917f9ac86127054741cd5877&chksm=9bd7ec88aca0659ee0185b657663169169493e9df2063fa4d28b38a0b4d0dd698d0301937898&scene=21#wechat_redirect">原创 | 手把手刷二叉搜索树（第二期） (qq.com)</a></p>
]]></content>
      <categories>
        <category>算法</category>
        <category>二叉树</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>leetcode</tag>
        <tag>二叉树</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode中的Shell习题</title>
    <url>/2021/05/06/Shell%EF%BC%9ALeetcode%E7%9A%84Shell%E4%B9%A0%E9%A2%98/</url>
    <content><![CDATA[<p>&ensp;&ensp;&ensp;&ensp;leetcode中的四道shell题</p>
<span id="more"></span>

<h4 id="192-统计词频"><a href="#192-统计词频" class="headerlink" title="192. 统计词频"></a><a href="https://leetcode-cn.com/problems/word-frequency/">192. 统计词频</a></h4><p>&ensp;&ensp;&ensp;&ensp;写一个 bash 脚本以统计一个文本文件 <code>words.txt</code> 中每个单词出现的频率。</p>
<p>&ensp;&ensp;&ensp;&ensp;为了简单起见，你可以假设：</p>
<ul>
<li><code>words.txt</code>只包括小写字母和 <code>&#39; &#39;</code> 。</li>
<li>每个单词只由小写字母组成。</li>
<li>单词间由一个或多个空格字符分隔。</li>
</ul>
<p><strong>示例:</strong></p>
<p>&ensp;&ensp;&ensp;&ensp;假设 <code>words.txt</code> 内容如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">the day is sunny the the</span><br><span class="line">the sunny is is</span><br></pre></td></tr></table></figure>

<p>&ensp;&ensp;&ensp;&ensp;你的脚本应当输出（以词频降序排列）：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">the 4</span><br><span class="line">is 3</span><br><span class="line">sunny 2</span><br><span class="line">day 1</span><br></pre></td></tr></table></figure>

<p><strong>说明:</strong></p>
<ul>
<li>不要担心词频相同的单词的排序问题，每个单词出现的频率都是唯一的。</li>
<li>你可以使用一行 Unix pipes实现吗？</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> Read from the file words.txt and output the word frequency list to stdout.</span></span><br><span class="line">cat words.txt |tr -s &#x27; &#x27; &#x27;\n&#x27; |sort|uniq -c|sort -r|awk &#x27;&#123;print $2,$1&#125;&#x27;</span><br></pre></td></tr></table></figure>

<p>&ensp;&ensp;&ensp;&ensp;1、首先cat命令查看words.txt<br>&ensp;&ensp;&ensp;&ensp;2、tr -s ‘ ‘ ‘\n’将空格都替换为换行 实现分词<br>&ensp;&ensp;&ensp;&ensp;3、sort排序 将分好的词按照顺序排序<br>&ensp;&ensp;&ensp;&ensp;4、uniq -c 统计重复次数（此步骤与上一步息息相关，-c原理是字符串相同则加一，如果不进行先排序的话将无法统计数目）<br>&ensp;&ensp;&ensp;&ensp;5、sort -r 将数目倒序排列<br>&ensp;&ensp;&ensp;&ensp;6、awk ‘{print $2,$1}’ 将词频和词语调换位置打印出来</p>
<h4 id="193-有效电话号码"><a href="#193-有效电话号码" class="headerlink" title="193. 有效电话号码"></a><a href="https://leetcode-cn.com/problems/valid-phone-numbers/">193. 有效电话号码</a></h4><p>&ensp;&ensp;&ensp;&ensp;给定一个包含电话号码列表（一行一个电话号码）的文本文件 <code>file.txt</code>，写一个单行 bash 脚本输出所有有效的电话号码。</p>
<p>&ensp;&ensp;&ensp;&ensp;你可以假设一个有效的电话号码必须满足以下两种格式： (xxx) xxx-xxxx 或 xxx-xxx-xxxx。（x 表示一个数字）</p>
<p>&ensp;&ensp;&ensp;&ensp;你也可以假设每行前后没有多余的空格字符。 </p>
<p><strong>示例：</strong></p>
<p>&ensp;&ensp;&ensp;&ensp;假设 <code>file.txt</code> 内容如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">987-123-4567</span><br><span class="line">123 456 7890</span><br><span class="line">(123) 456-7890</span><br></pre></td></tr></table></figure>

<p>&ensp;&ensp;&ensp;&ensp;你的脚本应当输出下列有效的电话号码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">987-123-4567</span><br><span class="line">(123) 456-7890</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">三种方法：</span><br><span class="line">grep -P <span class="string">&#x27;^(\d&#123;3&#125;-|\(\d&#123;3&#125;\) )\d&#123;3&#125;-\d&#123;4&#125;$&#x27;</span> file.txt</span><br><span class="line">sed -n -r <span class="string">&#x27;/^([0-9]&#123;3&#125;-|\([0-9]&#123;3&#125;\) )[0-9]&#123;3&#125;-[0-9]&#123;4&#125;$/p&#x27;</span> file.txt</span><br><span class="line">awk <span class="string">&#x27;/^([0-9]&#123;3&#125;-|\([0-9]&#123;3&#125;\) )[0-9]&#123;3&#125;-([0-9]&#123;4&#125;)$/&#x27;</span> file.txt</span><br></pre></td></tr></table></figure>

<h4 id="194-转置文件"><a href="#194-转置文件" class="headerlink" title="194. 转置文件"></a><a href="https://leetcode-cn.com/problems/transpose-file/">194. 转置文件</a></h4><p>&ensp;&ensp;&ensp;&ensp;给定一个文件 <code>file.txt</code>，转置它的内容。</p>
<p>&ensp;&ensp;&ensp;&ensp;你可以假设每行列数相同，并且每个字段由 <code>&#39; &#39;</code> 分隔。</p>
<p> <strong>示例：</strong></p>
<p>&ensp;&ensp;&ensp;&ensp;假设 <code>file.txt</code> 文件内容如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">name age</span><br><span class="line">alice 21</span><br><span class="line">ryan 30</span><br></pre></td></tr></table></figure>

<p>&ensp;&ensp;&ensp;&ensp;应当输出：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">name alice ryan</span><br><span class="line">age 21 30</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">awk <span class="string">&#x27;&#123; #这个大括号里的代码是 对正文的处理</span></span><br><span class="line"><span class="string">    # NF表示列数，NR表示已读的行数</span></span><br><span class="line"><span class="string">    # 注意for中的i从1开始，i前没有类型</span></span><br><span class="line"><span class="string">    for (i=1; i&lt;=NF; i++)&#123;#对每一列</span></span><br><span class="line"><span class="string">        if(NR==1)&#123;       #如果是第一行</span></span><br><span class="line"><span class="string">            #将第i列的值存入res[i],$i表示第i列的值，i为数组的下标，以列序号为下标，</span></span><br><span class="line"><span class="string">            #数组不用定义可以直接使用</span></span><br><span class="line"><span class="string">            res[i]=$i;   </span></span><br><span class="line"><span class="string">        &#125;</span></span><br><span class="line"><span class="string">        else&#123;</span></span><br><span class="line"><span class="string">            #不是第一行时，将该行对应i列的值拼接到res[i]</span></span><br><span class="line"><span class="string">            res[i]=res[i] &quot; &quot; $i</span></span><br><span class="line"><span class="string">        &#125;</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string"># BEGIN&#123;&#125; 文件进行扫描前要执行的操作；END&#123;&#125; 文件扫描结束后要执行的操作。</span></span><br><span class="line"><span class="string">END&#123;</span></span><br><span class="line"><span class="string">    #输出数组</span></span><br><span class="line"><span class="string">	for (i=1; i&lt;=NF; i++)&#123;</span></span><br><span class="line"><span class="string">		print res[i]</span></span><br><span class="line"><span class="string">	&#125;</span></span><br><span class="line"><span class="string">&#125;&#x27;</span> file.txt</span><br></pre></td></tr></table></figure>

<h4 id="195-第十行"><a href="#195-第十行" class="headerlink" title="195. 第十行"></a><a href="https://leetcode-cn.com/problems/tenth-line/">195. 第十行</a></h4><p>&ensp;&ensp;&ensp;&ensp;给定一个文本文件 <code>file.txt</code>，请只打印这个文件中的第十行。</p>
<p><strong>示例:</strong></p>
<p>&ensp;&ensp;&ensp;&ensp;假设 <code>file.txt</code> 有如下内容：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Line 1</span><br><span class="line">Line 2</span><br><span class="line">Line 3</span><br><span class="line">Line 4</span><br><span class="line">Line 5</span><br><span class="line">Line 6</span><br><span class="line">Line 7</span><br><span class="line">Line 8</span><br><span class="line">Line 9</span><br><span class="line">Line 10</span><br></pre></td></tr></table></figure>

<p>&ensp;&ensp;&ensp;&ensp;你的脚本应当显示第十行：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Line 10</span><br></pre></td></tr></table></figure>

<p><strong>说明:</strong></p>
<ol>
<li>如果文件少于十行，你应当输出什么？</li>
<li>至少有三种不同的解法，请尝试尽可能多的方法来解题</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">grep -n <span class="string">&quot;&quot;</span> file.txt | grep -w <span class="string">&#x27;10&#x27;</span> | cut -d: -f2</span><br><span class="line">sed -n <span class="string">&#x27;10p&#x27;</span> file.txt</span><br><span class="line">awk <span class="string">&#x27;&#123;if(NR==10)&#123;print $0&#125;&#125;&#x27;</span> file.txt</span><br></pre></td></tr></table></figure>

<p><a href="https://mp.weixin.qq.com/s/EI63RZZcPzJT4c0zl8XQSA">LeetCode上稀缺的四道shell编程题解析</a></p>
]]></content>
      <categories>
        <category>shell</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>shell</tag>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>shell入门</title>
    <url>/2021/05/06/Shell%EF%BC%9AShell%E5%85%A5%E9%97%A8%E7%9F%A5%E8%AF%86/</url>
    <content><![CDATA[<h3 id="Shell概述"><a href="#Shell概述" class="headerlink" title="Shell概述"></a>Shell概述</h3><p>&ensp;&ensp;&ensp;&ensp;Shell是一个命令行解释器，它接受应用程序/用户命令，然后调用操作系统内核。</p>
<span id="more"></span>

<p><img src="/2021/05/06/Shell%EF%BC%9AShell%E5%85%A5%E9%97%A8%E7%9F%A5%E8%AF%86/shell.png"></p>
<p>&ensp;&ensp;&ensp;&ensp;Shell还是一个功能相当强大的编程语言，易编写、易调试、灵活性强。</p>
<p><a href="https://www.runoob.com/linux/linux-shell.html">Shell 教程</a></p>
<h3 id="Shell解析器"><a href="#Shell解析器" class="headerlink" title="Shell解析器"></a>Shell解析器</h3><ul>
<li><p>Linux提供的shell解析器</p>
  <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">james@james-Vostro-5471:~$ sudo cat /etc/shells</span><br><span class="line">[sudo] james 的密码： </span><br><span class="line"><span class="meta">#</span><span class="bash"> /etc/shells: valid login shells</span></span><br><span class="line">/bin/sh</span><br><span class="line">/bin/bash</span><br><span class="line">/bin/rbash</span><br><span class="line">/bin/dash</span><br></pre></td></tr></table></figure>
</li>
<li><p>bash和sh的关系（sh调用bash）</p>
  <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">root@james-Vostro-5471:/bin# ll | grep bash</span><br><span class="line">-rwxr-xr-x  1 root root 1113504 6月   7  2019 bash*</span><br><span class="line">lrwxrwxrwx  1 root root       4 3月  11  2020 rbash -&gt; bash*</span><br></pre></td></tr></table></figure></li>
<li><p>SUSE默认的shell解析器是bash</p>
  <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">james@james-Vostro-5471:~$ echo $SHELL</span><br><span class="line">/bin/bash</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="Shell脚本入门"><a href="#Shell脚本入门" class="headerlink" title="Shell脚本入门"></a>Shell脚本入门</h3><h4 id="脚本格式"><a href="#脚本格式" class="headerlink" title="脚本格式"></a>脚本格式</h4><p>&ensp;&ensp;&ensp;&ensp;脚本以#！/bin/bash开头（指定解析器）</p>
<p>&ensp;&ensp;&ensp;&ensp;范例：创建一个shell脚本，输出helloworld</p>
<p>&ensp;&ensp;&ensp;&ensp;创建文件</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">james@james-Vostro-5471:~/datas$ touch helloworld.sh</span><br><span class="line">james@james-Vostro-5471:~/datas$ vim helloworld.sh</span><br></pre></td></tr></table></figure>

<p>&ensp;&ensp;&ensp;&ensp;文件内容:</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">!/bin/bash</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;hello world&quot;</span></span><br></pre></td></tr></table></figure>

<p>&ensp;&ensp;&ensp;&ensp;执行：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">james@james-Vostro-5471:~/datas$ sh helloworld.sh</span><br><span class="line">hello world</span><br><span class="line">james@james-Vostro-5471:~/datas$ bash helloworld.sh</span><br><span class="line">hello world</span><br></pre></td></tr></table></figure>

<h4 id="脚本的常用执行方式"><a href="#脚本的常用执行方式" class="headerlink" title="脚本的常用执行方式"></a>脚本的常用执行方式</h4><p>&ensp;&ensp;&ensp;&ensp;第一种：采用bash或sh+脚本的相对路径或绝对路径（不用赋予脚本+x权限）</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">root@james-Vostro-5471:/home/james/datas# sh helloworld.sh</span><br><span class="line">hello world</span><br><span class="line">root@james-Vostro-5471:/home/james/datas# sh /home/james/datas/helloworld.sh</span><br><span class="line">hello world</span><br></pre></td></tr></table></figure>

<p>&ensp;&ensp;&ensp;&ensp;第二种：采用输入脚本的绝对路径或相对路径执行脚本（必须具有可执行权限+x）</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">root@james-Vostro-5471:/home/james/datas# ./helloworld.sh</span><br><span class="line">bash: ./helloworld.sh: 权限不够</span><br><span class="line">root@james-Vostro-5471:/home/james/datas# ll | grep helloworld.sh</span><br><span class="line">-rw-r--r--  1 james james   32 5月   6 13:06 helloworld.sh</span><br><span class="line">root@james-Vostro-5471:/home/james/datas# chmod 777 helloworld.sh</span><br><span class="line">root@james-Vostro-5471:/home/james/datas# ll |grep helloworld.sh</span><br><span class="line">-rwxrwxrwx  1 james james   32 5月   6 13:06 helloworld.sh*</span><br><span class="line">root@james-Vostro-5471:/home/james/datas# ./helloworld.sh</span><br><span class="line">hello world</span><br><span class="line">root@james-Vostro-5471:/home/james/datas# /home/james/datas/helloworld.sh</span><br><span class="line">hello world</span><br></pre></td></tr></table></figure>

<p>&ensp;&ensp;&ensp;&ensp;第一种执行方法，本质是bash解析器帮你执行脚本，所以脚本本身不需要执行权限。第二种方法，本质是脚本需要自己执行，所以需要执行权限。</p>
<h4 id="多命令处理"><a href="#多命令处理" class="headerlink" title="多命令处理"></a>多命令处理</h4><p>&ensp;&ensp;&ensp;&ensp;在/home/james/datas目录下创建一个demo.txt 在demo.txt文件中增加“this is a demo”：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">root@james-Vostro-5471:/home/james/datas# touch batch.sh</span><br><span class="line">root@james-Vostro-5471:/home/james/datas# vim batch.sh</span><br><span class="line">root@james-Vostro-5471:/home/james/datas# ll</span><br><span class="line">总用量 16</span><br><span class="line">drwxr-xr-x  2 james james 4096 5月   6 13:27 ./</span><br><span class="line">drwxr-xr-x 22 james james 4096 5月   6 13:06 ../</span><br><span class="line">-rw-r--r--  1 root  root    84 5月   6 13:27 batch.sh</span><br><span class="line">-rwxrwxrwx  1 james james   32 5月   6 13:06 helloworld.sh*</span><br><span class="line">root@james-Vostro-5471:/home/james/datas# bash batch.sh</span><br><span class="line">root@james-Vostro-5471:/home/james/datas# ll</span><br><span class="line">总用量 20</span><br><span class="line">drwxr-xr-x  2 james james 4096 5月   6 13:29 ./</span><br><span class="line">drwxr-xr-x 22 james james 4096 5月   6 13:06 ../</span><br><span class="line">-rw-r--r--  1 root  root    84 5月   6 13:27 batch.sh</span><br><span class="line">-rw-r--r--  1 root  root    15 5月   6 13:29 demo.txt</span><br><span class="line">-rwxrwxrwx  1 james james   32 5月   6 13:06 helloworld.sh*</span><br><span class="line">root@james-Vostro-5471:/home/james/datas# cat demo.txt</span><br><span class="line">this is a demo</span><br><span class="line">root@james-Vostro-5471:/home/james/datas# cat batch.sh</span><br><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line"></span><br><span class="line">cd /home/james/datas</span><br><span class="line">touch demo.txt</span><br><span class="line">echo &quot;this is a demo&quot; &gt;&gt; demo.txt</span><br></pre></td></tr></table></figure>



<h3 id="Shell中的变量"><a href="#Shell中的变量" class="headerlink" title="Shell中的变量"></a>Shell中的变量</h3><h4 id="常用系统变量"><a href="#常用系统变量" class="headerlink" title="常用系统变量"></a>常用系统变量</h4><p>&ensp;&ensp;&ensp;&ensp;$HOME(根目录) 、$PWD(当前目录)、 $SHELL(shell解析器目录)、 $USER(当前用户)等</p>
<p>&ensp;&ensp;&ensp;&ensp;范例：查看系统变量的值</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">james@james-Vostro-5471:~$ echo $HOME</span><br><span class="line">/home/james</span><br><span class="line">james@james-Vostro-5471:~$ echo $PWD</span><br><span class="line">/home/james</span><br><span class="line">james@james-Vostro-5471:~$ echo $SHELL</span><br><span class="line">/bin/bash</span><br><span class="line">james@james-Vostro-5471:~$ echo $USER</span><br><span class="line">james</span><br></pre></td></tr></table></figure>

<h4 id="自定义变量"><a href="#自定义变量" class="headerlink" title="自定义变量"></a>自定义变量</h4><ul>
<li><p>定义变量 ： 变量=值（声明变量时等号左右不能有空格）</p>
  <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">james@james-Vostro-5471:~$ M=1</span><br><span class="line">james@james-Vostro-5471:~$ echo $M</span><br><span class="line">1</span><br></pre></td></tr></table></figure></li>
<li><p>撤销变量：unset 变量</p>
  <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">james@james-Vostro-5471:~$ unset M</span><br><span class="line">james@james-Vostro-5471:~$ echo $M</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li><p>声明静态变量：readonly 变量，注意：不能unset</p>
  <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">james@james-Vostro-5471:~$ readonly B=3</span><br><span class="line">james@james-Vostro-5471:~$ echo $B</span><br><span class="line">3</span><br><span class="line">james@james-Vostro-5471:~$ unset B</span><br><span class="line">bash: unset: B: 无法取消设定: 只读 variable</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="变量定义规则"><a href="#变量定义规则" class="headerlink" title="变量定义规则"></a>变量定义规则</h4><ul>
<li>变量名称可以由字母、数字、下划线组成，但是不能以数字开头，环境变量名建议大写。</li>
<li>等号两侧不能有空格</li>
<li>在bash中，变量默认类型都是字符串类型，无法直接进行数值运算</li>
<li>变量的值如果有空格，需要使用双引号或单引号括起来</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">james@james-Vostro-5471:~$ S=1+1</span><br><span class="line">james@james-Vostro-5471:~$ echo $S</span><br><span class="line">1+1</span><br><span class="line">james@james-Vostro-5471:~$ d=zx 12 3</span><br><span class="line">12：未找到命令</span><br><span class="line">james@james-Vostro-5471:~$ d=&#x27;zx 12 3&#x27;</span><br><span class="line">james@james-Vostro-5471:~$ echo $d</span><br><span class="line">zx 12 3</span><br><span class="line">james@james-Vostro-5471:~$ </span><br></pre></td></tr></table></figure>

<h4 id="提升全局变量"><a href="#提升全局变量" class="headerlink" title="提升全局变量"></a>提升全局变量</h4><p>&ensp;&ensp;&ensp;&ensp;把局部变量提升为全局变量，可供其他shell程序使用。</p>
<p>&ensp;&ensp;&ensp;&ensp;export 变量名</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">james@james-Vostro-5471:~/datas$ vim helloworld.sh</span><br><span class="line">james@james-Vostro-5471:~/datas$ cat helloworld.sh</span><br><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line"></span><br><span class="line">echo &quot;hello world&quot;</span><br><span class="line"></span><br><span class="line">echo $D</span><br><span class="line">james@james-Vostro-5471:~/datas$ D=&#x27;bian liang&#x27;</span><br><span class="line">james@james-Vostro-5471:~/datas$ echo $D</span><br><span class="line">bian liang</span><br><span class="line">james@james-Vostro-5471:~/datas$ sh helloworld.sh</span><br><span class="line">hello world</span><br><span class="line"></span><br><span class="line">james@james-Vostro-5471:~/datas$ export D</span><br><span class="line">james@james-Vostro-5471:~/datas$ sh helloworld.sh</span><br><span class="line">hello world</span><br><span class="line">bian liang</span><br><span class="line">james@james-Vostro-5471:~/datas$ </span><br></pre></td></tr></table></figure>

<h4 id="特殊变量"><a href="#特殊变量" class="headerlink" title="特殊变量"></a>特殊变量</h4><p>1、$n</p>
<p>&ensp;&ensp;&ensp;&ensp;功能描述：n为数字，$0代表该脚本名称，包含完整路径。$1- 9 代表第一到第九个参数 ，十 以上的参数需要用大括号包含，如{10}。</p>
<p>&ensp;&ensp;&ensp;&ensp;范例：输出该脚本文件名称，输入参数1和输入参数2的值</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">james@james-Vostro-5471:~/datas$ touch parameter.sh</span><br><span class="line">james@james-Vostro-5471:~/datas$ vim parameter.sh</span><br><span class="line">james@james-Vostro-5471:~/datas$ cat parameter.sh</span><br><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line"></span><br><span class="line">echo &quot;$0 $1 $2 $3&quot;</span><br><span class="line">james@james-Vostro-5471:~/datas$ bash parameter.sh</span><br><span class="line">parameter.sh   </span><br><span class="line">james@james-Vostro-5471:~/datas$ bash parameter.sh first</span><br><span class="line">parameter.sh first  </span><br><span class="line">james@james-Vostro-5471:~/datas$ bash parameter.sh first second</span><br><span class="line">parameter.sh first second </span><br><span class="line">james@james-Vostro-5471:~/datas$ bash parameter.sh first second third</span><br><span class="line">parameter.sh first second third</span><br><span class="line">james@james-Vostro-5471:~/datas$ bash parameter.sh first second third fourth</span><br><span class="line">parameter.sh first second third</span><br><span class="line">james@james-Vostro-5471:~/datas$ </span><br></pre></td></tr></table></figure>

<p>2、$#</p>
<p>&ensp;&ensp;&ensp;&ensp;功能描述：获取所有输入参数个数，常用于循环。</p>
<p>&ensp;&ensp;&ensp;&ensp;范例：获取输入参数的个数</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">james@james-Vostro-5471:~/datas$ vim parameter.sh</span><br><span class="line">james@james-Vostro-5471:~/datas$ cat parameter.sh</span><br><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line"></span><br><span class="line">echo &quot;$0 $1 $2 $3&quot;</span><br><span class="line"></span><br><span class="line">echo $#</span><br><span class="line">james@james-Vostro-5471:~/datas$ bash parameter.sh first second third</span><br><span class="line">parameter.sh first second third</span><br><span class="line">3</span><br><span class="line">james@james-Vostro-5471:~/datas$ </span><br></pre></td></tr></table></figure>

<p>3、$*和$@</p>
<p>&ensp;&ensp;&ensp;&ensp;$* : 这个变量代表命令行中所有的参数，$*把所有的参数看成一个整体</p>
<p>&ensp;&ensp;&ensp;&ensp;$@ : 这个变量也代表命令行中所有的参数，不过$@把每个参数区分对待</p>
<p>&ensp;&ensp;&ensp;&ensp;范例：打印输出所有参数</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">james@james-Vostro-5471:~/datas$ vim parameter.sh</span><br><span class="line">james@james-Vostro-5471:~/datas$ cat parameter.sh</span><br><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line"></span><br><span class="line">echo &quot;$0 $1 $2 $3&quot;</span><br><span class="line"></span><br><span class="line">echo $#</span><br><span class="line">echo $*</span><br><span class="line">echo $@</span><br><span class="line">james@james-Vostro-5471:~/datas$ bash parameter.sh first second third</span><br><span class="line">parameter.sh first second third</span><br><span class="line">3</span><br><span class="line">first second third</span><br><span class="line">first second third</span><br><span class="line">james@james-Vostro-5471:~/datas$ </span><br></pre></td></tr></table></figure>

<p>4、$?</p>
<p>&ensp;&ensp;&ensp;&ensp;功能描述：最后一次执行的命令的返回状态。如果这个变量的值为0，证明上一个命令正确执行；如果这个变量的值为非0（具体哪个数，由命令自己来决定），则证明上一个命令执行不正确了。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">james@james-Vostro-5471:~/datas$ $?</span><br><span class="line">0：未找到命令</span><br><span class="line">james@james-Vostro-5471:~/datas$ echo $?</span><br><span class="line">127</span><br><span class="line">james@james-Vostro-5471:~/datas$ bash helloworld.sh</span><br><span class="line">hello world</span><br><span class="line">bian liang</span><br><span class="line">james@james-Vostro-5471:~/datas$ echo $?</span><br><span class="line">0</span><br></pre></td></tr></table></figure>

<h3 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h3><h4 id="1、基本语法："><a href="#1、基本语法：" class="headerlink" title="1、基本语法："></a>1、基本语法：</h4><ol>
<li><p>“$((运算式))”或“$[运算式]”</p>
</li>
<li><p>expr  +，-，*，/，%  加，减，乘，除，取余</p>
</li>
</ol>
<p>&ensp;&ensp;&ensp;&ensp;注意：expr运算符间要有空格</p>
<h4 id="2、范例：计算3-2"><a href="#2、范例：计算3-2" class="headerlink" title="2、范例：计算3+2"></a>2、范例：计算3+2</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">james@james-Vostro-5471:~/datas$ expr 3 + 2</span><br><span class="line">5</span><br><span class="line">james@james-Vostro-5471:~/datas$ s=$((3+2))</span><br><span class="line">james@james-Vostro-5471:~/datas$ echo $s</span><br><span class="line">5</span><br></pre></td></tr></table></figure>

<p>范例：计算（2+3）*4</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">james@james-Vostro-5471:~/datas$ d=$[(2+3)*4]</span><br><span class="line">james@james-Vostro-5471:~/datas$ echo $d</span><br><span class="line">20</span><br><span class="line">james@james-Vostro-5471:~/datas$ expr `expr 2 + 3` \* 4</span><br><span class="line">20</span><br></pre></td></tr></table></figure>

<h3 id="条件判断"><a href="#条件判断" class="headerlink" title="条件判断"></a>条件判断</h3><h4 id="1、语法："><a href="#1、语法：" class="headerlink" title="1、语法："></a>1、语法：</h4><p>[ condition ] (<strong>condition前后要有空格</strong>)</p>
<p>注意：条件非空即为true，如[z]返回true，[] 返回false</p>
<h4 id="2、常用条件判断"><a href="#2、常用条件判断" class="headerlink" title="2、常用条件判断"></a>2、常用条件判断</h4><p>（1）两个整数之间比较</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x3D; 字符串比较</span><br><span class="line">-lt 小于（less than） -le 小于等于 （less equal）</span><br><span class="line">-eq 等于 （equal） -gt 大于 （greater than）</span><br><span class="line">-ge 大于等于 （greater equal） -ne不等于 （Not equal）</span><br></pre></td></tr></table></figure>

<p>（2）按照文件权限进行判断</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-r 有读的权限（read） -w 有写的权限 （write）</span><br><span class="line">-x 有执行的权限 （execute）</span><br></pre></td></tr></table></figure>

<p>（3）按照文件类型进行判断</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-f 文件存在并且是一个常规文件（file）</span><br><span class="line">-e 文件存在 （existence）</span><br><span class="line">-d 文件存在并是一个目录（directory）</span><br></pre></td></tr></table></figure>

<p>范例：23是否大于等于22</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">james@james-Vostro-5471:~/datas$ [ 23 -ge 22 ]</span><br><span class="line">james@james-Vostro-5471:~/datas$ echo $?</span><br><span class="line">0</span><br><span class="line">james@james-Vostro-5471:~/datas$ [ 23 -le 22 ]</span><br><span class="line">james@james-Vostro-5471:~/datas$ echo $?</span><br><span class="line">1</span><br></pre></td></tr></table></figure>

<p>范例：查看helloworld.sh 是否具有执行权限</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">james@james-Vostro-5471:~/datas$ [ -x /home/james/datas/helloworld.sh ]</span><br><span class="line">james@james-Vostro-5471:~/datas$ echo $?</span><br><span class="line">0</span><br></pre></td></tr></table></figure>

<p>范例：判断/home/james/datas/hello.txt是否存在</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">james@james-Vostro-5471:~/datas$ [ -e /home/james/datas/hello.txt ]</span><br><span class="line">james@james-Vostro-5471:~/datas$ echo $?</span><br><span class="line">1</span><br><span class="line">james@james-Vostro-5471:~/datas$ [ -e /home/james/datas/helloworld.sh ]</span><br><span class="line">james@james-Vostro-5471:~/datas$ echo $?</span><br><span class="line">0</span><br></pre></td></tr></table></figure>

<p>（4）多条件判断（&amp;&amp;表示前一条命令执行成功时，才执行后一条命令，|| 表示上一条命令执行失败后，才执行下一条命令）[]</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">james@james-Vostro-5471:~/datas$ [ 3 -ge 2 ] &amp;&amp; echo ok || echo notok</span><br><span class="line">ok</span><br><span class="line">james@james-Vostro-5471:~/datas$ [ 3 -ge 2 ] &amp;&amp; [ ] || echo notok</span><br><span class="line">notok</span><br><span class="line">james@james-Vostro-5471:~/datas$ [ 3 -ge 2 ] &amp; echo ok</span><br><span class="line">[1] 27351</span><br><span class="line">ok</span><br></pre></td></tr></table></figure>

<h3 id="流程控制"><a href="#流程控制" class="headerlink" title="流程控制"></a>流程控制</h3><h4 id="1、if判断"><a href="#1、if判断" class="headerlink" title="1、if判断"></a>1、if判断</h4><p>语法：</p>
<pre><code>if [ 条件判断式 ]；then
 程序
 fi
 或者
 if [ 条件判断式 ]
 then
 程序
 fi
</code></pre>
<p>注意事项：</p>
<ul>
<li>[ 条件判断式 ] ，中括号和条件判断式之间必须有空格</li>
<li>if后要有空格</li>
</ul>
<p>范例：输入一个数字，如果是1，则输出one，如果是2，则输出two，如果是其他，什么也不输出。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">james@james-Vostro-5471:~/datas$ cat testIf.sh</span><br><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line"></span><br><span class="line">if [ $1 -eq 1 ];then</span><br><span class="line">    echo &quot;one&quot;</span><br><span class="line">elif [ $1 -eq 2 ]</span><br><span class="line">then</span><br><span class="line">    echo &quot;two&quot;</span><br><span class="line">fi</span><br><span class="line">james@james-Vostro-5471:~/datas$ bash testIf.sh</span><br><span class="line">testIf.sh: 第 3 行: [: -eq: 需要一元表达式</span><br><span class="line">testIf.sh: 第 5 行: [: -eq: 需要一元表达式</span><br><span class="line">james@james-Vostro-5471:~/datas$ bash testIf.sh 1</span><br><span class="line">one</span><br><span class="line">james@james-Vostro-5471:~/datas$ bash testIf.sh 2</span><br><span class="line">two</span><br><span class="line">james@james-Vostro-5471:~/datas$ bash testIf.sh 3</span><br></pre></td></tr></table></figure>

<h4 id="2、case语句"><a href="#2、case语句" class="headerlink" title="2、case语句"></a>2、case语句</h4><p>语法：</p>
<pre><code>case $变量名 in
“值1”）
如果变量的值等于1，则执行程序1
;;
“值2”）
 如果变量的值等于2，则执行程序2
;;
…省略其他分支…
*)
 如果变量的值都不是以上的值，则执行此程序
;;
esac
</code></pre>
<p>注意事项：</p>
<ul>
<li><p>case行尾必须为单词“in”，每一个模式匹配必须以右括号“）”结束。</p>
</li>
<li><p>双分号“;;”表示命令序列结束，相当于java中的break。</p>
</li>
<li><p>最后的“*）”表示默认模式，相当于java中的default</p>
</li>
</ul>
<p>范例：输入一个数字，如果是1，则输出one，如果是2，则输出two，如果是其他，输出hello</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">james@james-Vostro-5471:~/datas$ cat testCase.sh</span><br><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line"></span><br><span class="line">case $1 in</span><br><span class="line">1)</span><br><span class="line">    echo &quot;one&quot;</span><br><span class="line">;;</span><br><span class="line">2)</span><br><span class="line">    echo &quot;two&quot;</span><br><span class="line">;;</span><br><span class="line">*)</span><br><span class="line">    echo &quot;hello&quot;</span><br><span class="line">;;</span><br><span class="line">esac</span><br><span class="line">james@james-Vostro-5471:~/datas$ bash testCase.sh 1</span><br><span class="line">one</span><br><span class="line">james@james-Vostro-5471:~/datas$ bash testCase.sh 2</span><br><span class="line">two</span><br><span class="line">james@james-Vostro-5471:~/datas$ bash testCase.sh 3</span><br><span class="line">hello</span><br></pre></td></tr></table></figure>

<h4 id="3、for循环"><a href="#3、for循环" class="headerlink" title="3、for循环"></a>3、for循环</h4><p>语法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">for ((初始值；循环控制条件；变量变化))</span><br><span class="line"> do</span><br><span class="line"> 程序</span><br><span class="line"> done</span><br></pre></td></tr></table></figure>

<p>范例：从1加到100</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">james@james-Vostro-5471:~/datas$ cat testFor.sh</span><br><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line"></span><br><span class="line">s=0</span><br><span class="line">for ((i=1;i&lt;=100;++i))</span><br><span class="line">do</span><br><span class="line">    s=$[$s+$i] </span><br><span class="line">done</span><br><span class="line"></span><br><span class="line">echo $s</span><br><span class="line">james@james-Vostro-5471:~/datas$ bash testFor.sh</span><br><span class="line">5050</span><br></pre></td></tr></table></figure>

<p>语法2：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">for 变量 in 值1 值2 值3…</span><br><span class="line"> do</span><br><span class="line"> 程序</span><br><span class="line"> done</span><br></pre></td></tr></table></figure>

<p>范例：打印所有输入参数（观察 ∗ 与 *与 ∗与@的区别）</p>
<p>使用$*</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">james@james-Vostro-5471:~/datas$ cat testFor.sh</span><br><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line"></span><br><span class="line">s=0</span><br><span class="line">for i in $* </span><br><span class="line">do</span><br><span class="line">    echo &quot;打印所有参数：$i&quot; </span><br><span class="line">done</span><br><span class="line"></span><br><span class="line">james@james-Vostro-5471:~/datas$ bash testFor.sh a c v r </span><br><span class="line">打印所有参数：a</span><br><span class="line">打印所有参数：c</span><br><span class="line">打印所有参数：v</span><br><span class="line">打印所有参数：r</span><br></pre></td></tr></table></figure>

<p>使用$@</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">james@james-Vostro-5471:~/datas$ cat testFor.sh</span><br><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line"></span><br><span class="line">s=0</span><br><span class="line">for i in $@ </span><br><span class="line">do</span><br><span class="line">    echo &quot;打印所有参数：$i&quot; </span><br><span class="line">done</span><br><span class="line"></span><br><span class="line">james@james-Vostro-5471:~/datas$ bash testFor.sh</span><br><span class="line">james@james-Vostro-5471:~/datas$ bash testFor.sh adda sda</span><br><span class="line">打印所有参数：adda</span><br><span class="line">打印所有参数：sda</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">james@james-Vostro-5471:~/datas$ cat testFor.sh</span><br><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line"></span><br><span class="line">for i in &quot;$*&quot; </span><br><span class="line">do</span><br><span class="line">    echo &quot;打印所有参数：$i&quot; </span><br><span class="line">done</span><br><span class="line"></span><br><span class="line">for j in &quot;$@&quot;</span><br><span class="line">do</span><br><span class="line">    echo &quot;打印参数：$j&quot;</span><br><span class="line">done    </span><br><span class="line">james@james-Vostro-5471:~/datas$ bash testFor.sh a b c</span><br><span class="line">打印所有参数：a b c</span><br><span class="line">打印参数：a</span><br><span class="line">打印参数：b</span><br><span class="line">打印参数：c</span><br></pre></td></tr></table></figure>



<p>&ensp;&ensp;&ensp;&ensp;总结：由上图可以看出” ∗ “ 将 所 有 参 数 看 做 一 个 整 体 输 出 ， 只 循 环 一 次 ； 而 “ *”将所有参数看做一个整体输出，只循环一次；而” ∗”将所有参数看做一个整体输出，只循环一次；而”@”将输出参数分开输出，执行三次循环。</p>
<h4 id="4、while循环"><a href="#4、while循环" class="headerlink" title="4、while循环"></a>4、while循环</h4><p>语法： </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">while [ 条件判断式 ]</span><br><span class="line"> do</span><br><span class="line"> 程序</span><br><span class="line"> done</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>范例：从1加到100</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">james@james-Vostro-5471:~/datas$ cat testWhile.sh</span><br><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line"></span><br><span class="line">s=0</span><br><span class="line">i=1</span><br><span class="line">while [ $i -le 100 ]</span><br><span class="line">do</span><br><span class="line">    s=$[$s + $i]</span><br><span class="line">    i=$[$i + 1]</span><br><span class="line">done</span><br><span class="line"></span><br><span class="line">echo $s</span><br><span class="line">james@james-Vostro-5471:~/datas$ bash testWhile.sh</span><br><span class="line">5050</span><br></pre></td></tr></table></figure>

<h3 id="read读取控制台输入"><a href="#read读取控制台输入" class="headerlink" title="read读取控制台输入"></a>read读取控制台输入</h3><p>语法：read 选项 参数</p>
<p>选项：</p>
<ul>
<li>-p：指定读取值时的提示符</li>
<li>-t ：指定读取值时的时间（秒）</li>
</ul>
<p>参数：</p>
<ul>
<li>变量：指定读取值的变量名</li>
</ul>
<p>范例：提示7秒内，读取控制台输入的名称</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">james@james-Vostro-5471:~/datas$ cat testRead.sh</span><br><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line"></span><br><span class="line">read -t 7 -p &quot;input your name: &quot; NAME</span><br><span class="line">echo $NAME</span><br><span class="line">james@james-Vostro-5471:~/datas$ bash testRead.sh</span><br><span class="line">input your name: 123456</span><br><span class="line">123456</span><br></pre></td></tr></table></figure>

<h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><h4 id="系统函数"><a href="#系统函数" class="headerlink" title="系统函数"></a>系统函数</h4><p>1、basename基本语法</p>
<p>&ensp;&ensp;&ensp;&ensp;basename [string/pathname] suffix </p>
<p>&ensp;&ensp;&ensp;&ensp;功能描述：basename命令会删掉所有的前缀包括最后一个（‘/’）字符，然后将字符显示出来。</p>
<p>&ensp;&ensp;&ensp;&ensp;选项：suffix为后缀，如果suffix被指定了，basename会将pathname或string中的suffix去掉</p>
<p>范例：截取/home/zby/read.sh路径的文件名称</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">james@james-Vostro-5471:~/datas$ basename /home/james/datas/helloworld.sh</span><br><span class="line">helloworld.sh</span><br><span class="line">james@james-Vostro-5471:~/datas$ basename /home/james/datas/testIf.sh .sh</span><br><span class="line">testIf</span><br></pre></td></tr></table></figure>



<p>2、dirrame基本语法</p>
<p>&ensp;&ensp;&ensp;&ensp;dirname 文件绝对路径 </p>
<p>&ensp;&ensp;&ensp;&ensp;功能描述：从给定的包含绝对路径的文件名中去除文件名（非目录的部分），然后返回剩下的路径（目录的部分）</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">james@james-Vostro-5471:~/datas$ dirname /home/james/datas/testIf.sh</span><br><span class="line">/home/james/datas</span><br></pre></td></tr></table></figure>

<h4 id="自定义函数"><a href="#自定义函数" class="headerlink" title="自定义函数"></a>自定义函数</h4><p>1、基本语法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[function] funname [()]</span><br><span class="line">&#123;</span><br><span class="line"> Action;</span><br><span class="line"> [return int;]</span><br><span class="line">&#125;</span><br><span class="line">funname</span><br></pre></td></tr></table></figure>


<p>2、经验技巧</p>
<p>&ensp;&ensp;&ensp;&ensp;必须在调用函数的地方之前，先声明函数，shell脚本是逐行运行。不会像其他语言一样先编译。<br>&ensp;&ensp;&ensp;&ensp;函数返回值，只能通过<code>$?</code>系统变量获得，可以显示加：return返回，如果不加，将以最后一条命令运行结果，作为返回值。return后跟数值n（0-255）</p>
<p>范例：计算两个输入参数的和</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">james@james-Vostro-5471:~/datas$ cat fun.sh</span><br><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line"></span><br><span class="line">function sum()</span><br><span class="line">&#123;</span><br><span class="line">    s=0;</span><br><span class="line">    s=$[$1+$2]</span><br><span class="line">    echo $s</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">read -p &quot;input parameter1:&quot; p1</span><br><span class="line">read -p &quot;input parameter2:&quot; p2</span><br><span class="line"></span><br><span class="line">sum $p1 $p2</span><br><span class="line">james@james-Vostro-5471:~/datas$ bash fun.sh</span><br><span class="line">input parameter1:1</span><br><span class="line">input parameter2:2</span><br><span class="line">3</span><br></pre></td></tr></table></figure>

<h3 id="Shell工具"><a href="#Shell工具" class="headerlink" title="Shell工具"></a>Shell工具</h3><h4 id="cut"><a href="#cut" class="headerlink" title="cut"></a>cut</h4><p>&ensp;&ensp;&ensp;&ensp;cut的工作就是“剪”，具体地说就是在文件中负责剪切数据用的。cut命令从文件中的每一行剪切文字、字符和字段并将这些字节、字符和字段输出。</p>
<p>1、基本用法：</p>
<ul>
<li>cut [选项参数] filename</li>
<li>说明：默认分隔符是制表符</li>
</ul>
<p>2、参数说明：</p>
<ul>
<li>-f  列号，提取第几列</li>
<li>-d 分隔符，按照指定分隔符分割lie</li>
</ul>
<p>范例：数据准备</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">james@james-Vostro-5471:~/datas$ vim cut.txt</span><br><span class="line">james@james-Vostro-5471:~/datas$ cat cut.txt</span><br><span class="line">bei jing sheng yang</span><br><span class="line">shang hai xiang gang</span><br><span class="line">tian jin xia men</span><br><span class="line">wu han tai bei</span><br><span class="line">zheng zhou</span><br><span class="line">fu zhou</span><br></pre></td></tr></table></figure>

<p>&ensp;&ensp;&ensp;&ensp;切割<code>cut.txt</code>的第一列</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">james@james-Vostro-5471:~/datas$ cut -d &quot; &quot; -f 1 cut.txt</span><br><span class="line">bei</span><br><span class="line">shang</span><br><span class="line">tian</span><br><span class="line">wu</span><br><span class="line">zheng</span><br><span class="line">fu</span><br></pre></td></tr></table></figure>

<p>&ensp;&ensp;&ensp;&ensp;切割<code>cut.txt</code>的第2，3列</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">james@james-Vostro-5471:~/datas$ cut -d &quot; &quot; -f 2,3 cut.txt</span><br><span class="line">jing sheng</span><br><span class="line">hai xiang</span><br><span class="line">jin xia</span><br><span class="line">han tai</span><br><span class="line">zhou</span><br><span class="line">zhou</span><br></pre></td></tr></table></figure>

<p>&ensp;&ensp;&ensp;&ensp;切割<code>cut.txt</code>文件中的<code>shang</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">james@james-Vostro-5471:~/datas$ cat cut.txt | grep shang</span><br><span class="line">shang hai xiang gang</span><br><span class="line">james@james-Vostro-5471:~/datas$ cat cut.txt | grep shang | cut -d &quot; &quot; -f 1</span><br><span class="line">shang</span><br></pre></td></tr></table></figure>

<p>&ensp;&ensp;&ensp;&ensp;选取系统<code>PATH</code>变量值，第二个“：”开始后的所有路径：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">james@james-Vostro-5471:~/datas$ echo $PATH</span><br><span class="line">/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games:/usr/local/games:/snap/bin</span><br><span class="line">james@james-Vostro-5471:~/datas$ echo $PATH | cut -d : -f 3-</span><br><span class="line">/usr/sbin:/usr/bin:/sbin:/bin:/usr/games:/usr/local/games:/snap/bin</span><br></pre></td></tr></table></figure>

<p>&ensp;&ensp;&ensp;&ensp;切割<code>ifconfig</code>后打印<code>IP</code>地址</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">james@james-Vostro-5471:~$ ifconfig lo</span><br><span class="line">lo: flags=73&lt;UP,LOOPBACK,RUNNING&gt;  mtu 65536</span><br><span class="line">        inet 127.0.0.1  netmask 255.0.0.0</span><br><span class="line">        inet6 ::1  prefixlen 128  scopeid 0x10&lt;host&gt;</span><br><span class="line">        loop  txqueuelen 1000  (本地环回)</span><br><span class="line">        RX packets 44305  bytes 5010333 (5.0 MB)</span><br><span class="line">        RX errors 0  dropped 0  overruns 0  frame 0</span><br><span class="line">        TX packets 44305  bytes 5010333 (5.0 MB)</span><br><span class="line">        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0</span><br><span class="line"></span><br><span class="line">james@james-Vostro-5471:~$ ifconfig lo | grep &quot;inet &quot;</span><br><span class="line">        inet 127.0.0.1  netmask 255.0.0.0</span><br><span class="line">james@james-Vostro-5471:~$ ifconfig lo | grep &quot;inet &quot; | cut -d &quot; &quot; -f 10</span><br><span class="line">127.0.0.1</span><br></pre></td></tr></table></figure>

<h4 id="sed"><a href="#sed" class="headerlink" title="sed"></a>sed</h4><p>&ensp;&ensp;&ensp;&ensp;<code>sed</code>是一种流编辑器，它一次处理一行内容。处理时，把当前处理的行存储在临时缓冲区中，称为“模式空间”，接着用<code>sed</code>命令处理缓存区中的内容，处理完成后，把缓冲区的内容送往屏幕。接着处理下一行，这样不断重复，知道文件末尾。文件内容并没有改变，除非你使用重定向存储输出。</p>
<ul>
<li><p>基本用法：</p>
<p>  sed [选项参数] ‘command’ filename</p>
</li>
<li><p>参数说明</p>
<p>  -e 直接在命令模式上进行sed的动作编辑</p>
</li>
<li><p>命令功能描述</p>
<p>  a 新增，a的后面可以接字符串，在下一行出现</p>
<p>  d 删除</p>
<p>  s 查找并替换</p>
</li>
</ul>
<p>范例：数据准备</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">james@james-Vostro-5471:~$ vim sed.txt</span><br><span class="line">james@james-Vostro-5471:~$ cat sed.txt</span><br><span class="line">abcd aaaa</span><br><span class="line">zxcv aaas</span><br><span class="line">dasd qwdd</span><br><span class="line">ad ad</span><br><span class="line">dc da</span><br><span class="line">da ee</span><br></pre></td></tr></table></figure>

<p>&ensp;&ensp;&ensp;&ensp;将<code>aa cc</code>这个字符串插入到<code>sed.txt</code>第二行下打印</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">james@james-Vostro-5471:~$ sed &quot;2a aa cc&quot; sed.txt</span><br><span class="line">abcd aaaa</span><br><span class="line">zxcv aaas</span><br><span class="line">aa cc</span><br><span class="line">dasd qwdd</span><br><span class="line">ad ad</span><br><span class="line">dc da</span><br><span class="line">da ee</span><br><span class="line">james@james-Vostro-5471:~$ cat sed.txt</span><br><span class="line">abcd aaaa</span><br><span class="line">zxcv aaas</span><br><span class="line">dasd qwdd</span><br><span class="line">ad ad</span><br><span class="line">dc da</span><br><span class="line">da ee</span><br></pre></td></tr></table></figure>

<p>&ensp;&ensp;&ensp;&ensp;删除 <code>sed.txt</code> 中包含<code>d</code>的行</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">james@james-Vostro-5471:~$ sed &quot;/d/d&quot; sed.txt</span><br><span class="line">zxcv aaas</span><br></pre></td></tr></table></figure>

<p>&ensp;&ensp;&ensp;&ensp;将<code>sed.txt</code>文件中的<code>aa</code>替换为<code>pp</code>(<code>g</code>表示global，全部替换)</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">james@james-Vostro-5471:~$ sed &quot;s/aa/pp/g&quot; sed.txt</span><br><span class="line">abcd pppp</span><br><span class="line">zxcv ppas</span><br><span class="line">dasd qwdd</span><br><span class="line">ad ad</span><br><span class="line">dc da</span><br><span class="line">da ee</span><br></pre></td></tr></table></figure>

<p>&ensp;&ensp;&ensp;&ensp;将<code>sed.txt</code>文件中的第二行删除并将<code>aaa</code>替换为<code>qf</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">james@james-Vostro-5471:~$ sed -e &quot;2d&quot; -e &quot;s/aaa/qf/g&quot; sed.txt</span><br><span class="line">abcd qfa</span><br><span class="line">dasd qwdd</span><br><span class="line">ad ad</span><br><span class="line">dc da</span><br><span class="line">da ee</span><br></pre></td></tr></table></figure>

<h4 id="awk"><a href="#awk" class="headerlink" title="awk"></a>awk</h4><p>&ensp;&ensp;&ensp;&ensp;一个强大的文本分析工具，把文件逐行的读入，以空格为默认的分割符并将每行切片，切开的部分再进行分析处理。<br>1.基本用法</p>
<p>&ensp;&ensp;&ensp;&ensp;awk [选项参数] ‘pattern1 {action} pattern2 {action}…’ filename</p>
<p>&ensp;&ensp;&ensp;&ensp;pattern :  表示AWK在数据中查找的内容，就是匹配模式</p>
<p>&ensp;&ensp;&ensp;&ensp;action：在找到匹配内容时所执行的一系列命令。</p>
<p>参数说明</p>
<ul>
<li>-F   指定输入文件拆分隔离</li>
<li>-v   赋值一个用户定义变量</li>
</ul>
<p>范例：数据准备(/etc/passwd文件)</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">james@james-Vostro-5471:~/datas$ sudo cp /etc/passwd ./</span><br><span class="line">[sudo] james 的密码： </span><br><span class="line">james@james-Vostro-5471:~/datas$ ls</span><br><span class="line">batch.sh  demo.txt  helloworsudold.sh  passwd       testFor.sh  testRead.sh</span><br><span class="line">cut.txt   fun.sh    parameter.sh   testCase.sh  testIf.sh   testWhile.sh</span><br><span class="line">james@james-Vostro-5471:~/datas$ cat passwd</span><br><span class="line">root:x:0:0:root:/root:/bin/bash</span><br><span class="line">daemon:x:1:1:daemon:/usr/sbin:/usr/sbin/nologin</span><br><span class="line">bin:x:2:2:bin:/bin:/usr/sbin/nologin</span><br><span class="line">sys:x:3:3:sys:/dev:/usr/sbin/nologin</span><br><span class="line">sync:x:4:65534:sync:/bin:/bin/sync</span><br><span class="line">games:x:5:60:games:/usr/games:/usr/sbin/nologin</span><br><span class="line">man:x:6:12:man:/var/cache/man:/usr/sbin/nologin</span><br><span class="line">lp:x:7:7:lp:/var/spool/lpd:/usr/sbin/nologin</span><br><span class="line">mail:x:8:8:mail:/var/mail:/usr/sbin/nologin</span><br><span class="line">news:x:9:9:news:/var/spool/news:/usr/sbin/nologin</span><br><span class="line">uucp:x:10:10:uucp:/var/spool/uucp:/usr/sbin/nologin</span><br><span class="line">proxy:x:13:13:proxy:/bin:/usr/sbin/nologin</span><br><span class="line">www-data:x:33:33:www-data:/var/www:/usr/sbin/nologin</span><br><span class="line">backup:x:34:34:backup:/var/backups:/usr/sbin/nologin</span><br><span class="line">list:x:38:38:Mailing List Manager:/var/list:/usr/sbin/nologin</span><br><span class="line">irc:x:39:39:ircd:/var/run/ircd:/usr/sbin/nologin</span><br><span class="line">gnats:x:41:41:Gnats Bug-Reporting System (admin):/var/lib/gnats:/usr/sbin/nologin</span><br><span class="line">nobody:x:65534:65534:nobody:/nonexistent:/usr/sbin/nologin</span><br><span class="line">systemd-network:x:100:102:systemd Network Management,,,:/run/systemd/netif:/usr/sbin/nologin</span><br><span class="line">systemd-resolve:x:101:103:systemd Resolver,,,:/run/systemd/resolve:/usr/sbin/nologin</span><br><span class="line">syslog:x:102:106::/home/syslog:/usr/sbin/nologin</span><br><span class="line">messagebus:x:103:107::/nonexistent:/usr/sbin/nologin</span><br><span class="line">_apt:x:104:65534::/nonexistent:/usr/sbin/nologin</span><br><span class="line">uuidd:x:105:111::/run/uuidd:/usr/sbin/nologin</span><br><span class="line">avahi-autoipd:x:106:112:Avahi autoip daemon,,,:/var/lib/avahi-autoipd:/usr/sbin/nologin</span><br><span class="line">usbmux:x:107:46:usbmux daemon,,,:/var/lib/usbmux:/usr/sbin/nologin</span><br><span class="line">dnsmasq:x:108:65534:dnsmasq,,,:/var/lib/misc:/usr/sbin/nologin</span><br><span class="line">rtkit:x:109:114:RealtimeKit,,,:/proc:/usr/sbin/nologin</span><br><span class="line">cups-pk-helper:x:110:116:user for cups-pk-helper service,,,:/home/cups-pk-helper:/usr/sbin/nologin</span><br><span class="line">speech-dispatcher:x:111:29:Speech Dispatcher,,,:/var/run/speech-dispatcher:/bin/false</span><br><span class="line">whoopsie:x:112:117::/nonexistent:/bin/false</span><br><span class="line">kernoops:x:113:65534:Kernel Oops Tracking Daemon,,,:/:/usr/sbin/nologin</span><br><span class="line">saned:x:114:119::/var/lib/saned:/usr/sbin/nologin</span><br><span class="line">pulse:x:115:120:PulseAudio daemon,,,:/var/run/pulse:/usr/sbin/nologin</span><br><span class="line">avahi:x:116:122:Avahi mDNS daemon,,,:/var/run/avahi-daemon:/usr/sbin/nologin</span><br><span class="line">colord:x:117:123:colord colour management daemon,,,:/var/lib/colord:/usr/sbin/nologin</span><br><span class="line">hplip:x:118:7:HPLIP system user,,,:/var/run/hplip:/bin/false</span><br><span class="line">geoclue:x:119:124::/var/lib/geoclue:/usr/sbin/nologin</span><br><span class="line">gnome-initial-setup:x:120:65534::/run/gnome-initial-setup/:/bin/false</span><br><span class="line">gdm:x:121:125:Gnome Display Manager:/var/lib/gdm3:/bin/false</span><br><span class="line">james:x:1000:1000:James,,,:/home/james:/bin/bash</span><br></pre></td></tr></table></figure>

<p>&ensp;&ensp;&ensp;&ensp;搜索<code>passwd</code>文件以<code>root</code>关键字开头的所有行，并输出该行的第一列和第七列，中间以“，”号分割。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">james@james-Vostro-5471:~/datas$ awk -F : &#x27;/^root/ &#123;print $7&#125;&#x27; passwd</span><br><span class="line">/bin/bash</span><br><span class="line">james@james-Vostro-5471:~/datas$ awk -F : &#x27;/^root/ &#123;print $1&quot;,&quot;$7&#125;&#x27; passwd</span><br><span class="line">root,/bin/bash</span><br><span class="line">james@james-Vostro-5471:~/datas$ </span><br></pre></td></tr></table></figure>

<p>&ensp;&ensp;&ensp;&ensp;只显示<code>passwd</code>的第一列和第七列，以逗号分割，且在所有行前面添加列名<code>user</code>，<code>shell</code> 在最后一行添加<code>gqw, /bin/zuihsuai</code>。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">james@james-Vostro-5471:~/datas$ awk -F : &#x27;BEGIN&#123;print &quot;user,shell&quot;&#125;&#123;print $1&quot;,&quot;$7&#125; END&#123;print &quot;gqw,/bin/zuihuai&quot;&#125;&#x27; passwd</span><br><span class="line">user,shell</span><br><span class="line">root,/bin/bash</span><br><span class="line">daemon,/usr/sbin/nologin</span><br><span class="line">bin,/usr/sbin/nologin</span><br><span class="line">sys,/usr/sbin/nologin</span><br><span class="line">sync,/bin/sync</span><br><span class="line">games,/usr/sbin/nologin</span><br><span class="line">man,/usr/sbin/nologin</span><br><span class="line">lp,/usr/sbin/nologin</span><br><span class="line">mail,/usr/sbin/nologin</span><br><span class="line">news,/usr/sbin/nologin</span><br><span class="line">uucp,/usr/sbin/nologin</span><br><span class="line">…………………………………………………………………………………………</span><br></pre></td></tr></table></figure>

<p>注意：</p>
<ul>
<li><code>BEGIN</code>在所有数据读取行之前执行</li>
<li><code>END</code> 在所有数据执行之后执行</li>
</ul>
<p>&ensp;&ensp;&ensp;&ensp;将passwd文件中的用户id增加数值1并输出</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">james@james-Vostro-5471:~/datas$ awk -F : &#x27;&#123;print $3&#125;&#x27; passwd</span><br><span class="line">0</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">………………………………………………………………………………………………………………</span><br><span class="line">james@james-Vostro-5471:~/datas$ awk -F : -v i=1 &#x27;&#123;print $3+i&#125;&#x27; passwd</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">…………………………………………………………………………………………………………………………</span><br></pre></td></tr></table></figure>

<p>2.<code>awk</code>的内置变量 </p>
<table>
<thead>
<tr>
<th align="center">变量</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">FILENAME</td>
<td align="center">文件名</td>
</tr>
<tr>
<td align="center">NR</td>
<td align="center">已读的记录数</td>
</tr>
<tr>
<td align="center">NF</td>
<td align="center">浏览记录的域的个数（切割后，列的个数）</td>
</tr>
</tbody></table>
<p>范例：统计<code>passwd</code>文件名，每行的行号，每行的列数。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">james@james-Vostro-5471:~/datas$ awk -F : &#x27;&#123;print FILENAME&quot;,&quot;NR&quot;,&quot;NF&#125;&#x27; passwd</span><br><span class="line">passwd,1,7</span><br><span class="line">passwd,2,7</span><br><span class="line">passwd,3,7</span><br><span class="line">passwd,4,7</span><br><span class="line">passwd,5,7</span><br><span class="line">passwd,6,7</span><br><span class="line">passwd,7,7</span><br><span class="line">passwd,8,7</span><br><span class="line">………………………………………………………………</span><br></pre></td></tr></table></figure>

<p>&ensp;&ensp;&ensp;&ensp;切割<code>inet</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">james@james-Vostro-5471:~/datas$ ifconfig lo |grep &quot;inet &quot;</span><br><span class="line">        inet 127.0.0.1  netmask 255.0.0.0</span><br><span class="line">james@james-Vostro-5471:~/datas$ ifconfig lo |grep &quot;inet &quot; | awk -F &quot; &quot; &#x27;&#123;print $2&#125;&#x27;</span><br><span class="line">127.0.0.1</span><br></pre></td></tr></table></figure>

<p>&ensp;&ensp;&ensp;&ensp;查询<code>cut.txt</code>中空行所在的行号</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">james@james-Vostro-5471:~/datas$ cat cut.txt</span><br><span class="line"></span><br><span class="line">bei jing sheng yang</span><br><span class="line"></span><br><span class="line">shang hai xiang gang</span><br><span class="line">tian jin xia men</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">wu han tai bei</span><br><span class="line">zheng zhou</span><br><span class="line">fu zhou</span><br><span class="line">james@james-Vostro-5471:~/datas$ awk &#x27;/^$/&#123;print NR&#125;&#x27; cut.txt</span><br><span class="line">1</span><br><span class="line">3</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td></tr></table></figure>

<h4 id="sort"><a href="#sort" class="headerlink" title="sort"></a>sort</h4><p>&ensp;&ensp;&ensp;&ensp;sort命令是在Linux里非常有用，它将文件进行排序，并将排序的结果标准输出。</p>
<p>基本语法： sort 选项 参数</p>
<ul>
<li>-n 依照数值大小排序</li>
<li>-r 以相反的顺序来排序</li>
<li>-t 设置排序时所用的分隔字符</li>
<li>-k 指定需要排序的列</li>
</ul>
<p>&ensp;&ensp;&ensp;&ensp;参数： 指定待排序的文件列表</p>
<p>范例：</p>
<p>数据准备：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">james@james-Vostro-5471:~/datas$ vim sort.txt</span><br><span class="line">james@james-Vostro-5471:~/datas$ cat sort.txt</span><br><span class="line">aa:12:5.4</span><br><span class="line">ba:14:67</span><br><span class="line">kl:421:4</span><br><span class="line">er:00:5</span><br><span class="line">hj:213:00</span><br></pre></td></tr></table></figure>

<p>按照 “:” 分割后的第三列倒序排序</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">james@james-Vostro-5471:~/datas$ sort -t : -k 3 -n sort.txt</span><br><span class="line">hj:213:00</span><br><span class="line">kl:421:4</span><br><span class="line">er:00:5</span><br><span class="line">aa:12:5.4</span><br><span class="line">ba:14:67</span><br></pre></td></tr></table></figure>

<p>用第二列的数值进行倒序排序</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">james@james-Vostro-5471:~/datas$ sort -t : -nrk 2 sort.txt</span><br><span class="line">kl:421:4</span><br><span class="line">hj:213:00</span><br><span class="line">ba:14:67</span><br><span class="line">aa:12:5.4</span><br><span class="line">er:00:5</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>shell</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>shell</tag>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>二叉树中的序列化和反序列化</title>
    <url>/2021/05/05/%E4%BA%8C%E5%8F%89%E6%A0%91%EF%BC%9A%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%BA%8F%E5%88%97%E5%8C%96%E5%92%8C%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/</url>
    <content><![CDATA[<h3 id="一、题目"><a href="#一、题目" class="headerlink" title="一、题目"></a>一、题目</h3><p>&ensp;&ensp;&ensp;&ensp;序列化是将一个数据结构或者对象转换为连续的比特位的操作，进而可以将转换后的数据存储在一个文件或者内存中，同时也可以通过网络传输到另一个计算机环境，采取相反方式重构得到原数据。</p>
<span id="more"></span>

<p>&ensp;&ensp;&ensp;&ensp;请设计一个算法来实现二叉树的序列化与反序列化。这里不限定你的序列 / 反序列化算法执行逻辑，你只需要保证一个二叉树可以被序列化为一个字符串并且将这个字符串反序列化为原始的树结构。 </p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">     1</span><br><span class="line">   &#x2F;   \</span><br><span class="line">  2     3</span><br><span class="line">       &#x2F; \</span><br><span class="line">      4   5</span><br><span class="line">输入：root &#x3D; [1,2,3,null,null,4,5]</span><br><span class="line">输出：[1,2,3,null,null,4,5]</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：root &#x3D; []</span><br><span class="line">输出：[]</span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：root &#x3D; [1]</span><br><span class="line">输出：[1]</span><br></pre></td></tr></table></figure>

<p><strong>示例 4：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：root &#x3D; [1,2]</span><br><span class="line">输出：[1,2]</span><br></pre></td></tr></table></figure>

<p> <strong>提示：</strong></p>
<ul>
<li>树中结点数在范围 <code>[0, 104]</code> 内</li>
<li><code>-1000 &lt;= Node.val &lt;= 1000</code></li>
</ul>
<h3 id="二、思路与代码"><a href="#二、思路与代码" class="headerlink" title="二、思路与代码"></a>二、思路与代码</h3><p>&ensp;&ensp;&ensp;&ensp;说白了，这不就是先按照一定的规则遍历二叉树，再用与之对应的规则把相应的字符串构建成二叉树。</p>
<p>&ensp;&ensp;&ensp;&ensp;序列化与反序列化主要分为两个流派：dfs和bfs；由于二叉树的特殊性，dfs分为前序、中序、后序遍历，但<strong>只有前序和后序遍历才可以在线性复杂度下进行反序列化</strong>。</p>
<p>&ensp;&ensp;&ensp;&ensp;前序、后序、层序都能够很好的找到根节点，而且不同于一般构造二叉树的问题，为了区分子树，此处将空指针的地方指出，相当于比较完整的给出了树的结构。而且为了区分每个节点的值，不管是空节点还是普通节点，都必须以“,”或其他标记结尾。</p>
<p>&ensp;&ensp;&ensp;&ensp;反序列化时，在确定根节点后，紧接着确定某一子树，对当前子树采用递归，形成了相同的问题，类似于序列化过程中的递归问题。</p>
<p>&ensp;&ensp;&ensp;&ensp;反序列化中值得注意的是，前序是利用序列化结果，依次从前往后构造节点，类似于队列；后序依次从后往前，类似于栈；中序时，由于无法从序列化结果中找到根节点位置，也就无法准确划分左右子树，无法形成递归的结构，这种方式不能反序列化！</p>
<p>&ensp;&ensp;&ensp;&ensp;层序遍历思路类似，相对要麻烦一点，拿新结点一层一层的往后面接，这里可以考虑直接用vector加上索引（也可以用queue，但是vector访问简洁一点）。</p>
<h5 id="先序遍历序列化与反序列化"><a href="#先序遍历序列化与反序列化" class="headerlink" title="先序遍历序列化与反序列化"></a>先序遍历序列化与反序列化</h5><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Codec</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    string treeStr;</span><br><span class="line">    <span class="comment">// Encodes a tree to a single string.</span></span><br><span class="line">    <span class="function">string <span class="title">serialize</span><span class="params">(TreeNode* root)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">preorder</span>(root);</span><br><span class="line">        treeStr.<span class="built_in">pop_back</span>();</span><br><span class="line">        <span class="keyword">return</span> treeStr;</span><br><span class="line">    &#125;  </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">preorder</span><span class="params">(TreeNode* root)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!root)</span><br><span class="line">        &#123;</span><br><span class="line">            treeStr += <span class="string">&quot;#,&quot;</span>;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        treeStr += (<span class="built_in">to_string</span>(root-&gt;val) + <span class="string">&quot;,&quot;</span>);</span><br><span class="line">        <span class="built_in">preorder</span>(root-&gt;left);</span><br><span class="line">        <span class="built_in">preorder</span>(root-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">queue&lt;string&gt; <span class="title">split</span><span class="params">(string&amp; str)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        queue&lt;string&gt; treeNodeQue;</span><br><span class="line">        <span class="keyword">if</span> (str.<span class="built_in">empty</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> treeNodeQue;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> strLength = str.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> pre = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= strLength; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (i == strLength || str[i] == <span class="string">&#x27;,&#x27;</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                treeNodeQue.<span class="built_in">emplace</span>(str.<span class="built_in">substr</span>(pre, i - pre));</span><br><span class="line">                pre = i + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> treeNodeQue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">TreeNode* <span class="title">deserialize</span><span class="params">(queue&lt;string&gt;&amp; treeNodeQue)</span></span></span><br><span class="line"><span class="function">    </span>&#123;        </span><br><span class="line">        <span class="keyword">if</span> (treeNodeQue.<span class="built_in">empty</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        string first = treeNodeQue.<span class="built_in">front</span>();</span><br><span class="line">        treeNodeQue.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">if</span> (first == <span class="string">&quot;#&quot;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        TreeNode* root = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(<span class="built_in">stoi</span>(first));</span><br><span class="line">        root-&gt;left = <span class="built_in">deserialize</span>(treeNodeQue);</span><br><span class="line">        root-&gt;right = <span class="built_in">deserialize</span>(treeNodeQue);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Decodes your encoded data to tree.</span></span><br><span class="line">    <span class="function">TreeNode* <span class="title">deserialize</span><span class="params">(string data)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        queue&lt;string&gt; temp = <span class="built_in">split</span>(data);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">deserialize</span>(temp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="后序遍历序列化与反序列化"><a href="#后序遍历序列化与反序列化" class="headerlink" title="后序遍历序列化与反序列化"></a>后序遍历序列化与反序列化</h5><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Codec</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    string treeStr;</span><br><span class="line">    <span class="comment">// Encodes a tree to a single string.</span></span><br><span class="line">    <span class="function">string <span class="title">serialize</span><span class="params">(TreeNode* root)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">preorder</span>(root);</span><br><span class="line">        treeStr.<span class="built_in">pop_back</span>();</span><br><span class="line">        <span class="keyword">return</span> treeStr;</span><br><span class="line">    &#125;  </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">preorder</span><span class="params">(TreeNode* root)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!root)</span><br><span class="line">        &#123;</span><br><span class="line">            treeStr += <span class="string">&quot;#,&quot;</span>;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">preorder</span>(root-&gt;left);</span><br><span class="line">        <span class="built_in">preorder</span>(root-&gt;right);</span><br><span class="line">        treeStr += (<span class="built_in">to_string</span>(root-&gt;val) + <span class="string">&quot;,&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">stack&lt;string&gt; <span class="title">split</span><span class="params">(string&amp; str)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        stack&lt;string&gt; treeNodeStk;</span><br><span class="line">        <span class="keyword">if</span> (str.<span class="built_in">empty</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> treeNodeStk;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> strLength = str.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> pre = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= strLength; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (i == strLength || str[i] == <span class="string">&#x27;,&#x27;</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                treeNodeStk.<span class="built_in">emplace</span>(str.<span class="built_in">substr</span>(pre, i - pre));</span><br><span class="line">                pre = i + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> treeNodeStk;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">TreeNode* <span class="title">deserialize</span><span class="params">(stack&lt;string&gt;&amp; treeNodeStk)</span></span></span><br><span class="line"><span class="function">    </span>&#123;        </span><br><span class="line">        <span class="keyword">if</span> (treeNodeStk.<span class="built_in">empty</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        string first = treeNodeStk.<span class="built_in">top</span>();</span><br><span class="line">        treeNodeStk.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">if</span> (first == <span class="string">&quot;#&quot;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        TreeNode* root = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(<span class="built_in">stoi</span>(first));</span><br><span class="line">        root-&gt;right = <span class="built_in">deserialize</span>(treeNodeStk);</span><br><span class="line">        root-&gt;left = <span class="built_in">deserialize</span>(treeNodeStk);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Decodes your encoded data to tree.</span></span><br><span class="line">    <span class="function">TreeNode* <span class="title">deserialize</span><span class="params">(string data)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        stack&lt;string&gt; temp = <span class="built_in">split</span>(data);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">deserialize</span>(temp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h5 id="层序遍历序列化与反序列化"><a href="#层序遍历序列化与反序列化" class="headerlink" title="层序遍历序列化与反序列化"></a>层序遍历序列化与反序列化</h5><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Codec</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// Encodes a tree to a single string.</span></span><br><span class="line">    <span class="function">string <span class="title">serialize</span><span class="params">(TreeNode* root)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!root)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        &#125;    </span><br><span class="line">        string str;</span><br><span class="line">        queue&lt;TreeNode*&gt; q;</span><br><span class="line">        q.<span class="built_in">push</span>(root);</span><br><span class="line">        <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) </span><br><span class="line">        &#123;</span><br><span class="line">            TreeNode* node = q.<span class="built_in">front</span>();</span><br><span class="line">            q.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">if</span> (node)</span><br><span class="line">            &#123;</span><br><span class="line">                str += (<span class="built_in">to_string</span>(node-&gt;val) + <span class="string">&quot;,&quot;</span>);</span><br><span class="line">            &#125;                </span><br><span class="line">            <span class="keyword">else</span> </span><br><span class="line">            &#123;</span><br><span class="line">                str += <span class="string">&quot;#,&quot;</span>;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            q.<span class="built_in">push</span>(node-&gt;left);</span><br><span class="line">            q.<span class="built_in">push</span>(node-&gt;right);</span><br><span class="line">        &#125;</span><br><span class="line">        str.<span class="built_in">pop_back</span>();</span><br><span class="line">        <span class="keyword">return</span> str;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">split</span><span class="params">(string&amp; str)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        vector&lt;string&gt; ans;</span><br><span class="line">        <span class="keyword">if</span> (str.<span class="built_in">empty</span>()) <span class="keyword">return</span> ans;</span><br><span class="line">        <span class="keyword">int</span> size = str.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> pre = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= size; ++i) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (i == size || str[i] == <span class="string">&#x27;,&#x27;</span>) </span><br><span class="line">            &#123;</span><br><span class="line">                ans.<span class="built_in">emplace_back</span>(str.<span class="built_in">substr</span>(pre, i - pre));</span><br><span class="line">                pre = i + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">TreeNode* <span class="title">deserialize</span><span class="params">(vector&lt;string&gt;&amp; data)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (data.<span class="built_in">empty</span>())   </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        string node = data[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">        TreeNode* root = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(<span class="built_in">stoi</span>(node));</span><br><span class="line">        queue&lt;TreeNode*&gt; q;</span><br><span class="line">        q.<span class="built_in">push</span>(root);</span><br><span class="line">        <span class="keyword">int</span> i =<span class="number">1</span>; </span><br><span class="line">        <span class="keyword">while</span> (i &lt; data.<span class="built_in">size</span>()) </span><br><span class="line">        &#123;</span><br><span class="line">            TreeNode* node = q.<span class="built_in">front</span>();</span><br><span class="line">            q.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">if</span> (node == <span class="literal">nullptr</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;    </span><br><span class="line">            string s_left = data[i++];</span><br><span class="line">            <span class="keyword">if</span> (s_left == <span class="string">&quot;#&quot;</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                node-&gt;left = <span class="literal">nullptr</span>;</span><br><span class="line">            &#125;                </span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                node-&gt;left = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(<span class="built_in">stoi</span>(s_left));</span><br><span class="line">            &#125;                </span><br><span class="line">            q.<span class="built_in">push</span>(node-&gt;left);</span><br><span class="line">            string s_right = data[i++];</span><br><span class="line">            <span class="keyword">if</span> (s_right == <span class="string">&quot;#&quot;</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                node-&gt;right = <span class="literal">nullptr</span>;</span><br><span class="line">            &#125;                </span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                node-&gt;right = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(<span class="built_in">stoi</span>(s_right));</span><br><span class="line">            &#125;</span><br><span class="line">            q.<span class="built_in">push</span>(node-&gt;right);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Decodes your encoded data to tree.</span></span><br><span class="line">    <span class="function">TreeNode* <span class="title">deserialize</span><span class="params">(string data)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        vector&lt;string&gt; iters = <span class="built_in">split</span>(data);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">deserialize</span>(iters);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><a href="https://leetcode-cn.com/problems/serialize-and-deserialize-binary-tree/solution/ji-chong-bu-tong-bian-li-fang-shi-xia-de-0eap/">参考</a></p>
<p><a href="https://mp.weixin.qq.com/s?__biz=MzAxODQxMDM0Mw==&mid=2247485871&idx=1&sn=bcb24ea8927995b585629a8b9caeed01&chksm=9bd7f7a7aca07eb1b4c330382a4e0b916ef5a82ca48db28908ab16563e28a376b5ca6805bec2&scene=21#wechat_redirect">二叉树的序列化</a></p>
]]></content>
      <categories>
        <category>算法</category>
        <category>二叉树</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>leetcode</tag>
        <tag>二叉树</tag>
      </tags>
  </entry>
  <entry>
    <title>二叉树中路径和相关习题</title>
    <url>/2021/05/05/%E4%BA%8C%E5%8F%89%E6%A0%91%EF%BC%9A%E8%B7%AF%E5%BE%84%E5%92%8C%E7%9B%B8%E5%85%B3/</url>
    <content><![CDATA[<p>&ensp;&ensp;&ensp;&ensp;本文有四道二叉树路径和相关的题目，前两道给出了详解。求路径和相关，说到底还是遍历问题，只不过有全局变量或者参数做记录。</p>
<span id="more"></span>

<h2 id="二叉树的最大路径和"><a href="#二叉树的最大路径和" class="headerlink" title="二叉树的最大路径和"></a><strong>二叉树的最大路径和</strong></h2><h3 id="一、题目"><a href="#一、题目" class="headerlink" title="一、题目"></a>一、题目</h3><p>&ensp;&ensp;&ensp;&ensp;<strong>路径</strong>被定义为一条从树中任意节点出发，沿父节点-子节点连接，达到任意节点的序列。同一个节点在一条路径序列中 <strong>至多出现一次</strong> 。该路径 <strong>至少包含一个</strong> 节点，且不一定经过根节点。</p>
<!-- more -->

<p>&ensp;&ensp;&ensp;&ensp;<strong>路径和</strong> 是路径中各节点值的总和。</p>
<p>&ensp;&ensp;&ensp;&ensp;给你一个二叉树的根节点 <code>root</code> ，返回其 <strong>最大路径和</strong> 。 </p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">   1</span><br><span class="line">  &#x2F; \</span><br><span class="line"> 2   3</span><br><span class="line">输入：root &#x3D; [1,2,3]</span><br><span class="line">输出：6</span><br><span class="line">解释：最优路径是 2 -&gt; 1 -&gt; 3 ，路径和为 2 + 1 + 3 &#x3D; 6</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">       -10</span><br><span class="line">      &#x2F;   \</span><br><span class="line">     9     20</span><br><span class="line">          &#x2F;  \</span><br><span class="line">         15   7</span><br><span class="line">输入：root &#x3D; [-10,9,20,null,null,15,7]</span><br><span class="line">输出：42</span><br><span class="line">解释：最优路径是 15 -&gt; 20 -&gt; 7 ，路径和为 15 + 20 + 7 &#x3D; 42</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li>树中节点数目范围是 <code>[1, 3 * 104]</code></li>
<li><code>-1000 &lt;= Node.val &lt;= 1000</code></li>
</ul>
<h3 id="二、思路与代码"><a href="#二、思路与代码" class="headerlink" title="二、思路与代码"></a>二、思路与代码</h3><p>&ensp;&ensp;&ensp;&ensp;对于一个结点，需要向上层节点提供“最大路径和“：即目标最大路径和上的每个节点，它的下层节点是最优的。有三种情况：只有当其那节点值（root-&gt;val）、当前节点值加最大左子树节点和（max(0, help(root-&gt;left))）、当前节点值加最大右子树节点和（max(0, help(root-&gt;right))）。</p>
<p>&ensp;&ensp;&ensp;&ensp;最大左子树节点和不能小于0，可以返回0，最大右子树节点和也是如此。</p>
<p>&ensp;&ensp;&ensp;&ensp;对父节点而言的三种选择，最大收益取最大值：root-&gt;val + max(help(root-&gt;left), help(root-&gt;right))。（获取左右后才判定最大收益，故采用后序遍历）</p>
<p>&ensp;&ensp;&ensp;&ensp;遍历每一个节点过程中，使用全局变量记录最大路径和。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> ans = INT_MIN;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxPathSum</span><span class="params">(TreeNode* root)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">help</span>(root);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">help</span><span class="params">(TreeNode* root)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">//节点为空，返回 0</span></span><br><span class="line">        <span class="keyword">if</span> (!root)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//获取当前节点的最大左子树路径和和最大右子树路径和</span></span><br><span class="line">        <span class="keyword">int</span> left = <span class="built_in">max</span>(<span class="number">0</span>, <span class="built_in">help</span>(root-&gt;left));</span><br><span class="line">        <span class="keyword">int</span> right = <span class="built_in">max</span>(<span class="number">0</span>, <span class="built_in">help</span>(root-&gt;right));</span><br><span class="line">        <span class="comment">//更新全局变量</span></span><br><span class="line">        ans = <span class="built_in">max</span>(ans, left + right + root-&gt;val);</span><br><span class="line">        <span class="comment">//返回当前节点的最优情况</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(left, right) + root-&gt;val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><a href="https://blog.csdn.net/m0_53157173/article/details/116399871">参考</a></p>
<h2 id="路径总和III"><a href="#路径总和III" class="headerlink" title="路径总和III"></a><strong>路径总和III</strong></h2><h3 id="一、题目-1"><a href="#一、题目-1" class="headerlink" title="一、题目"></a>一、题目</h3><p>&ensp;&ensp;&ensp;&ensp;给定一个二叉树，它的每个结点都存放着一个整数值。找出路径和等于给定数值的路径总数。路径不需要从根节点开始，也不需要在叶子节点结束，但是路径方向必须是向下的（只能从父节点到子节点）。</p>
<!-- more -->

<p>&ensp;&ensp;&ensp;&ensp;二叉树不超过1000个节点，且节点数值范围是 [-1000000,1000000] 的整数。</p>
<p><strong>示例：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">root &#x3D; [10,5,-3,3,2,null,11,3,-2,null,1], sum &#x3D; 8</span><br><span class="line"></span><br><span class="line">      10</span><br><span class="line">     &#x2F;  \</span><br><span class="line">    5   -3</span><br><span class="line">   &#x2F; \    \</span><br><span class="line">  3   2   11</span><br><span class="line"> &#x2F; \   \</span><br><span class="line">3  -2   1</span><br><span class="line"></span><br><span class="line">返回 3。和等于 8 的路径有:</span><br><span class="line"></span><br><span class="line">1.  5 -&gt; 3</span><br><span class="line">2.  5 -&gt; 2 -&gt; 1</span><br><span class="line">3.  -3 -&gt; 11</span><br></pre></td></tr></table></figure>

<h3 id="二、思路与代码-1"><a href="#二、思路与代码-1" class="headerlink" title="二、思路与代码"></a>二、思路与代码</h3><p>&ensp;&ensp;&ensp;&ensp;遍历每个节点，对各个节点，获取每个其不同路径和（再进行一次前序遍历），注意初始值为0。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">pathSum</span><span class="params">(TreeNode* root, <span class="keyword">int</span> targetSum)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!root)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">traver</span>(root, targetSum);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">traver</span><span class="params">(TreeNode* root, <span class="keyword">const</span> <span class="keyword">int</span> targetSum)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!root)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">traver</span>(root, targetSum, <span class="number">0</span>);</span><br><span class="line">        <span class="built_in">traver</span>(root-&gt;left, targetSum);</span><br><span class="line">        <span class="built_in">traver</span>(root-&gt;right, targetSum);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">traver</span><span class="params">(TreeNode* root, <span class="keyword">const</span> <span class="keyword">int</span> targetSum, <span class="keyword">int</span> cur)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!root)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (root-&gt;val + cur == targetSum)</span><br><span class="line">        &#123;</span><br><span class="line">            ans++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">traver</span>(root-&gt;left, targetSum, cur + root-&gt;val);</span><br><span class="line">        <span class="built_in">traver</span>(root-&gt;right, targetSum, cur + root-&gt;val);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h2 id="路径总和"><a href="#路径总和" class="headerlink" title="路径总和"></a>路径总和</h2><p>&ensp;&ensp;&ensp;&ensp;给你二叉树的根节点 <code>root</code> 和一个表示目标和的整数 <code>targetSum</code> ，判断该树中是否存在 <strong>根节点到叶子节点</strong> 的路径，这条路径上所有节点值相加等于目标和 <code>targetSum</code> 。</p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>叶子节点</strong> 是指没有子节点的节点。</p>
<p> <strong>示例 1：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">                  5</span><br><span class="line">                &#x2F;   \</span><br><span class="line">               4     8</span><br><span class="line">              &#x2F;     &#x2F; \</span><br><span class="line">            11     13  4</span><br><span class="line">           &#x2F;  \         \</span><br><span class="line">          7    2          1</span><br><span class="line">输入：root &#x3D; [5,4,8,11,null,13,4,7,2,null,null,null,1], targetSum &#x3D; 22</span><br><span class="line">输出：true</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">   1</span><br><span class="line">  &#x2F; \</span><br><span class="line"> 2   3</span><br><span class="line">输入：root &#x3D; [1,2,3], targetSum &#x3D; 5</span><br><span class="line">输出：false</span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：root &#x3D; [1,2], targetSum &#x3D; 0</span><br><span class="line">输出：false</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li>  树中节点的数目在范围 <code>[0, 5000]</code> 内</li>
<li>  <code>-1000 &lt;= Node.val &lt;= 1000</code></li>
<li>  <code>-1000 &lt;= targetSum &lt;= 1000</code></li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">hasPathSum</span><span class="params">(TreeNode* root, <span class="keyword">int</span> targetSum)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!root)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (root-&gt;val == targetSum &amp;&amp; !root-&gt;left &amp;&amp; !root-&gt;right)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">hasPathSum</span>(root-&gt;left, targetSum - root-&gt;val) || <span class="built_in">hasPathSum</span>(root-&gt;right, targetSum - root-&gt;val );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h2 id="路径总和-II"><a href="#路径总和-II" class="headerlink" title="路径总和 II"></a>路径总和 II</h2><p>&ensp;&ensp;&ensp;&ensp;给你二叉树的根节点 <code>root</code> 和一个整数目标和 <code>targetSum</code> ，找出所有 <strong>从根节点到叶子节点</strong> 路径总和等于给定目标和的路径。</p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>叶子节点</strong> 是指没有子节点的节点。</p>
<p> <strong>示例 1：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">                  5</span><br><span class="line">                &#x2F;   \</span><br><span class="line">               4     8</span><br><span class="line">              &#x2F;     &#x2F; \</span><br><span class="line">            11     13  4</span><br><span class="line">           &#x2F;  \         \</span><br><span class="line">          7    2          1</span><br><span class="line">输入：root &#x3D; [5,4,8,11,null,13,4,7,2,null,null,5,1], targetSum &#x3D; 22</span><br><span class="line">输出：[[5,4,11,2],[5,8,4,5]]</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">   1</span><br><span class="line">  &#x2F; \</span><br><span class="line"> 2   3</span><br><span class="line">输入：root &#x3D; [1,2,3], targetSum &#x3D; 5</span><br><span class="line">输出：[]</span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：root &#x3D; [1,2], targetSum &#x3D; 0</span><br><span class="line">输出：[]</span><br></pre></td></tr></table></figure>

<p> <strong>提示：</strong></p>
<ul>
<li>  树中节点总数在范围 <code>[0, 5000]</code> 内</li>
<li>  <code>-1000 &lt;= Node.val &lt;= 1000</code></li>
<li>  <code>-1000 &lt;= targetSum &lt;= 1000</code></li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; ans;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; temp;</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">pathSum</span>(TreeNode* root, <span class="keyword">int</span> targetSum) </span><br><span class="line">    &#123;        </span><br><span class="line">        <span class="built_in">help</span>(root, targetSum);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">help</span> <span class="params">(TreeNode* root, <span class="keyword">int</span> targetSum)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!root)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        temp.<span class="built_in">push_back</span>(root-&gt;val);</span><br><span class="line">        <span class="keyword">if</span> (root-&gt;val == targetSum &amp;&amp; !root-&gt;left &amp;&amp; !root-&gt;right)</span><br><span class="line">        &#123;</span><br><span class="line">            ans.<span class="built_in">push_back</span>(temp);</span><br><span class="line">        &#125;        </span><br><span class="line">        <span class="built_in">help</span>(root-&gt;left, targetSum - root-&gt;val);</span><br><span class="line">        <span class="built_in">help</span>(root-&gt;right, targetSum - root-&gt;val);</span><br><span class="line">        temp.<span class="built_in">pop_back</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法</category>
        <category>二叉树</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>leetcode</tag>
        <tag>二叉树</tag>
      </tags>
  </entry>
  <entry>
    <title>makedown语法</title>
    <url>/2021/05/01/makedown%EF%BC%9Amakedown%E8%AF%AD%E6%B3%95/</url>
    <content><![CDATA[<p>    介绍一些<code>makedown语法</code>，在<code>Typora</code>可以完美显示，在其它makedown编辑器或网页上可能显示不成功。这篇文章并不是总结性质的，是搜集性质的（需要用到时搜的）。</p>
<span id="more"></span>

<h5 id="空格"><a href="#空格" class="headerlink" title="空格"></a>空格</h5><figure class="highlight tex"><table><tr><td class="code"><pre><span class="line"><span class="built_in">&amp;</span>ensp;<span class="built_in">&amp;</span>ensp;<span class="built_in">&amp;</span>ensp;<span class="built_in">&amp;</span>ensp;          空格</span><br></pre></td></tr></table></figure>

<h5 id="折叠文章"><a href="#折叠文章" class="headerlink" title="折叠文章"></a>折叠文章</h5><figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">&lt;!-- more --&gt;					折叠文章</span><br></pre></td></tr></table></figure>

<h5 id="上标与下标"><a href="#上标与下标" class="headerlink" title="上标与下标"></a>上标与下标</h5><p>x^2^                    x<del>0</del></p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">输入上标，如：x2，则输入 x<span class="built_in">^</span>2<span class="built_in">^</span></span><br><span class="line">输入下标，如：x0，则输入 x~0~</span><br></pre></td></tr></table></figure>

<h5 id="箭头"><a href="#箭头" class="headerlink" title="箭头"></a>箭头</h5><table>
<thead>
<tr>
<th align="center">$\longleftrightarrow$</th>
<th align="center">$\longleftrightarrow$</th>
</tr>
</thead>
<tbody><tr>
<td align="center">$\Longrightarrow$</td>
<td align="center">$\Longrightarrow$</td>
</tr>
<tr>
<td align="center">$\Longleftrightarrow$</td>
<td align="center">$\Longleftrightarrow$</td>
</tr>
<tr>
<td align="center">$\Longleftarrow$</td>
<td align="center">$\Longleftarrow$</td>
</tr>
<tr>
<td align="center">$\Updownarrow$</td>
<td align="center">$\Updownarrow$</td>
</tr>
<tr>
<td align="center">$\circlearrowleft$</td>
<td align="center">$\circlearrowleft$</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>makedown</category>
      </categories>
      <tags>
        <tag>makedown</tag>
      </tags>
  </entry>
  <entry>
    <title>设计链表</title>
    <url>/2021/04/30/%E9%93%BE%E8%A1%A8%EF%BC%9A%E8%AE%BE%E8%AE%A1%E9%93%BE%E8%A1%A8%EF%BC%88%E5%8D%95%E9%93%BE%E8%A1%A8%EF%BC%89/</url>
    <content><![CDATA[<h3 id="一、题目描述"><a href="#一、题目描述" class="headerlink" title="一、题目描述"></a>一、题目描述</h3><p>&ensp;&ensp;&ensp;&ensp;设计链表的实现。您可以选择使用单链表或双链表。单链表中的节点应该具有两个属性：val 和 next。val 是当前节点的值，next 是指向下一个节点的指针/引用。如果要使用双向链表，则还需要一个属性 prev 以指示链表中的上一个节点。假设链表中的所有节点都是 0-index 的。</p>
<span id="more"></span>

<p>&ensp;&ensp;&ensp;&ensp;在链表类中实现这些功能：</p>
<p>&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;get(index)：获取链表中第 index 个节点的值。如果索引无效，则返回-1。<br>&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;addAtHead(val)：在链表的第一个元素之前添加一个值为 val 的节点。插入后，新节点将成为链表的第一个节点。<br>&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;addAtTail(val)：将值为 val 的节点追加到链表的最后一个元素。<br>&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;addAtIndex(index,val)：在链表中的第 index 个节点之前添加值为 val  的节点。如果 index 等于链表的长度，则该节点将附加到链表的末尾。如果 index 大于链表长度，则不会插入节点。如果index小于0，则在头部插入节点。<br>&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;deleteAtIndex(index)：如果索引 index 有效，则删除链表中的第 index 个节点。</p>
<p>&ensp;&ensp;&ensp;&ensp;示例：</p>
<pre><code>MyLinkedList linkedList = new MyLinkedList();
linkedList.addAtHead(1);
linkedList.addAtTail(3);
linkedList.addAtIndex(1,2);   //链表变为1-&gt; 2-&gt; 3
linkedList.get(1);            //返回2
linkedList.deleteAtIndex(1);  //现在链表是1-&gt; 3
linkedList.get(1);            //返回3
</code></pre>
<p>&ensp;&ensp;&ensp;&ensp;提示：</p>
<p>&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;所有val值都在 [1, 1000] 之内。<br>&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;操作次数将在  [1, 1000] 之内。<br>&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;请不要使用内置的 LinkedList 库。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyLinkedList</span> &#123;</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/** Initialize your data structure here. */</span></span><br><span class="line">    <span class="built_in">MyLinkedList</span>() &#123;</span><br><span class="line">       </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Get the value of the index-th node in the linked list. If the index is invalid, return -1. */</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Add a node of value val before the first element of the linked list. After the insertion, the new node will be the first node of the linked list. */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addAtHead</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">       </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Append a node of value val to the last element of the linked list. */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addAtTail</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Add a node of value val before the index-th node in the linked list. If index equals to the length of linked list, the node will be appended to the end of linked list. If index is greater than the length, the node will not be inserted. */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addAtIndex</span><span class="params">(<span class="keyword">int</span> index, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Delete the index-th node in the linked list, if the index is valid. */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">deleteAtIndex</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your MyLinkedList object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * MyLinkedList* obj = new MyLinkedList();</span></span><br><span class="line"><span class="comment"> * int param_1 = obj-&gt;get(index);</span></span><br><span class="line"><span class="comment"> * obj-&gt;addAtHead(val);</span></span><br><span class="line"><span class="comment"> * obj-&gt;addAtTail(val);</span></span><br><span class="line"><span class="comment"> * obj-&gt;addAtIndex(index,val);</span></span><br><span class="line"><span class="comment"> * obj-&gt;deleteAtIndex(index);</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>
<h3 id="二、解题思路"><a href="#二、解题思路" class="headerlink" title="二、解题思路"></a>二、解题思路</h3><p>&ensp;&ensp;&ensp;&ensp;首先定义链表节点（Node）的结构，它有一个值val，和指向下个节点的指针<em>next；故有Node(int x):val(x),next(NULL){}：定义一个节点，它的值为x，下个节点为空。<br>&ensp;&ensp;&ensp;&ensp;链表的属性、成员有链表的长度（size），指向链表头结点的指针（</em>dummy），其作用域标记为private。<br>&ensp;&ensp;&ensp;&ensp; MyLinkedList() ，初始化一个链表，长度为0，只有个dummy。<br>&ensp;&ensp;&ensp;&ensp;get(index)：先判断index是否有效：index&gt;(size-1)||index&lt;0则无效，然后生成一个指针，移到目标节点即可。<br>&ensp;&ensp;&ensp;&ensp;addAtHead(val)：初始化一个节点head，将head指向头节点，dummy指向head。<br>&ensp;&ensp;&ensp;&ensp;addAtTail(val)：遍历到尾节点，加上去即可<br>&ensp;&ensp;&ensp;&ensp;addAtIndex(index,val)：先判断index是否有效：size&lt;index则返回空值；然后将指针移到第 index 个节点之前的那个节点，插入即可（使之成为第index个节点）<br>&ensp;&ensp;&ensp;&ensp;deleteAtIndex(index)：先判断index是否有效：index&gt;=size||index&lt;0则返回空值；然后将指针移到第 index 个节点之前的那个节点，删除后面那个节点，再连接后面节点的后面节点即可。（老套娃了🐶🐶🐶）</p>
<h5 id="全场最佳：将指针移到第-index-个节点之前的那个节点"><a href="#全场最佳：将指针移到第-index-个节点之前的那个节点" class="headerlink" title="全场最佳：将指针移到第 index 个节点之前的那个节点"></a>全场最佳：将指针移到第 index 个节点之前的那个节点</h5><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//index从0开始，第一个结点的index为0，题目是这么要求的🐶</span></span><br><span class="line">	Node *head=dummy;</span><br><span class="line">      <span class="keyword">while</span>(index--)&#123;</span><br><span class="line">          head=head-&gt;next;</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure>

<h3 id="三、我的代码"><a href="#三、我的代码" class="headerlink" title="三、我的代码"></a>三、我的代码</h3><p>&ensp;&ensp;&ensp;&ensp;直接在力扣上写的。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyLinkedList</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">        <span class="keyword">int</span> val;</span><br><span class="line">        Node *next;</span><br><span class="line">        <span class="built_in">Node</span>(<span class="keyword">int</span> x):<span class="built_in">val</span>(x),<span class="built_in">next</span>(<span class="literal">NULL</span>)&#123;&#125;</span><br><span class="line">    &#125;;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> size;</span><br><span class="line">    Node *dummy;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/** Initialize your data structure here. */</span></span><br><span class="line">    <span class="built_in">MyLinkedList</span>() &#123;</span><br><span class="line">        dummy=<span class="keyword">new</span> <span class="built_in">Node</span>(<span class="number">0</span>);</span><br><span class="line">        size=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Get the value of the index-th node in the linked list. If the index is invalid, return -1. */</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(index&gt;(size<span class="number">-1</span>)||index&lt;<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        Node *head=dummy-&gt;next;</span><br><span class="line">        <span class="keyword">while</span>(index--)&#123;</span><br><span class="line">            head=head-&gt;next;            </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> head-&gt;val;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Add a node of value val before the first element of the linked list. After the insertion, the new node will be the first node of the linked list. */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addAtHead</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        Node *head=<span class="keyword">new</span> <span class="built_in">Node</span>(val);</span><br><span class="line">        head-&gt;next=dummy-&gt;next;</span><br><span class="line">        dummy-&gt;next=head;</span><br><span class="line">        size++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Append a node of value val to the last element of the linked list. */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addAtTail</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        Node *tailNode=dummy;</span><br><span class="line">        Node *newTailNode=<span class="keyword">new</span> <span class="built_in">Node</span>(val);</span><br><span class="line">        <span class="keyword">while</span>(tailNode-&gt;next!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">            tailNode=tailNode-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        tailNode-&gt;next=newTailNode;</span><br><span class="line">        size++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Add a node of value val before the index-th node in the linked list. If index equals to the length of linked list, the node will be appended to the end of linked list. If index is greater than the length, the node will not be inserted. */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addAtIndex</span><span class="params">(<span class="keyword">int</span> index, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(size&lt;index)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        Node *head=dummy;</span><br><span class="line">        Node *t=<span class="keyword">new</span> <span class="built_in">Node</span>(val);</span><br><span class="line">        <span class="keyword">while</span>(index--)&#123;</span><br><span class="line">            head=head-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        t-&gt;next=head-&gt;next;</span><br><span class="line">        head-&gt;next=t;</span><br><span class="line">        size++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Delete the index-th node in the linked list, if the index is valid. */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">deleteAtIndex</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(index&gt;=size||index&lt;<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        Node *head=dummy;</span><br><span class="line">        <span class="keyword">while</span>(index--)&#123;</span><br><span class="line">            head=head-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        Node *t=head-&gt;next;</span><br><span class="line">        head-&gt;next=head-&gt;next-&gt;next;</span><br><span class="line">        <span class="keyword">delete</span> t;</span><br><span class="line">        size--;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your MyLinkedList object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * MyLinkedList* obj = new MyLinkedList();</span></span><br><span class="line"><span class="comment"> * int param_1 = obj-&gt;get(index);</span></span><br><span class="line"><span class="comment"> * obj-&gt;addAtHead(val);</span></span><br><span class="line"><span class="comment"> * obj-&gt;addAtTail(val);</span></span><br><span class="line"><span class="comment"> * obj-&gt;addAtIndex(index,val);</span></span><br><span class="line"><span class="comment"> * obj-&gt;deleteAtIndex(index);</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法</category>
        <category>链表</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>leetcode</tag>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title>扁平化多级双向链表</title>
    <url>/2021/04/30/%E9%93%BE%E8%A1%A8%EF%BC%9A%E6%89%81%E5%B9%B3%E5%8C%96%E5%A4%9A%E7%BA%A7%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<h3 id="一、题目描述"><a href="#一、题目描述" class="headerlink" title="一、题目描述"></a>一、题目描述</h3><p>    多级双向链表中，除了指向下一个节点和前一个节点指针之外，它还有一个子链表指针，可能指向单独的双向链表。这些子列表也可能会有一个或多个自己的子项，依此类推，生成多级数据结构，如下面的示例所示。</p>
<span id="more"></span>

<p>    给你位于列表第一级的头节点，请你扁平化列表，使所有结点出现在单级双链表中。 </p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：head &#x3D; [1,2,3,4,5,6,null,null,null,7,8,9,10,null,null,11,12]</span><br><span class="line">输出：[1,2,3,7,8,11,12,9,10,4,5,6]</span><br></pre></td></tr></table></figure>

<p>解释：</p>
<p>    输入的多级列表如下图所示：</p>
<p><img src="/2021/04/30/%E9%93%BE%E8%A1%A8%EF%BC%9A%E6%89%81%E5%B9%B3%E5%8C%96%E5%A4%9A%E7%BA%A7%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8/1.png" alt="image-20201213163356430"></p>
<p>    扁平化后的链表如下图：</p>
<p><img src="/2021/04/30/%E9%93%BE%E8%A1%A8%EF%BC%9A%E6%89%81%E5%B9%B3%E5%8C%96%E5%A4%9A%E7%BA%A7%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8/2.png" alt="image-20201213163430536"></p>
<p><strong>示例 2：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：head &#x3D; [1,2,null,3]</span><br><span class="line">输出：[1,3,2]</span><br><span class="line">解释：</span><br><span class="line"></span><br><span class="line">输入的多级列表如下图所示：</span><br><span class="line"></span><br><span class="line">  1---2---NULL</span><br><span class="line">  |</span><br><span class="line">  3---NULL</span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：head &#x3D; []</span><br><span class="line">输出：[]</span><br></pre></td></tr></table></figure>

<p>    <strong>如何表示测试用例中的多级链表？</strong></p>
<p>    以 <strong>示例 1</strong> 为例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1---2---3---4---5---6--NULL</span><br><span class="line">        |</span><br><span class="line">        7---8---9---10--NULL</span><br><span class="line">            |</span><br><span class="line">            11--12--NULL</span><br></pre></td></tr></table></figure>

<p>    序列化其中的每一级之后：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[1,2,3,4,5,6,null]</span><br><span class="line">[7,8,9,10,null]</span><br><span class="line">[11,12,null]</span><br></pre></td></tr></table></figure>

<p>    为了将每一级都序列化到一起，我们需要每一级中添加值为 null 的元素，以表示没有节点连接到上一级的上级节点。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[1,2,3,4,5,6,null]</span><br><span class="line">[null,null,7,8,9,10,null]</span><br><span class="line">[null,11,12,null]</span><br></pre></td></tr></table></figure>

<p>    合并所有序列化结果，并去除末尾的 null 。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[1,2,3,4,5,6,null,null,null,7,8,9,10,null,null,11,12]</span><br></pre></td></tr></table></figure>

<p> <strong>提示：</strong></p>
<ul>
<li>节点数目不超过 1000</li>
<li>1 &lt;= Node.val &lt;= 10^5</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">// Definition for a Node.</span></span><br><span class="line"><span class="comment">class Node &#123;</span></span><br><span class="line"><span class="comment">public:</span></span><br><span class="line"><span class="comment">    int val;</span></span><br><span class="line"><span class="comment">    Node* prev;</span></span><br><span class="line"><span class="comment">    Node* next;</span></span><br><span class="line"><span class="comment">    Node* child;</span></span><br><span class="line"><span class="comment">&#125;;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Node* <span class="title">flatten</span><span class="params">(Node* head)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//to do</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="二、解题思路"><a href="#二、解题思路" class="headerlink" title="二、解题思路"></a>二、解题思路</h3><ol>
<li><p>对于每个节点，先用双指针：p，pNext=p-&gt;next，当p-&gt;child为空时，p指针向后移动。</p>
</li>
<li><p>当p-&gt;child不为空</p>
<p>2.1将p与p-&gt;child连接为双向链表结构，并将p-&gt;child置为空；</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Node* pChild=p-&gt;child;</span><br><span class="line">p-&gt;next=pChild;</span><br><span class="line">pChild-&gt;prev=p;</span><br><span class="line">p-&gt;child=<span class="literal">nullptr</span>;</span><br></pre></td></tr></table></figure>

<p>2.2找到p-&gt;child那条子链的尾节点，并与pNext连为双向链表结构</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Node* tail=pChild;</span><br><span class="line"><span class="keyword">while</span>(tail-&gt;next!=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">	tail=tail-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line">tail-&gt;next=pNext;</span><br><span class="line"><span class="keyword">if</span>(pNext!=<span class="literal">nullptr</span>)</span><br><span class="line">	pNext-&gt;prev=tail;  </span><br></pre></td></tr></table></figure></li>
</ol>
<p><img src="/2021/04/30/%E9%93%BE%E8%A1%A8%EF%BC%9A%E6%89%81%E5%B9%B3%E5%8C%96%E5%A4%9A%E7%BA%A7%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8/3.png" alt="image-20201213205439630"></p>
<p><img src="/2021/04/30/%E9%93%BE%E8%A1%A8%EF%BC%9A%E6%89%81%E5%B9%B3%E5%8C%96%E5%A4%9A%E7%BA%A7%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8/4.png" alt="image-20201213205445673"></p>
<p><img src="/2021/04/30/%E9%93%BE%E8%A1%A8%EF%BC%9A%E6%89%81%E5%B9%B3%E5%8C%96%E5%A4%9A%E7%BA%A7%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8/5.png" alt="image-20201213205450099"></p>
<p>    以上三图是消除一条子链的情况。</p>
<h3 id="三、我的代码"><a href="#三、我的代码" class="headerlink" title="三、我的代码"></a>三、我的代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">// Definition for a Node.</span></span><br><span class="line"><span class="comment">class Node &#123;</span></span><br><span class="line"><span class="comment">public:</span></span><br><span class="line"><span class="comment">    int val;</span></span><br><span class="line"><span class="comment">    Node* prev;</span></span><br><span class="line"><span class="comment">    Node* next;</span></span><br><span class="line"><span class="comment">    Node* child;</span></span><br><span class="line"><span class="comment">&#125;;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Node* <span class="title">flatten</span><span class="params">(Node* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head==<span class="literal">nullptr</span>)</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        Node* p=head;</span><br><span class="line">        <span class="keyword">while</span>(p!=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">            Node* pNext=p-&gt;next;</span><br><span class="line">            <span class="keyword">if</span>(p-&gt;child!=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">                Node* pChild=p-&gt;child;</span><br><span class="line">                p-&gt;next=pChild;</span><br><span class="line">                pChild-&gt;prev=p;</span><br><span class="line">                p-&gt;child=<span class="literal">nullptr</span>;</span><br><span class="line">                Node* tail=pChild;</span><br><span class="line">                <span class="keyword">while</span>(tail-&gt;next!=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">                    tail=tail-&gt;next;</span><br><span class="line">                &#125;</span><br><span class="line">                tail-&gt;next=pNext;</span><br><span class="line">                <span class="keyword">if</span>(pNext!=<span class="literal">nullptr</span>)</span><br><span class="line">                    pNext-&gt;prev=tail;                </span><br><span class="line">            &#125;</span><br><span class="line">            p=p-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法</category>
        <category>链表</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>leetcode</tag>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title>奇偶链表</title>
    <url>/2021/04/30/%E9%93%BE%E8%A1%A8%EF%BC%9A%E5%A5%87%E5%81%B6%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<h1 id="LeetCode328：奇偶链表"><a href="#LeetCode328：奇偶链表" class="headerlink" title="LeetCode328：奇偶链表"></a>LeetCode328：奇偶链表</h1><h3 id="一、题目描述"><a href="#一、题目描述" class="headerlink" title="一、题目描述"></a>一、题目描述</h3><p>&ensp;&ensp;&ensp;&ensp;给定一个单链表，把所有的奇数节点和偶数节点分别排在一起。请注意，这里的奇数节点和偶数节点指的是节点编号的奇偶性，而不是节点的值的奇偶性。</p>
<span id="more"></span>

<p>&ensp;&ensp;&ensp;&ensp;请尝试使用原地算法完成。你的算法的空间复杂度应为 O(1)，时间复杂度应为 O(nodes)，nodes 为节点总数。<br>示例 1:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL</span><br><span class="line">输出: 1-&gt;3-&gt;5-&gt;2-&gt;4-&gt;NULL</span><br></pre></td></tr></table></figure>
<p>示例 2:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: 2-&gt;1-&gt;3-&gt;5-&gt;6-&gt;4-&gt;7-&gt;NULL </span><br><span class="line">输出: 2-&gt;3-&gt;6-&gt;7-&gt;1-&gt;5-&gt;4-&gt;NULL</span><br></pre></td></tr></table></figure>
<p>说明:<br>&ensp;&ensp;&ensp;&ensp;应当保持奇数节点和偶数节点的相对顺序。<br>&ensp;&ensp;&ensp;&ensp;链表的第一个节点视为奇数节点，第二个节点视为偶数节点，以此类推。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">oddEvenList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="二、解题思路"><a href="#二、解题思路" class="headerlink" title="二、解题思路"></a>二、解题思路</h3><p>&ensp;&ensp;&ensp;&ensp;看图</p>
<img src="/2021/04/30/%E9%93%BE%E8%A1%A8%EF%BC%9A%E5%A5%87%E5%81%B6%E9%93%BE%E8%A1%A8/1.png" alt="image-20210430234220085" style="zoom:80%;">

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(p-&gt;next!=<span class="literal">nullptr</span>&amp;&amp;q-&gt;next!=<span class="literal">nullptr</span>)&#123;        </span><br><span class="line">               p-&gt;next=q-&gt;next;</span><br><span class="line">               p=p-&gt;next;</span><br><span class="line">               q-&gt;next=p-&gt;next;</span><br><span class="line">               q=q-&gt;next;</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure>

<h3 id="三、我的代码"><a href="#三、我的代码" class="headerlink" title="三、我的代码"></a>三、我的代码</h3><p>&ensp;&ensp;&ensp;&ensp;直接在力扣上写的。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">oddEvenList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head==<span class="literal">nullptr</span>)</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        ListNode* p=head;</span><br><span class="line">        ListNode* head1=head-&gt;next;</span><br><span class="line">        ListNode* q=head-&gt;next;</span><br><span class="line">        <span class="keyword">while</span>(p-&gt;next!=<span class="literal">nullptr</span>&amp;&amp;q-&gt;next!=<span class="literal">nullptr</span>)&#123;        </span><br><span class="line">                p-&gt;next=q-&gt;next;</span><br><span class="line">                p=p-&gt;next;</span><br><span class="line">                q-&gt;next=p-&gt;next;</span><br><span class="line">                q=q-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        p-&gt;next=head1;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法</category>
        <category>链表</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>leetcode</tag>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title>反转链表</title>
    <url>/2021/04/30/%E9%93%BE%E8%A1%A8%EF%BC%9A%E5%9B%9E%E6%96%87%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<h3 id="一、题目描述"><a href="#一、题目描述" class="headerlink" title="一、题目描述"></a>一、题目描述</h3><p>&ensp;&ensp;&ensp;&ensp;请判断一个链表是否为回文链表。</p>
<span id="more"></span>

<p>示例 1:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: 1-&gt;2</span><br><span class="line">输出: false</span><br></pre></td></tr></table></figure>
<p>示例 2:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: 1-&gt;2-&gt;2-&gt;1</span><br><span class="line">输出: true</span><br></pre></td></tr></table></figure>
<p>进阶：<br>&ensp;&ensp;&ensp;&ensp;你能否用 O(n) 时间复杂度和 O(1) 空间复杂度解决此题？</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isPalindrome</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="二、解题思路"><a href="#二、解题思路" class="headerlink" title="二、解题思路"></a>二、解题思路</h3><p>&ensp;&ensp;&ensp;&ensp;先判断链表长度</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> length=<span class="number">0</span>;</span><br><span class="line">   ListNode* p=head;</span><br><span class="line">    <span class="keyword">while</span>(p!=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">        length++;</span><br><span class="line">        p=p-&gt;next;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>&ensp;&ensp;&ensp;&ensp;创建一个与链表等长的数组，再把每个节点对应的值放入数组中</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a[length];</span><br><span class="line">   <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;length;i++)&#123;</span><br><span class="line">       a[i]=p-&gt;val;</span><br><span class="line">       p=p-&gt;next;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>&ensp;&ensp;&ensp;&ensp;比较数组中对应的值</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;length/<span class="number">2</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(a[i]!=a[length-i<span class="number">-1</span>])</span><br><span class="line">             <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure>
<h3 id="三、我的代码"><a href="#三、我的代码" class="headerlink" title="三、我的代码"></a>三、我的代码</h3><p>&ensp;&ensp;&ensp;&ensp;直接在力扣上写的。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isPalindrome</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> length=<span class="number">0</span>;</span><br><span class="line">        ListNode* p=head;</span><br><span class="line">        <span class="keyword">while</span>(p!=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">            length++;</span><br><span class="line">            p=p-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(length==<span class="number">0</span>||length==<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        p=head;</span><br><span class="line">        <span class="keyword">int</span> a[length];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;length;i++)&#123;</span><br><span class="line">            a[i]=p-&gt;val;</span><br><span class="line">            p=p-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;length/<span class="number">2</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(a[i]!=a[length-i<span class="number">-1</span>])</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法</category>
        <category>链表</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>leetcode</tag>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title>移除链表元素</title>
    <url>/2021/04/30/%E9%93%BE%E8%A1%A8%EF%BC%9A%E7%A7%BB%E9%99%A4%E9%93%BE%E8%A1%A8%E5%85%83%E7%B4%A0/</url>
    <content><![CDATA[<h3 id="一、题目描述"><a href="#一、题目描述" class="headerlink" title="一、题目描述"></a>一、题目描述</h3><p>&ensp;&ensp;&ensp;&ensp;删除链表中等于给定值 val 的所有节点。</p>
<span id="more"></span>

<p>示例:</p>
<pre><code>输入: 1-&gt;2-&gt;6-&gt;3-&gt;4-&gt;5-&gt;6, val = 6
输出: 1-&gt;2-&gt;3-&gt;4-&gt;5
</code></pre>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">removeElements</span><span class="params">(ListNode* head, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">		<span class="comment">//to do</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="二、解题思路"><a href="#二、解题思路" class="headerlink" title="二、解题思路"></a>二、解题思路</h3><p>&ensp;&ensp;&ensp;&ensp;当链表为空，返回nullptr;<br>&ensp;&ensp;&ensp;&ensp;确保头节点不是要删除的节点</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(head-&gt;val==val)&#123;</span><br><span class="line">         head=head-&gt;next;</span><br><span class="line">         <span class="keyword">if</span>(head==<span class="literal">nullptr</span>)</span><br><span class="line">             <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure>
<p>&ensp;&ensp;&ensp;&ensp;使用双指针p，q，两指针紧挨着，遇到目标节点则删除</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">ListNode* p=head;</span><br><span class="line">   ListNode* q=p-&gt;next;</span><br><span class="line">   <span class="keyword">while</span>(q!=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">       <span class="keyword">if</span>(q-&gt;val==val)&#123;</span><br><span class="line">           q=q-&gt;next;</span><br><span class="line">           p-&gt;next=q;</span><br><span class="line">           <span class="keyword">continue</span>;</span><br><span class="line">       &#125; </span><br><span class="line">       p=p-&gt;next;</span><br><span class="line">       q=p-&gt;next;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h3 id="三、我的代码"><a href="#三、我的代码" class="headerlink" title="三、我的代码"></a>三、我的代码</h3><p>&ensp;&ensp;&ensp;&ensp;直接在力扣上写的。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">removeElements</span><span class="params">(ListNode* head, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head==<span class="literal">nullptr</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">while</span>(head-&gt;val==val)&#123;</span><br><span class="line">            head=head-&gt;next;</span><br><span class="line">            <span class="keyword">if</span>(head==<span class="literal">nullptr</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(head-&gt;next==<span class="literal">nullptr</span>)</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        ListNode* p=head;</span><br><span class="line">        ListNode* q=p-&gt;next;</span><br><span class="line">        <span class="keyword">while</span>(q!=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(q-&gt;val==val)&#123;</span><br><span class="line">                q=q-&gt;next;</span><br><span class="line">                p-&gt;next=q;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125; </span><br><span class="line">            p=p-&gt;next;</span><br><span class="line">            q=p-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法</category>
        <category>链表</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>leetcode</tag>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title>神奇的双指针在链表中的应用</title>
    <url>/2021/04/30/%E9%93%BE%E8%A1%A8%EF%BC%9A%E7%A5%9E%E5%A5%87%E7%9A%84%E5%8F%8C%E6%8C%87%E9%92%88%E5%9C%A8%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8/</url>
    <content><![CDATA[<p>双指针在链表中的应用广泛，尤其涉及到有环的链表。</p>
<span id="more"></span>

<h2 id="141：环形链表1"><a href="#141：环形链表1" class="headerlink" title="141：环形链表1"></a>141：环形链表1</h2><h3 id="一、题目描述"><a href="#一、题目描述" class="headerlink" title="一、题目描述"></a>一、题目描述</h3><p>&ensp;&ensp;&ensp;&ensp;给定一个链表，判断链表中是否有环。<br>&ensp;&ensp;&ensp;&ensp;如果链表中有某个节点，可以通过连续跟踪 next 指针再次到达，则链表中存在环。为了表示给定链表中的环，我们使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。如果 pos 是 -1，则在该链表中没有环。注意：pos 不作为参数进行传递，仅仅是为了标识链表的实际情况。</p>
<p>&ensp;&ensp;&ensp;&ensp;如果链表中存在环，则返回 true 。 否则，返回 false 。<br><em>进阶</em>：<br>&ensp;&ensp;&ensp;&ensp;你能用 O(1)（即，常量）内存解决此问题吗？<br><em>提示</em>：<br>&ensp;&ensp;&ensp;&ensp;链表中节点的数目范围是 [0, 104]<br>&ensp;&ensp;&ensp;&ensp;-105 &lt;= Node.val &lt;= 105<br>&ensp;&ensp;&ensp;&ensp;pos 为 -1 或者链表中的一个 有效索引 。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">hasCycle</span><span class="params">(ListNode *head)</span> </span>&#123;</span><br><span class="line">       <span class="comment">//to do</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><img src="/2021/04/30/%E9%93%BE%E8%A1%A8%EF%BC%9A%E7%A5%9E%E5%A5%87%E7%9A%84%E5%8F%8C%E6%8C%87%E9%92%88%E5%9C%A8%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8/1.png"></p>
<h3 id="二、解题思路"><a href="#二、解题思路" class="headerlink" title="二、解题思路"></a>二、解题思路</h3><p>&ensp;&ensp;&ensp;&ensp;为了防止越界问题，每次都需提前判断指针是否为nullptr；两个指针，一快一慢，当二者相等，则有环（快指针在环中转了几圈后“追上”慢的）。</p>
<h3 id="三、我的代码"><a href="#三、我的代码" class="headerlink" title="三、我的代码"></a>三、我的代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">hasCycle</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        ListNode* p1 = head;</span><br><span class="line">        <span class="keyword">if</span> (p1 == <span class="literal">nullptr</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        ListNode* p2 = head;</span><br><span class="line">        <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (p1-&gt;next == <span class="literal">nullptr</span> || p2-&gt;next == <span class="literal">nullptr</span> || p2-&gt;next-&gt;next == <span class="literal">nullptr</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            p1 = p1-&gt;next;		<span class="comment">//跑的慢</span></span><br><span class="line">            p2 = p2-&gt;next-&gt;next;<span class="comment">//跑的快</span></span><br><span class="line">            <span class="keyword">if</span> (p1 == p2)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;            </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="142：环形链表2"><a href="#142：环形链表2" class="headerlink" title="142：环形链表2"></a>142：环形链表2</h2><h3 id="一、题目描述-1"><a href="#一、题目描述-1" class="headerlink" title="一、题目描述"></a>一、题目描述</h3><p>给定一个链表，返回链表开始入环的第一个节点。 如果链表无环，则返回 null。</p>
<p>为了表示给定链表中的环，我们使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。注意，pos 仅仅是用于标识环的情况，并不会作为参数传递到函数中。<br><em>说明：</em><br>&ensp;&ensp;&ensp;&ensp;不允许修改给定的链表。<br><em>进阶：</em><br>&ensp;&ensp;&ensp;&ensp;你是否可以使用 O(1) 空间解决此题？<br><img src="/2021/04/30/%E9%93%BE%E8%A1%A8%EF%BC%9A%E7%A5%9E%E5%A5%87%E7%9A%84%E5%8F%8C%E6%8C%87%E9%92%88%E5%9C%A8%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8/2.png" style="zoom:50%;"></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>: </span><br><span class="line">    <span class="function">ListNode *<span class="title">detectCycle</span><span class="params">(ListNode *head)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//to do</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="二、解题思路-1"><a href="#二、解题思路-1" class="headerlink" title="二、解题思路"></a>二、解题思路</h3><p>&ensp;&ensp;&ensp;&ensp;我们使用两个指针，fast 与 slow。它们起始都位于链表的头部。随后，slow 指针每次向后移动一个位置，而 fast 指针向后移动两个位置。如果链表中存在环，则 fast 指针最终将再次与slow 指针在环中相遇。</p>
<p>&ensp;&ensp;&ensp;&ensp;如下图所示，设链表中环外部分的长度为 a。slow 指针进入环后，又走了b 的距离与 fast 相遇。此时fast 指针已经走完了环的 n 圈，因此它走过的总距离为 a+n(b+c)+b=a+(n+1)b+nca+n(b+c)+b=a+(n+1)b+nc。<br><img src="/%E9%93%BE%E8%A1%A8%EF%BC%9A%E7%A5%9E%E5%A5%87%E7%9A%84%E5%8F%8C%E6%8C%87%E9%92%88%E5%9C%A8%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8/3.png"></p>
<p>&ensp;&ensp;&ensp;&ensp;根据题意，任意时刻，fast 指针走过的距离都为 slow 指针的 2 倍。因此，我们有<br>a+(n+1)b+nc=2(a+b)⟹a=c+(n−1)(b+c)<br>&ensp;&ensp;&ensp;&ensp;有了 a=c+(n-1)(b+c)a=c+(n−1)(b+c) 的等量关系，我们会发现：从相遇点到入环点的距离加上 n-1n−1 圈的环长，恰好等于从链表头部到入环点的距离。<br>&ensp;&ensp;&ensp;&ensp;因此，当发现 slow 与 fast 相遇时，我们再额外使用一个指针ptr。起始，它指向链表头部；随后，它和 slow 每次向后移动一个位置。最终，它们会在入环点相遇。<br>&ensp;&ensp;&ensp;&ensp;数学大法好！！！💀💀💀💀</p>
<h3 id="三、我的代码-1"><a href="#三、我的代码-1" class="headerlink" title="三、我的代码"></a>三、我的代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">   <span class="function">ListNode* <span class="title">detectCycle</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        ListNode* p1 = head;</span><br><span class="line">        <span class="keyword">if</span> (p1 == <span class="literal">nullptr</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        ListNode* p2 = head;</span><br><span class="line">        <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (p1-&gt;next == <span class="literal">nullptr</span> || p2-&gt;next == <span class="literal">nullptr</span> || p2-&gt;next-&gt;next == <span class="literal">nullptr</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">            p1 = p1-&gt;next;</span><br><span class="line">            p2 = p2-&gt;next-&gt;next;</span><br><span class="line">            <span class="keyword">if</span> (p1 == p2) &#123;</span><br><span class="line">                ListNode* ptr = head;</span><br><span class="line">                <span class="keyword">while</span> (ptr != p1) &#123;</span><br><span class="line">                    ptr = ptr-&gt;next;</span><br><span class="line">                    p1 = p1-&gt;next;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> ptr;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="160：相交链表"><a href="#160：相交链表" class="headerlink" title="160：相交链表"></a>160：相交链表</h2><h3 id="一、题目描述-2"><a href="#一、题目描述-2" class="headerlink" title="一、题目描述"></a>一、题目描述</h3><p>&ensp;&ensp;&ensp;&ensp;编写一个程序，找到两个单链表相交的起始节点。<br>&ensp;&ensp;&ensp;&ensp;如下面的两个链表：在节点 c1 开始相交。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">示例 1：</span><br><span class="line">输入：intersectVal &#x3D; 8, listA &#x3D; [4,1,8,4,5], listB &#x3D; [5,0,1,8,4,5], skipA &#x3D; 2, skipB &#x3D; 3</span><br><span class="line">输出：Reference of the node with value &#x3D; 8</span><br><span class="line">输入解释：相交节点的值为 8 （注意，如果两个链表相交则不能为 0）。从各自的表头开始算起，链表 A 为 [4,1,8,4,5]，链表 B 为 [5,0,1,8,4,5]。在 A 中，相交节点前有 2 个节点；在 B 中，相交节点前有 3 个节点。</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line">输入：intersectVal &#x3D; 2, listA &#x3D; [0,9,1,2,4], listB &#x3D; [3,2,4], skipA &#x3D; 3, skipB &#x3D; 1</span><br><span class="line">输出：Reference of the node with value &#x3D; 2</span><br><span class="line">输入解释：相交节点的值为 2 （注意，如果两个链表相交则不能为 0）。从各自的表头开始算起，链表 A 为 [0,9,1,2,4]，链表 B 为 [3,2,4]。在 A 中，相交节点前有 3 个节点；在 B 中，相交节点前有 1 个节点。</span><br><span class="line"></span><br><span class="line">示例 3：</span><br><span class="line">输入：intersectVal &#x3D; 0, listA &#x3D; [2,6,4], listB &#x3D; [1,5], skipA &#x3D; 3, skipB &#x3D; 2</span><br><span class="line">输出：null</span><br><span class="line">输入解释：从各自的表头开始算起，链表 A 为 [2,6,4]，链表 B 为 [1,5]。由于这两个链表不相交，所以 intersectVal 必须为 0，而 skipA 和 skipB 可以是任意值。</span><br><span class="line">解释：这两个链表不相交，因此返回 null。</span><br></pre></td></tr></table></figure>

<p>注意：<br>&ensp;&ensp;&ensp;&ensp;如果两个链表没有交点，返回 null.<br>&ensp;&ensp;&ensp;&ensp;在返回结果后，两个链表仍须保持原有的结构。<br>&ensp;&ensp;&ensp;&ensp;可假定整个链表结构中没有循环。<br>&ensp;&ensp;&ensp;&ensp;程序尽量满足 O(n) 时间复杂度，且仅用 O(1) 内存。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode *<span class="title">getIntersectionNode</span><span class="params">(ListNode *headA, ListNode *headB)</span> </span>&#123;</span><br><span class="line">    		<span class="comment">//to do</span></span><br><span class="line">       &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="二、解题思路-2"><a href="#二、解题思路-2" class="headerlink" title="二、解题思路"></a>二、解题思路</h3><p>&ensp;&ensp;&ensp;&ensp;方法一: 暴力法<br>&ensp;&ensp;&ensp;&ensp;对链表A中的每一个结点 a，遍历整个链表 B 并检查链表 B 中是否存在结点和 a相同。</p>
<p>&ensp;&ensp;&ensp;&ensp;方法二: 双指针法<br>&ensp;&ensp;&ensp;&ensp;创建两个指针 pA 和 pB，分别初始化为链表 A 和 B 的头结点，然后让它们向后逐结点遍历；当 pA 到达链表的尾部时，将它重定位到链表 B 的头结点 (你没看错，就是链表 B); 类似的，当 pB 到达链表的尾部时，将它重定位到链表 A 的头结点；若在某一时刻 pA 和 pB 相遇，则 pA/pB 为相交结点。<br>&ensp;&ensp;&ensp;&ensp;起点虽然不一样，但路程一样,终点一样,速度一样，必定同时到达。</p>
<h3 id="三、我的代码-2"><a href="#三、我的代码-2" class="headerlink" title="三、我的代码"></a>三、我的代码</h3><p>方法一：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">   <span class="function">ListNode* <span class="title">getIntersectionNode</span><span class="params">(ListNode* headA, ListNode* headB)</span> </span>&#123;</span><br><span class="line">        ListNode* pa = headA;</span><br><span class="line">        <span class="keyword">if</span> (pa == <span class="literal">nullptr</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        ListNode* pb = headB;</span><br><span class="line">        <span class="keyword">if</span> (pb == <span class="literal">nullptr</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (pa == pb)</span><br><span class="line">                    <span class="keyword">return</span> pa;</span><br><span class="line">                <span class="keyword">if</span> (pb-&gt;next == <span class="literal">nullptr</span>)</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                pb = pb-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (pa-&gt;next == <span class="literal">nullptr</span>)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            pa = pa-&gt;next;</span><br><span class="line">            pb = headB;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>方法二：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">getIntersectionNode</span><span class="params">(ListNode* headA, ListNode* headB)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = <span class="number">0</span>;</span><br><span class="line">        ListNode* pa = headA;</span><br><span class="line">        ListNode* pb = headB;</span><br><span class="line">        <span class="keyword">if</span> (pa == <span class="literal">nullptr</span> || pb == <span class="literal">nullptr</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">while</span> (n &lt; <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (pa == pb)</span><br><span class="line">                <span class="keyword">return</span> pa;</span><br><span class="line">            <span class="keyword">if</span> (pb-&gt;next == <span class="literal">nullptr</span>)</span><br><span class="line">                pb = headA, n++;<span class="comment">//不能用pb-&gt;next=headA,会改变链表结构</span></span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                pb = pb-&gt;next;</span><br><span class="line">            <span class="keyword">if</span> (pa-&gt;next == <span class="literal">nullptr</span>)</span><br><span class="line">                pa = headB;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                pa = pa-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法</category>
        <category>链表</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>leetcode</tag>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title>复制带随机指针的链表</title>
    <url>/2021/04/30/%E9%93%BE%E8%A1%A8%EF%BC%9A%E5%A4%8D%E5%88%B6%E5%B8%A6%E9%9A%8F%E6%9C%BA%E6%8C%87%E9%92%88%E7%9A%84%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<h3 id="一、题目描述"><a href="#一、题目描述" class="headerlink" title="一、题目描述"></a>一、题目描述</h3><p>给定一个链表，每个节点包含一个额外增加的随机指针，该指针可以指向链表中的任何节点或空节点。</p>
<p>要求返回这个链表的深拷贝。 </p>
<span id="more"></span>

<p>我们用一个由 n 个节点组成的链表来表示输入/输出中的链表。每个节点用一个 [val, random_index] 表示：</p>
<ul>
<li>val：一个表示 Node.val 的整数。</li>
<li>random_index：随机指针指向的节点索引（范围从 0 到 n-1）；如果不指向任何节点，则为  null 。</li>
</ul>
<p><strong>示例 1：</strong></p>
<p><img src="/2021/04/30/%E9%93%BE%E8%A1%A8%EF%BC%9A%E5%A4%8D%E5%88%B6%E5%B8%A6%E9%9A%8F%E6%9C%BA%E6%8C%87%E9%92%88%E7%9A%84%E9%93%BE%E8%A1%A8/1.png" alt="image-20201213164012901"></p>
<p>输入：head = [[7,null],[13,0],[11,4],[10,2],[1,0]]</p>
<p>输出：[[7,null],[13,0],[11,4],[10,2],[1,0]]</p>
<p><strong>示例 2：</strong></p>
<p><img src="/2021/04/30/%E9%93%BE%E8%A1%A8%EF%BC%9A%E5%A4%8D%E5%88%B6%E5%B8%A6%E9%9A%8F%E6%9C%BA%E6%8C%87%E9%92%88%E7%9A%84%E9%93%BE%E8%A1%A8/2.png" alt="image-20201213164032257"></p>
<p>输入：head = [[1,1],[2,1]]</p>
<p>输出：[[1,1],[2,1]]</p>
<p><strong>示例 3：</strong></p>
<p><img src="/2021/04/30/%E9%93%BE%E8%A1%A8%EF%BC%9A%E5%A4%8D%E5%88%B6%E5%B8%A6%E9%9A%8F%E6%9C%BA%E6%8C%87%E9%92%88%E7%9A%84%E9%93%BE%E8%A1%A8/3.png" alt="image-20201213164059316"></p>
<p>输入：head = [[3,null],[3,0],[3,null]]</p>
<p>输出：[[3,null],[3,0],[3,null]]</p>
<p><strong>示例 4：</strong></p>
<p>输入：head = []</p>
<p>输出：[]<br>解释：给定的链表为空（空指针），因此返回 null。</p>
<p><strong>提示：</strong></p>
<ul>
<li>-10000 &lt;= Node.val &lt;= 10000</li>
<li>Node.random 为空（null）或指向链表中的节点。</li>
<li>节点数目不超过 1000 。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">// Definition for a Node.</span></span><br><span class="line"><span class="comment">class Node &#123;</span></span><br><span class="line"><span class="comment">public:</span></span><br><span class="line"><span class="comment">    int val;</span></span><br><span class="line"><span class="comment">    Node* next;</span></span><br><span class="line"><span class="comment">    Node* random;</span></span><br><span class="line"><span class="comment">    </span></span><br><span class="line"><span class="comment">    Node(int _val) &#123;</span></span><br><span class="line"><span class="comment">        val = _val;</span></span><br><span class="line"><span class="comment">        next = NULL;</span></span><br><span class="line"><span class="comment">        random = NULL;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Node* <span class="title">copyRandomList</span><span class="params">(Node* head)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//to do</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h3 id="二、解题思路"><a href="#二、解题思路" class="headerlink" title="二、解题思路"></a>二、解题思路</h3><ol>
<li><p>使用哈希图，先生成与原来链表相同个数的节点</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">unordered_map&lt;Node*,Node*&gt;nodemap;</span><br><span class="line">   nodemap[<span class="literal">nullptr</span>]=<span class="literal">nullptr</span>;</span><br><span class="line">   Node* p=head;</span><br><span class="line">   <span class="keyword">while</span>(p)&#123;</span><br><span class="line">       nodemap[p]=<span class="keyword">new</span> <span class="built_in">Node</span>(p-&gt;val);</span><br><span class="line">       p=p-&gt;next;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></li>
<li><p>使哈希图中每个节点等于原节点</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">p=head;</span><br><span class="line">  <span class="keyword">while</span>(p!=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">      nodemap[p]-&gt;next=nodemap[p-&gt;next];</span><br><span class="line">      p=p-&gt;next;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li>
<li><p>再复制random指针</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">p=head;</span><br><span class="line"><span class="keyword">while</span>(p!=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">    nodemap[p]-&gt;random=nodemap[p-&gt;random];</span><br><span class="line">    p=p-&gt;next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="三、我的代码"><a href="#三、我的代码" class="headerlink" title="三、我的代码"></a>三、我的代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">// Definition for a Node.</span></span><br><span class="line"><span class="comment">class Node &#123;</span></span><br><span class="line"><span class="comment">public:</span></span><br><span class="line"><span class="comment">    int val;</span></span><br><span class="line"><span class="comment">    Node* next;</span></span><br><span class="line"><span class="comment">    Node* random;</span></span><br><span class="line"><span class="comment">    </span></span><br><span class="line"><span class="comment">    Node(int _val) &#123;</span></span><br><span class="line"><span class="comment">        val = _val;</span></span><br><span class="line"><span class="comment">        next = NULL;</span></span><br><span class="line"><span class="comment">        random = NULL;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Node* <span class="title">copyRandomList</span><span class="params">(Node* head)</span> </span>&#123;</span><br><span class="line">        unordered_map&lt;Node*,Node*&gt;nodemap;</span><br><span class="line">        nodemap[<span class="literal">nullptr</span>]=<span class="literal">nullptr</span>;</span><br><span class="line">        Node* p=head;</span><br><span class="line">        <span class="keyword">while</span>(p!=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">            nodemap[p]=<span class="keyword">new</span> <span class="built_in">Node</span>(p-&gt;val);</span><br><span class="line">            p=p-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        p=head;</span><br><span class="line">        <span class="keyword">while</span>(p!=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">            nodemap[p]-&gt;next=nodemap[p-&gt;next];</span><br><span class="line">            p=p-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        p=head;</span><br><span class="line">        <span class="keyword">while</span>(p!=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">            nodemap[p]-&gt;random=nodemap[p-&gt;random];</span><br><span class="line">            p=p-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nodemap[head];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法</category>
        <category>链表</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>leetcode</tag>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title>旋转链表</title>
    <url>/2021/04/30/%E9%93%BE%E8%A1%A8%EF%BC%9A%E6%97%8B%E8%BD%AC%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<h3 id="一、题目描述"><a href="#一、题目描述" class="headerlink" title="一、题目描述"></a>一、题目描述</h3><p>给定一个链表，旋转链表，将链表每个节点向右移动 <em>k</em> 个位置，其中 <em>k</em> 是非负数。</p>
<span id="more"></span>

<p><strong>示例 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL, k &#x3D; 2</span><br><span class="line">输出: 4-&gt;5-&gt;1-&gt;2-&gt;3-&gt;NULL</span><br><span class="line">解释:</span><br><span class="line">向右旋转 1 步: 5-&gt;1-&gt;2-&gt;3-&gt;4-&gt;NULL</span><br><span class="line">向右旋转 2 步: 4-&gt;5-&gt;1-&gt;2-&gt;3-&gt;NULL</span><br></pre></td></tr></table></figure>

<p><strong>示例 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: 0-&gt;1-&gt;2-&gt;NULL, k &#x3D; 4</span><br><span class="line">输出: 2-&gt;0-&gt;1-&gt;NULL</span><br><span class="line">解释:</span><br><span class="line">向右旋转 1 步: 2-&gt;0-&gt;1-&gt;NULL</span><br><span class="line">向右旋转 2 步: 1-&gt;2-&gt;0-&gt;NULL</span><br><span class="line">向右旋转 3 步: 0-&gt;1-&gt;2-&gt;NULL</span><br><span class="line">向右旋转 4 步: 2-&gt;0-&gt;1-&gt;NULL</span><br></pre></td></tr></table></figure>

<h3 id="二、解题思路"><a href="#二、解题思路" class="headerlink" title="二、解题思路"></a>二、解题思路</h3><ol>
<li><p>先确定链表的长度</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> length=<span class="number">0</span>;</span><br><span class="line">        ListNode* p=head;</span><br><span class="line">        <span class="keyword">while</span>(p!=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">            p=p-&gt;next;</span><br><span class="line">            length++;</span><br><span class="line">        &#125;       </span><br></pre></td></tr></table></figure></li>
<li><p>当链表为空或长度为一或移动零步或移动链表的整数倍步时，返回原链表头结点指针</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(length==<span class="number">0</span>||length==<span class="number">1</span>||k==<span class="number">0</span>||k%length==<span class="number">0</span>)</span><br><span class="line">           <span class="keyword">return</span> head;</span><br></pre></td></tr></table></figure></li>
<li><p>前两步之后，另k=k%length，再使一个指针移动到原链表末端</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">k=k%length;</span><br><span class="line">   p=head;</span><br><span class="line">   <span class="keyword">while</span>(p-&gt;next!=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">   	p=p-&gt;next;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></li>
<li><p>使用双指针法，从头开始向末端移动 length-k-1步，再见链表断为两个，重新连接</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">ListNode* t1=head;</span><br><span class="line">   ListNode* t2=head-&gt;next;</span><br><span class="line">   <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;length-k<span class="number">-1</span>;i++)&#123;</span><br><span class="line">   	t1=t1-&gt;next;</span><br><span class="line">       t2=t2-&gt;next;</span><br><span class="line">   &#125;</span><br><span class="line">   t1-&gt;next=<span class="literal">nullptr</span>;</span><br><span class="line">   p-&gt;next=head;</span><br></pre></td></tr></table></figure>

<img src="/2021/04/30/%E9%93%BE%E8%A1%A8%EF%BC%9A%E6%97%8B%E8%BD%AC%E9%93%BE%E8%A1%A8/1.png" style="zoom:80%;">

<img src="/2021/04/30/%E9%93%BE%E8%A1%A8%EF%BC%9A%E6%97%8B%E8%BD%AC%E9%93%BE%E8%A1%A8/2.png" style="zoom:80%;"></li>
</ol>
<h3 id="三、我的代码"><a href="#三、我的代码" class="headerlink" title="三、我的代码"></a>三、我的代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">rotateRight</span><span class="params">(ListNode* head, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> length=<span class="number">0</span>;</span><br><span class="line">        ListNode* p=head;</span><br><span class="line">        <span class="keyword">while</span>(p!=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">            p=p-&gt;next;</span><br><span class="line">            length++;</span><br><span class="line">        &#125;       </span><br><span class="line">        <span class="keyword">if</span>(length==<span class="number">0</span>||length==<span class="number">1</span>||k==<span class="number">0</span>||k%length==<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        k=k%length;</span><br><span class="line">        p=head;</span><br><span class="line">        <span class="keyword">while</span>(p-&gt;next!=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">            p=p-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode* t1=head;</span><br><span class="line">        ListNode* t2=head-&gt;next;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;length-k<span class="number">-1</span>;i++)&#123;</span><br><span class="line">            t1=t1-&gt;next;</span><br><span class="line">            t2=t2-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        t1-&gt;next=<span class="literal">nullptr</span>;</span><br><span class="line">        p-&gt;next=head;</span><br><span class="line">        <span class="keyword">return</span> t2;</span><br><span class="line">    &#125;c</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法</category>
        <category>链表</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>leetcode</tag>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title>合并两个有序链表</title>
    <url>/2021/04/30/%E9%93%BE%E8%A1%A8%EF%BC%9A%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<h3 id="一、题目描述"><a href="#一、题目描述" class="headerlink" title="一、题目描述"></a>一、题目描述</h3><p>&ensp;&ensp;&ensp;&ensp;将两个升序链表合并为一个新的 <strong>升序</strong> 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 </p>
<span id="more"></span>

<p><strong>示例：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：1-&gt;2-&gt;4, 1-&gt;3-&gt;4</span><br><span class="line">输出：1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4</span><br></pre></td></tr></table></figure>

<h3 id="二、解题思路"><a href="#二、解题思路" class="headerlink" title="二、解题思路"></a>二、解题思路</h3><ol>
<li><p>先判断有无空链表</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(l1==<span class="literal">nullptr</span>)</span><br><span class="line">	<span class="keyword">return</span> l2;</span><br><span class="line"><span class="keyword">if</span>(l2==<span class="literal">nullptr</span>)</span><br><span class="line">	<span class="keyword">return</span> l1;</span><br></pre></td></tr></table></figure></li>
<li><p>确定合并链表的头结点（整数值小的结点）</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">ListNode* head;</span><br><span class="line">l1-&gt;val&gt;l2-&gt;val ? (head=l2,l2=l2-&gt;next):(head=l1,l1=l1-&gt;next); </span><br></pre></td></tr></table></figure></li>
<li><p>连接后续结点</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(l1!=<span class="literal">nullptr</span>&amp;&amp;l2!=<span class="literal">nullptr</span>)&#123;            </span><br><span class="line">            l1-&gt;val&gt;l2-&gt;val ? (p-&gt;next=l2,l2=l2-&gt;next):(p-&gt;next=l1,l1=l1-&gt;next);            </span><br><span class="line">            p=p-&gt;next;            </span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="三、我的代码"><a href="#三、我的代码" class="headerlink" title="三、我的代码"></a>三、我的代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">mergeTwoLists</span><span class="params">(ListNode* l1, ListNode* l2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(l1==<span class="literal">nullptr</span>)</span><br><span class="line">            <span class="keyword">return</span> l2;</span><br><span class="line">        <span class="keyword">if</span>(l2==<span class="literal">nullptr</span>)</span><br><span class="line">            <span class="keyword">return</span> l1;</span><br><span class="line">        ListNode* head;</span><br><span class="line">        l1-&gt;val&gt;l2-&gt;val ? (head=l2,l2=l2-&gt;next):(head=l1,l1=l1-&gt;next);        </span><br><span class="line">        ListNode* p=head;</span><br><span class="line">        <span class="keyword">while</span>(l1!=<span class="literal">nullptr</span>&amp;&amp;l2!=<span class="literal">nullptr</span>)&#123;            </span><br><span class="line">            l1-&gt;val&gt;l2-&gt;val ? (p-&gt;next=l2,l2=l2-&gt;next):(p-&gt;next=l1,l1=l1-&gt;next);            </span><br><span class="line">            p=p-&gt;next;            </span><br><span class="line">        &#125;</span><br><span class="line">        p-&gt;next=(l1==<span class="literal">nullptr</span>)? l2:l1;        </span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法</category>
        <category>链表</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>leetcode</tag>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title>删除链表的倒数第n个节点</title>
    <url>/2021/04/30/%E9%93%BE%E8%A1%A8%EF%BC%9A%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E5%80%92%E6%95%B0%E7%AC%ACn%E4%B8%AA%E8%8A%82%E7%82%B9/</url>
    <content><![CDATA[<h3 id="一、题目描述"><a href="#一、题目描述" class="headerlink" title="一、题目描述"></a>一、题目描述</h3><p>&ensp;&ensp;&ensp;&ensp;给定一个链表，删除链表的倒数第 n 个节点，并且返回链表的头结点。</p>
<span id="more"></span>

<p>&ensp;&ensp;&ensp;&ensp;示例：<br>&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;给定一个链表: 1-&gt;2-&gt;3-&gt;4-&gt;5, 和 n = 2.<br>&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;当删除了倒数第二个节点后，链表变为 1-&gt;2-&gt;3-&gt;5.<br>&ensp;&ensp;&ensp;&ensp;说明：给定的 n 保证是有效的。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">removeNthFromEnd</span><span class="params">(ListNode* head, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    	<span class="comment">//to do            </span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="二、解题思路"><a href="#二、解题思路" class="headerlink" title="二、解题思路"></a>二、解题思路</h3><p>&ensp;&ensp;&ensp;&ensp;首先需要知道所给链表的长度</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> length=<span class="number">0</span>;</span><br><span class="line">ListNode *lengthptr=head;</span><br><span class="line">        <span class="keyword">while</span>(lengthptr!=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">            length++;</span><br><span class="line">            lengthptr=length1-&gt;next;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<p>&ensp;&ensp;&ensp;&ensp;然后将中间指针移动到所要删除的节点的前一个节点上，然后执行删除操作。<br>&ensp;&ensp;&ensp;&ensp;根据注释中链表的定义，我们创造了一个新的节点beforhead，它指向head；然后对beforehead后面的链表执行操作，最后返回beforhead-&gt;next，这样便于解决一些特殊情况，比如删除头结点时。</p>
<h3 id="三、我的代码"><a href="#三、我的代码" class="headerlink" title="三、我的代码"></a>三、我的代码</h3><p>&ensp;&ensp;&ensp;&ensp;直接在力扣上写的。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">removeNthFromEnd</span><span class="params">(ListNode* head, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> length=<span class="number">0</span>;</span><br><span class="line">        ListNode *beforhead=<span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">0</span>,head);</span><br><span class="line">        ListNode *begin=beforhead;</span><br><span class="line">        ListNode *lengthptr=head;</span><br><span class="line">        <span class="keyword">while</span>(lengthptr!=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">            length++;</span><br><span class="line">            lengthptr=length1-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;length-n+<span class="number">1</span>;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            begin=begin-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        begin-&gt;next=begin-&gt;next-&gt;next;</span><br><span class="line">        ListNode *ans=beforhead-&gt;next;</span><br><span class="line">        <span class="keyword">return</span> ans;                    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法</category>
        <category>链表</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>leetcode</tag>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title>反转链表</title>
    <url>/2021/04/30/%E9%93%BE%E8%A1%A8%EF%BC%9A%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<h3 id="一、题目描述"><a href="#一、题目描述" class="headerlink" title="一、题目描述"></a>一、题目描述</h3><p>&ensp;&ensp;&ensp;&ensp;反转一个单链表。</p>
<span id="more"></span>

<p>示例:</p>
<pre><code>输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL
输出: 5-&gt;4-&gt;3-&gt;2-&gt;1-&gt;NULL
</code></pre>
<p>进阶:<br>&ensp;&ensp;&ensp;&ensp;你可以迭代或递归地反转链表。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">reverseList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">		<span class="comment">//to do</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="二、解题思路"><a href="#二、解题思路" class="headerlink" title="二、解题思路"></a>二、解题思路</h3><p>&ensp;&ensp;&ensp;&ensp;当链表为空或者只有一个头结点时，直接返回head即可。<br>&ensp;&ensp;&ensp;&ensp;定义三个指针：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">ListNode* p=head;</span><br><span class="line">ListNode* q=head-&gt;next;</span><br><span class="line">ListNode* tmp;</span><br></pre></td></tr></table></figure>
<p>&ensp;&ensp;&ensp;&ensp;p是反转链表的头节点，q是老链表的头节点，tmp作为p，q移动时的中间节点。<br><img src="/2021/04/30/%E9%93%BE%E8%A1%A8%EF%BC%9A%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/1.png" alt="在这里插入图片描述"><br>&ensp;&ensp;&ensp;&ensp;移动一次</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">tmp=q;</span><br><span class="line">q=q-&gt;next;</span><br><span class="line">tmp-&gt;next=p;</span><br><span class="line">p=tmp;</span><br></pre></td></tr></table></figure>

<h3 id="三、我的代码"><a href="#三、我的代码" class="headerlink" title="三、我的代码"></a>三、我的代码</h3><p>&ensp;&ensp;&ensp;&ensp;直接在力扣上写的。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">reverseList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head==<span class="literal">nullptr</span>||head-&gt;next==<span class="literal">nullptr</span>)</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        ListNode* p=head;</span><br><span class="line">        ListNode* q=head-&gt;next;</span><br><span class="line">        ListNode* tmp;</span><br><span class="line">        p-&gt;next=<span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">while</span>(q!=<span class="literal">nullptr</span>)&#123;            </span><br><span class="line">            tmp=q;</span><br><span class="line">            q=q-&gt;next;</span><br><span class="line">            tmp-&gt;next=p;</span><br><span class="line">            p=tmp;          </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> p;          </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="25-K-个一组翻转链表"><a href="#25-K-个一组翻转链表" class="headerlink" title="25. K 个一组翻转链表"></a><a href="https://leetcode-cn.com/problems/reverse-nodes-in-k-group/">25. K 个一组翻转链表</a></h3><p>给你一个链表，每 <em>k</em> 个节点一组进行翻转，请你返回翻转后的链表。</p>
<p><em>k</em> 是一个正整数，它的值小于或等于链表的长度。</p>
<p>如果节点总数不是 <em>k</em> 的整数倍，那么请将最后剩余的节点保持原有顺序。</p>
<p><strong>进阶：</strong></p>
<ul>
<li>  你可以设计一个只使用常数额外空间的算法来解决此问题吗？</li>
<li>  <strong>你不能只是单纯的改变节点内部的值</strong>，而是需要实际进行节点交换。 </li>
</ul>
<p><strong>示例 1：</strong></p>
<p><img src="/2021/04/30/%E9%93%BE%E8%A1%A8%EF%BC%9A%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/2.jpg" alt="img"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：head &#x3D; [1,2,3,4,5], k &#x3D; 2</span><br><span class="line">输出：[2,1,4,3,5]</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<p><img src="/%E5%8F%8D%E8%BD%AC%E9%93%BE%EF%BF%BD.jpg" alt="img"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：head &#x3D; [1,2,3,4,5], k &#x3D; 3</span><br><span class="line">输出：[3,2,1,4,5]</span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：head &#x3D; [1,2,3,4,5], k &#x3D; 1</span><br><span class="line">输出：[1,2,3,4,5]</span><br></pre></td></tr></table></figure>

<p><strong>示例 4：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：head &#x3D; [1], k &#x3D; 1</span><br><span class="line">输出：[1]</span><br></pre></td></tr></table></figure>



<p><strong>提示：</strong></p>
<ul>
<li>  列表中节点的数量在范围 <code>sz</code> 内</li>
<li>  <code>1 &lt;= sz &lt;= 5000</code></li>
<li>  <code>0 &lt;= Node.val &lt;= 1000</code></li>
<li>  <code>1 &lt;= k &lt;= sz</code></li>
</ul>
<p>代码</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">reverse</span><span class="params">(ListNode* a, ListNode* b)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        ListNode* pre = <span class="literal">nullptr</span>;</span><br><span class="line">        ListNode* cur = a;</span><br><span class="line">        ListNode* nxt = a;</span><br><span class="line">        <span class="keyword">while</span>(cur != b)</span><br><span class="line">        &#123;</span><br><span class="line">            nxt = cur-&gt;next;</span><br><span class="line">            cur-&gt;next = pre;</span><br><span class="line">            pre = cur;</span><br><span class="line">            cur = nxt;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pre;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">ListNode* <span class="title">reverseKGroup</span><span class="params">(ListNode* head, <span class="keyword">int</span> k)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!head)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        </span><br><span class="line">        ListNode *a = head, *b = head;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(!b)</span><br><span class="line">                <span class="keyword">return</span> head;</span><br><span class="line">            b = b-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ListNode *newHead = <span class="built_in">reverse</span>(a, b);</span><br><span class="line"></span><br><span class="line">        a-&gt;next = <span class="built_in">reverseKGroup</span>(b, k);</span><br><span class="line">        <span class="keyword">return</span> newHead;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法</category>
        <category>链表</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>leetcode</tag>
        <tag>链表</tag>
        <tag>反转链表</tag>
      </tags>
  </entry>
  <entry>
    <title>模幂运算</title>
    <url>/2021/04/30/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E5%AD%A6%EF%BC%9A%E6%A8%A1%E5%B9%82%E8%BF%90%E7%AE%97/</url>
    <content><![CDATA[<p>&ensp;&ensp;&ensp;&ensp;由于格式原因可能文章显示有问题，a^1234^代表a的1234次幂</p>
<p>&ensp;&ensp;&ensp;&ensp;a^1234^  =  a^4^  *  (a^123^)^10^</p>
<p>&ensp;&ensp;&ensp;&ensp;(a * b) % mod = (a % mod)(b % mod) % mod</p>
<span id="more"></span>

<h4 id="50-Pow-x-n"><a href="#50-Pow-x-n" class="headerlink" title="50. Pow(x, n)"></a><a href="https://leetcode-cn.com/problems/powx-n/">50. Pow(x, n)</a></h4><p>&ensp;&ensp;&ensp;&ensp;实现 pow(<em>x</em>, <em>n</em>) ，即计算 x 的 n 次幂函数（即，x^n^）。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：x &#x3D; 2.00000, n &#x3D; 10</span><br><span class="line">输出：1024.00000</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：x &#x3D; 2.10000, n &#x3D; 3</span><br><span class="line">输出：9.26100</span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：x &#x3D; 2.00000, n &#x3D; -2</span><br><span class="line">输出：0.25000</span><br><span class="line">解释：2^(-2) &#x3D; 1&#x2F;22 &#x3D; 1&#x2F;4 &#x3D; 0.25</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li>  <code>-100.0 &lt; x &lt; 100.0</code></li>
<li>  <code>-231 &lt;= n &lt;= 231-1</code></li>
<li>  <code>-10^4 &lt;= x^n &lt;= 10^4</code></li>
</ul>
<p>&ensp;&ensp;&ensp;&ensp;递归：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">quickMul</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">long</span> <span class="keyword">long</span> N)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (N == <span class="number">0</span>) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1.0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">double</span> y = <span class="built_in">quickMul</span>(x, N / <span class="number">2</span>);</span><br><span class="line">        <span class="keyword">return</span> N % <span class="number">2</span> == <span class="number">0</span> ? y * y : y * y * x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">myPow</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">int</span> n)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> N = n;</span><br><span class="line">        <span class="keyword">return</span> N &gt;= <span class="number">0</span> ? <span class="built_in">quickMul</span>(x, N) : <span class="number">1.0</span> / <span class="built_in">quickMul</span>(x, -N);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>&ensp;&ensp;&ensp;&ensp;迭代：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">quickMul</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">long</span> <span class="keyword">long</span> N)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">double</span> ans = <span class="number">1.0</span>;</span><br><span class="line">        <span class="comment">// 贡献的初始值为 x</span></span><br><span class="line">        <span class="keyword">double</span> x_contribute = x;</span><br><span class="line">        <span class="comment">// 在对 N 进行二进制拆分的同时计算答案</span></span><br><span class="line">        <span class="keyword">while</span> (N &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (N &amp; <span class="number">1</span>) </span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 如果 N 二进制表示的最低位为 1，那么需要计入贡献</span></span><br><span class="line">                ans *= x_contribute;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 将贡献不断地平方</span></span><br><span class="line">            x_contribute *= x_contribute;</span><br><span class="line">            <span class="comment">// 舍弃 N 二进制表示的最低位，这样我们每次只要判断最低位即可</span></span><br><span class="line">            N /= <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">myPow</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">int</span> n)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> N = n;</span><br><span class="line">        <span class="keyword">return</span> N &gt;= <span class="number">0</span> ? <span class="built_in">quickMul</span>(x, N) : <span class="number">1.0</span> / <span class="built_in">quickMul</span>(x, -N);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>&ensp;&ensp;&ensp;&ensp;a^1234^  =  a^4^  *  (a^123^)^10^  $\Longrightarrow$ a^[1,2,3,4]^  =  a^4^  *  (a^[1,2,3]^)^10^ </p>
<h4 id="372-超级次方"><a href="#372-超级次方" class="headerlink" title="372. 超级次方"></a><a href="https://leetcode-cn.com/problems/super-pow/">372. 超级次方</a></h4><p>你的任务是计算  a^b^  对 <code>1337</code> 取模，<code>a</code> 是一个正整数，<code>b</code> 是一个非常大的正整数且会以数组形式给出。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：a &#x3D; 2, b &#x3D; [3]</span><br><span class="line">输出：8</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：a &#x3D; 2, b &#x3D; [1,0]</span><br><span class="line">输出：1024</span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：a &#x3D; 1, b &#x3D; [4,3,3,8,5,2]</span><br><span class="line">输出：1</span><br></pre></td></tr></table></figure>

<p><strong>示例 4：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：a &#x3D; 2147483647, b &#x3D; [2,0,0]</span><br><span class="line">输出：1198</span><br></pre></td></tr></table></figure>

<p> <strong>提示：</strong></p>
<ul>
<li>  <code>1 &lt;= a &lt;= 231 - 1</code></li>
<li>  <code>1 &lt;= b.length &lt;= 2000</code></li>
<li>  <code>0 &lt;= b[i] &lt;= 9</code></li>
<li>  <code>b</code> 不含前导 0</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> mod = <span class="number">1337</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">myPow</span> <span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        x %= mod;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (n) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (n &amp; <span class="number">1</span>) res = res * x % mod;</span><br><span class="line">            x = x * x % mod;</span><br><span class="line">            n &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">superPow</span><span class="params">(<span class="keyword">int</span> a, vector&lt;<span class="keyword">int</span>&gt;&amp; b)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (b.<span class="built_in">empty</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> lastValue = b.<span class="built_in">back</span>();</span><br><span class="line">        b.<span class="built_in">pop_back</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> part1 = <span class="built_in">myPow</span>(a, lastValue);</span><br><span class="line">        <span class="keyword">int</span> part2 = <span class="built_in">myPow</span>(<span class="built_in">superPow</span>(a, b), <span class="number">10</span>);</span><br><span class="line">        <span class="keyword">return</span> part1 * part2 % mod;  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><a href="https://mp.weixin.qq.com/s?__biz=MzAxODQxMDM0Mw==&mid=2247485035&idx=1&sn=c03c9056f412bf590480156e4357b433&chksm=9bd7f863aca07175eca0bd5e638c857969af1936cc2b7b4a01610809ba1d85a3272703e2b3a2&scene=21#wechat_redirect">Super Pow：如何高效进行模幂运算 (qq.com)</a></p>
<p><a href="https://mp.weixin.qq.com/s?__biz=MzA5MTM1NTc2Ng==&mid=2458321758&idx=1&sn=e92e7a72d245831c29acb3d2a29607da&scene=21#wechat_redirect">客户端基本不用的算法系列：快速幂 (qq.com)</a></p>
<p><a href="https://blog.csdn.net/FlushHip/article/details/82495034">右移一位和除二的区别</a></p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>leetcode</tag>
        <tag>数学</tag>
        <tag>模幂运算</tag>
      </tags>
  </entry>
  <entry>
    <title>跳跃游戏</title>
    <url>/2021/04/29/%E7%AE%97%E6%B3%95%EF%BC%9A%E8%B7%B3%E8%B7%83%E6%B8%B8%E6%88%8F/</url>
    <content><![CDATA[<h3 id="一、介绍"><a href="#一、介绍" class="headerlink" title="一、介绍"></a>一、介绍</h3><p>&ensp;&ensp;&ensp;&ensp;2021年4月14日华为笔试题第四题，好像是一个有关信号塔传播的题，后来在刷Leetcode的时候碰见了原题，也就是《跳跃游戏2》；跳跃游戏1和2只是问法不一样，核心算法相同。</p>
<span id="more"></span>

<h3 id="二、题目"><a href="#二、题目" class="headerlink" title="二、题目"></a>二、题目</h3><p><a href="https://leetcode-cn.com/problems/jump-game/">跳跃游戏</a></p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">给定一个非负整数数组 nums ，你最初位于数组的第一个下标 。数组中的每个元素代表你在该位置可以跳跃的最大长度。判断你是否能够到达最后一个下标。 </span><br><span class="line"></span><br><span class="line">示例 1：</span><br><span class="line">输入：nums = [2,3,1,1,4]</span><br><span class="line">输出：true</span><br><span class="line">解释：可以先跳 1 步，从下标 0 到达下标 1, 然后再从下标 1 跳 3 步到达最后一个下标。</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line">输入：nums = [3,2,1,0,4]</span><br><span class="line">输出：false</span><br><span class="line">解释：无论怎样，总会到达下标为 3 的位置。但该下标的最大跳跃长度是 0 ， 所以永远不可能到达最后一个下标。</span><br><span class="line">提示：</span><br><span class="line">1 &lt;= nums.length &lt;= 3 * 10<span class="built_in">^</span>4</span><br><span class="line">0 &lt;= nums[i] &lt;= 105</span><br></pre></td></tr></table></figure>

<p><a href="https://leetcode-cn.com/problems/jump-game-ii/">跳跃游戏 II</a></p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">给定一个非负整数数组，你最初位于数组的第一个位置。数组中的每个元素代表你在该位置可以跳跃的最大长度。你的目标是使用最少的跳跃次数到达数组的最后一个位置。假设你总是可以到达数组的最后一个位置。</span><br><span class="line"></span><br><span class="line">示例 1:</span><br><span class="line">输入: [2,3,1,1,4]</span><br><span class="line">输出: 2</span><br><span class="line">解释: 跳到最后一个位置的最小跳跃数是 2。</span><br><span class="line">     从下标为 0 跳到下标为 1 的位置，跳 1 步，然后跳 3 步到达数组的最后一个位置。</span><br><span class="line"></span><br><span class="line">示例 2:</span><br><span class="line">输入: [2,3,0,1,4]</span><br><span class="line">输出: 2</span><br><span class="line"></span><br><span class="line">提示:</span><br><span class="line">1 &lt;= nums.length &lt;= 1000`</span><br><span class="line">0 &lt;= nums[i] &lt;= 105`</span><br></pre></td></tr></table></figure>

<h3 id="三、题解："><a href="#三、题解：" class="headerlink" title="三、题解："></a>三、题解：</h3><p>题一：</p>
<ol>
<li> 如果数组长度为<code>1</code>或数组中没有<code>0</code>，一定可以到达；</li>
<li>对于每一个元素，循环判断它前面的元素是否可以到达<ul>
<li>  如果可以到达，则跳出循环</li>
<li>  如果不可以到达：循环到该元素前面的一个元素，当那个值为<code>0</code></li>
</ul>
</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">canJump</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> numsLength = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span> (numsLength == <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;            </span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt;::iterator it = <span class="built_in">find</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>(), <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (it == nums.<span class="built_in">end</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; numsLength; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; ++j)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums[j] &gt;= i - j)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (nums[j] == <span class="number">0</span> &amp;&amp; i == j + <span class="number">1</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125; </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>题二：</p>
<ol>
<li> 用动态规划的思想，生成一数组<code>dp</code>，<code>dp[i]</code>用来记录<code>nums[0]</code>到达<code>nums[i]</code>的最小跳跃次数</li>
<li> dp[0] = 0</li>
<li> 遍历每个元素，当<code>nums[j]</code>可以到达<code>nums[i]</code>时，另<code>dp[i] = dp[j] + 1;</code>，立即跳出循环</li>
<li> 返回<code>dp[nums.size() - 1]</code></li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">jump</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> numsLength = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">dp</span><span class="params">(nums.size())</span></span>;</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; numsLength; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; ++j)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums[j] &gt;= i - j)</span><br><span class="line">                &#123;</span><br><span class="line">                    dp[i] = dp[j] + <span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125; </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[numsLength - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法</category>
        <category>遇到的笔试（面试）题</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>leetcode</tag>
        <tag>动态规划</tag>
        <tag>华为笔试题</tag>
      </tags>
  </entry>
  <entry>
    <title>位运算</title>
    <url>/2021/04/26/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E5%AD%A6%EF%BC%9A%E4%BD%8D%E8%BF%90%E7%AE%97/</url>
    <content><![CDATA[<p>&ensp;&ensp;本文介绍一些我在刷题时遇到的有关位运算的算法题。</p>
<span id="more"></span>

<h3 id="位异或："><a href="#位异或：" class="headerlink" title="位异或："></a><strong>位异或</strong>：</h3><p>&ensp;&ensp;&ensp;&ensp;一个数和它本身做异或运算结果为 0，即 <code>a ^ a = 0</code>；一个数和 0 做异或运算的结果为它本身，即 <code>a ^ 0 = a</code>。</p>
<p>&ensp;&ensp;&ensp;&ensp;例：</p>
<p>&ensp;&ensp;&ensp;&ensp;<a href="https://leetcode-cn.com/problems/single-number/">只出现一次的数字</a></p>
<p>&ensp;&ensp;&ensp;&ensp;给定一个<strong>非空</strong>整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。</p>
<p><strong>说明：</strong></p>
<p>&ensp;&ensp;&ensp;&ensp;你的算法应该具有线性时间复杂度。 你可以不使用额外空间来实现吗？</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [2,2,1]</span><br><span class="line">输出: 1</span><br></pre></td></tr></table></figure>

<p><strong>示例 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [4,1,2,1,2]</span><br><span class="line">输出: 4</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">singleNumber</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; nums.<span class="built_in">size</span>(); ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            ans = ans ^ nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h3 id="汉明权重"><a href="#汉明权重" class="headerlink" title="汉明权重"></a>汉明权重</h3><p>&ensp;&ensp;位与<code>&amp;</code>，<code>1 &amp; 1 = 1</code>，<code>1 &amp; 0 = 0 &amp; 1 = 0 &amp; 0 = 0</code></p>
<p>&ensp;&ensp;判断奇偶，n &amp; 1 == 1则为奇数，否则为偶数。</p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>汉明重量</strong>是一串符号中非零符号的个数。因此它等同于同样长度的全零符号串的<a href="https://baike.baidu.com/item/%E6%B1%89%E6%98%8E%E8%B7%9D%E7%A6%BB">汉明距离</a>。在最为常见的<a href="https://baike.baidu.com/item/%E6%95%B0%E6%8D%AE%E4%BD%8D">数据位</a>符号串中，它是1的个数。</p>
<p>&ensp;&ensp;&ensp;&ensp;<code>n&amp;(n-1)</code> 这个操作是算法中常见的，作用是消除数字 <code>n</code> 的二进制表示中的最后一个 1。</p>
<img src="/2021/04/26/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E5%AD%A6%EF%BC%9A%E4%BD%8D%E8%BF%90%E7%AE%97/2021-4-30-bit.png" alt="图片" style="zoom:50%;">

<p>&ensp;&ensp;&ensp;&ensp;其核心逻辑就是，<code>n - 1</code> 一定可以消除最后一个 1，同时把其后的 0 都变成 1，这样再和 <code>n</code> 做一次 <code>&amp;</code> 运算，就可以仅仅把最后一个 1 变成 0 了。</p>
<p>&ensp;&ensp;&ensp;&ensp;核心代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">hammingWeight</span><span class="params">(<span class="keyword">uint32_t</span> n)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (n != <span class="number">0</span>) </span><br><span class="line">    &#123;</span><br><span class="line">        n = n &amp; (n - <span class="number">1</span>);</span><br><span class="line">        res++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="338-比特位计数"><a href="#338-比特位计数" class="headerlink" title="338. 比特位计数"></a><a href="https://leetcode-cn.com/problems/counting-bits/">338. 比特位计数</a></h4><p>&ensp;&ensp;&ensp;&ensp;给定一个非负整数 <strong>num</strong>。对于 <strong>0 ≤ i ≤ num</strong> 范围中的每个数字 <strong>i</strong> ，计算其二进制数中的 1 的数目并将它们作为数组返回。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: 2</span><br><span class="line">输出: [0,1,1]</span><br></pre></td></tr></table></figure>

<p><strong>示例 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: 5</span><br><span class="line">输出: [0,1,1,2,1,2]</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">countBits</span><span class="params">(<span class="keyword">int</span> num)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt; ans;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= num; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            ans.<span class="built_in">push_back</span>(<span class="built_in">hammingWeight</span>(i));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">hammingWeight</span><span class="params">(<span class="keyword">int</span> n)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (n != <span class="number">0</span>) &#123;</span><br><span class="line">            n = n &amp; (n - <span class="number">1</span>);</span><br><span class="line">            res++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>另一解法：</p>
<p>&ensp;&ensp;&ensp;&ensp;对于所有的数字，只有两类：</p>
<p>&ensp;&ensp;&ensp;&ensp;奇数：二进制表示中，奇数一定比前面那个偶数多一个 1，因为多的就是最低位的 1。        </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">举例： </span><br><span class="line">    0 &#x3D; 0       1 &#x3D; 1</span><br><span class="line">    2 &#x3D; 10      3 &#x3D; 11</span><br></pre></td></tr></table></figure>

<p>&ensp;&ensp;&ensp;&ensp;偶数：二进制表示中，偶数中 1 的个数一定和除以 2 之后的那个数一样多。因为最低位是 0，除以 2 就是右移一位，也就是把那个 0 抹掉而已，所以 1 的个数是不变的。         </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">举例：</span><br><span class="line">    2 &#x3D; 10       4 &#x3D; 100       8 &#x3D; 1000</span><br><span class="line">    3 &#x3D; 11       6 &#x3D; 110       12 &#x3D; 1100</span><br></pre></td></tr></table></figure>

<p>&ensp;&ensp;&ensp;&ensp;另外，0 的 1 个数为 0，于是就可以根据奇偶性开始遍历计算了。</p>
<p>&ensp;&ensp;&ensp;&ensp;代码</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">countBits</span><span class="params">(<span class="keyword">int</span> num)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">result</span><span class="params">(num+<span class="number">1</span>)</span></span>;</span><br><span class="line">    result[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= num; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(i % <span class="number">2</span> == <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            result[i] = result[i<span class="number">-1</span>] + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            result[i] = result[i/<span class="number">2</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;        </span><br></pre></td></tr></table></figure>

<h4 id="461-汉明距离"><a href="#461-汉明距离" class="headerlink" title="461. 汉明距离"></a><a href="https://leetcode-cn.com/problems/hamming-distance/">461. 汉明距离</a></h4><p>两个整数之间的<a href="https://baike.baidu.com/item/%E6%B1%89%E6%98%8E%E8%B7%9D%E7%A6%BB">汉明距离</a>指的是这两个数字对应二进制位不同的位置的数目。</p>
<p>给出两个整数 <code>x</code> 和 <code>y</code>，计算它们之间的汉明距离。</p>
<p><strong>注意：</strong><br>0 ≤ <code>x</code>, <code>y</code> &lt; 231.</p>
<p><strong>示例:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: x &#x3D; 1, y &#x3D; 4</span><br><span class="line"></span><br><span class="line">输出: 2</span><br><span class="line"></span><br><span class="line">解释:</span><br><span class="line">1   (0 0 0 1)</span><br><span class="line">4   (0 1 0 0)</span><br><span class="line">       ↑   ↑</span><br><span class="line"></span><br><span class="line">上面的箭头指出了对应二进制位不同的位置。</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">hammingDistance</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = x ^ y;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (n != <span class="number">0</span>) </span><br><span class="line">        &#123;</span><br><span class="line">            n = n &amp; (n - <span class="number">1</span>);</span><br><span class="line">            ++res;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><a href="https://mp.weixin.qq.com/s?__biz=MzAxODQxMDM0Mw==&mid=2247486704&idx=2&sn=59b011722fe722551de8b56f234a4050&chksm=9bd7f2f8aca07bee47852e7bce72325157897ad0a3d5f383d18bca5379d66716518c2b968ae9&scene=21#wechat_redirect">原创 | 东哥教你几招常用的位运算技巧 (qq.com)</a></p>
]]></content>
      <categories>
        <category>算法</category>
        <category>数学</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>位运算</tag>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>前缀和数组与差分数组</title>
    <url>/2021/04/23/%E6%95%B0%E7%BB%84%EF%BC%9A%E5%89%8D%E7%BC%80%E5%92%8C%E6%95%B0%E7%BB%84%E4%B8%8E%E5%B7%AE%E5%88%86%E6%95%B0%E7%BB%84/</url>
    <content><![CDATA[<p>&ensp;&ensp;&ensp;&ensp;当我们需要频繁地查询数组某个区间的累加和或频繁地对数组的某个区间的元素进行增减，便需要用到前缀和数组以及差分数组来提高效率</p>
<span id="more"></span>

<h3 id="一、概念简介"><a href="#一、概念简介" class="headerlink" title="一、概念简介"></a>一、概念简介</h3><p>&ensp;&ensp;&ensp;&ensp;<strong>前缀和数组</strong>：对于一个给定的数组 <code>nums</code>，额外开辟一个前缀和数组进行预处理：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">preSum</span><span class="params">(nums.size() + <span class="number">1</span>)</span></span>;</span><br><span class="line">preSum[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i++)</span><br><span class="line">&#123;</span><br><span class="line">    preSum[i + <span class="number">1</span>] = preSum[i] + nums[i];</span><br><span class="line">&#125;    </span><br></pre></td></tr></table></figure>

<p>&ensp;&ensp;&ensp;&ensp;前缀和数组 <code>preSum</code> 的含义很好理解，<code>preSum[i]</code> 就是 <code>nums[0..i-1]</code> 的和。那么如果我们想求 <code>nums[i...j]</code> 的和，只需要一步操作 <code>preSum[j+1] - preSum[i]</code> 即可，而不需要重新去遍历数组了。</p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>前缀和主要适用的场景是原始数组不会被修改的情况下，频繁查询某个区间的累加和</strong>。</p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>差分数组</strong>：对于一个给定的数组<code>nums</code>，额外开辟一个差分数组进行预处理：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">diff</span><span class="params">(nums.size())</span></span>;</span><br><span class="line">diff[<span class="number">0</span>] = diff[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; nums.<span class="built_in">size</span>(); ++i)</span><br><span class="line">&#123;</span><br><span class="line">    diff[i] = nums[i] - nums[i - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&ensp;&ensp;&ensp;&ensp;通过这个<code>diff</code>差分数组是可以反推出原始数组<code>nums</code>的，代码逻辑如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">nums</span><span class="params">(diff.size())</span></span>;</span><br><span class="line"><span class="comment">// 根据差分数组构造结果数组</span></span><br><span class="line">nums[<span class="number">0</span>] = diff[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; diff.<span class="built_in">size</span>(); ++i) </span><br><span class="line">&#123;</span><br><span class="line">    nums[i] = nums[i - <span class="number">1</span>] + diff[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&ensp;&ensp;&ensp;&ensp;这样构造差分数组<code>diff</code>，就可以快速进行区间增减的操作，如果你想对区间<code>nums[i..j]</code>的元素全部加 3，那么只需要让<code>diff[i] += 3</code>，然后再让<code>diff[j+1] -= 3</code>即可。</p>
<p>&ensp;&ensp;&ensp;&ensp;<code>diff[i] += 3</code>意味着给<code>nums[i..]</code>所有的元素都加了 3，然后<code>diff[j+1] -= 3</code>又意味着对于<code>nums[j+1..]</code>所有元素再减 3，那综合起来，就是对<code>nums[i..j]</code>中的所有元素都加 3 了。</p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>差分数组的主要适用场景是频繁对原始数组的某个区间的元素进行增减</strong>。</p>
<h3 id="二、举个例子"><a href="#二、举个例子" class="headerlink" title="二、举个例子"></a>二、举个例子</h3><p><a href="https://leetcode-cn.com/problems/subarray-sum-equals-k/">560. 和为K的子数组</a></p>
<p>&ensp;&ensp;&ensp;&ensp;给定一个整数数组和一个整数 <strong>k，</strong>你需要找到该数组中和为 <strong>k</strong> 的连续的子数组的个数。</p>
<p><strong>示例 1 :</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入:nums &#x3D; [1,1,1], k &#x3D; 2</span><br><span class="line">输出: 2 , [1,1] 与 [1,1] 为两种不同的情况。</span><br></pre></td></tr></table></figure>

<p><strong>说明 :</strong></p>
<ol>
<li> 数组的长度为 [1, 20,000]。</li>
<li> 数组中元素的范围是 [-1000, 1000] ，且整数 <strong>k</strong> 的范围是 [-1e7, 1e7]。</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">subarraySum</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt; nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">  <span class="comment">// 构造前缀和</span></span><br><span class="line">  <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">sum</span><span class="params">(n + <span class="number">1</span>)</span></span>;</span><br><span class="line">  sum[<span class="number">0</span>] = <span class="number">0</span>; </span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    sum[i + <span class="number">1</span>] = sum[i] + nums[i];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">  <span class="comment">// 穷举所有子数组</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">  &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; j++)</span><br><span class="line">      &#123;</span><br><span class="line">          <span class="comment">// sum of nums[j..i-1]</span></span><br><span class="line">          <span class="keyword">if</span> (sum[i] - sum[j] == k)</span><br><span class="line">          &#123;</span><br><span class="line">               ans++;</span><br><span class="line">          &#125;             </span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">    </span><br><span class="line">  <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&ensp;&ensp;&ensp;&ensp;前缀和进阶，与 unordered_map 结合。</p>
<p>&ensp;&ensp;&ensp;&ensp;前面的解法有嵌套的 for 循环：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line"> &#123;</span><br><span class="line">     <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; j++)</span><br><span class="line">     &#123;</span><br><span class="line">         <span class="comment">// sum of nums[j..i-1]</span></span><br><span class="line">         <span class="keyword">if</span> (sum[i] - sum[j] == k)</span><br><span class="line">         &#123;</span><br><span class="line">              ans++;</span><br><span class="line">         &#125;             </span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>&ensp;&ensp;&ensp;&ensp;第二层 for 循环在计算有几个<code>j</code>能够使得<code>sum[i]</code>和<code>sum[j]</code>的差为 k。毎找到一个这样的<code>j</code>，就把结果加一。</p>
<p>&ensp;&ensp;&ensp;&ensp;我们可以把 if 语句里的条件判断移项，这样写：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if (sum[j] &#x3D;&#x3D; sum[i] - k)</span><br><span class="line">    ans++;</span><br></pre></td></tr></table></figure>

<p>&ensp;&ensp;&ensp;&ensp;优化的思路是：<strong>我直接记录下有几个<code>sum[j]</code>和<code>sum[i]-k</code>相等，直接更新结果，就避免了内层的 for 循环</strong>。我们可以用哈希表，在记录前缀和的同时记录该前缀和出现的次数。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">subarraySum</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        unordered_map&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; mp;</span><br><span class="line">        mp[<span class="number">0</span>] = <span class="number">1</span>;			<span class="comment">//前缀和为 0 的子数组个数为 1</span></span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> pre = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; x : nums)</span><br><span class="line">        &#123;</span><br><span class="line">            pre += x;	<span class="comment">//前缀和，直接采用一个变量</span></span><br><span class="line">            <span class="keyword">if</span> (mp.<span class="built_in">find</span>(pre - k) != mp.<span class="built_in">end</span>()) <span class="comment">//pre - k 是目标区间前面数组元素的前缀和</span></span><br><span class="line">            &#123;</span><br><span class="line">                count += mp[pre - k];</span><br><span class="line">            &#125;</span><br><span class="line">            ++mp[pre];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="1109-航班预订统计"><a href="#1109-航班预订统计" class="headerlink" title="1109. 航班预订统计"></a><a href="https://leetcode-cn.com/problems/corporate-flight-bookings/">1109. 航班预订统计</a></h4><p>&ensp;&ensp;&ensp;&ensp;这里有 <code>n</code> 个航班，它们分别从 <code>1</code> 到 <code>n</code> 进行编号。</p>
<p>&ensp;&ensp;&ensp;&ensp;有一份航班预订表 <code>bookings</code> ，表中第 <code>i</code> 条预订记录 <code>bookings[i] = [firsti, lasti, seatsi]</code> 意味着在从 <code>firsti</code> 到 <code>lasti</code> （<strong>包含</strong> <code>firsti</code> 和 <code>lasti</code> ）的 <strong>每个航班</strong> 上预订了 <code>seatsi</code> 个座位。</p>
<p>&ensp;&ensp;&ensp;&ensp;请你返回一个长度为 <code>n</code> 的数组 <code>answer</code>，其中 <code>answer[i]</code> 是航班 <code>i</code> 上预订的座位总数。</p>
<p> <strong>示例 1：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：bookings &#x3D; [[1,2,10],[2,3,20],[2,5,25]], n &#x3D; 5</span><br><span class="line">输出：[10,55,45,25,25]</span><br><span class="line">解释：</span><br><span class="line">航班编号        1   2   3   4   5</span><br><span class="line">预订记录 1 ：   10  10</span><br><span class="line">预订记录 2 ：       20  20</span><br><span class="line">预订记录 3 ：       25  25  25  25</span><br><span class="line">总座位数：      10  55  45  25  25</span><br><span class="line">因此，answer &#x3D; [10,55,45,25,25]</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：bookings &#x3D; [[1,2,10],[2,2,15]], n &#x3D; 2</span><br><span class="line">输出：[10,25]</span><br><span class="line">解释：</span><br><span class="line">航班编号        1   2</span><br><span class="line">预订记录 1 ：   10  10</span><br><span class="line">预订记录 2 ：       15</span><br><span class="line">总座位数：      10  25</span><br><span class="line">因此，answer &#x3D; [10,25]</span><br></pre></td></tr></table></figure>

<p> <strong>提示：</strong></p>
<ul>
<li>  <code>1 &lt;= n &lt;= 2 * 104</code></li>
<li>  <code>1 &lt;= bookings.length &lt;= 2 * 104</code></li>
<li>  <code>bookings[i].length == 3</code></li>
<li>  <code>1 &lt;= firsti &lt;= lasti &lt;= n</code></li>
<li>  <code>1 &lt;= seatsi &lt;= 104</code></li>
</ul>
<p>&ensp;&ensp;&ensp;&ensp;直接上差分数组：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">corpFlightBookings</span><span class="params">(vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; bookings, <span class="keyword">int</span> n)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">res</span><span class="params">(n,<span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">diff</span><span class="params">(n+<span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; bookings.<span class="built_in">size</span>(); ++k)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> i = bookings[k][<span class="number">0</span>] - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">int</span> j = bookings[k][<span class="number">1</span>] - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">int</span> seat = bookings[k][<span class="number">2</span>];</span><br><span class="line">            diff[i] = diff[i] + seat;</span><br><span class="line">            diff[j+<span class="number">1</span>] = diff[j+<span class="number">1</span>] - seat;</span><br><span class="line">        &#125;</span><br><span class="line">        res[<span class="number">0</span>] = diff[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">1</span>; k &lt; n; k++)</span><br><span class="line">        &#123;</span><br><span class="line">            res[k] = res[k<span class="number">-1</span>] + diff[k];</span><br><span class="line">        &#125;          </span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>[参考：论那些小而美的算法技巧：差分数组/前缀和](<a href="https://mp.weixin.qq.com/s?__biz=MzAxODQxMDM0Mw==&mid=2247487011&idx=1&sn=5e2b00c1c736fd7afbf3ed35edc4aeec&chksm=9bd7f02baca0793d569a9633cc14117e708ccc9eb41b7f0add430ea78f22e4f2443f421c6841&scene=21#wechat_redirect">论那些小而美的算法技巧：差分数组/前缀和 (qq.com)</a>)</p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>leetcode</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title>缺失的第一个整数</title>
    <url>/2021/04/21/%E7%AE%97%E6%B3%95%EF%BC%9A%E7%BC%BA%E5%A4%B1%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E6%AD%A3%E6%95%B0/</url>
    <content><![CDATA[<h3 id="一、简介"><a href="#一、简介" class="headerlink" title="一、简介"></a>一、简介</h3><p>&ensp;&ensp;&ensp;&ensp;2021年拼多多暑期实习技术面一面时碰到了这道题，面试官直接告诉我这是道 hard 级别的题目，还问我要不要换一道，当时头铁，没想换，结果就是代码各种细节漏洞（拼多多面试平台不能运行代码，很痛苦），最后还是换了一道二叉树的 medium 题。</p>
 <span id="more"></span>

<p>&ensp;&ensp;&ensp;&ensp;题目描述：(<a href="https://leetcode-cn.com/problems/first-missing-positive/">leetcode: 41</a>)</p>
<p>&ensp;&ensp;&ensp;&ensp;给你一个未排序的整数数组 <code>nums</code> ，请你找出其中没有出现的最小的正整数要求时间复杂度O(n)，空间复杂度O(1)</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：nums &#x3D; [1,2,0]</span><br><span class="line">输出：3</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：nums &#x3D; [3,4,-1,1]</span><br><span class="line">输出：2</span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：nums &#x3D; [7,8,9,11,12]</span><br><span class="line">输出：1</span><br></pre></td></tr></table></figure>

<p> <strong>提示：</strong></p>
<ul>
<li>  <code>0 &lt;= nums.length &lt;= 300</code></li>
<li>  <code>-231 &lt;= nums[i] &lt;= 231 - 1</code></li>
</ul>
<h3 id="二、题目分析"><a href="#二、题目分析" class="headerlink" title="二、题目分析"></a>二、题目分析</h3><p>&ensp;&ensp;&ensp;&ensp;首先，我们可以确定给定数组的缺失的最小整数的范围：[1, nums.size() + 1]，因此我们可以把数组中的元素<strong>归位</strong>，比如数组中的 1 放在数组第1个位置， 2 放在数组第2个位置……</p>
<p>&ensp;&ensp;&ensp;&ensp;然后从头遍历该数组，当 <code>nums[i] - 1 != i</code>时，返回 <code>i + 1</code>即可；若遍历完仍然没返回值，则返回<code>nums.size() + 1</code>。</p>
<p>&ensp;&ensp;&ensp;&ensp;重点是<strong>归位</strong>元素，使数组中的元素 <code>a</code>，归位到 <code>nums[a - 1]</code>（a的范围有限制），还要考虑<code>a</code>的目标位置上的元素不被覆盖。</p>
<blockquote>
<p>  所以应该交换 a 和 目标位置的元素，这是原来 a 的位置有了新元素，再归位这个新元素。（不要以为只交换一次，新元素可能 ‘’德不配位’‘ ）</p>
</blockquote>
<p>&ensp;&ensp;&ensp;&ensp;例：[3, 4, -1, 1] → [-1, 4, 3, 1] → [-1, 1, 3, 4] → [1, -1, 3, 4]</p>
<ol>
<li> 归位 3， -1 换到 nums[0]，-1 不满足范围限制</li>
<li> 归位 4， 1 换到 nums[1]; 再归位 1，使nums[0] = 1, -1换到nums[1] 处</li>
<li> 再归位后面的元素</li>
</ol>
<p>代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">firstMissingPositive</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> length = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//范围限制</span></span><br><span class="line">            <span class="keyword">while</span> (nums[i] &gt; <span class="number">0</span> &amp;&amp; </span><br><span class="line">                   nums[i] &lt;= nums.<span class="built_in">size</span>() &amp;&amp; </span><br><span class="line">                   nums[nums[i] - <span class="number">1</span>] != nums[i]) </span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">swap</span>(nums[i], nums[nums[i] - <span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); ++i) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] - <span class="number">1</span> != i) </span><br><span class="line">                <span class="keyword">return</span> i + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums.<span class="built_in">size</span>() + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>&ensp;&ensp;&ensp;&ensp;更多博客，敬请期待。</p>
]]></content>
      <categories>
        <category>算法</category>
        <category>遇到的笔试（面试）题</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>leetcode</tag>
        <tag>拼多多实习面试</tag>
      </tags>
  </entry>
  <entry>
    <title>MySql8.0窗口函数</title>
    <url>/2021/04/21/%E6%95%B0%E6%8D%AE%E5%BA%93%EF%BC%9AMySql8.0%E7%AA%97%E5%8F%A3%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<h3 id="一、基本概念"><a href="#一、基本概念" class="headerlink" title="一、基本概念"></a>一、基本概念</h3><p>&ensp;&ensp;&ensp;&ensp;MySQL从<strong>8.0</strong>开始支持窗口函数，这个功能在大多商业数据库和部分开源数据库中早已支持，有的也叫分析函数。</p>
 <span id="more"></span>

<p>概念：</p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>窗口</strong>的概念可以理解为记录集合；<strong>窗口函数</strong>也就是在满足某种条件的记录集合上执行的特殊函数，对于每条记录都要在此窗口内执行函数，有的函数随着记录不同，窗口大小都是固定的，这种是静态窗口；有的函数则是不同的记录对应着不同的窗口，这种动态变化的窗口叫滑动窗口。</p>
<p>窗口函数与聚合函数：</p>
<ol>
<li>聚合函数是将多条记录聚合为一条；</li>
<li>窗口函数是每条记录都会执行，有几条记录执行完还是几条；</li>
<li>聚合函数也可以用于窗口函数。</li>
</ol>
<h3 id="二、基本格式"><a href="#二、基本格式" class="headerlink" title="二、基本格式"></a>二、基本格式</h3><p>基本语法：&lt;窗口函数&gt; over (子句)</p>
<ul>
<li><p>&lt;窗口函数&gt;的位置可以放专用窗口函数（rank()，percent_rank()，dense_rank()等），或者放聚合函数（sum()，avg()，max()等）。</p>
</li>
<li><p>窗口函数是对where或group by子句处理后的结果进行操作，故其原则上只写于SELECT子句中。</p>
</li>
<li><p>over 用来指定函数执行的窗口范围，<strong>若子句为空</strong>，则意味着窗口包含满足WHERE条件的所有行，窗口函数基于所有行进行计算。</p>
</li>
<li><p>若子句非空，则支持以下4中语法来设置窗口：</p>
<p>​        <strong>window_name</strong>：给窗口指定一个别名，如果SQL中涉及的窗口较多，采用别名可以看起来更清晰易读。        </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT</span><br><span class="line">	&#96;姓名&#96;,</span><br><span class="line">	&#96;班级&#96;,</span><br><span class="line">	&#96;人气&#96;,</span><br><span class="line">	rank() over w1 AS rak</span><br><span class="line">FROM</span><br><span class="line">	&#96;民工漫班级&#96; window w1 AS ( PARTITION BY &#96;班级&#96; ORDER BY &#96;人气&#96; DESC );</span><br></pre></td></tr></table></figure>

<p>​        结果：</p>
<img src="/2021/04/21/%E6%95%B0%E6%8D%AE%E5%BA%93%EF%BC%9AMySql8.0%E7%AA%97%E5%8F%A3%E5%87%BD%E6%95%B0/1.png" alt="image-20201217104056497" style="zoom:80%;">

<p>​        <strong>partition子句</strong>：窗口按照那些字段进行分组，窗口函数在不同的分组上分别执行。</p>
<p>​        <strong>order by子句</strong>：按照哪些字段进行排序，窗口函数将按照排序后的记录顺序进行编号。</p>
<p>​        frame子句：frame是当前分区的一个子集，子句用来定义子集的规则，通常用来作为滑动窗口使用。（本文暂不介绍）</p>
<p>​        用于操作示例新建的民工漫班级表：</p>
<img src="/2021/04/21/%E6%95%B0%E6%8D%AE%E5%BA%93%EF%BC%9AMySql8.0%E7%AA%97%E5%8F%A3%E5%87%BD%E6%95%B0/2.png" alt="民工漫班级" style="zoom: 67%;">

<p>​        </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT</span><br><span class="line">	*,</span><br><span class="line">	RANK() over ( PARTITION BY &#96;班级&#96; ORDER BY &#96;人气&#96; DESC ) AS ranking </span><br><span class="line">FROM</span><br><span class="line">	&#96;民工漫班级&#96;;</span><br><span class="line"># PARTITION BY &#96;班级&#96;：按班级分组（使用group by会改变表的行数，一个类别只保留一行；partition by则不会减少表的行数）</span><br><span class="line"># ORDER BY &#96;人气&#96; DESC：对按班级分组后的结果按人气降序排名，名次作为字段 ranking</span><br></pre></td></tr></table></figure>

<p>得到结果：</p>
<img src="/2021/04/21/%E6%95%B0%E6%8D%AE%E5%BA%93%EF%BC%9AMySql8.0%E7%AA%97%E5%8F%A3%E5%87%BD%E6%95%B0/3.png" alt="image-20201217000959621" style="zoom: 50%;"></li>
</ul>
<h3 id="三、mysql窗口函数"><a href="#三、mysql窗口函数" class="headerlink" title="三、mysql窗口函数"></a>三、mysql窗口函数</h3><p><strong>功能划分</strong>：</p>
<p> 按功能划分可将MySQL支持的窗口函数分为如下几类：</p>
<ol>
<li>序号函数：ROW_NUMBER()、RANK()、DENSE_RANK()</li>
<li>分布函数：PERCENT_RANK()、CUME_DIST()，PERCENT_RANK()</li>
<li>前后函数：LAG(expr,n)、LEAD(expr,n)</li>
<li>头尾函数：FIRST_VALUE(expr)、LAST_VALUE(expr)</li>
<li>其它函数：NTH_VALUE(expr, n)、NTILE(n)</li>
</ol>
<p><strong>分别介绍：</strong></p>
<p><strong>序号函数：ROW_NUMBER()、RANK()、DENSE_RANK()</strong></p>
<p>&ensp;&ensp;&ensp;&ensp;举个例子，还用上面的民工漫班级表，用三个函数按人气对其排序：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT</span><br><span class="line">	*,</span><br><span class="line">	RANK() over (  ORDER BY &#96;人气&#96; DESC ) AS &#96;rank&#96; ,</span><br><span class="line">	DENSE_RANK() over (  ORDER BY &#96;人气&#96; DESC ) AS &#96;dense_rank&#96; ,</span><br><span class="line">	ROW_NUMBER() over (  ORDER BY &#96;人气&#96; DESC ) AS &#96;row_number&#96; </span><br><span class="line">FROM</span><br><span class="line">	&#96;民工漫班级&#96;;</span><br></pre></td></tr></table></figure>

<p>&ensp;&ensp;&ensp;&ensp;结果：没有再用partition by对班级分组</p>
<img src="/2021/04/21/%E6%95%B0%E6%8D%AE%E5%BA%93%EF%BC%9AMySql8.0%E7%AA%97%E5%8F%A3%E5%87%BD%E6%95%B0/4.png" alt="image-20201217004449218" style="zoom: 67%;">

<p>由此可知：</p>
<ul>
<li>RANK()：并列排序，跳过重复序号——1、1、3</li>
<li>DENSE_RANK()：并列排序，不跳过重复序号——1、1、2</li>
<li>ROW_NUMBER()：顺序排序——1、2、3；相当于行号。</li>
</ul>
<p><strong>分布函数：PERCENT_RANK()、CUME_DIST()</strong></p>
<p><strong>percent_rank()</strong></p>
<p>&ensp;&ensp;&ensp;&ensp;用途：和之前的RANK()函数相关，每行按照如下公式进行计算：(rank - 1) / (rows - 1)， 其中，rank为RANK()函数产生的序号，rows为当前窗口的记录总行数 该函数可以用来计算分位数。</p>
<p>&ensp;&ensp;&ensp;&ensp;继续举例子（想不到实际生活的应用场景）：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT</span><br><span class="line">	*,</span><br><span class="line">	RANK() OVER w AS rankNo,</span><br><span class="line">	PERCENT_RANK() OVER w AS percent_rankNo </span><br><span class="line">FROM</span><br><span class="line">	&#96;民工漫班级&#96; WINDOW w AS ( ORDER BY &#96;人气&#96; DESC );</span><br></pre></td></tr></table></figure>

<p>结果：</p>
<img src="/2021/04/21/%E6%95%B0%E6%8D%AE%E5%BA%93%EF%BC%9AMySql8.0%E7%AA%97%E5%8F%A3%E5%87%BD%E6%95%B0/5.png" alt="image-20201217105136040" style="zoom: 50%;">

<p>&ensp;&ensp;&ensp;&ensp;对于路飞，percent_rankNo = (rank - 1) / (rows - 1) =(3 - 1) / (10 - 1) =0.22222222……</p>
<p><strong>CUME_DIST()</strong></p>
<p>&ensp;&ensp;&ensp;&ensp;用途：分组内小于、等于当前rank值的行数 / 分组内总行数</p>
<p>&ensp;&ensp;&ensp;&ensp;举例：查询小于等于当前人气的比例（或者说某人是前百分之几，生活中很常用）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT</span><br><span class="line">	*,</span><br><span class="line">	CUME_DIST() OVER w AS cdt </span><br><span class="line">FROM</span><br><span class="line">	&#96;民工漫班级&#96; WINDOW w AS ( ORDER BY &#96;人气&#96; DESC );</span><br></pre></td></tr></table></figure>

<p>结果：</p>
<img src="/2021/04/21/%E6%95%B0%E6%8D%AE%E5%BA%93%EF%BC%9AMySql8.0%E7%AA%97%E5%8F%A3%E5%87%BD%E6%95%B0/6.png" alt="image-20201217110444956" style="zoom: 67%;">

<p><strong>前后函数：LAG(expr,n)、LEAD(expr,n)</strong></p>
<p>&ensp;&ensp;&ensp;&ensp;用途：返回位于当前行的前n行（LAG(expr,n)）或后n行（LEAD(expr,n)）的expr的值（以当前行为原点）</p>
<p>&ensp;&ensp;&ensp;&ensp;例：这个生活中应该挺常用</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT</span><br><span class="line">	*,</span><br><span class="line">	&#96;我的前面一名人气&#96; - &#96;人气&#96; AS &#96;我和前面一名的差距&#96;,</span><br><span class="line">	&#96;人气&#96; - &#96;后面一名人气&#96; AS &#96;我甩开后面一名多少差距&#96; </span><br><span class="line">FROM</span><br><span class="line">	(</span><br><span class="line">	SELECT</span><br><span class="line">		*,</span><br><span class="line">		LAG( &#96;人气&#96;, 1 ) OVER w AS &#96;我的前面一名人气&#96;,# 取前面第一行的人气值</span><br><span class="line">		LEAD( &#96;人气&#96;, 1 ) OVER w AS &#96;后面一名人气&#96; # 取后面第一行的人气值</span><br><span class="line">		</span><br><span class="line">	FROM</span><br><span class="line">		&#96;民工漫班级&#96; WINDOW w AS ( ORDER BY &#96;人气&#96; DESC ) </span><br><span class="line">	) t;</span><br></pre></td></tr></table></figure>

<p>结果：</p>
<img src="/2021/04/21/%E6%95%B0%E6%8D%AE%E5%BA%93%EF%BC%9AMySql8.0%E7%AA%97%E5%8F%A3%E5%87%BD%E6%95%B0/7.png" alt="image-20201217113619889" style="zoom: 67%;">

<p>&ensp;&ensp;&ensp;&ensp;蓝染的前1行是路飞，其人气为90，差距为2；后一行是佐助，甩开他1人气。</p>
<p><strong>头尾函数：FIRST_VALUE(expr),LAST_VALUE(expr)</strong></p>
<p>&ensp;&ensp;&ensp;&ensp;用途：返回第一个（FIRST_VALUE(expr)）或最后一个（LAST_VALUE(expr)）expr的值</p>
<p>&ensp;&ensp;&ensp;&ensp;例：截止到当前人气，按人气排名，第一名和最后一名是多少（降序排，最后一名肯定是自己）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT</span><br><span class="line">	*,</span><br><span class="line">	FIRST_VALUE( &#96;人气&#96; ) OVER w AS &#96;当前第一人气值&#96;,</span><br><span class="line">	LAST_VALUE( &#96;人气&#96; ) OVER w AS &#96;当前倒数第一人气值&#96; </span><br><span class="line">FROM</span><br><span class="line">	&#96;民工漫班级&#96; WINDOW w AS ( ORDER BY &#96;人气&#96; DESC );</span><br></pre></td></tr></table></figure>

<p>结果：</p>
<img src="/2021/04/21/%E6%95%B0%E6%8D%AE%E5%BA%93%EF%BC%9AMySql8.0%E7%AA%97%E5%8F%A3%E5%87%BD%E6%95%B0/8.png" alt="image-20201217114336947" style="zoom: 67%;">

<p><strong>其它函数：NTH_VALUE(expr, n)、NTILE(n)</strong></p>
<p><strong>NTH_VALUE(expr, n)</strong></p>
<p>&ensp;&ensp;&ensp;&ensp;用途：返回窗口中第N个expr的值，expr可以是表达式，也可以是列名。</p>
<p>&ensp;&ensp;&ensp;&ensp;例：截至当前人气，显示每个人物的人气中排名第2、第4、第6的人气值</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT</span><br><span class="line">	*,</span><br><span class="line">	NTH_VALUE( &#96;人气&#96;, 2 ) OVER w AS &#96;第二人气值&#96;,</span><br><span class="line">	NTH_VALUE( &#96;人气&#96;, 4 ) OVER w AS &#96;第四人气值&#96;,</span><br><span class="line">	NTH_VALUE( &#96;人气&#96;, 6 ) OVER w AS &#96;第六人气值&#96; </span><br><span class="line">FROM</span><br><span class="line">	&#96;民工漫班级&#96; WINDOW w AS ( ORDER BY &#96;人气&#96; DESC );</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>结果：</p>
<img src="/2021/04/21/%E6%95%B0%E6%8D%AE%E5%BA%93%EF%BC%9AMySql8.0%E7%AA%97%E5%8F%A3%E5%87%BD%E6%95%B0/9.png" alt="image-20201217135748608" style="zoom: 67%;">

<p><strong>NTILE(n)</strong></p>
<p>&ensp;&ensp;&ensp;&ensp;用途：将分区中的有序数据分为n个等级，记录等级数</p>
<p>例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT</span><br><span class="line">	*,</span><br><span class="line">	ROW_NUMBER() OVER w AS &#39;row_number&#39;,</span><br><span class="line">	NTILE( 2 ) OVER w AS &#39;ntile2&#39;,</span><br><span class="line">	NTILE( 4 ) OVER w AS &#39;ntile4&#39; </span><br><span class="line">FROM</span><br><span class="line">	&#96;民工漫班级&#96; WINDOW w AS ( ORDER BY &#96;人气&#96; );</span><br></pre></td></tr></table></figure>

<p>结果：</p>
<img src="/2021/04/21/%E6%95%B0%E6%8D%AE%E5%BA%93%EF%BC%9AMySql8.0%E7%AA%97%E5%8F%A3%E5%87%BD%E6%95%B0/10.png" alt="image-20201217170421940" style="zoom:67%;">

<h3 id="四、用聚合函数作为窗口函数"><a href="#四、用聚合函数作为窗口函数" class="headerlink" title="四、用聚合函数作为窗口函数"></a>四、用聚合函数作为窗口函数</h3><p>&ensp;&ensp;&ensp;&ensp;用途：在窗口中每条记录动态地应用聚合函数（SUM()、AVG()、MAX()、MIN()、COUNT()），可以动态计算在指定的窗口内的各种聚合函数值</p>
<p>例：普通使用：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT</span><br><span class="line">	*,</span><br><span class="line">	sum( &#96;人气&#96; )  AS current_sum,</span><br><span class="line">	avg( &#96;人气&#96; )  AS current_avg,</span><br><span class="line">	count( &#96;人气&#96; )  AS current_count,</span><br><span class="line">	max( &#96;人气&#96; )  AS current_max,</span><br><span class="line">	min( &#96;人气&#96; ) AS current_min </span><br><span class="line">FROM</span><br><span class="line">	&#96;民工漫班级&#96;;</span><br></pre></td></tr></table></figure>

<p>结果：</p>
<img src="/2021/04/21/%E6%95%B0%E6%8D%AE%E5%BA%93%EF%BC%9AMySql8.0%E7%AA%97%E5%8F%A3%E5%87%BD%E6%95%B0/11.png" alt="image-20201217172447565" style="zoom: 67%;">

<p>&ensp;&ensp;&ensp;&ensp;按学号排序，作为窗口函数：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT</span><br><span class="line">	*,</span><br><span class="line">	sum( &#96;人气&#96; ) over w AS current_sum,</span><br><span class="line">	avg( &#96;人气&#96; ) over w AS current_avg,</span><br><span class="line">	count( &#96;人气&#96; ) over w AS current_count,</span><br><span class="line">	max( &#96;人气&#96; ) over w AS current_max,</span><br><span class="line">	min( &#96;人气&#96; ) over w AS current_min </span><br><span class="line">FROM</span><br><span class="line">	&#96;民工漫班级&#96; WINDOW w AS ( ORDER BY &#96;学号&#96; );</span><br></pre></td></tr></table></figure>

<p>结果：</p>
<img src="/2021/04/21/%E6%95%B0%E6%8D%AE%E5%BA%93%EF%BC%9AMySql8.0%E7%AA%97%E5%8F%A3%E5%87%BD%E6%95%B0/12.png" alt="image-20201217172207911" style="zoom:67%;">

<p>&ensp;&ensp;&ensp;&ensp;以current_sum为例，每一行current_sum的值为上面所有行的<code>人气</code>值之和。</p>
<p>本文主要参考：</p>
<p><a href="https://dev.mysql.com/doc/refman/8.0/en/">《MySql8.0参考手册》</a></p>
]]></content>
      <categories>
        <category>数据库</category>
        <category>MySql</category>
      </categories>
      <tags>
        <tag>数据库</tag>
        <tag>窗口函数</tag>
        <tag>MySql</tag>
      </tags>
  </entry>
</search>
