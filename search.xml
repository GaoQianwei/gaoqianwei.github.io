<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>近期说明</title>
    <url>/2021/04/10/top%EF%BC%9A%E8%AF%B4%E6%98%8E/</url>
    <content><![CDATA[<p>&ensp;&ensp;介绍一些博客较大的变化（增删改查）以及其它说明。</p>
<span id="more"></span>

<h3 id="2021年5月15日"><a href="#2021年5月15日" class="headerlink" title="2021年5月15日"></a>2021年5月15日</h3><p>    本周刷了几道和数组有关的算法题，有子数组相关、数组元素与下标等，趁着周六整理了出来。</p>
<h3 id="2021年5月9日"><a href="#2021年5月9日" class="headerlink" title="2021年5月9日"></a>2021年5月9日</h3><p>&ensp;&ensp;&ensp;&ensp;把以前和数学有关的几道算法题整理了一下，主要是杨辉三角和排列组合子集的相关问题。</p>
<h3 id="2021年5月7日"><a href="#2021年5月7日" class="headerlink" title="2021年5月7日"></a>2021年5月7日</h3><p>&ensp;&ensp;&ensp;&ensp;增加了一些有关二叉树的算法题，不再像链表题那样一个题一篇博客，而是一类题一篇博客；同时由于在学习<code>Shell</code>，所以还增加了两篇和<code>Shell</code>相关的博客。</p>
<p>    顺道把以前学习C++时的<code>STL</code>笔记整理了上去。</p>
<h3 id="2021年5月1日"><a href="#2021年5月1日" class="headerlink" title="2021年5月1日"></a>2021年5月1日</h3><p>&ensp;&ensp;&ensp;&ensp;为这个小破站添加了友情链接，主要是收藏自己喜欢的学习网站和好友的博客；同时在侧边栏添加了一个粒子时钟，方便查看时间。</p>
<h3 id="2021年4月29日"><a href="#2021年4月29日" class="headerlink" title="2021年4月29日"></a>2021年4月29日</h3><p>    增添了大量有关链表算法题的文章，都是自己以前写的，今天整理出来了。其它的内容，趁着五一假期，会陆续发布。</p>
]]></content>
  </entry>
  <entry>
    <title>缺失的第一个整数</title>
    <url>/2021/05/15/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E7%BB%84%EF%BC%9A%E7%BC%BA%E5%A4%B1%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E6%AD%A3%E6%95%B0/</url>
    <content><![CDATA[ <span id="more"></span>

<h3 id="一、简介"><a href="#一、简介" class="headerlink" title="一、简介"></a>一、简介</h3><p>&ensp;&ensp;&ensp;&ensp;2021年拼多多暑期实习技术面一面时碰到了这道题，面试官直接告诉我这是道 hard 级别的题目，还问我要不要换一道，当时头铁，没想换，结果就是代码各种细节漏洞（拼多多面试平台不能运行代码，很痛苦），最后还是换了一道二叉树的 medium 题。</p>
<p>题目描述：(<a href="https://leetcode-cn.com/problems/first-missing-positive/">leetcode: 41</a>)</p>
<p>&ensp;&ensp;&ensp;&ensp;给你一个未排序的整数数组 <code>nums</code> ，请你找出其中没有出现的最小的正整数要求时间复杂度O(n)，空间复杂度O(1)</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：nums &#x3D; [1,2,0]</span><br><span class="line">输出：3</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：nums &#x3D; [3,4,-1,1]</span><br><span class="line">输出：2</span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：nums &#x3D; [7,8,9,11,12]</span><br><span class="line">输出：1</span><br></pre></td></tr></table></figure>

<p> <strong>提示：</strong></p>
<ul>
<li>  <code>0 &lt;= nums.length &lt;= 300</code></li>
<li>  <code>-231 &lt;= nums[i] &lt;= 231 - 1</code></li>
</ul>
<h3 id="二、题目分析"><a href="#二、题目分析" class="headerlink" title="二、题目分析"></a>二、题目分析</h3><p>&ensp;&ensp;&ensp;&ensp;首先，我们可以确定给定数组的缺失的最小整数的范围：[1, nums.size() + 1]，因此我们可以把数组中的元素<strong>归位</strong>，比如数组中的 1 放在数组第1个位置， 2 放在数组第2个位置……</p>
<p>&ensp;&ensp;&ensp;&ensp;然后从头遍历该数组，当 <code>nums[i] - 1 != i</code>时，返回 <code>i + 1</code>即可；若遍历完仍然没返回值，则返回<code>nums.size() + 1</code>。</p>
<p>&ensp;&ensp;&ensp;&ensp;重点是<strong>归位</strong>元素，使数组中的元素 <code>a</code>，归位到 <code>nums[a - 1]</code>（a的范围有限制），还要考虑<code>a</code>的目标位置上的元素不被覆盖。</p>
<blockquote>
<p>  所以应该交换 a 和 目标位置的元素，这是原来 a 的位置有了新元素，再归位这个新元素。（不要以为只交换一次，新元素可能 ‘’德不配位’‘ ）</p>
</blockquote>
<p>例：[3, 4, -1, 1] → [-1, 4, 3, 1] → [-1, 1, 3, 4] → [1, -1, 3, 4]</p>
<ol>
<li> 归位 3， -1 换到 nums[0]，-1 不满足范围限制</li>
<li> 归位 4， 1 换到 nums[1]; 再归位 1，使nums[0] = 1, -1换到nums[1] 处</li>
<li> 再归位后面的元素</li>
</ol>
<p>代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">firstMissingPositive</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> length = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//范围限制</span></span><br><span class="line">            <span class="keyword">while</span> (nums[i] &gt; <span class="number">0</span> &amp;&amp; </span><br><span class="line">                   nums[i] &lt;= nums.<span class="built_in">size</span>() &amp;&amp; </span><br><span class="line">                   nums[nums[i] - <span class="number">1</span>] != nums[i]) </span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">swap</span>(nums[i], nums[nums[i] - <span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); ++i) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] - <span class="number">1</span> != i) </span><br><span class="line">                <span class="keyword">return</span> i + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums.<span class="built_in">size</span>() + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>更多博客，敬请期待。</p>
]]></content>
      <categories>
        <category>algorithm</category>
      </categories>
      <tags>
        <tag>数组</tag>
        <tag>拼多多实习面试</tag>
        <tag>algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>除自身以外数组的乘积</title>
    <url>/2021/05/15/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E7%BB%84%EF%BC%9A%E9%99%A4%E8%87%AA%E8%BA%AB%E4%BB%A5%E5%A4%96%E6%95%B0%E7%BB%84%E7%9A%84%E4%B9%98%E7%A7%AF/</url>
    <content><![CDATA[<h3 id="一、题目"><a href="#一、题目" class="headerlink" title="一、题目"></a>一、题目</h3><p>&ensp;&ensp;&ensp;&ensp;给你一个长度为 <em>n</em> 的整数数组 <code>nums</code>，其中 <em>n</em> &gt; 1，返回输出数组 <code>output</code> ，其中 <code>output[i]</code> 等于 <code>nums</code> 中除 <code>nums[i]</code> 之外其余各元素的乘积。 </p>
<span id="more"></span>

<p><strong>示例:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [1,2,3,4]</span><br><span class="line">输出: [24,12,8,6]</span><br></pre></td></tr></table></figure>

<p> <strong>提示：</strong>题目数据保证数组之中任意元素的全部前缀元素和后缀（甚至是整个数组）的乘积都在 32 位整数范围内。</p>
<p><strong>说明:</strong> 请<strong>不要使用除法，</strong>且在 O(<em>n</em>) 时间复杂度内完成此题。</p>
<p><strong>进阶：</strong><br>&ensp;&ensp;&ensp;&ensp;你可以在常数空间复杂度内完成这个题目吗？（ 出于对空间复杂度分析的目的，输出数组<strong>不被视为</strong>额外空间。）</p>
<h3 id="二、思路与代码"><a href="#二、思路与代码" class="headerlink" title="二、思路与代码"></a>二、思路与代码</h3><p>&ensp;&ensp;&ensp;&ensp;刚开始想到的是用一个半角矩阵保存数组中<code>i ~ j</code>之间元素的乘积，但是这样时间复杂度太大，会超时。所以改用其它思路优化时间复杂度。</p>
<p>&ensp;&ensp;&ensp;&ensp;我们不必将所有数字的乘积除以给定索引处的数字得到相应的答案，而是利用索引左侧所有数字的乘积和右侧所有数字的乘积（即前缀与后缀）相乘得到答案。（官方解释）</p>
<p>&ensp;&ensp;&ensp;&ensp;所以建立两个数组<code>vector&lt;int&gt; left</code>与<code>vector&lt;int&gt; right</code>，其中<code>left[i]</code>表示数组元素<code>nums[i]</code>的左边元素的乘积，<code>right[i]</code>表示数组元素<code>nums[i]</code>的右边边元素的乘积。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">productExceptSelf</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> numsLength = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">left</span><span class="params">(numsLength)</span></span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">right</span><span class="params">(numsLength)</span></span>;</span><br><span class="line">        </span><br><span class="line">        left[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; numsLength; ++i) </span><br><span class="line">        &#123;</span><br><span class="line">            left[i] = nums[i - <span class="number">1</span>] * left[i - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        right[numsLength - <span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = numsLength - <span class="number">2</span>; i &gt;= <span class="number">0</span>; --i) </span><br><span class="line">        &#123;</span><br><span class="line">            right[i] = nums[i + <span class="number">1</span>] * right[i + <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//vector&lt;int&gt; ans(numsLength);</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numsLength; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            left[i] = left[i] * right[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>&ensp;&ensp;&ensp;&ensp;leetcode评论区总有大佬，看其优化空间：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">productExceptSelf</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> n=nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> left=<span class="number">1</span>,right=<span class="number">1</span>;     <span class="comment">//left：从左边累乘，right：从右边累乘</span></span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">res</span><span class="params">(n,<span class="number">1</span>)</span></span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;++i)    <span class="comment">//最终每个元素其左右乘积进行相乘得出结果</span></span><br><span class="line">        &#123;</span><br><span class="line">            res[i]*=left;       <span class="comment">//乘以其左边的乘积</span></span><br><span class="line">            left*=nums[i];</span><br><span class="line">            </span><br><span class="line">            res[n<span class="number">-1</span>-i]*=right;  <span class="comment">//乘以其右边的乘积</span></span><br><span class="line">            right*=nums[n<span class="number">-1</span>-i];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">       </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法</category>
        <category>数组</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title>子数组相关算法问题</title>
    <url>/2021/05/15/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E7%BB%84%EF%BC%9A%E5%AD%90%E6%95%B0%E7%BB%84%E7%9B%B8%E5%85%B3/</url>
    <content><![CDATA[<p>&ensp;&ensp;&ensp;&ensp;对与数组题，有一类题喜欢对数组的子序列做文章，这篇博客便搜集了几道相关的题目。</p>
<span id="more"></span>

<h3 id="一、最大子序和"><a href="#一、最大子序和" class="headerlink" title="一、最大子序和"></a><a href="https://leetcode-cn.com/problems/maximum-subarray/">一、最大子序和</a></h3><h4 id="1-1题目"><a href="#1-1题目" class="headerlink" title="1.1题目"></a>1.1题目</h4><p>&ensp;&ensp;&ensp;&ensp;给定一个整数数组 <code>nums</code> ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：nums &#x3D; [-2,1,-3,4,-1,2,1,-5,4]</span><br><span class="line">输出：6</span><br><span class="line">解释：连续子数组 [4,-1,2,1] 的和最大，为 6 。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：nums &#x3D; [1]</span><br><span class="line">输出：1</span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：nums &#x3D; [0]</span><br><span class="line">输出：0</span><br></pre></td></tr></table></figure>

<p><strong>示例 4：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：nums &#x3D; [-1]</span><br><span class="line">输出：-1</span><br></pre></td></tr></table></figure>

<p><strong>示例 5：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：nums &#x3D; [-100000]</span><br><span class="line">输出：-100000</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li>  <code>1 &lt;= nums.length &lt;= 3 * 104</code></li>
<li>  <code>-105 &lt;= nums[i] &lt;= 105</code></li>
</ul>
<h4 id="1-2思路与代码："><a href="#1-2思路与代码：" class="headerlink" title="1.2思路与代码："></a>1.2思路与代码：</h4><p>&ensp;&ensp;&ensp;&ensp;很明显是动态规划来解决，<code>dp[i]</code> 用来记载下标 <code>0 ~ i</code> 之间的最大子序和，由于 <code>dp[i]</code> 只与 <code>dp[i - 1]</code> 有关：<code>dp[i] = max&#123;dp[i - 1] + nums[i], nums[i]&#125;</code>。</p>
<p>&ensp;&ensp;&ensp;&ensp;所以无需数组 <code>dp[]</code>，用一个变量 <code>sum</code> 记载即可，另有 <code>ans</code> 记录最大值。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxSubArray</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">const</span> <span class="keyword">int</span> &amp;i : nums)</span><br><span class="line">        &#123;</span><br><span class="line">            sum = sum &gt; <span class="number">0</span> ? sum + i : i; </span><br><span class="line">            ans = ans &gt; sum ? ans : sum;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h3 id="二、乘积最大子数组"><a href="#二、乘积最大子数组" class="headerlink" title="二、乘积最大子数组"></a><a href="https://leetcode-cn.com/problems/maximum-product-subarray/">二、乘积最大子数组</a></h3><h4 id="2-1题目"><a href="#2-1题目" class="headerlink" title="2.1题目"></a>2.1题目</h4><p>&ensp;&ensp;&ensp;&ensp;你一个整数数组 <code>nums</code> ，请你找出数组中乘积最大的连续子数组（该子数组中至少包含一个数字），并返回该子数组所对应的乘积。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [2,3,-2,4]</span><br><span class="line">输出: 6</span><br><span class="line">解释: 子数组 [2,3] 有最大乘积 6。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [-2,0,-1]</span><br><span class="line">输出: 0</span><br><span class="line">解释: 结果不能为 2, 因为 [-2,-1] 不是子数组。</span><br></pre></td></tr></table></figure>

<h4 id="2-2思路与代码"><a href="#2-2思路与代码" class="headerlink" title="2.2思路与代码"></a>2.2思路与代码</h4><p>&ensp;&ensp;&ensp;&ensp;与最大子序和类似，本题也要用动态规划。</p>
<p>&ensp;&ensp;&ensp;&ensp;首先假设存在某个最大乘积，然后对数组遍历，在经过每个元素的时候，有以下四种情况：</p>
<ul>
<li>如果该元素为正数：<ul>
<li>  如果到上一个元素为止的最大乘积也是正数，那么直接乘上就好了，同样的最大乘积也会变得更大</li>
<li>  如果到上一个元素为止的最大乘积是负数，那么最大乘积就会变成该元素本身，且连续性被断掉</li>
</ul>
</li>
<li>如果该元素为负数：<ul>
<li>  如果到上一个元素为止的最大乘积也是负数，那么直接乘上就好了，同样的最大乘积也会变得更大</li>
<li>  如果到上一个元素为止的最大乘积是正数，那么最大乘积就会不变，且连续性被断掉</li>
</ul>
</li>
</ul>
<p>&ensp;&ensp;&ensp;&ensp;以上四种情况中说到的最大乘积都是临时最大乘积，每遍历新的元素都需要进行比较来确定真正的最大乘积。</p>
<p>&ensp;&ensp;&ensp;&ensp;如果细心的话就可以发现，如果要得到乘以当前元素以后的最大乘积，需要记录最大乘积，也要记录最小乘积，因为最小值可能翻身变最大值。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxProduct</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> minValue = <span class="number">1</span>, maxValue = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> ans = INT_MIN;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> it = nums.<span class="built_in">begin</span>(); it != nums.<span class="built_in">end</span>(); ++it)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (*it &lt; <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">swap</span>(minValue, maxValue);</span><br><span class="line">            &#125;</span><br><span class="line">            maxValue = <span class="built_in">max</span>((*it) * maxValue, *it);</span><br><span class="line">            minValue = <span class="built_in">min</span>((*it) * minValue, *it);</span><br><span class="line"></span><br><span class="line">            ans = ans &gt; maxValue ? ans : maxValue;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h3 id="三、最短无序连续子数组"><a href="#三、最短无序连续子数组" class="headerlink" title="三、最短无序连续子数组"></a><a href="https://leetcode-cn.com/problems/shortest-unsorted-continuous-subarray/">三、最短无序连续子数组</a></h3><h4 id="3-1题目"><a href="#3-1题目" class="headerlink" title="3.1题目"></a>3.1题目</h4><p>&ensp;&ensp;&ensp;&ensp;给你一个整数数组 <code>nums</code> ，你需要找出一个 <strong>连续子数组</strong> ，如果对这个子数组进行升序排序，那么整个数组都会变为升序排序。</p>
<p>&ensp;&ensp;&ensp;&ensp;请你找出符合题意的 <strong>最短</strong> 子数组，并输出它的长度。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：nums &#x3D; [2,6,4,8,10,9,15]</span><br><span class="line">输出：5</span><br><span class="line">解释：你只需要对 [6, 4, 8, 10, 9] 进行升序排序，那么整个表都会变为升序排序。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：nums &#x3D; [1,2,3,4]</span><br><span class="line">输出：0</span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：nums &#x3D; [1]</span><br><span class="line">输出：0</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li>  <code>1 &lt;= nums.length &lt;= 104</code></li>
<li>  <code>-105 &lt;= nums[i] &lt;= 105</code></li>
</ul>
<p> <strong>进阶：</strong>你可以设计一个时间复杂度为 <code>O(n)</code> 的解决方案吗？</p>
<h4 id="3-2思路与代码"><a href="#3-2思路与代码" class="headerlink" title="3.2思路与代码"></a>3.2思路与代码</h4><p>&ensp;&ensp;&ensp;&ensp;将数组拷贝一份并进行排序，然后我们比较原数组和排序后的数组的元素来决定最左边和最右边不匹配的元素。它们之间的子数组就是要求的最短无序子数组。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findUnsortedSubarray</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">sortedNums</span><span class="params">(nums)</span></span>;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">sort</span>(sortedNums.<span class="built_in">begin</span>(), sortedNums.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] != sortedNums[i])</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            ++count;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (count == nums.<span class="built_in">size</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = nums.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] != sortedNums[i])</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            ++count;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums.<span class="built_in">size</span>() - count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法</category>
        <category>数组</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>数组</tag>
        <tag>子数组</tag>
      </tags>
  </entry>
  <entry>
    <title>数组元素与下标</title>
    <url>/2021/05/15/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E7%BB%84%EF%BC%9A%E5%85%83%E7%B4%A0%E4%B8%8E%E4%B8%8B%E6%A0%87/</url>
    <content><![CDATA[<p>&ensp;&ensp;&ensp;&ensp;在有关数组的算法题中，经常会对数组的元素限定范围，通常为<code>1 ~ nums.size()</code>，这样的题目往往可以把数组元素和其下标联系起来。</p>
<span id="more"></span>

<h3 id="一、寻找重复数"><a href="#一、寻找重复数" class="headerlink" title="一、寻找重复数"></a><a href="https://leetcode-cn.com/problems/find-the-duplicate-number/">一、寻找重复数</a></h3><h4 id="1-1题目"><a href="#1-1题目" class="headerlink" title="1.1题目"></a>1.1题目</h4><p>&ensp;&ensp;&ensp;&ensp;给定一个包含 <code>n + 1</code> 个整数的数组 <code>nums</code> ，其数字都在 <code>1</code> 到 <code>n</code> 之间（包括 <code>1</code> 和 <code>n</code>），可知至少存在一个重复的整数。</p>
<p>&ensp;&ensp;&ensp;&ensp;假设 <code>nums</code> 只有 <strong>一个重复的整数</strong> ，找出 <strong>这个重复的数</strong> 。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：nums &#x3D; [1,3,4,2,2]</span><br><span class="line">输出：2</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：nums &#x3D; [3,1,3,4,2]</span><br><span class="line">输出：3</span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：nums &#x3D; [1,1]</span><br><span class="line">输出：1</span><br></pre></td></tr></table></figure>

<p><strong>示例 4：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：nums &#x3D; [1,1,2]</span><br><span class="line">输出：1</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li>  <code>2 &lt;= n &lt;= 3 * 104</code></li>
<li>  <code>nums.length == n + 1</code></li>
<li>  <code>1 &lt;= nums[i] &lt;= n</code></li>
<li>  <code>nums</code> 中 <strong>只有一个整数</strong> 出现 <strong>两次或多次</strong> ，其余整数均只出现 <strong>一次</strong></li>
</ul>
<h4 id="1-2思路与代码"><a href="#1-2思路与代码" class="headerlink" title="1.2思路与代码"></a>1.2思路与代码</h4><p>&ensp;&ensp;&ensp;&ensp;先说一下自己一开始的思路，本来想先排序，再遍历，但这样明显低估了本题，时间复杂度太大。后来联想到了<a href="https://leetcode-cn.com/problems/first-missing-positive/">leetcode: 41</a>，由于面试时遇到过此题，对其印象深刻，故写了相似的算法：</p>
<ol>
<li> 把数组中的元素<strong>归位</strong>，比如数组中的 1 放在数组第1个位置， 2 放在数组第2个位置……</li>
<li> 当 <code>nums[i] != i + 1</code>时，若<code>nums[i] == nums[nums[i] - 1]</code>，说明<code>nums[i]</code>就是要找的数</li>
<li> 当 <code>nums[i] != i + 1</code>时，若<code>nums[i] != nums[nums[i] - 1]</code>，交换<code>nums[i]</code>和<code>nums[nums[i] - 1]</code></li>
<li> 必须确保再找到目标之前，<code>nums[i] = i + 1</code>（所以交换的过程可能是多个）</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findDuplicate</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] == i + <span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (nums[i] != i + <span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums[i] == nums[nums[i] - <span class="number">1</span>])</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">return</span> nums[i];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="built_in">swap</span>(nums[i], nums[nums[i] - <span class="number">1</span>]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums[nums.<span class="built_in">size</span>() - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>&ensp;&ensp;&ensp;&ensp;运行之后，发现时间复杂度还是太高，仅仅比排序好了一点。看了一眼评论区，在大佬的启发下写了快慢指针的解题方法。</p>
<p>&ensp;&ensp;&ensp;&ensp;快慢指针思想：<code>fast</code> 和 <code>slow</code> 是指针，<code>nums[slow]</code> 表示取指针对应的元素注意 <code>nums</code> 数组中的数字都是在 <code>1</code> 到 <code>n</code> 之间的(在数组中进行游走不会越界)，因为有重复数字的出现，所以这个游走必然是成环的，环的入口就是重复的元素，即按照寻找链表环入口的思路来做。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findDuplicate</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> slow = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> fast = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            slow = nums[slow];</span><br><span class="line">            fast = nums[nums[fast]];</span><br><span class="line">            <span class="keyword">if</span> (slow == fast)</span><br><span class="line">            &#123;</span><br><span class="line">                fast = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">while</span> (nums[slow] != nums[fast])</span><br><span class="line">                &#123;</span><br><span class="line">                    slow = nums[slow];</span><br><span class="line">                    fast = nums[fast];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> nums[slow];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="二、找到所有数组中消失的数字"><a href="#二、找到所有数组中消失的数字" class="headerlink" title="二、找到所有数组中消失的数字"></a><a href="https://leetcode-cn.com/problems/find-all-numbers-disappeared-in-an-array/">二、找到所有数组中消失的数字</a></h3><h4 id="2-1题目"><a href="#2-1题目" class="headerlink" title="2.1题目"></a>2.1题目</h4><p>&ensp;&ensp;&ensp;&ensp;给定一个范围在 1 ≤ a[i] ≤ <em>n</em> ( <em>n</em> = 数组大小 ) 的 整型数组，数组中的元素一些出现了两次，另一些只出现一次。</p>
<p>&ensp;&ensp;&ensp;&ensp;找到所有在 [1, <em>n</em>] 范围之间没有出现在数组中的数字。</p>
<p>&ensp;&ensp;&ensp;&ensp;能在不使用额外空间且时间复杂度为*O(n)*的情况下完成这个任务吗? 你可以假定返回的数组不算在额外空间内。</p>
<p><strong>示例:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入:</span><br><span class="line">[4,3,2,7,8,2,3,1]</span><br><span class="line">输出:</span><br><span class="line">[5,6]</span><br></pre></td></tr></table></figure>

<h4 id="2-2思路与代码"><a href="#2-2思路与代码" class="headerlink" title="2.2思路与代码"></a>2.2思路与代码</h4><p>&ensp;&ensp;&ensp;&ensp;数组的元素有范围，便可以将它们与自己的下标联系起来。这里采用力扣评论区的一个方法：将所有正数作为数组下标，置对应数组值为负值。那么，仍为正数的位置即为（未出现过）消失的数字。</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">举个例子：</span><br><span class="line">原始数组：[4,3,2,7,8,2,3,1]</span><br><span class="line">重置后为：[-4,-3,-2,-7,8,2,-3,-1]</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">findDisappearedNumbers</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            nums[<span class="built_in">abs</span>(nums[i]) - <span class="number">1</span>] = -<span class="built_in">abs</span>(nums[<span class="built_in">abs</span>(nums[i])<span class="number">-1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt; ans;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] &gt; <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                ans.<span class="built_in">push_back</span>(i + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法</category>
        <category>数组</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>数组</tag>
        <tag>下标</tag>
      </tags>
  </entry>
  <entry>
    <title>任务调度器</title>
    <url>/2021/05/15/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E7%BB%84%EF%BC%9A%E4%BB%BB%E5%8A%A1%E8%B0%83%E5%BA%A6%E5%99%A8/</url>
    <content><![CDATA[<h3 id="一、题目"><a href="#一、题目" class="headerlink" title="一、题目"></a>一、题目</h3><p>&ensp;&ensp;&ensp;&ensp;给你一个用字符数组 <code>tasks</code> 表示的 CPU 需要执行的任务列表。其中每个字母表示一种不同种类的任务。任务可以以任意顺序执行，并且每个任务都可以在 1 个单位时间内执行完。在任何一个单位时间，CPU 可以完成一个任务，或者处于待命状态。</p>
<span id="more"></span>

<p>&ensp;&ensp;&ensp;&ensp;然而，两个 <strong>相同种类</strong> 的任务之间必须有长度为整数 <code>n</code> 的冷却时间，因此至少有连续 <code>n</code> 个单位时间内 CPU 在执行不同的任务，或者在待命状态。</p>
<p>&ensp;&ensp;&ensp;&ensp;你需要计算完成所有任务所需要的 <strong>最短时间</strong> 。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：tasks &#x3D; [&quot;A&quot;,&quot;A&quot;,&quot;A&quot;,&quot;B&quot;,&quot;B&quot;,&quot;B&quot;], n &#x3D; 2</span><br><span class="line">输出：8</span><br><span class="line">解释：A -&gt; B -&gt; (待命) -&gt; A -&gt; B -&gt; (待命) -&gt; A -&gt; B</span><br><span class="line">     在本示例中，两个相同类型任务之间必须间隔长度为 n &#x3D; 2 的冷却时间，而执行一个任务只需要一个单位时间，所以中间出现了（待命）状态。 </span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：tasks &#x3D; [&quot;A&quot;,&quot;A&quot;,&quot;A&quot;,&quot;B&quot;,&quot;B&quot;,&quot;B&quot;], n &#x3D; 0</span><br><span class="line">输出：6</span><br><span class="line">解释：在这种情况下，任何大小为 6 的排列都可以满足要求，因为 n &#x3D; 0</span><br><span class="line">[&quot;A&quot;,&quot;A&quot;,&quot;A&quot;,&quot;B&quot;,&quot;B&quot;,&quot;B&quot;]</span><br><span class="line">[&quot;A&quot;,&quot;B&quot;,&quot;A&quot;,&quot;B&quot;,&quot;A&quot;,&quot;B&quot;]</span><br><span class="line">[&quot;B&quot;,&quot;B&quot;,&quot;B&quot;,&quot;A&quot;,&quot;A&quot;,&quot;A&quot;]</span><br><span class="line">...</span><br><span class="line">诸如此类</span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：tasks &#x3D; [&quot;A&quot;,&quot;A&quot;,&quot;A&quot;,&quot;A&quot;,&quot;A&quot;,&quot;A&quot;,&quot;B&quot;,&quot;C&quot;,&quot;D&quot;,&quot;E&quot;,&quot;F&quot;,&quot;G&quot;], n &#x3D; 2</span><br><span class="line">输出：16</span><br><span class="line">解释：一种可能的解决方案是：</span><br><span class="line">     A -&gt; B -&gt; C -&gt; A -&gt; D -&gt; E -&gt; A -&gt; F -&gt; G -&gt; A -&gt; (待命) -&gt; (待命) -&gt; A -&gt; (待命) -&gt; (待命) -&gt; A</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li>  <code>1 &lt;= task.length &lt;= 104</code></li>
<li>  <code>tasks[i]</code> 是大写英文字母</li>
<li>  <code>n</code> 的取值范围为 <code>[0, 100]</code></li>
</ul>
<h3 id="二、思路和代码"><a href="#二、思路和代码" class="headerlink" title="二、思路和代码"></a>二、思路和代码</h3><p>使用公式<code>(everyCharacterCount[0] - 1) * (n + 1) + theMostKinds</code></p>
<ul>
<li>  假设数组 [“A”,”A”,”A”,”B”,”B”,”C”]，n = 2，A的频率最高，记为<code>everyCharacterCount[0] = 3</code>，所以两个<code>A</code>之间必须间隔2个任务，才能满足题意并且是最短时间（两个<code>A</code>的间隔大于2的总时间必然不是最短），因此执行顺序为： A-&gt;X-&gt;X-&gt;A-&gt;X-&gt;X-&gt;A，这里的<code>X</code>表示除了<code>A</code>以外其他字母，或者是待命，不用关心具体是什么，反正用来填充两个<code>A</code>的间隔的。上面执行顺序的规律是： 有<code>count - 1</code>个<code>A</code>，其中每个<code>A</code>需要搭配<code>n</code>个<code>X</code>，再加上最后一个<code>A</code>，所以总时间为 <code>(count - 1) * (n + 1) + 1</code></li>
<li>  要注意可能会出现多个频率相同且都是最高的任务，比如 [“A”,”A”,”A”,”B”,”B”,”B”,”C”,”C”]，所以最后会剩下一个<code>A</code>和一个<code>B</code>，因此最后要加上频率最高的不同任务的个数 <code>theMostKinds</code></li>
<li>  公式算出的值可能会比数组的长度小，如[“A”,”A”,”B”,”B”]，n = 0，此时要取数组的长度</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">leastInterval</span><span class="params">(vector&lt;<span class="keyword">char</span>&gt;&amp; tasks, <span class="keyword">int</span> n)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> tasksNum = tasks.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">everyCharacterCount</span><span class="params">(<span class="number">26</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">char</span>&amp; c : tasks)</span><br><span class="line">        &#123;</span><br><span class="line">            ++everyCharacterCount[c - <span class="string">&#x27;A&#x27;</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">sort</span>(everyCharacterCount.<span class="built_in">rbegin</span>(), everyCharacterCount.<span class="built_in">rend</span>());</span><br><span class="line">        <span class="keyword">int</span> theMostKinds = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (theMostKinds &lt; everyCharacterCount.<span class="built_in">size</span>() &amp;&amp; </span><br><span class="line">                   everyCharacterCount[theMostKinds] == everyCharacterCount[<span class="number">0</span>])</span><br><span class="line">              &#123;</span><br><span class="line">                  ++theMostKinds;</span><br><span class="line">              &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(tasksNum, (everyCharacterCount[<span class="number">0</span>] - <span class="number">1</span>) * (n + <span class="number">1</span>) + theMostKinds);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><a href="https://leetcode-cn.com/problems/task-scheduler/solution/tong-zi-by-popopop/">【任务调度器】C++ 桶子_配图理解 - 任务调度器 - 力扣（LeetCode） (leetcode-cn.com)</a></p>
]]></content>
      <categories>
        <category>算法</category>
        <category>数组</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title>杨辉三角相关</title>
    <url>/2021/05/09/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E5%AD%A6%EF%BC%9A%E6%9D%A8%E8%BE%89%E4%B8%89%E8%A7%92%E7%9B%B8%E5%85%B3/</url>
    <content><![CDATA[<h3 id="一、杨辉三角"><a href="#一、杨辉三角" class="headerlink" title="一、杨辉三角"></a>一、杨辉三角</h3><p>&ensp;&ensp;&ensp;&ensp;杨辉三角，是<a href="https://baike.baidu.com/item/%E4%BA%8C%E9%A1%B9%E5%BC%8F%E7%B3%BB%E6%95%B0/6763242">二项式系数</a>在三角形中的一种几何排列。</p>
<span id="more"></span>

<p><img src="/2021/05/09/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E5%AD%A6%EF%BC%9A%E6%9D%A8%E8%BE%89%E4%B8%89%E8%A7%92%E7%9B%B8%E5%85%B3/1.png" alt="查看源图像"></p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>在写代码时遇到阶乘，要用杨辉三角相关公式，不让时间复杂度太大。</strong></p>
<h3 id="二、例题"><a href="#二、例题" class="headerlink" title="二、例题"></a>二、例题</h3><h4 id="2-1"><a href="#2-1" class="headerlink" title="2.1"></a>2.1</h4><p>&ensp;&ensp;&ensp;&ensp;给定一个非负整数 numRows，生成杨辉三角的前 numRows 行。</p>
<p>&ensp;&ensp;&ensp;&ensp;在杨辉三角中，每个数是它左上方和右上方的数的和。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">示例:</span><br><span class="line">输入: <span class="number">5</span></span><br><span class="line">输出:</span><br><span class="line">[</span><br><span class="line">     [<span class="number">1</span>],</span><br><span class="line">    [<span class="number">1</span>,<span class="number">1</span>],</span><br><span class="line">   [<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>],</span><br><span class="line">  [<span class="number">1</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">1</span>],</span><br><span class="line"> [<span class="number">1</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">4</span>,<span class="number">1</span>]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p>&ensp;&ensp;&ensp;&ensp;代码</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">generate</span>(<span class="keyword">int</span> numRows) </span><br><span class="line">    &#123; </span><br><span class="line">        vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; ans;</span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt; temp;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numRows ; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            temp.<span class="built_in">push_back</span>(<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>; j &lt; i + <span class="number">1</span> ; ++j)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(j &lt; i)   temp.<span class="built_in">push_back</span>(ans[i<span class="number">-1</span>][j]+ans[i<span class="number">-1</span>][j<span class="number">-1</span>]);</span><br><span class="line">                <span class="keyword">if</span>(j == i)  temp.<span class="built_in">push_back</span>(<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            ans.<span class="built_in">push_back</span>(temp);</span><br><span class="line">            temp.<span class="built_in">clear</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h4 id="2-2"><a href="#2-2" class="headerlink" title="2.2"></a>2.2</h4><p>&ensp;&ensp;&ensp;&ensp;给定一个非负索引 <em>k</em>，其中 <em>k</em> ≤ 33，返回杨辉三角的第 <em>k</em> 行。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">示例:</span><br><span class="line">输入: 3</span><br><span class="line">输出: [1,3,3,1]</span><br></pre></td></tr></table></figure>

<p>&ensp;&ensp;&ensp;&ensp;递推式<img src="/2021/05/09/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E5%AD%A6%EF%BC%9A%E6%9D%A8%E8%BE%89%E4%B8%89%E8%A7%92%E7%9B%B8%E5%85%B3/2.png" alt="image-20210307172241629">表明，当前行第 i 项的计算只与上一行第 i-1 项及第 i 项有关。因此我们可以倒着计算当前行，这样计算到第 i 项时，第 i−1 项仍然是上一行的值。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">getRow</span><span class="params">(<span class="keyword">int</span> rowIndex)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">row</span><span class="params">(rowIndex + <span class="number">1</span>)</span></span>;</span><br><span class="line">        row[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= rowIndex; ++i) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &gt; <span class="number">0</span>; --j) </span><br><span class="line">            &#123;</span><br><span class="line">                row[j] += row[j - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> row;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>&ensp;&ensp;&ensp;&ensp;由组合数公式</p>
<p>&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;<img src="/2021/05/09/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E5%AD%A6%EF%BC%9A%E6%9D%A8%E8%BE%89%E4%B8%89%E8%A7%92%E7%9B%B8%E5%85%B3/3.png" alt="image-20210307172802452">     </p>
<p>&ensp;&ensp;&ensp;&ensp;可以得到同一行的相邻组合数的关系</p>
<p>&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;<img src="/2021/05/09/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E5%AD%A6%EF%BC%9A%E6%9D%A8%E8%BE%89%E4%B8%89%E8%A7%92%E7%9B%B8%E5%85%B3/4.png" alt="image-20210307172822607"></p>
<p>&ensp;&ensp;&ensp;&ensp;由于<img src="/2021/05/09/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E5%AD%A6%EF%BC%9A%E6%9D%A8%E8%BE%89%E4%B8%89%E8%A7%92%E7%9B%B8%E5%85%B3/5.png" alt="image-20210307172841470"></p>
<p>&ensp;&ensp;&ensp;&ensp; 利用上述公式我们可以在线性时间计算出第 n 行的所有组合数。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">getRow</span><span class="params">(<span class="keyword">int</span> rowIndex)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">row</span><span class="params">(rowIndex + <span class="number">1</span>)</span></span>;</span><br><span class="line">        row[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= rowIndex; ++i) </span><br><span class="line">        &#123;</span><br><span class="line">            row[i] = <span class="number">1LL</span> * row[i - <span class="number">1</span>] * (rowIndex - i + <span class="number">1</span>) / i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> row;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>&ensp;&ensp;&ensp;&ensp;复杂度分析</p>
<p>&ensp;&ensp;&ensp;&ensp;时间复杂度：O(rowIndex)。</p>
<p>&ensp;&ensp;&ensp;&ensp;空间复杂度：O(1)，不考虑返回值的空间占用。</p>
<h4 id="2-3"><a href="#2-3" class="headerlink" title="2.3"></a>2.3</h4><p>&ensp;&ensp;&ensp;&ensp;小Q有X首长度为A的不同的歌和Y首长度为B的不同的歌，现在小Q想用这些歌组成一个总长度正好为K的歌单，每首歌最多只能在歌单中出现一次，在不考虑歌单内歌曲的先后顺序的情况下，请问有多少种组成歌单的方法。</p>
<p><strong>输入描述:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">每个输入包含一个测试用例。</span><br><span class="line">每个测试用例的第一行包含一个整数，表示歌单的总长度K(1&lt;&#x3D;K&lt;&#x3D;1000)。</span><br><span class="line">接下来的一行包含四个正整数，分别表示歌的第一种长度A(A&lt;&#x3D;10)和数量X(X&lt;&#x3D;100)以及歌的第二种长度B(B&lt;&#x3D;10)和数量Y(Y&lt;&#x3D;100)。保证A不等于B。</span><br></pre></td></tr></table></figure>

<p><strong>输出描述:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输出一个整数,表示组成歌单的方法取模。因为答案可能会很大,输出对1000000007取模的结果。</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">示例1</span><br><span class="line">输入</span><br><span class="line">5</span><br><span class="line">2 3 3 3</span><br><span class="line">输出</span><br><span class="line">9</span><br></pre></td></tr></table></figure>

<p><strong>思路与代码</strong>：</p>
<p>&ensp;&ensp;&ensp;&ensp;选取歌曲的过程即为组合的过程，为了减少时间复杂度，使用杨辉三角的公式。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//核心是计算阶乘</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">int</span> k, a, x, b, y, i, j;</span><br><span class="line">   <span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">   <span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> c[<span class="number">101</span>][<span class="number">101</span>];</span><br><span class="line">   <span class="keyword">while</span>(cin&gt;&gt;k)</span><br><span class="line">   &#123;</span><br><span class="line">       cin &gt;&gt; a &gt;&gt; x &gt;&gt; b &gt;&gt; y;</span><br><span class="line">       c[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">       <span class="comment">//j</span></span><br><span class="line">       <span class="keyword">for</span>( i=<span class="number">1</span>; i &lt;= <span class="number">100</span>; i++)</span><br><span class="line">       &#123;</span><br><span class="line">           c[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">           <span class="keyword">for</span>(j = <span class="number">1</span>; j &lt;= <span class="number">100</span>; j++)</span><br><span class="line">           &#123;</span><br><span class="line">               c[i][j] = (c[i<span class="number">-1</span>][j<span class="number">-1</span>] + c[i<span class="number">-1</span>][j]) % <span class="number">1000000007</span>;</span><br><span class="line">           &#125;</span><br><span class="line">	   &#125;  		</span><br><span class="line">   		</span><br><span class="line">   		<span class="keyword">for</span>(i = <span class="number">0</span>; i &lt;= k /a &amp;&amp; i &lt;= x; i++)</span><br><span class="line">        &#123;</span><br><span class="line">   			<span class="keyword">if</span>( (k - i * a) % b == <span class="number">0</span> &amp;&amp; (k - i * a) / b &lt;= y)</span><br><span class="line">   				count=(count + (c[x][i] * c[y][( k - i * a) / b]) % <span class="number">1000000007</span>) % <span class="number">1000000007</span>;</span><br><span class="line">		&#125;</span><br><span class="line">   		cout &lt;&lt; count &lt;&lt; endl;</span><br><span class="line">   	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法</category>
        <category>数学</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>排列组合</tag>
        <tag>杨辉三角</tag>
      </tags>
  </entry>
  <entry>
    <title>排列组合之组合</title>
    <url>/2021/05/09/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E5%AD%A6%EF%BC%9A%E7%BB%84%E5%90%88/</url>
    <content><![CDATA[<p>&ensp;排列组合子集问题都是用回溯算法解决，解决组合的问题就是解决子集是把符合情况的中间节点加入结果。</p>
<span id="more"></span>

<h3 id="一、-组合"><a href="#一、-组合" class="headerlink" title="一、 组合"></a>一、 组合</h3><p>    给定两个整数 n 和 k，返回 1 … <em>n</em> 中所有可能的 k 个数的组合。</p>
<p><strong>示例:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: n &#x3D; 4, k &#x3D; 2</span><br><span class="line">输出:</span><br><span class="line">[</span><br><span class="line">  [2,4],</span><br><span class="line">  [3,4],</span><br><span class="line">  [2,3],</span><br><span class="line">  [1,2],</span><br><span class="line">  [1,3],</span><br><span class="line">  [1,4],</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">combine</span>(<span class="keyword">int</span> n, <span class="keyword">int</span> k) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (n &lt;= <span class="number">0</span> || k &lt;= <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt; track;</span><br><span class="line">        <span class="built_in">backtrack</span>(n, k, <span class="number">1</span>, track);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">backtrack</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> n, <span class="keyword">const</span> <span class="keyword">int</span> k, <span class="keyword">int</span> start, vector&lt;<span class="keyword">int</span>&gt;&amp; track)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// 到达树的底部</span></span><br><span class="line">        <span class="keyword">if</span> (k == track.<span class="built_in">size</span>()) </span><br><span class="line">        &#123;</span><br><span class="line">            res.<span class="built_in">push_back</span>(track);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 注意 i 从 start 开始递增</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = start; i &lt;= n; i++) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 做选择</span></span><br><span class="line">            track.<span class="built_in">push_back</span>(i);</span><br><span class="line">            <span class="built_in">backtrack</span>(n, k, i + <span class="number">1</span>, track);</span><br><span class="line">            <span class="comment">// 撤销选择</span></span><br><span class="line">            track.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="二、组合总和"><a href="#二、组合总和" class="headerlink" title="二、组合总和"></a>二、组合总和</h3><p>    给定一个<strong>无重复元素</strong>的数组 <code>candidates</code> 和一个目标数 <code>target</code> ，找出 <code>candidates</code> 中所有可以使数字和为 <code>target</code> 的组合。</p>
<p>    <code>candidates</code> 中的数字可以无限制重复被选取。</p>
<p><strong>说明：</strong></p>
<ul>
<li>  所有数字（包括 <code>target</code>）都是正整数。</li>
<li>  解集不能包含重复的组合。 </li>
</ul>
<p><strong>示例 1：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：candidates &#x3D; [2,3,6,7], target &#x3D; 7,</span><br><span class="line">所求解集为：</span><br><span class="line">[</span><br><span class="line">  [7],</span><br><span class="line">  [2,2,3]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：candidates &#x3D; [2,3,5], target &#x3D; 8,</span><br><span class="line">所求解集为：</span><br><span class="line">[</span><br><span class="line">  [2,2,2,2],</span><br><span class="line">  [2,3,3],</span><br><span class="line">  [3,5]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li>  <code>1 &lt;= candidates.length &lt;= 30</code></li>
<li>  <code>1 &lt;= candidates[i] &lt;= 200</code></li>
<li>  <code>candidate</code> 中的每个元素都是独一无二的。</li>
<li>  <code>1 &lt;= target &lt;= 500</code></li>
</ul>
<p><a href="https://leetcode-cn.com/problems/combination-sum/solution/zu-he-zong-he-by-leetcode-solution/">组合总和</a></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; ans;</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">combinationSum</span>(vector&lt;<span class="keyword">int</span>&gt;&amp; candidates, <span class="keyword">int</span> target) </span><br><span class="line">    &#123;</span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt; track;</span><br><span class="line">        <span class="built_in">dfs</span>(candidates, target, track, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; candidates, <span class="keyword">int</span> target, vector&lt;<span class="keyword">int</span>&gt;&amp; track, <span class="keyword">int</span> idx)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (idx == candidates.<span class="built_in">size</span>()) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (target == <span class="number">0</span>) </span><br><span class="line">        &#123;</span><br><span class="line">            ans.<span class="built_in">emplace_back</span>(track);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 直接跳过</span></span><br><span class="line">        <span class="built_in">dfs</span>(candidates, target, track, idx + <span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 选择当前数</span></span><br><span class="line">        <span class="keyword">if</span> (target - candidates[idx] &gt;= <span class="number">0</span>) </span><br><span class="line">        &#123;</span><br><span class="line">            track.<span class="built_in">emplace_back</span>(candidates[idx]);</span><br><span class="line">            <span class="built_in">dfs</span>(candidates, target - candidates[idx], track, idx);</span><br><span class="line">            track.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="三、组合总和-II"><a href="#三、组合总和-II" class="headerlink" title="三、组合总和 II"></a>三、组合总和 II</h3><p>    给定一个数组 <code>candidates</code> 和一个目标数 <code>target</code> ，找出 <code>candidates</code> 中所有可以使数字和为 <code>target</code> 的组合。</p>
<p>    <code>candidates</code> 中的每个数字在每个组合中只能使用一次。</p>
<p><strong>说明：</strong></p>
<ul>
<li>  所有数字（包括目标数）都是正整数。</li>
<li>  解集不能包含重复的组合。 </li>
</ul>
<p><strong>示例 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: candidates &#x3D; [10,1,2,7,6,1,5], target &#x3D; 8,</span><br><span class="line">所求解集为:</span><br><span class="line">[</span><br><span class="line">  [1, 7],</span><br><span class="line">  [1, 2, 5],</span><br><span class="line">  [2, 6],</span><br><span class="line">  [1, 1, 6]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p><a href></a></p>
<p><strong>示例 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: candidates &#x3D; [2,5,2,1,2], target &#x3D; 5,</span><br><span class="line">所求解集为:</span><br><span class="line">[</span><br><span class="line">  [1,2,2],</span><br><span class="line">  [5]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p><a href="https://leetcode-cn.com/problems/combination-sum-ii/solution/zu-he-zong-he-ii-by-leetcode-solution/">组合总和 II - 组合总和 II - 力扣（LeetCode） (leetcode-cn.com)</a></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    vector&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; freq;</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; ans;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; sequence;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> pos, <span class="keyword">int</span> rest)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (rest == <span class="number">0</span>) &#123;</span><br><span class="line">            ans.<span class="built_in">push_back</span>(sequence);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (pos == freq.<span class="built_in">size</span>() || rest &lt; freq[pos].first) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">dfs</span>(pos + <span class="number">1</span>, rest);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> most = <span class="built_in">min</span>(rest / freq[pos].first, freq[pos].second);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= most; ++i) &#123;</span><br><span class="line">            sequence.<span class="built_in">push_back</span>(freq[pos].first);</span><br><span class="line">            <span class="built_in">dfs</span>(pos + <span class="number">1</span>, rest - i * freq[pos].first);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= most; ++i) &#123;</span><br><span class="line">            sequence.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">combinationSum2</span>(vector&lt;<span class="keyword">int</span>&gt;&amp; candidates, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        <span class="built_in">sort</span>(candidates.<span class="built_in">begin</span>(), candidates.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num: candidates) &#123;</span><br><span class="line">            <span class="keyword">if</span> (freq.<span class="built_in">empty</span>() || num != freq.<span class="built_in">back</span>().first) &#123;</span><br><span class="line">                freq.<span class="built_in">emplace_back</span>(num, <span class="number">1</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                ++freq.<span class="built_in">back</span>().second;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">dfs</span>(<span class="number">0</span>, target);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>算法</category>
        <category>数学</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>leetcode</tag>
        <tag>数学</tag>
        <tag>回溯</tag>
        <tag>排列组合</tag>
      </tags>
  </entry>
  <entry>
    <title>排列组合之子集</title>
    <url>/2021/05/09/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E5%AD%A6%EF%BC%9A%E5%AD%90%E9%9B%86/</url>
    <content><![CDATA[<p>&ensp;&ensp;排列组合子集问题都是用回溯算法解决，解决子集的问题与解决排列大致相同。</p>
<span id="more"></span>

<h3 id="一、子集"><a href="#一、子集" class="headerlink" title="一、子集"></a>一、子集</h3><h4 id="1-1题目"><a href="#1-1题目" class="headerlink" title="1.1题目"></a>1.1题目</h4><p>&ensp;&ensp;&ensp;&ensp;给你一个整数数组 <code>nums</code> ，数组中的元素 <strong>互不相同</strong> 。返回该数组所有可能的子集（幂集）。</p>
<p>解集 <strong>不能</strong> 包含重复的子集。你可以按 <strong>任意顺序</strong> 返回解集。</p>
<p> <strong>示例 1：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：nums &#x3D; [1,2,3]</span><br><span class="line">输出：[[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：nums &#x3D; [0]</span><br><span class="line">输出：[[],[0]]</span><br></pre></td></tr></table></figure>

<p> <strong>提示：</strong></p>
<ul>
<li>  <code>1 &lt;= nums.length &lt;= 10</code></li>
<li>  <code>-10 &lt;= nums[i] &lt;= 10</code></li>
<li>  <code>nums</code> 中的所有元素 <strong>互不相同</strong></li>
</ul>
<h4 id="1-2思路与代码"><a href="#1-2思路与代码" class="headerlink" title="1.2思路与代码"></a>1.2思路与代码</h4><p>&ensp;&ensp;&ensp;&ensp;照着《排列组合之排列》的基本思路，改变一下代码：</p>
<ul>
<li>  每一步都要加入<code>ans</code></li>
<li>  递归的时候改变起点</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; ans;</span><br><span class="line"></span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">subsets</span>(vector&lt;<span class="keyword">int</span>&gt;&amp; nums) </span><br><span class="line">    &#123;</span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt; track;</span><br><span class="line">        <span class="built_in">backtrack</span>(nums, <span class="number">0</span>, track);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">backtrack</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> start, vector&lt;<span class="keyword">int</span>&gt;&amp; track)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        ans.<span class="built_in">push_back</span>(track);</span><br><span class="line">        <span class="comment">// 注意 i 从 start 开始递增</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = start; i &lt; nums.<span class="built_in">size</span>(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 做选择</span></span><br><span class="line">            track.<span class="built_in">push_back</span>(nums[i]);</span><br><span class="line">            <span class="comment">// 回溯</span></span><br><span class="line">            <span class="built_in">backtrack</span>(nums, i + <span class="number">1</span>, track);</span><br><span class="line">            <span class="comment">// 撤销选择</span></span><br><span class="line">            track.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="二、子集-II"><a href="#二、子集-II" class="headerlink" title="二、子集 II"></a>二、子集 II</h3><p>&ensp;&ensp;&ensp;&ensp;给你一个整数数组 <code>nums</code> ，其中可能包含重复元素，请你返回该数组所有可能的子集（幂集）。</p>
<p>&ensp;&ensp;&ensp;&ensp;解集 <strong>不能</strong> 包含重复的子集。返回的解集中，子集可以按 <strong>任意顺序</strong> 排列。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：nums &#x3D; [1,2,2]</span><br><span class="line">输出：[[],[1],[1,2],[1,2,2],[2],[2,2]]</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：nums &#x3D; [0]</span><br><span class="line">输出：[[],[0]]</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li>  <code>1 &lt;= nums.length &lt;= 10</code></li>
<li>  <code>-10 &lt;= nums[i] &lt;= 10</code></li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    set&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; ans;</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">subsetsWithDup</span>(vector&lt;<span class="keyword">int</span>&gt;&amp; nums) </span><br><span class="line">    &#123;</span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt; track;</span><br><span class="line">        <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line">        <span class="built_in">backtrack</span>(nums, <span class="number">0</span>, track);</span><br><span class="line">        vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">res</span>(ans.<span class="built_in">begin</span>(), ans.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">backtrack</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> start, vector&lt;<span class="keyword">int</span>&gt;&amp; track)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        ans.<span class="built_in">insert</span>(track);</span><br><span class="line">        <span class="comment">// 注意 i 从 start 开始递增</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = start; i &lt; nums.<span class="built_in">size</span>(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 做选择</span></span><br><span class="line">            track.<span class="built_in">push_back</span>(nums[i]);</span><br><span class="line">            <span class="comment">// 回溯</span></span><br><span class="line">            <span class="built_in">backtrack</span>(nums, i + <span class="number">1</span>, track);</span><br><span class="line">            <span class="comment">// 撤销选择</span></span><br><span class="line">            track.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><a href="https://mp.weixin.qq.com/s?__biz=MzAxODQxMDM0Mw==&mid=2247485007&idx=1&sn=ceb42ba2f341af34953d158358c61f7c&chksm=9bd7f847aca071517fe0889d2679ead78b40caf6978ebc1d3d8355d6693acc7ec3aca60823f0&scene=21#wechat_redirect">回溯算法团灭排列/组合/子集问题</a></p>
]]></content>
      <categories>
        <category>算法</category>
        <category>数学</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>leetcode</tag>
        <tag>数学</tag>
        <tag>回溯</tag>
        <tag>排列组合</tag>
      </tags>
  </entry>
  <entry>
    <title>排列组合之排列</title>
    <url>/2021/05/09/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E5%AD%A6%EF%BC%9A%E6%8E%92%E5%88%97/</url>
    <content><![CDATA[<p>&ensp;&ensp;&ensp;&ensp;排列组合子集问题都是用回溯算法解决，下面以<code>leetcode</code>中相关的习题为例进行分析。</p>
<span id="more"></span>

<h3 id="一、-全排列"><a href="#一、-全排列" class="headerlink" title="一、 全排列"></a>一、 全排列</h3><h4 id="1-1题目"><a href="#1-1题目" class="headerlink" title="1.1题目"></a>1.1题目</h4><p>&ensp;&ensp;&ensp;&ensp;给定一个 <strong>没有重复</strong> 数字的序列，返回其所有可能的全排列。</p>
<p><strong>示例:</strong></p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">输入: [1,2,3]</span><br><span class="line">输出:</span><br><span class="line">[</span><br><span class="line">  [1,2,3],</span><br><span class="line">  [1,3,2],</span><br><span class="line">  [2,1,3],</span><br><span class="line">  [2,3,1],</span><br><span class="line">  [3,1,2],</span><br><span class="line">  [3,2,1]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<h4 id="1-2思路与代码"><a href="#1-2思路与代码" class="headerlink" title="1.2思路与代码"></a>1.2思路与代码</h4><p>大体思路如下：</p>
<ul>
<li>  第一步：从n个数中选取第一个排列的第一个元素，如1；</li>
<li>  第一步：从n个数中选取第一个排列的第二个元素，如2；</li>
<li>  ……</li>
<li>  第n步：从n个数中选取第一个排列的第n个元素，如n；</li>
</ul>
<p>&ensp;&ensp;&ensp;&ensp;当然不能选重复的。到此，第一个排列已经选出来了。那么第二个排列怎么选呢？</p>
<p>&ensp;&ensp;&ensp;&ensp;上一个排列执行到第n步后，这个函数不再执行，进行回溯，那么就会回到第n-1步，这时前面的n-1个数都已经选过了，所以第n-1步选择的就会是n了，然后第n步选择的就是n-1。</p>
<p>&ensp;&ensp;&ensp;&ensp;所以第一个排列是：1 2 3 。。。n-1 n；</p>
<p>&ensp;&ensp;&ensp;&ensp;第二个是：1 2 3 。。。n n-1；</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; ans;</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">permute</span>(vector&lt;<span class="keyword">int</span>&gt;&amp; nums) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums.<span class="built_in">size</span>() == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> ans;</span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt; track;</span><br><span class="line">        <span class="built_in">backtrack</span>(nums, track);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">backtrack</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, vector&lt;<span class="keyword">int</span>&gt;&amp; track)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(track.<span class="built_in">size</span>() == nums.<span class="built_in">size</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            ans.<span class="built_in">push_back</span>(track);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 做选择</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">find</span>(track.<span class="built_in">begin</span>(), track.<span class="built_in">end</span>(), nums[i]) != track.<span class="built_in">end</span>())</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 回溯</span></span><br><span class="line">            track.<span class="built_in">push_back</span>(nums[i]);</span><br><span class="line">            <span class="built_in">backtrack</span>(nums, track);</span><br><span class="line">            <span class="comment">// 撤销选择</span></span><br><span class="line">            track.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<img src="/2021/05/09/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E5%AD%A6%EF%BC%9A%E6%8E%92%E5%88%97/1.png" alt="image-20210508234947950" style="zoom:50%;">

<p>&ensp;&ensp;&ensp;&ensp;还有另外一种实现的方法，有着很好的用处，可以方便的解决一些搜索的题目。思路就是我选择了一个元素，那么就把这个元素交换到当前这个位置，就不用开一个数组标记了。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; ans;</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">permute</span>(vector&lt;<span class="keyword">int</span>&gt;&amp; nums) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums.<span class="built_in">size</span>() == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> ans;</span><br><span class="line">        <span class="built_in">backtrack</span>(nums, <span class="number">0</span>, nums.<span class="built_in">size</span>());</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">backtrack</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> start, <span class="keyword">const</span> <span class="keyword">int</span> size)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(start == size)</span><br><span class="line">        &#123;</span><br><span class="line">            ans.<span class="built_in">push_back</span>(nums);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">            </span><br><span class="line">        <span class="comment">// 注意 i 从 start 开始递增</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = start; i &lt; size; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 做选择</span></span><br><span class="line">            <span class="built_in">swap</span>(nums[i], nums[start]);</span><br><span class="line">            <span class="comment">// 递归</span></span><br><span class="line">            <span class="built_in">backtrack</span>(nums, start + <span class="number">1</span>, size);</span><br><span class="line">            <span class="comment">// 撤销选择</span></span><br><span class="line">            <span class="built_in">swap</span>(nums[i], nums[start]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="二、全排列-II"><a href="#二、全排列-II" class="headerlink" title="二、全排列 II"></a>二、全排列 II</h3><h4 id="2-1题目"><a href="#2-1题目" class="headerlink" title="2.1题目"></a>2.1题目</h4><p>&ensp;&ensp;&ensp;&ensp;给定一个可包含重复数字的序列 <code>nums</code> ，<strong>按任意顺序</strong> 返回所有不重复的全排列。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：nums &#x3D; [1,1,2]</span><br><span class="line">输出：</span><br><span class="line">[[1,1,2],</span><br><span class="line"> [1,2,1],</span><br><span class="line"> [2,1,1]]</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：nums &#x3D; [1,2,3]</span><br><span class="line">输出：[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li>  <code>1 &lt;= nums.length &lt;= 8</code></li>
<li>  <code>-10 &lt;= nums[i] &lt;= 10</code></li>
</ul>
<h4 id="2-2思路与代码"><a href="#2-2思路与代码" class="headerlink" title="2.2思路与代码"></a>2.2思路与代码</h4><p>&ensp;&ensp;&ensp;&ensp;基本算法不需过多改变，可以增加一个查询判断即可；也可以巧用数据结构以简化代码，既然涉及到去重，那么用<code>set</code>代替<code>vector</code>即可。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    set&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">permuteUnique</span>(vector&lt;<span class="keyword">int</span>&gt;&amp; nums) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">backtrack</span>(nums, <span class="number">0</span>, nums.<span class="built_in">size</span>());</span><br><span class="line">        vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">ans</span>(res.<span class="built_in">begin</span>(), res.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">backtrack</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> start, <span class="keyword">const</span> <span class="keyword">int</span> size)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(start == size)</span><br><span class="line">        &#123;</span><br><span class="line">            res.<span class="built_in">insert</span>(nums);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">            </span><br><span class="line">        <span class="comment">// 注意 i 从 start 开始递增</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = start; i &lt; size; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 做选择</span></span><br><span class="line">            <span class="built_in">swap</span>(nums[i], nums[start]);</span><br><span class="line">            <span class="comment">// 递归</span></span><br><span class="line">            <span class="built_in">backtrack</span>(nums, start + <span class="number">1</span>, size);</span><br><span class="line">            <span class="comment">// 撤销选择</span></span><br><span class="line">            <span class="built_in">swap</span>(nums[i], nums[start]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><a href="https://mp.weixin.qq.com/s?__biz=MzAxODQxMDM0Mw==&mid=2247485007&idx=1&sn=ceb42ba2f341af34953d158358c61f7c&chksm=9bd7f847aca071517fe0889d2679ead78b40caf6978ebc1d3d8355d6693acc7ec3aca60823f0&scene=21#wechat_redirect">回溯算法团灭排列/组合/子集问题</a></p>
<p><a href="https://mp.weixin.qq.com/s?__biz=MzAxODQxMDM0Mw==&mid=2247484709&idx=1&sn=1c24a5c41a5a255000532e83f38f2ce4&chksm=9bd7fb2daca0723be888b30345e2c5e64649fc31a00b05c27a0843f349e2dd9363338d0dac61&scene=21#wechat_redirect">回溯算法详解（修订版） (qq.com)</a></p>
]]></content>
      <categories>
        <category>算法</category>
        <category>数学</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>leetcode</tag>
        <tag>数学</tag>
        <tag>回溯</tag>
        <tag>排列组合</tag>
      </tags>
  </entry>
  <entry>
    <title>STL_综合案例</title>
    <url>/2021/05/07/STL%EF%BC%9A%E7%BB%BC%E5%90%88%E6%A1%88%E4%BE%8B/</url>
    <content><![CDATA[<h3 id="学校演讲比赛"><a href="#学校演讲比赛" class="headerlink" title="学校演讲比赛"></a>学校演讲比赛</h3><p>&ensp;&ensp;&ensp;&ensp;1）某市举行一场演讲比赛，共有24个人参加，按参加顺序设置参赛号。比赛共三轮，前两轮为淘汰赛，第三轮为决赛。</p>
<span id="more"></span>

<p>&ensp;&ensp;&ensp;&ensp;2）比赛方式：分组比赛<br>&ensp;&ensp;&ensp;&ensp;    第一轮分为4个小组，根据参赛号顺序依次划分，比如100-105为一组，106-111为第二组，依次类推，每组6个人，每人分别按参赛号顺序演讲。<br>当小组演讲完后，淘汰组内排名最后的三个选手，然后继续下一个小组的比赛。<br>    &ensp;&ensp;&ensp;&ensp;第二轮分为2个小组，每组6人，每个人分别按参赛号顺序演讲。当小组完后，淘汰组内排名最后的三个选手，然后继续下一个小组的比赛。<br>    &ensp;&ensp;&ensp;&ensp;第三轮只剩下6个人，本轮为赛决，选出前三名。<br>    &ensp;&ensp;&ensp;&ensp;选手每次要随机分组，进行比赛。<br>&ensp;&ensp;&ensp;&ensp;3）比赛评分：10个评委打分，去除最低、最高分，求平均分<br>    &ensp;&ensp;&ensp;&ensp;每个选手演讲完由10个评委分别打分。该选手的最终得分是去掉一个最高分和一个最低分，求得剩下的8个成绩的平均分。选手的名次按得分降序排列，<br>若得分一样，按参赛号升序排名。</p>
<p>&ensp;&ensp;&ensp;&ensp;用STL编程，求解一下问题</p>
<ol>
<li>请打印出所有选手的名字与参赛号，并以参赛号的升序排列。</li>
<li>打印每一轮比赛前，分组情况</li>
<li>打印每一轮比赛后，小组晋级名单</li>
<li>打印决赛前三名，选手名称、成绩。</li>
</ol>
<h3 id="main-cpp文件"><a href="#main-cpp文件" class="headerlink" title="main.cpp文件"></a>main.cpp文件</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;manager.h&quot;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Manager m;</span><br><span class="line">	m.<span class="built_in">show</span>();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Speaker-h文件"><a href="#Speaker-h文件" class="headerlink" title="Speaker.h文件"></a>Speaker.h文件</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Speaker</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">setName</span><span class="params">(string s)</span></span>;</span><br><span class="line">	<span class="function">string <span class="title">getName</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">setScore</span><span class="params">(<span class="keyword">int</span> n)</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">getScore</span><span class="params">(<span class="keyword">int</span> n)</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">setNumber</span><span class="params">(<span class="keyword">int</span> n)</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">getNumber</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	string name;</span><br><span class="line">	<span class="keyword">int</span> number;</span><br><span class="line">	vector&lt;<span class="keyword">int</span>&gt;scores;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h3 id="Speaker-cpp文件"><a href="#Speaker-cpp文件" class="headerlink" title="Speaker.cpp文件"></a>Speaker.cpp文件</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;Speaker.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Speaker::setName</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">this</span>-&gt;name = s;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">string <span class="title">Speaker::getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">this</span>-&gt;name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Speaker::setScore</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;<span class="comment">//n是第n+1次成绩</span></span><br><span class="line">	<span class="keyword">this</span>-&gt;scores.<span class="built_in">push_back</span>(n);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Speaker::getScore</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (n &lt; <span class="number">0</span> || n&gt;<span class="number">2</span>)</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;error&quot;</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">this</span>-&gt;scores[n];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Speaker::setNumber</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">this</span>-&gt;number = n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Speaker::getNumber</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">this</span>-&gt;number;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="Manager-h文件"><a href="#Manager-h文件" class="headerlink" title="Manager.h文件"></a>Manager.h文件</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SPEAKER_NUMBER 24</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deque&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;Speaker.h&quot;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Manager</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">create_speaker</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">divid_speaker</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">first_game</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">second_game</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">final_game</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	vector&lt;Speaker&gt; first_vector;</span><br><span class="line">	vector&lt;Speaker&gt; second_vector;</span><br><span class="line">	vector&lt;Speaker&gt; third_vector;</span><br><span class="line">	multimap&lt;<span class="keyword">int</span>,Speaker&gt; first_groups;</span><br><span class="line">	multimap&lt;<span class="keyword">int</span>, Speaker&gt; second_groups;</span><br><span class="line">	multimap&lt;<span class="keyword">int</span>, Speaker&gt; third_groups;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="Manager-cpp文件"><a href="#Manager-cpp文件" class="headerlink" title="Manager.cpp文件"></a>Manager.cpp文件</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;Manager.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get_avg_score</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	deque&lt;<span class="keyword">int</span>&gt;score_list;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">		<span class="keyword">int</span> score = <span class="built_in">rand</span>() % <span class="number">61</span> + <span class="number">40</span>;</span><br><span class="line">		score_list.<span class="built_in">push_back</span>(score);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">sort</span>(score_list.<span class="built_in">begin</span>(), score_list.<span class="built_in">end</span>());</span><br><span class="line">	score_list.<span class="built_in">pop_back</span>();</span><br><span class="line">	score_list.<span class="built_in">pop_front</span>();</span><br><span class="line">	<span class="keyword">int</span> total_score = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (deque&lt;<span class="keyword">int</span>&gt;::iterator it = score_list.<span class="built_in">begin</span>(); it != score_list.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">		total_score += (*it);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> total_score / score_list.<span class="built_in">size</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print_info_after_game</span><span class="params">(multimap&lt;<span class="keyword">int</span>, Speaker&gt;::iterator p,<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;姓名:&quot;</span> &lt;&lt; (*p).second.<span class="built_in">getName</span>()</span><br><span class="line">		&lt;&lt; <span class="string">&quot;   编号：&quot;</span> &lt;&lt; (*p).second.<span class="built_in">getNumber</span>()</span><br><span class="line">		&lt;&lt; <span class="string">&quot;   组号：&quot;</span> &lt;&lt; (*p).first</span><br><span class="line">		&lt;&lt; <span class="string">&quot;   分数：&quot;</span> &lt;&lt; (*p).second.<span class="built_in">getScore</span>(n)</span><br><span class="line">		&lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">divide_and_print</span><span class="params">(vector&lt;Speaker&gt; &amp;v, multimap&lt;<span class="keyword">int</span>, Speaker&gt; &amp;m)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> flag = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span> (vector&lt;Speaker&gt;::iterator it = v.<span class="built_in">begin</span>(); it != v.<span class="built_in">end</span>(); ) &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">6</span>; j++, it++) &#123;</span><br><span class="line">			m.<span class="built_in">insert</span>(<span class="built_in">make_pair</span>(flag, *it));</span><br><span class="line">		&#125;</span><br><span class="line">		flag++;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;第二次分组：&quot;</span> &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">for</span> (multimap&lt;<span class="keyword">int</span>, Speaker&gt;::iterator p = m.<span class="built_in">begin</span>(); p != m.<span class="built_in">end</span>(); p++) &#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;姓名:&quot;</span> &lt;&lt; (*p).second.<span class="built_in">getName</span>() &lt;&lt; <span class="string">&quot;   编号：&quot;</span> &lt;&lt; (*p).second.<span class="built_in">getNumber</span>() &lt;&lt; <span class="string">&quot;   组号：&quot;</span> &lt;&lt; (*p).first &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print_info_after_game</span><span class="params">(multimap&lt;<span class="keyword">int</span>, Speaker&gt; &amp;m,vector&lt;Speaker&gt; &amp;v)</span> </span>&#123;	</span><br><span class="line">	<span class="keyword">for</span> (multimap&lt;<span class="keyword">int</span>, Speaker&gt;::iterator p = m.<span class="built_in">begin</span>(); p != m.<span class="built_in">end</span>(); p++) &#123;</span><br><span class="line">		<span class="built_in">print_info_after_game</span>(p, <span class="number">0</span>);</span><br><span class="line">		v.<span class="built_in">push_back</span>((*p).second);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Manager::create_speaker</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	string name_seed = <span class="string">&quot;ABCDEFGHIJKLMNOPQRSTUVWXYZ&quot;</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; SPEAKER_NUMBER; i++) &#123;</span><br><span class="line"></span><br><span class="line">		Speaker speaker;</span><br><span class="line">		string tmp = name_seed.<span class="built_in">substr</span>(i, <span class="number">1</span>);</span><br><span class="line">		speaker.<span class="built_in">setName</span>(<span class="string">&quot;选手&quot;</span> + tmp);</span><br><span class="line">		<span class="keyword">this</span>-&gt;first_vector.<span class="built_in">push_back</span>(speaker);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">compare</span><span class="params">(Speaker &amp;s1,Speaker &amp;s2)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> s1.<span class="built_in">getNumber</span>() &lt; s2.<span class="built_in">getNumber</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Manager::divid_speaker</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">//随机分配编号</span></span><br><span class="line">	<span class="built_in">random_shuffle</span>(<span class="keyword">this</span>-&gt;first_vector.<span class="built_in">begin</span>(), <span class="keyword">this</span>-&gt;first_vector.<span class="built_in">end</span>()); </span><br><span class="line">	<span class="keyword">int</span> ij = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (vector&lt;Speaker&gt;::iterator it = <span class="keyword">this</span>-&gt;first_vector.<span class="built_in">begin</span>(); it != <span class="keyword">this</span>-&gt;first_vector.<span class="built_in">end</span>(); ij++,it++) &#123;</span><br><span class="line">		<span class="keyword">this</span>-&gt;first_vector[ij].<span class="built_in">setNumber</span>(ij+<span class="number">100</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">sort</span>(<span class="keyword">this</span>-&gt;first_vector.<span class="built_in">begin</span>(),<span class="keyword">this</span>-&gt;first_vector.<span class="built_in">end</span>(),compare);</span><br><span class="line">	<span class="built_in">divide_and_print</span>(<span class="keyword">this</span>-&gt;first_vector, <span class="keyword">this</span>-&gt;first_groups);	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">compare_score</span><span class="params">(Speaker&amp; s1, Speaker&amp; s2)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> s1.<span class="built_in">getScore</span>(<span class="number">0</span>) &gt; s2.<span class="built_in">getScore</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Manager::first_game</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">srand</span>(<span class="built_in">time</span>(<span class="literal">nullptr</span>));</span><br><span class="line">	<span class="keyword">for</span> (multimap&lt;<span class="keyword">int</span>, Speaker&gt;::iterator p = <span class="keyword">this</span>-&gt;first_groups.<span class="built_in">begin</span>(); p != <span class="keyword">this</span>-&gt;first_groups.<span class="built_in">end</span>(); p++) &#123;</span><br><span class="line">		<span class="comment">//cout &lt;&lt; &quot;姓名:&quot; &lt;&lt; (*p).second.getName() &lt;&lt; &quot;   编号：&quot; &lt;&lt; (*p).second.getNumber() &lt;&lt; &quot;   组号：&quot; &lt;&lt; (*p).first &lt;&lt; endl;</span></span><br><span class="line">		<span class="keyword">int</span> avg_score = <span class="built_in">get_avg_score</span>();</span><br><span class="line">		(*p).second.<span class="built_in">setScore</span>(avg_score);</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;第一次比赛后：&quot;</span> &lt;&lt; endl;</span><br><span class="line">	<span class="built_in">print_info_after_game</span>(<span class="keyword">this</span>-&gt;first_groups, <span class="keyword">this</span>-&gt;second_vector);</span><br><span class="line">		</span><br><span class="line">	<span class="comment">//先按分数排序，再去掉后一半，再按编号排序</span></span><br><span class="line">	<span class="built_in">sort</span>(<span class="keyword">this</span>-&gt;second_vector.<span class="built_in">begin</span>(),<span class="keyword">this</span>-&gt;second_vector.<span class="built_in">end</span>(),compare_score);</span><br><span class="line">	<span class="keyword">this</span>-&gt;second_vector.<span class="built_in">erase</span>(<span class="keyword">this</span>-&gt;second_vector.<span class="built_in">begin</span>()+<span class="number">12</span>,<span class="keyword">this</span>-&gt;second_vector.<span class="built_in">end</span>());</span><br><span class="line">	<span class="built_in">sort</span>(<span class="keyword">this</span>-&gt;second_vector.<span class="built_in">begin</span>(), <span class="keyword">this</span>-&gt;second_vector.<span class="built_in">end</span>(), compare);</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;第一次比赛后晋级名单:&quot;</span> &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">for</span> (vector&lt;Speaker&gt;::iterator it = <span class="keyword">this</span>-&gt;second_vector.<span class="built_in">begin</span>(); it != <span class="keyword">this</span>-&gt;second_vector.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">		cout &lt;&lt; (*it).<span class="built_in">getName</span>() &lt;&lt; <span class="string">&quot;  &quot;</span>&lt;&lt;(*it).<span class="built_in">getNumber</span>()&lt;&lt;endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">divide_and_print</span>(<span class="keyword">this</span>-&gt;second_vector, <span class="keyword">this</span>-&gt;second_groups);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">compare_score_second</span><span class="params">(Speaker&amp; s1, Speaker&amp; s2)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> s1.<span class="built_in">getScore</span>(<span class="number">1</span>) &gt; s2.<span class="built_in">getScore</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Manager::second_game</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">srand</span>(<span class="built_in">time</span>(<span class="literal">nullptr</span>));</span><br><span class="line">	<span class="keyword">for</span> (multimap&lt;<span class="keyword">int</span>, Speaker&gt;::iterator p = <span class="keyword">this</span>-&gt;second_groups.<span class="built_in">begin</span>(); p != <span class="keyword">this</span>-&gt;second_groups.<span class="built_in">end</span>(); p++) &#123;</span><br><span class="line">		<span class="comment">//cout &lt;&lt; &quot;姓名:&quot; &lt;&lt; (*p).second.getName() &lt;&lt; &quot;   编号：&quot; &lt;&lt; (*p).second.getNumber() &lt;&lt; &quot;   组号：&quot; &lt;&lt; (*p).first &lt;&lt; endl;</span></span><br><span class="line">		<span class="keyword">int</span> avg_score = <span class="built_in">get_avg_score</span>();</span><br><span class="line">		(*p).second.<span class="built_in">setScore</span>(avg_score);</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;第二次比赛后：&quot;</span> &lt;&lt; endl;</span><br><span class="line">	<span class="built_in">print_info_after_game</span>(<span class="keyword">this</span>-&gt;second_groups, <span class="keyword">this</span>-&gt;third_vector);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//先按分数排序，再去掉后一半，再按编号排序</span></span><br><span class="line">	<span class="built_in">sort</span>(<span class="keyword">this</span>-&gt;third_vector.<span class="built_in">begin</span>(), <span class="keyword">this</span>-&gt;third_vector.<span class="built_in">end</span>(), compare_score_second);</span><br><span class="line">	<span class="keyword">this</span>-&gt;third_vector.<span class="built_in">erase</span>(<span class="keyword">this</span>-&gt;third_vector.<span class="built_in">begin</span>() + <span class="number">6</span>, <span class="keyword">this</span>-&gt;third_vector.<span class="built_in">end</span>());</span><br><span class="line">	<span class="built_in">sort</span>(<span class="keyword">this</span>-&gt;third_vector.<span class="built_in">begin</span>(), <span class="keyword">this</span>-&gt;third_vector.<span class="built_in">end</span>(), compare);</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;第二次比赛后晋级名单:&quot;</span> &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">for</span> (vector&lt;Speaker&gt;::iterator it = <span class="keyword">this</span>-&gt;third_vector.<span class="built_in">begin</span>(); it != <span class="keyword">this</span>-&gt;third_vector.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">		cout &lt;&lt; (*it).<span class="built_in">getName</span>() &lt;&lt; <span class="string">&quot;  &quot;</span> &lt;&lt; (*it).<span class="built_in">getNumber</span>() &lt;&lt; endl;</span><br><span class="line">	&#125;	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">compare_score_third</span><span class="params">(Speaker&amp; s1, Speaker&amp; s2)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> s1.<span class="built_in">getScore</span>(<span class="number">2</span>) &gt; s2.<span class="built_in">getScore</span>(<span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Manager::final_game</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">srand</span>(<span class="built_in">time</span>(<span class="literal">nullptr</span>));</span><br><span class="line">	<span class="keyword">for</span> (vector&lt;Speaker&gt;::iterator p = <span class="keyword">this</span>-&gt;third_vector.<span class="built_in">begin</span>(); p != <span class="keyword">this</span>-&gt;third_vector.<span class="built_in">end</span>(); p++) &#123;</span><br><span class="line">		<span class="keyword">int</span> avg_score = <span class="built_in">get_avg_score</span>();</span><br><span class="line">		(*p).<span class="built_in">setScore</span>(avg_score);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;第三次比赛后：&quot;</span> &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">for</span> (vector&lt;Speaker&gt;::iterator p = <span class="keyword">this</span>-&gt;third_vector.<span class="built_in">begin</span>(); p != <span class="keyword">this</span>-&gt;third_vector.<span class="built_in">end</span>(); p++) &#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;姓名:&quot;</span> &lt;&lt; (*p).<span class="built_in">getName</span>()&lt;&lt; <span class="string">&quot;   编号：&quot;</span> &lt;&lt; (*p).<span class="built_in">getNumber</span>()&lt;&lt; <span class="string">&quot;   分数：&quot;</span> &lt;&lt; (*p).<span class="built_in">getScore</span>(<span class="number">2</span>)	&lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//先按分数排序，再去掉后一半，再按编号排序</span></span><br><span class="line">	<span class="built_in">sort</span>(<span class="keyword">this</span>-&gt;third_vector.<span class="built_in">begin</span>(), <span class="keyword">this</span>-&gt;third_vector.<span class="built_in">end</span>(), compare_score_third);</span><br><span class="line">	<span class="keyword">this</span>-&gt;third_vector.<span class="built_in">erase</span>(<span class="keyword">this</span>-&gt;third_vector.<span class="built_in">begin</span>() + <span class="number">3</span>, <span class="keyword">this</span>-&gt;third_vector.<span class="built_in">end</span>());</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;前三名名单:&quot;</span> &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">for</span> (vector&lt;Speaker&gt;::iterator it = <span class="keyword">this</span>-&gt;third_vector.<span class="built_in">begin</span>(); it != <span class="keyword">this</span>-&gt;third_vector.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;姓名:&quot;</span> &lt;&lt; (*it).<span class="built_in">getName</span>() &lt;&lt; <span class="string">&quot;   编号：&quot;</span>&lt;&lt; (*it).<span class="built_in">getNumber</span>() &lt;&lt; <span class="string">&quot;   分数：&quot;</span> &lt;&lt;(*it).<span class="built_in">getScore</span>(<span class="number">2</span>)&lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Manager::show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">this</span>-&gt;<span class="built_in">create_speaker</span>();</span><br><span class="line">	<span class="keyword">this</span>-&gt;<span class="built_in">divid_speaker</span>();</span><br><span class="line">	<span class="keyword">this</span>-&gt;<span class="built_in">first_game</span>();</span><br><span class="line">	<span class="keyword">this</span>-&gt;<span class="built_in">second_game</span>();</span><br><span class="line">	<span class="keyword">this</span>-&gt;<span class="built_in">final_game</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>C++</category>
        <category>STL</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>STL</tag>
        <tag>STL案例</tag>
      </tags>
  </entry>
  <entry>
    <title>STL_员工分组案例</title>
    <url>/2021/05/07/STL%EF%BC%9A%E5%91%98%E5%B7%A5%E5%88%86%E7%BB%84%E6%A1%88%E4%BE%8B/</url>
    <content><![CDATA[<p>公司今天招聘了 5 个员工， 5 名员工进入公司之后，需要指派员工在那个部门工作</p>
<ul>
<li>人员信息有: 姓名 年龄 电话 工资等组成</li>
<li>通过 Multimap 进行信息的插入 保存 显示</li>
<li>分部门显示员工信息 显示全部员工信息</li>
</ul>
<span id="more"></span>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//main.cpp文件</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;worker.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;manager.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	manager m;</span><br><span class="line">	m.<span class="built_in">show</span>();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//work.h文件</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">worker</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function">string <span class="title">getName</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">setName</span><span class="params">(string name)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="function">string <span class="title">getTelephone</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">setTelephone</span><span class="params">(string telephone)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">float</span> <span class="title">getSalary</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">setSalary</span><span class="params">(<span class="keyword">float</span> salary)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	string name;</span><br><span class="line">	<span class="keyword">int</span> age;</span><br><span class="line">	string telephone;</span><br><span class="line">	<span class="keyword">float</span> salary;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//work.cpp文件</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;worker.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function">string <span class="title">worker::getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">this</span>-&gt;name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">worker::setName</span><span class="params">(string name)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">this</span>-&gt;name = name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">string <span class="title">worker::getTelephone</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">this</span>-&gt;telephone;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">worker::setTelephone</span><span class="params">(string telephone)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">this</span>-&gt;telephone = telephone;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">worker::getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">this</span>-&gt;age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">worker::setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">this</span>-&gt;age = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">float</span> <span class="title">worker::getSalary</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">this</span>-&gt;salary;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">worker::setSalary</span><span class="params">(<span class="keyword">float</span> salary)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">this</span>-&gt;salary = salary;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//manager.h文件</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> WORKER_NUMBER 5</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SALE_DEPATMENT 1 <span class="comment">//销售部门</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DEVELOP_DEPATMENT 2 <span class="comment">//研发部门</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FINACIAL_DEPATMENT 3 <span class="comment">//财务部门</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;worker.h&quot;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">manager</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">create_worker</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">divide_worker</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">print_worker</span><span class="params">(<span class="keyword">int</span> departID)</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">print_worker_by_group</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	vector&lt;worker&gt; worker_vector;</span><br><span class="line">	multimap&lt;<span class="keyword">int</span>, worker&gt; worker_group;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//manager.cpp文件</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;worker.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;manager.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">manager::create_worker</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	string name_seed = <span class="string">&quot;ABCDE&quot;</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; WORKER_NUMBER; i++) &#123;</span><br><span class="line"></span><br><span class="line">		worker worker;</span><br><span class="line">		string tmp = name_seed.<span class="built_in">substr</span>(i, <span class="number">1</span>);</span><br><span class="line">		worker.<span class="built_in">setName</span>(<span class="string">&quot;选手&quot;</span> + tmp);</span><br><span class="line">		worker.<span class="built_in">setAge</span>(<span class="built_in">rand</span>() % <span class="number">15</span> + <span class="number">20</span>);</span><br><span class="line">		worker.<span class="built_in">setTelephone</span>(<span class="string">&quot;010-88888888&quot;</span>);</span><br><span class="line">		worker.<span class="built_in">setSalary</span>(<span class="built_in">rand</span>()%<span class="number">10000</span>+<span class="number">1000.00</span>);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">this</span>-&gt;worker_vector.<span class="built_in">push_back</span>(worker);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">manager::divide_worker</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">srand</span>(<span class="built_in">time</span>(<span class="literal">NULL</span>));</span><br><span class="line">	<span class="keyword">for</span> (vector&lt;worker&gt;::iterator it = <span class="keyword">this</span>-&gt;worker_vector.<span class="built_in">begin</span>() ; it !=<span class="keyword">this</span>-&gt;worker_vector.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">int</span> departID = <span class="built_in">rand</span>() % <span class="number">3</span> + <span class="number">1</span>;</span><br><span class="line">		<span class="built_in"><span class="keyword">switch</span></span> (departID) &#123;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">case</span> SALE_DEPATMENT:</span><br><span class="line">				<span class="keyword">this</span>-&gt;worker_group.<span class="built_in">insert</span>(<span class="built_in">make_pair</span>(SALE_DEPATMENT, *it));</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> DEVELOP_DEPATMENT:</span><br><span class="line">				<span class="keyword">this</span>-&gt;worker_group.<span class="built_in">insert</span>(<span class="built_in">make_pair</span>(DEVELOP_DEPATMENT, *it));</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> FINACIAL_DEPATMENT:</span><br><span class="line">				<span class="keyword">this</span>-&gt;worker_group.<span class="built_in">insert</span>(<span class="built_in">make_pair</span>(FINACIAL_DEPATMENT, *it));</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">default</span>:</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">manager::print_worker</span><span class="params">(<span class="keyword">int</span> departID)</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">	multimap&lt;<span class="keyword">int</span>, worker&gt;::iterator it = <span class="keyword">this</span>-&gt;worker_group.<span class="built_in">find</span>(departID);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">int</span> DepartCount = <span class="keyword">this</span>-&gt;worker_group.<span class="built_in">count</span>(departID);</span><br><span class="line">	<span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (multimap&lt;<span class="keyword">int</span>, worker&gt;::iterator pos = it; it != <span class="keyword">this</span>-&gt;worker_group.<span class="built_in">end</span>() &amp;&amp; num &lt; DepartCount; pos++, num++) &#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;姓名:&quot;</span> &lt;&lt; pos-&gt;second.<span class="built_in">getName</span>()&lt;&lt; <span class="string">&quot; 年龄:&quot;</span> &lt;&lt; pos-&gt;second.<span class="built_in">getAge</span>() &lt;&lt; <span class="string">&quot; 电话:&quot;</span> &lt;&lt; pos-&gt;second.<span class="built_in">getTelephone</span>() &lt;&lt; <span class="string">&quot; 工资:&quot;</span> &lt;&lt; pos-&gt;second.<span class="built_in">getSalary</span>() &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//打印每一部分员工信息</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">manager::print_worker_by_group</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//显示销售部门</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;销售部门:&quot;</span> &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">this</span>-&gt;<span class="built_in">print_worker</span>(SALE_DEPATMENT);</span><br><span class="line">	<span class="comment">//显示开发部门</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;研发部门:&quot;</span> &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">this</span>-&gt;<span class="built_in">print_worker</span>(DEVELOP_DEPATMENT);</span><br><span class="line">	<span class="comment">//显示财务部门</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;财务部门:&quot;</span> &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">this</span>-&gt;<span class="built_in">print_worker</span>(FINACIAL_DEPATMENT);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">manager::show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">this</span>-&gt;<span class="built_in">create_worker</span>();</span><br><span class="line">	<span class="keyword">this</span>-&gt;<span class="built_in">divide_worker</span>();</span><br><span class="line">	<span class="keyword">this</span>-&gt;<span class="built_in">print_worker_by_group</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>C++</category>
        <category>STL</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>STL</tag>
        <tag>STL案例</tag>
      </tags>
  </entry>
  <entry>
    <title>STL_算法基础</title>
    <url>/2021/05/07/STL%EF%BC%9A%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<h3 id="一、算法概述"><a href="#一、算法概述" class="headerlink" title="一、算法概述"></a>一、算法概述</h3><p>    算法部分主要由头文件&lt;algorithm&gt;，&lt;numeric&gt;和&lt;functional&gt;组成。</p>
<span id="more"></span>

<p>    &lt;algorithm&gt;是所有STL头文件中最大的一个，其中常用到的功能范围涉及到比较、交换、查找、遍历操作、复制、修改、反转、排序、合并等等。</p>
<p>    &lt;numeric&gt;体积很小，只包括几个在序列上面进行简单数学运算的模板函数，包括加法和乘法在序列上的一些操作。</p>
<p>    &lt;functional&gt;中则定义了一些模板类，用以声明函数对象。</p>
<p>    STL提供了大量实现算法的模版函数，只要我们熟悉了STL之后，许多代码可以被大大的化简，只需要通过调用一两个算法模板，就可以完成所需要的功能，从而大大地提升效率。</p>
<p>    #include &lt;algorithm&gt;</p>
<p>    #include &lt;numeric&gt;</p>
<p>    #include &lt;functional&gt;</p>
<h3 id="二、STL中算法分类"><a href="#二、STL中算法分类" class="headerlink" title="二、STL中算法分类"></a>二、STL中算法分类</h3><ul>
<li><p>操作对象 </p>
</li>
<li><ul>
<li>直接改变容器的内容</li>
<li>将原容器的内容复制一份,修改其副本,然后传回该副本</li>
</ul>
</li>
<li><p>功能: </p>
</li>
<li><ul>
<li><p>非可变序列算法 指不直接修改其所操作的容器内容的算法</p>
</li>
<li><ul>
<li>计数算法     count、count_if</li>
<li>搜索算法     search、find、find_if、find_first_of、…</li>
<li>比较算法     equal、mismatch、lexicographical_compare</li>
</ul>
</li>
<li><p>可变序列算法 指可以修改它们所操作的容器内容的算法</p>
</li>
<li><ul>
<li>删除算法     remove、remove_if、remove_copy、…</li>
<li>修改算法     for_each、transform</li>
<li>排序算法     sort、stable_sort、partial_sort、</li>
</ul>
</li>
<li><p>排序算法 包括对序列进行排序和合并的算法、搜索算法以及有序序列上的集合操作</p>
</li>
<li><p>数值算法 对容器内容进行数值计算</p>
</li>
</ul>
</li>
</ul>
<h3 id="三、常用算法汇总"><a href="#三、常用算法汇总" class="headerlink" title="三、常用算法汇总"></a>三、常用算法汇总</h3><p>    常用的<strong>查找</strong>算法：adjacent_find()（ adjacent 是邻近的意思）,binary_search(),count(),count_if(),equal_range(),find(),find_if()。</p>
<p>    常用的<strong>排序</strong>算法：merge(),sort(),random_shuffle()（shuffle是洗牌的意思） ,reverse()。</p>
<p>    常用的<strong>拷贝和替换</strong>算法：copy(), replace(),replace_if(),swap()</p>
<p>    常用的<strong>算术和生成</strong>算法：accumulate()（ accumulate 是求和的意思）,fill(),。</p>
<p>    常用的<strong>集合</strong>算法：set_union(),set_intersection(),set_difference()。</p>
<p>    常用的<strong>遍历</strong>算法：for_each(), transform()（ transform 是变换的意思）。</p>
]]></content>
      <categories>
        <category>C++</category>
        <category>STL</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>STL</tag>
        <tag>STL算法</tag>
      </tags>
  </entry>
  <entry>
    <title>STL_容器共性机制与使用时机</title>
    <url>/2021/05/07/STL%EF%BC%9A%E5%AE%B9%E5%99%A8%E5%85%B1%E6%80%A7%E6%9C%BA%E5%88%B6%E4%B8%8E%E4%BD%BF%E7%94%A8%E6%97%B6%E6%9C%BA/</url>
    <content><![CDATA[<h3 id="一、容器的共通能力"><a href="#一、容器的共通能力" class="headerlink" title="一、容器的共通能力"></a>一、容器的共通能力</h3><p>    C++模板是容器的概念。                            </p>
<p>    理论提高：所有容器提供的都是值（value）语意，而非引用（reference）语意。<strong>容器执行插入元素的操作时，内部实施拷贝动作。</strong>所以STL容器内存储的元素必须<strong>能够被拷贝</strong>（必须提供拷贝构造函数）。</p>
<span id="more"></span>

<p>     除了queue与stack外，每个容器都提供可返回迭代器的函数，运用返回的迭代器就可以访问元素。</p>
<p>    通常STL不会丢出异常，要求使用者确保传入正确的参数。</p>
<p>    每个容器都提供了一个默认构造函数跟一个默认拷贝构造函数。</p>
<p>    如已有容器vecIntA。 </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">vecIntB</span><span class="params">(vecIntA)</span></span>; <span class="comment">//调用拷贝构造函数，复制vecIntA到vecIntB中。</span></span><br></pre></td></tr></table></figure>

<p>    与大小相关的操作方法(c代表容器)：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">c.<span class="built_in">size</span>();  <span class="comment">//返回容器中元素的个数</span></span><br><span class="line">c.<span class="built_in">empty</span>();  <span class="comment">//判断容器是否为空</span></span><br></pre></td></tr></table></figure>

<p>    比较操作(c1,c2代表容器)：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">c1 == c2   <span class="comment">//判断c1是否等于c2</span></span><br><span class="line">c1 != c2   <span class="comment">//判断c1是否不等于c2</span></span><br><span class="line">c1 = c2    <span class="comment">//把c2的所有元素指派给c1 </span></span><br></pre></td></tr></table></figure>



<h3 id="二、STL容器使用时机"><a href="#二、STL容器使用时机" class="headerlink" title="二、STL容器使用时机"></a>二、STL容器使用时机</h3><table>
<thead>
<tr>
<th>.</th>
<th>vector</th>
<th>deque</th>
<th>list</th>
<th>set</th>
<th>multiset</th>
<th>map</th>
<th>multimap</th>
</tr>
</thead>
<tbody><tr>
<td>典型内存结构</td>
<td>单端数组</td>
<td>双端数组</td>
<td>双向链表</td>
<td>二叉树</td>
<td>二叉树</td>
<td>二叉树</td>
<td>二叉树</td>
</tr>
<tr>
<td>可随机存取</td>
<td>是</td>
<td>是</td>
<td>否</td>
<td>否</td>
<td>否</td>
<td>对key而言：是</td>
<td>否</td>
</tr>
<tr>
<td>元素搜寻速度</td>
<td>慢</td>
<td>慢</td>
<td>非常慢</td>
<td>快</td>
<td>快</td>
<td>对key而言：快</td>
<td>对key而言：快</td>
</tr>
<tr>
<td>元素安插移除</td>
<td>尾端</td>
<td>头尾两端</td>
<td>任何位置</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
</tr>
</tbody></table>
<p>    vector的使用场景：比如软件历史操作记录的存储，我们经常要查看历史记录，比如上一次的记录，上上次的记录，但却不会去删除记录，因为记录是事实的描述。</p>
<p>    deque的使用场景：比如排队购票系统，对排队者的存储可以采用deque，支持头端的快速移除，尾端的快速添加。如果采用vector，则头端移除时，会移动大量的数据，速度慢。</p>
<p>    vector与deque的比较：</p>
<ul>
<li>一：vector.at()比deque.at()效率高，比如vector.at(0)是固定的，deque的开始位置 却是不固定的。</li>
<li>二：如果有大量释放操作的话，vector花的时间更少，这跟二者的内部实现有关。</li>
<li>三：deque支持头部的快速插入与快速移除，这是deque的优点。</li>
</ul>
<p>    list的使用场景：比如公交车乘客的存储，随时可能有乘客下车，支持频繁的不确实位置元素的移除插入。</p>
<p>    set的使用场景：比如对手机游戏的个人得分记录的存储，存储要求从高分到低分的顺序排列。</p>
<p>    map的使用场景：比如按ID号存储十万个用户，想要快速要通过ID查找对应的用户。二叉树的查找效率，这时就体现出来了。如果是vector容器，最坏的情况下可能要遍历完整个容器才能找到该用户。</p>
]]></content>
      <categories>
        <category>C++</category>
        <category>STL</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>STL</tag>
        <tag>STL容器</tag>
      </tags>
  </entry>
  <entry>
    <title>STL_简介</title>
    <url>/2021/05/07/STL%EF%BC%9A%E7%AE%80%E4%BB%8B/</url>
    <content><![CDATA[<h3 id="一、基本概念"><a href="#一、基本概念" class="headerlink" title="一、基本概念"></a>一、基本概念</h3><p>    STL（Standard Template Library，标准模板库)是惠普实验室开发的一系列软件的统称。现然主要出现在C++中，但在被引入C++之前该技术就已经存在了很长的一段时间。</p>
<span id="more"></span>

<p>    STL的从广义上讲分为三类：<strong>algorithm（算法）、container（容器）和iterator（迭代器）</strong>，容器和算法通过迭代器可以进行无缝地连接。几乎所有的代码都采 用了模板类和模板函数的方式，这相比于传统的由函数和类组成的库来说提供了更好的代码重用机会。</p>
<p>    在C++标准中，STL 就位于各个 C++ 的头文件中，即它并非以二进制代码的形式提供，而是以源代码的形式提供。STL被组织为下面的13个头文 件：&lt;algorithm&gt;、&lt;deque&gt;、&lt;functional&gt;、&lt;iterator&gt;、&lt;vector&gt;、&lt;list&gt;、&lt;map&gt;、&lt;memory&gt;、&lt;numeric&gt;、&lt;queue&gt;、&lt;set&gt;、&lt;stack&gt; 和&lt;utility&gt;。</p>
<p>STL详细的说六大组件：</p>
<ol>
<li><strong>容器</strong>：各种数据结构，如vector、list、deque、set、map等,用来存放数据，从实现角度来看，STL容器是一种class template。</li>
<li><strong>算法</strong>：各种常用的算法，如sort、find、copy、for_each。从实现的角度来看，STL算法是一种function tempalte.</li>
<li><strong>迭代器</strong>：扮演了容器与算法之间的胶合剂，共有五种类型，从实现角度来看，迭代器是一种将operator* , operator-&gt; , operator++,operator–等指针相关操作予以重载的class template. 所有STL容器都附带有自己专属的迭代器，只有容器的设计者才知道如何遍历自己的元素。原生指针(native pointer)也是一种迭代器。</li>
<li><strong>仿函数</strong>：行为类似函数，可作为算法的某种策略。从实现角度来看，仿函数是一种重载了operator()的class 或者class template</li>
<li><strong>适配器</strong>：一种用来修饰容器或者仿函数或迭代器接口的东西。</li>
<li><strong>空间配置器</strong>：负责空间的配置与管理。从实现角度看，配置器是一个实现了动态空间配置、空间管理、空间释放的class tempalte.</li>
</ol>
<p>    STL六大组件的交互关系，容器通过空间配置器取得数据存储空间，算法通过迭代器存储容器中的内容，仿函数可以协助算法完成不同的策略的变化，适配器可以修饰仿函数</p>
<h3 id="二、STL优点"><a href="#二、STL优点" class="headerlink" title="二、STL优点"></a>二、STL优点</h3><p>    1）STL是C++的一部分，因此不用额外安装什么，它被内建在你的编译器之内。</p>
<p>    2）STL的一个重要特点是数据结构和算法的分离。尽管这是个简单的概念，但是这种分离确实使得STL变得非常通用。</p>
<p>    例如，在STL的vector容器中，可以放入元素、基础数据类型变量、元素的地址；</p>
<p>    STL的sort()函数可以用来操作vector,list等容器。</p>
<p>    3） 程序员可以不用思考STL具体的实现过程，只要能够熟练使用STL就OK了。这样他们就可以把精力放在程序开发的别的方面。</p>
<p>    4） STL具有高可重用性，高性能，高移植性，跨平台的优点。</p>
<ul>
<li>高可重用性：STL中几乎所有的代码都采用了模板类和模版函数的方式实现，这相比于传统的由函数和类组成的库来说提供了更好的代码重用机会。关于模板的知识，已经给大家介绍了。</li>
<li>高性能：如map可以高效地从十万条记录里面查找出指定的记录，因为map是采用红黑树的变体实现的。(红黑树是平横二叉树的一种)</li>
<li>高移植性：如在项目A上用STL编写的模块，可以直接移植到项目B上。</li>
<li>跨平台：如用windows的Visual Studio编写的代码可以在Mac OS的XCode上直接编译。</li>
</ul>
<p>    5） 程序员可以不用思考STL具体的实现过程，只要能够熟练使用STL就OK了。这样他们就可以把精力放在程序开发的别的方面。</p>
<p>    6） 了解到STL的这些好处，我们知道STL无疑是最值得C++程序员骄傲的一部分。每一个C++程序员都应该好好学习STL。只有能够熟练使用STL的程序员，才是好的C++程序员。</p>
<p>    7）  总之：招聘工作中，经常遇到C++程序员对STL不是非常了解。大多是有一个大致的映像，而对于在什么情况下应该使用哪个容器和算法都感到比较茫然。<strong>STL是C++程序员的一项不可或缺的基本技能</strong>，掌握它对提升C++编程大有裨益。</p>
<h3 id="三、三大组件介绍"><a href="#三、三大组件介绍" class="headerlink" title="三、三大组件介绍"></a>三、三大组件介绍</h3><h4 id="容器"><a href="#容器" class="headerlink" title="容器"></a>容器</h4><p>    几乎可以说，任何特定的数据结构都是为了实现某种特定的算法。STL容器就是将运用最广泛的一些数据结构实现出来。</p>
<p>    常用的数据结构：<strong>数组</strong>(array) , <strong>链表</strong>(list), tree(<strong>树</strong>)，<strong>栈</strong>(stack), <strong>队列</strong>(queue), <strong>集合</strong>(set),<strong>映射表</strong>(map), 根据数据在容器中的排列特性，这些数据分为序列式容器和关联式容器两种。</p>
<ul>
<li><p>序列式容器（Sequence containers）</p>
<p>每个元素都有固定位置－－取决于插入时机和地点，和元素值无关。如：Array数组、Vector容器、Deque容器、List容器等。</p>
</li>
<li><p>关联式容器（Associated containers）</p>
<p>元素位置取决于特定的排序准则，和插入顺序无关。关联式容器是非线性的树结构，更准确的说是二叉树结构。各元素之间没有严格的物理上的顺序关系，也就是说元素在容器中并没有保存元素置入容器时的逻辑顺序。关联式容器另一个显著特点是：在值中选择一个值作为关键字key，这个关键字对值起到索引的作用，方便查找。Set/multiset容器 Map/multimap容器 </p>
</li>
</ul>
<table>
<thead>
<tr>
<th>数据结构</th>
<th>描述</th>
<th>实现头文件</th>
</tr>
</thead>
<tbody><tr>
<td>向量(vector)</td>
<td>连续存储的元素</td>
<td>&lt;vector&gt;</td>
</tr>
<tr>
<td>列表(list)</td>
<td>由节点组成的双向链表，每个结点包含着一个元素</td>
<td>&lt;list&gt;</td>
</tr>
<tr>
<td>双队列(deque)</td>
<td>连续存储的指向不同元素的指针所组成的数组</td>
<td>&lt;deque&gt;</td>
</tr>
<tr>
<td>集合(set)</td>
<td>由节点组成的红黑树，每个节点都包含着一个元素，节点之间以某种作用于元素对的谓词排列，没有两个不同的元素能够拥有相同的次序</td>
<td>&lt;set&gt;</td>
</tr>
<tr>
<td>多重集合(multiset)</td>
<td>允许存在两个次序相等的元素的集合</td>
<td>&lt;set&gt;</td>
</tr>
<tr>
<td>栈(stack)</td>
<td>后进先出的值的排列</td>
<td>&lt;stack&gt;</td>
</tr>
<tr>
<td>队列(queue)</td>
<td>先进先出的执的排列</td>
<td>&lt;queue&gt;</td>
</tr>
<tr>
<td>优先队列(priority_queue)</td>
<td>元素的次序是由作用于所存储的值对上的某种谓词决定的的一种队列</td>
<td>&lt;queue&gt;</td>
</tr>
<tr>
<td>映射(map)</td>
<td>由{键，值}对组成的集合，以某种作用于键对上的谓词排列</td>
<td>&lt;map&gt;</td>
</tr>
<tr>
<td>多重映射(multimap)</td>
<td>允许键对有相等的次序的映射</td>
<td>&lt;map&gt;</td>
</tr>
</tbody></table>
<h4 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h4><p>    迭代器从作用上来说是最基本的部分，可是理解起来比前两者都要费力一些。软件设计有一个基本原则，所有的问题都可以通过引进一个间接层来简化， 这种简化在STL中就是用迭代器来完成的。概括来说，迭代器在STL中用来将算法和容器联系起来，起着一种黏和剂的作用。几乎STL提供的所有算法都是通 过迭代器存取元素序列进行工作的，每一个容器都定义了其本身所专有的迭代器，用以存取容器中的元素。</p>
<p>    迭代器部分主要由头文件&lt;utility&gt;,&lt;iterator&gt;和&lt;memory&gt;组 成。&lt;utility&gt;是一个很小的头文件，它包括了贯穿使用在STL中的几个模板的声明，&lt;iterator&gt;中提供了迭代器 使用的许多方法，而对于&lt;memory&gt;的描述则十分的困难，它以不同寻常的方式为容器中的元素分配存储空间，同时也为某些算法执行期间产生 的临时对象提供机制,&lt;memory&gt;中的主要部分是模板类allocator，它负责产生所有容器中的默认分配器。</p>
<p>    迭代器的种类:</p>
<table>
<thead>
<tr>
<th>迭代器</th>
<th>功能</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>输入迭代器</td>
<td>提供对数据的只读访问</td>
<td>只读，支持++、==、！=</td>
</tr>
<tr>
<td>输出迭代器</td>
<td>提供对数据的只写访问</td>
<td>只写，支持++</td>
</tr>
<tr>
<td>前向迭代器</td>
<td>提供读写操作，并能向前推进迭代器</td>
<td>读写，支持++、==、！=</td>
</tr>
<tr>
<td>双向迭代器</td>
<td>提供读写操作，并能向前和向后操作</td>
<td>读写，支持++、–，</td>
</tr>
<tr>
<td>随机访问迭代器</td>
<td>提供读写操作，并能以跳跃的方式访问容器的任意数据，是功能最强的迭代器</td>
<td>读写，支持++、–、[n]、-n、&lt;、&lt;=、&gt;、&gt;=</td>
</tr>
</tbody></table>
<h4 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h4><p>    函数库对数据类型的选择对其可重用性起着至关重要的作用。举例来说，一个求方根的函数，在使用浮点数作为其参数类型的情况下的可重用性肯定比使 用整型作为它的参数类性要高。而C++通过模板的机制允许推迟对某些类型的选择，直到真正想使用模板或者说对模板进行特化的时候，STL就利用了这一点提 供了相当多的有用算法。它是在一个有效的框架中完成这些算法的——可以将所有的类型划分为少数的几类，然后就可以在模版的参数中使用一种类型替换掉同一种 类中的其他类型。</p>
<p>    STL提供了大约100个实现算法的模版函数，比如算法for_each将为指定序列中的每一个元素调用指定的函数，stable_sort以你所指定的规则对序列进行稳定性排序等等。这样一来，只要熟悉了STL之后，许多代码可以被大大的化简，只需要通过调用一两个算法模板，就可以完成所需要 的功能并大大地提升效率。</p>
<p>    算法部分主要由头文件&lt;algorithm&gt;，&lt;numeric&gt;和&lt;functional&gt;组 成。&lt;algorithm&gt;是所有STL头文件中最大的一个（尽管它很好理解），它是由一大堆模版函数组成的，可以认为每个函数在很大程度上 都是独立的，其中常用到的功能范围涉及到比较、交换、查找、遍历操作、复制、修改、移除、反转、排序、合并等等。&lt;numeric&gt;体积很 小，只包括几个在序列上面进行简单数学运算的模板函数，包括加法和乘法在序列上的一些操作。&lt;functional&gt;中则定义了一些模板类， 用以声明函数对象。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _CRT_SECURE_NO_WARNINGS</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//STL 中的容器 算法 迭代器</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span>&#123;</span><br><span class="line">	vector&lt;<span class="keyword">int</span>&gt; v; <span class="comment">//STL 中的标准容器之一 ：动态数组</span></span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="number">1</span>); <span class="comment">//vector 容器提供的插入数据的方法</span></span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="number">5</span>);</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="number">3</span>);</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="number">7</span>);</span><br><span class="line">	<span class="comment">//迭代器</span></span><br><span class="line">	vector&lt;<span class="keyword">int</span>&gt;::iterator pStart = v.<span class="built_in">begin</span>(); <span class="comment">//vector 容器提供了 begin()方法 返回指向第一个元素的迭代器</span></span><br><span class="line">	vector&lt;<span class="keyword">int</span>&gt;::iterator pEnd = v.<span class="built_in">end</span>(); <span class="comment">//vector 容器提供了 end()方法 返回指向最后一个元素下一个位置的迭代器</span></span><br><span class="line">	<span class="comment">//通过迭代器遍历</span></span><br><span class="line">	<span class="keyword">while</span> (pStart != pEnd)&#123;</span><br><span class="line">		cout &lt;&lt; *pStart &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">		pStart++;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">	<span class="comment">//算法 count 算法 用于统计元素的个数</span></span><br><span class="line">	<span class="keyword">int</span> n = <span class="built_in">count</span>(pStart, pEnd, <span class="number">5</span>);</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;n:&quot;</span> &lt;&lt; n &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//STL 容器不单单可以存储基础数据类型，也可以存储类对象</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Teacher</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Teacher</span>(<span class="keyword">int</span> age) :<span class="built_in">age</span>(age)&#123;&#125;;</span><br><span class="line">	~<span class="built_in">Teacher</span>()&#123;&#125;;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">int</span> age;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test02</span><span class="params">()</span></span>&#123;</span><br><span class="line">	vector&lt;Teacher&gt; v; <span class="comment">//存储 Teacher 类型数据的容器</span></span><br><span class="line">	Teacher t1(10), t2(20), t3(30);</span><br><span class="line">	v.<span class="built_in">push_back</span>(t1);</span><br><span class="line">	v.<span class="built_in">push_back</span>(t2);</span><br><span class="line">	v.<span class="built_in">push_back</span>(t3);</span><br><span class="line">	vector&lt;Teacher&gt;::iterator pStart = v.<span class="built_in">begin</span>();</span><br><span class="line">	vector&lt;Teacher&gt;::iterator pEnd = v.<span class="built_in">end</span>();</span><br><span class="line">	<span class="comment">//通过迭代器遍历</span></span><br><span class="line">	<span class="keyword">while</span> (pStart != pEnd)&#123;</span><br><span class="line">		cout &lt;&lt; pStart-&gt;age &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">		pStart++;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//存储 Teacher 类型指针</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test03</span><span class="params">()</span></span>&#123;</span><br><span class="line">	vector&lt;Teacher*&gt; v; <span class="comment">//存储 Teacher 类型指针</span></span><br><span class="line">	Teacher* t1 = <span class="keyword">new</span> <span class="built_in">Teacher</span>(<span class="number">10</span>);</span><br><span class="line">	Teacher* t2 = <span class="keyword">new</span> <span class="built_in">Teacher</span>(<span class="number">20</span>);</span><br><span class="line">	Teacher* t3 = <span class="keyword">new</span> <span class="built_in">Teacher</span>(<span class="number">30</span>);</span><br><span class="line">	v.<span class="built_in">push_back</span>(t1);</span><br><span class="line">	v.<span class="built_in">push_back</span>(t2);</span><br><span class="line">	v.<span class="built_in">push_back</span>(t3);</span><br><span class="line">	<span class="comment">//拿到容器迭代器</span></span><br><span class="line">	vector&lt;Teacher*&gt;::iterator pStart = v.<span class="built_in">begin</span>();</span><br><span class="line">	vector&lt;Teacher*&gt;::iterator pEnd = v.<span class="built_in">end</span>();</span><br><span class="line">	<span class="comment">//通过迭代器遍历</span></span><br><span class="line">	<span class="keyword">while</span> (pStart != pEnd)&#123;</span><br><span class="line">		cout &lt;&lt; (*pStart)-&gt;age &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">		pStart++;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//容器嵌套容器 难点</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test04</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	vector&lt; vector&lt;<span class="keyword">int</span>&gt; &gt; v;</span><br><span class="line">	vector&lt;<span class="keyword">int</span>&gt;v1;</span><br><span class="line">	vector&lt;<span class="keyword">int</span>&gt;v2;</span><br><span class="line">	vector&lt;<span class="keyword">int</span>&gt;v3;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		v1.<span class="built_in">push_back</span>(i);</span><br><span class="line">		v2.<span class="built_in">push_back</span>(i * <span class="number">10</span>);</span><br><span class="line">		v3.<span class="built_in">push_back</span>(i * <span class="number">100</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	v.<span class="built_in">push_back</span>(v1);</span><br><span class="line">	v.<span class="built_in">push_back</span>(v2);</span><br><span class="line">	v.<span class="built_in">push_back</span>(v3);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (vector&lt; vector&lt;<span class="keyword">int</span>&gt; &gt;::iterator it = v.<span class="built_in">begin</span>(); it != v.<span class="built_in">end</span>();it++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span> (vector&lt;<span class="keyword">int</span>&gt;::iterator subIt = (*it).<span class="built_in">begin</span>(); subIt != (*it).<span class="built_in">end</span>(); subIt ++)</span><br><span class="line">		&#123;</span><br><span class="line">			cout &lt;&lt; *subIt &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		cout &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="comment">//test01();</span></span><br><span class="line">	<span class="comment">//test02();</span></span><br><span class="line">	<span class="comment">//test03();</span></span><br><span class="line">	<span class="built_in">test04</span>();</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>部分内容来自：</p>
<p><a href="https://blog.csdn.net/qq_42322103/article/details/99685797">STL详解</a></p>
]]></content>
      <categories>
        <category>C++</category>
        <category>STL</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>STL</tag>
      </tags>
  </entry>
  <entry>
    <title>STL_函数对象、谓词、预定义函数对象、函数适配器</title>
    <url>/2021/05/07/STL%EF%BC%9A%E5%87%BD%E6%95%B0%E5%AF%B9%E8%B1%A1%E3%80%81%E8%B0%93%E8%AF%8D%E3%80%81%E9%A2%84%E5%AE%9A%E4%B9%89%E5%87%BD%E6%95%B0%E5%AF%B9%E8%B1%A1%E3%80%81%E5%87%BD%E6%95%B0%E9%80%82%E9%85%8D%E5%99%A8/</url>
    <content><![CDATA[<h3 id="一、函数对象（仿函数）"><a href="#一、函数对象（仿函数）" class="headerlink" title="一、函数对象（仿函数）"></a>一、函数对象（仿函数）</h3><p>重载函数调用操作符的类，其对象常称为函数对象（function object），即它们是行为类似函数的对象，也叫仿函数(functor),其实就是重载“()”操作符，使得类对象可以像函数那样调用。</p>
<span id="more"></span>

<p>注意: </p>
<ol>
<li>函数对象(仿函数)是一个类，不是一个函数。</li>
<li>函数对象(仿函数)重载了”() ”操作符使得它可以像函数一样调用。</li>
</ol>
<p>分类:假定某个类有一个重载的operator()，而且重载的operator()要求获取一个参数，我们就将这个类称为“一元仿函数”（unary functor）；相反，如果重载的operator()要求获取两个参数，就将这个类称为“二元仿函数”（binary functor）。</p>
<p>函数对象的作用:</p>
<p>STL提供的算法往往都有两个版本，其中一个版本表现出最常用的某种运算，另一版本则允许用户通过template参数的形式来指定所要采取的策略。</p>
<p>“在标准库中，函数对象被广泛地使用以获得弹性”，标准库中的很多算法都可以使用函数对象或者函数来作为自定的回调行为。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _CRT_SECURE_NO_WARNINGS</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">MyPrint</span> &#123;</span></span><br><span class="line">	<span class="built_in">MyPrint</span>() &#123;</span><br><span class="line">		mNum = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">		mNum++;</span><br><span class="line">		cout &lt;&lt; val &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">int</span> mNum;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> num = <span class="number">0</span>; <span class="comment">//真正开发中，尽量避免去使用全局变量，加锁解锁繁琐</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MyPrint02</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">	num++;</span><br><span class="line">	cout &lt;&lt; val &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	MyPrint print;</span><br><span class="line">	<span class="built_in">print</span>(<span class="number">10</span>);</span><br><span class="line">	<span class="comment">//函数对象可以像普通函数一样调用</span></span><br><span class="line">	<span class="comment">//函数对象可以像普通函数那样接收参数</span></span><br><span class="line">	<span class="comment">//函数对象超出了函数的概念，函数对象可以保存函数调用的状态，避免使用全局变量</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test02</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	vector&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="number">10</span>);</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="number">20</span>);</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="number">30</span>);</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="number">40</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//计算函数调用次数</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> 0</span></span><br><span class="line">	<span class="built_in">MyPrint02</span>(<span class="number">10</span>);</span><br><span class="line">	<span class="built_in">MyPrint02</span>(<span class="number">20</span>);</span><br><span class="line">	cout &lt;&lt; num &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	MyPrint print;</span><br><span class="line">	<span class="built_in">print</span>(<span class="number">10</span>);</span><br><span class="line">	<span class="built_in">print</span>(<span class="number">20</span>);</span><br><span class="line">	cout &lt;&lt; print.mNum &lt;&lt; endl;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">	MyPrint print;</span><br><span class="line">	MyPrint print02=for_each(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), print);</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;print调用次数:&quot;</span> &lt;&lt; print.mNum &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;print调用次数:&quot;</span> &lt;&lt; print02.mNum &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">	<span class="built_in">test02</span>();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">结果：</span></span><br><span class="line"><span class="comment">10</span></span><br><span class="line"><span class="comment">20</span></span><br><span class="line"><span class="comment">30</span></span><br><span class="line"><span class="comment">40</span></span><br><span class="line"><span class="comment">print调用次数:0</span></span><br><span class="line"><span class="comment">print调用次数:4</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h3 id="二、谓词"><a href="#二、谓词" class="headerlink" title="二、谓词"></a>二、谓词</h3><p>谓词是指普通函数或重载的operator()返回值是bool类型的函数对象(仿函数)。如果operator接受一个参数，那么叫做一元谓词,如果接受两个参数，那么叫做二元谓词，谓词可作为一个判断式。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//一元谓词函数举例如下</span></span><br><span class="line"><span class="comment">//1，判断给出的string对象的长度是否小于6</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">GT6</span><span class="params">(<span class="keyword">const</span> string &amp;s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> s.<span class="built_in">size</span>() &gt;= <span class="number">6</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//2,判断给出的int是否在3到8之间</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Compare</span><span class="params">( <span class="keyword">int</span> i )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> ( i &gt;= <span class="number">3</span> &amp;&amp; i &lt;= <span class="number">8</span> );</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//二元谓词举例如下</span></span><br><span class="line"><span class="comment">//1，比较两个string对象，返回一个bool值，指出第一个string是否比第二个短</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isShorter</span><span class="params">(<span class="keyword">const</span> string &amp;s1, <span class="keyword">const</span> string &amp;s2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> s1.<span class="built_in">size</span>() &lt; s2.<span class="built_in">size</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="三、预定义函数对象"><a href="#三、预定义函数对象" class="headerlink" title="三、预定义函数对象"></a>三、预定义函数对象</h3><h5 id="1）预定义函数对象基本概念："><a href="#1）预定义函数对象基本概念：" class="headerlink" title="1）预定义函数对象基本概念："></a>1）预定义函数对象基本概念：</h5><p>标准模板库STL提前定义了很多预定义函数对象，#include &lt;functional&gt; 必须包含。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//使用预定义函数对象：</span></span><br><span class="line"><span class="comment">//类模板plus&lt;&gt; 的实现了： 不同类型的数据进行加法运算</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main41</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    plus&lt;<span class="keyword">int</span>&gt; intAdd;</span><br><span class="line">    <span class="keyword">int</span> x = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">int</span> y = <span class="number">20</span>;</span><br><span class="line">    <span class="keyword">int</span> z = <span class="built_in">intAdd</span>(x, y); <span class="comment">//等价于 x + y </span></span><br><span class="line">    cout &lt;&lt; z &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    plus&lt;string&gt; stringAdd;</span><br><span class="line">    string myc = <span class="built_in">stringAdd</span>(<span class="string">&quot;aaa&quot;</span>, <span class="string">&quot;bbb&quot;</span>);</span><br><span class="line">    cout &lt;&lt; myc &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    vector&lt;string&gt; v1;</span><br><span class="line">    v1.<span class="built_in">push_back</span>(<span class="string">&quot;bbb&quot;</span>);</span><br><span class="line">    v1.<span class="built_in">push_back</span>(<span class="string">&quot;aaa&quot;</span>);</span><br><span class="line">    v1.<span class="built_in">push_back</span>(<span class="string">&quot;ccc&quot;</span>);</span><br><span class="line">    v1.<span class="built_in">push_back</span>(<span class="string">&quot;zzzz&quot;</span>);</span><br><span class="line"> </span><br><span class="line">   <span class="comment">//缺省情况下，sort()用底层元素类型的小于操作符以升序排列容器的元素。</span></span><br><span class="line">   <span class="comment">//为了降序，可以传递预定义的类模板greater,它调用底层元素类型的大于操作符：</span></span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;sort()函数排序&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">sort</span>(v1.<span class="built_in">begin</span>(), v1.<span class="built_in">end</span>(), greater&lt;string&gt;() ); <span class="comment">//从大到小</span></span><br><span class="line">    <span class="keyword">for</span> (vector&lt;string&gt;::iterator it=v1.<span class="built_in">begin</span>(); it!=v1.<span class="built_in">end</span>(); it++ )</span><br><span class="line">    &#123;</span><br><span class="line">         cout &lt;&lt; *it &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="2）算术函数对象"><a href="#2）算术函数对象" class="headerlink" title="2）算术函数对象"></a>2）算术函数对象</h5><p>预定义的函数对象支持加、减、乘、除、求余和取反。调用的操作符是与type相关联的实例</p>
<p>加法：plus&lt;Types&gt;</p>
<p>plus&lt;string&gt; stringAdd;</p>
<p>sres = stringAdd(sva1,sva2);</p>
<p>减法：minus&lt;Types&gt;</p>
<p>乘法：multiplies&lt;Types&gt;</p>
<p>除法divides&lt;Tpye&gt;</p>
<p>求余：modulus&lt;Tpye&gt;</p>
<p>取反：negate&lt;Type&gt;</p>
<p>negate&lt;int&gt; intNegate;</p>
<p>ires = intNegate(ires);</p>
<p>Ires= UnaryFunc(negate&lt;int&gt;(),Ival1);</p>
<h5 id="3）关系函数对象"><a href="#3）关系函数对象" class="headerlink" title="3）关系函数对象"></a>3）关系函数对象</h5><p>等于equal_to&lt;Tpye&gt;</p>
<p>equal_to&lt;string&gt; stringEqual;</p>
<p>sres = stringEqual(sval1,sval2);</p>
<p>不等于not_equal_to&lt;Type&gt;</p>
<p>大于 greater&lt;Type&gt;</p>
<p>大于等于greater_equal&lt;Type&gt;</p>
<p>小于 less&lt;Type&gt;</p>
<p>小于等于less_equal&lt;Type&gt;</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main42</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;string&gt; v1;</span><br><span class="line">    v1.<span class="built_in">push_back</span>(<span class="string">&quot;bbb&quot;</span>);</span><br><span class="line">    v1.<span class="built_in">push_back</span>(<span class="string">&quot;aaa&quot;</span>);</span><br><span class="line">    v1.<span class="built_in">push_back</span>(<span class="string">&quot;ccc&quot;</span>);</span><br><span class="line">    v1.<span class="built_in">push_back</span>(<span class="string">&quot;zzzz&quot;</span>);</span><br><span class="line">    v1.<span class="built_in">push_back</span>(<span class="string">&quot;ccc&quot;</span>);</span><br><span class="line">    string s1 = <span class="string">&quot;ccc&quot;</span>;</span><br><span class="line">    <span class="comment">//int num = count_if(v1.begin(),v1.end(), equal_to&lt;string&gt;(),s1);</span></span><br><span class="line">    <span class="keyword">int</span> num = <span class="built_in">count_if</span>(v1.<span class="built_in">begin</span>(),v1.<span class="built_in">end</span>(),<span class="built_in">bind2nd</span>(equal_to&lt;string&gt;(), s1));</span><br><span class="line">    cout &lt;&lt; num &lt;&lt; endl;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<h5 id="4）逻辑函数对象"><a href="#4）逻辑函数对象" class="headerlink" title="4）逻辑函数对象"></a>4）逻辑函数对象</h5><p>逻辑与 logical_and&lt;Type&gt;</p>
<p>logical_and&lt;int&gt; indAnd;</p>
<p>ires = intAnd(ival1,ival2);</p>
<p>dres=BinaryFunc( logical_and&lt;double&gt;(),dval1,dval2);</p>
<p>逻辑或logical_or&lt;Type&gt;</p>
<p>逻辑非logical_not&lt;Type&gt;</p>
<p>logical_not&lt;int&gt; IntNot;</p>
<p>Ires = IntNot(ival1);</p>
<p>Dres=UnaryFunc( logical_not&lt;double&gt;,dval1);</p>
<h3 id="四、函数适配器"><a href="#四、函数适配器" class="headerlink" title="四、函数适配器"></a>四、函数适配器</h3><p>标准库提供一组函数适配器，用来特殊化或者扩展一元和二元函数对象。常用适配器是：</p>
<ul>
<li>绑定器（binder）: binder通过把二元函数对象的一个实参绑定到一个特殊的值上，将其转换成一元函数对象。C＋＋标准库提供两种预定义的binder适配器：bind1st和bind2nd，前者把值绑定到二元函数对象的第一个实参上，后者绑定在第二个实参上。</li>
<li>取反器(negator) : negator是一个将函数对象的值翻转的函数适配器。标准库提供两个预定义的ngeator适配器：not1翻转一元预定义函数对象的真值，而not2翻转二元谓词函数的真值。</li>
</ul>
<p>常用函数适配器列表如下：</p>
<ul>
<li>bind1st(op, value)</li>
<li>bind2nd(op, value)</li>
<li>not1(op)</li>
<li>not2(op)</li>
<li>mem_fun_ref(op)</li>
<li>mem_fun(op)</li>
<li>ptr_fun(op)</li>
</ul>
<h5 id="绑定器（binder）"><a href="#绑定器（binder）" class="headerlink" title="绑定器（binder）"></a>绑定器（binder）</h5><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">MyPrint</span> :</span> <span class="keyword">public</span> binary_function&lt;<span class="keyword">int</span>, <span class="keyword">int</span>, <span class="keyword">void</span>&gt; &#123;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">int</span> v, <span class="keyword">int</span> val)</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;v:&quot;</span> &lt;&lt; v &lt;&lt; <span class="string">&quot;   val:&quot;</span>&lt;&lt; val&lt;&lt; <span class="string">&quot;   v+val:&quot;</span> &lt;&lt; v + val &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; endl;</span><br><span class="line">		&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	vector&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">		v.<span class="built_in">push_back</span>(i);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> addNum = <span class="number">200</span>;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;bind1st结果:&quot;</span> &lt;&lt; endl;</span><br><span class="line">	for_each(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="built_in">bind1st</span>(<span class="built_in">MyPrint</span>(), addNum));<span class="comment">//绑定适配器  将一个二元函数对象转变成一元函数对象</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;bind2nd结果:&quot;</span> &lt;&lt; endl;</span><br><span class="line">	for_each(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="built_in">bind2nd</span>(<span class="built_in">MyPrint</span>(), addNum));</span><br><span class="line">	<span class="comment">//bind1st bind2nd区别？</span></span><br><span class="line">	<span class="comment">//bind1st，将addNum绑定为函数对象的第一个参数</span></span><br><span class="line">	<span class="comment">//bind2nd，将addNum绑定为函数对象的第二个参数</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">bind1st结果:</span></span><br><span class="line"><span class="comment">v:200   val:0   v+val:200</span></span><br><span class="line"><span class="comment">v:200   val:1   v+val:201</span></span><br><span class="line"><span class="comment">v:200   val:2   v+val:202</span></span><br><span class="line"><span class="comment">bind2nd结果:</span></span><br><span class="line"><span class="comment">v:0   val:200   v+val:200</span></span><br><span class="line"><span class="comment">v:1   val:200   v+val:201</span></span><br><span class="line"><span class="comment">v:2   val:200   v+val:202</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h5 id="取反器-negator"><a href="#取反器-negator" class="headerlink" title="取反器(negator)"></a>取反器(negator)</h5><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">MyPrint02</span> &#123;</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">		cout &lt;&lt; v &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">MyCompare</span> :</span> <span class="keyword">public</span> binary_function&lt;<span class="keyword">int</span>, <span class="keyword">int</span>, <span class="keyword">bool</span>&gt; &#123;</span><br><span class="line">	<span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">int</span> v1, <span class="keyword">int</span> v2)</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> v1 &gt; v2;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">MyGreater5</span> :</span> <span class="keyword">public</span> binary_function&lt;<span class="keyword">int</span>, <span class="keyword">int</span>, <span class="keyword">bool</span>&gt; &#123;</span><br><span class="line">	<span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">int</span> v, <span class="keyword">int</span> val)</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;v:&quot;</span> &lt;&lt; v &lt;&lt; <span class="string">&quot; val:&quot;</span> &lt;&lt; val &lt;&lt; endl;</span><br><span class="line">		<span class="keyword">return</span> v &gt; val;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//仿函数适配器 not1 not2 取反适配器</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test02</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	vector&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">		v.<span class="built_in">push_back</span>(<span class="built_in">rand</span>()%<span class="number">100</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	for_each(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="built_in">MyPrint02</span>()); </span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">	<span class="built_in">sort</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="built_in">MyCompare</span>());</span><br><span class="line">	for_each(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="built_in">MyPrint02</span>());</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">	<span class="built_in">sort</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="built_in">not2</span>(<span class="built_in">MyCompare</span>()));</span><br><span class="line">	for_each(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="built_in">MyPrint02</span>());</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//not1 not2 </span></span><br><span class="line">	<span class="comment">//如果对二元谓词取反，用not2</span></span><br><span class="line">	<span class="comment">//如果对一元谓词取反，用not1</span></span><br><span class="line">	vector&lt;<span class="keyword">int</span>&gt;::iterator it = <span class="built_in">find_if</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="built_in">not1</span>(<span class="built_in">bind2nd</span>(<span class="built_in">MyGreater5</span>(), <span class="number">10</span>)));</span><br><span class="line">	<span class="keyword">if</span> (it == v.<span class="built_in">end</span>()) &#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;没有找到&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		cout &lt;&lt; *it &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="ptr-fun-op"><a href="#ptr-fun-op" class="headerlink" title="ptr_fun(op)"></a>ptr_fun(op)</h5><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MyPrint03</span><span class="params">(<span class="keyword">int</span> val, <span class="keyword">int</span> val2)</span> </span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;val1:&quot;</span> &lt;&lt; val &lt;&lt; <span class="string">&quot;   val2:&quot;</span> &lt;&lt; val2 &lt;&lt; <span class="string">&quot;   val + val2:&quot;</span>&lt;&lt;val + val2 &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test03</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	vector&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">		v.<span class="built_in">push_back</span>(i);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//ptr_func把普通函数转成函数对象</span></span><br><span class="line">	for_each(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="built_in">bind2nd</span>(<span class="built_in">ptr_fun</span>(MyPrint03), <span class="number">10</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">结果：</span></span><br><span class="line"><span class="comment">val1:0   val2:10   val + val2:10</span></span><br><span class="line"><span class="comment">val1:1   val2:10   val + val2:11</span></span><br><span class="line"><span class="comment">val1:2   val2:10   val + val2:12</span></span><br><span class="line"><span class="comment">val1:3   val2:10   val + val2:13</span></span><br><span class="line"><span class="comment">val1:4   val2:10   val + val2:14</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h5 id="成员函数适配器："><a href="#成员函数适配器：" class="headerlink" title="成员函数适配器："></a>成员函数适配器：</h5><p>mem_fun_ref、mem_fun</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Person</span>(<span class="keyword">int</span> age, <span class="keyword">int</span> id) :<span class="built_in">age</span>(age), <span class="built_in">id</span>(id) &#123;&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;age:&quot;</span> &lt;&lt; age &lt;&lt; <span class="string">&quot; id:&quot;</span> &lt;&lt; id &lt;&lt; <span class="string">&quot; aaa&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">int</span> age;</span><br><span class="line">	<span class="keyword">int</span> id;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test04</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//如果容器中存放的对象或者对象指针，我们for_each算法打印的时候，调用类自己提供的打印函数</span></span><br><span class="line"></span><br><span class="line">	vector&lt;Person&gt; v;</span><br><span class="line">	Person p1(10, 20), p2(30, 40), p3(50, 60);</span><br><span class="line">	v.<span class="built_in">push_back</span>(p1);</span><br><span class="line">	v.<span class="built_in">push_back</span>(p2);</span><br><span class="line">	v.<span class="built_in">push_back</span>(p3);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//格式: &amp;类名::函数名</span></span><br><span class="line">	for_each(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="built_in">mem_fun_ref</span>(&amp;Person::show));</span><br><span class="line"></span><br><span class="line">	vector&lt;Person*&gt; v1;</span><br><span class="line">	v1.<span class="built_in">push_back</span>(&amp;p1);</span><br><span class="line">	v1.<span class="built_in">push_back</span>(&amp;p2);</span><br><span class="line">	v1.<span class="built_in">push_back</span>(&amp;p3);</span><br><span class="line"></span><br><span class="line">	for_each(v1.<span class="built_in">begin</span>(), v1.<span class="built_in">end</span>(), <span class="built_in">mem_fun</span>(&amp;Person::show));</span><br><span class="line">	<span class="comment">//mem_fun_ref mem_fun区别?</span></span><br><span class="line">	<span class="comment">//如果存放的是对象指针 使用mem_fun</span></span><br><span class="line">	<span class="comment">//如果使用的是对象 使用mem_fun_ref</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">结果：</span></span><br><span class="line"><span class="comment">age:10 id:20 aaa</span></span><br><span class="line"><span class="comment">age:30 id:40 aaa</span></span><br><span class="line"><span class="comment">age:50 id:60 aaa</span></span><br><span class="line"><span class="comment">age:10 id:20 aaa</span></span><br><span class="line"><span class="comment">age:30 id:40 aaa</span></span><br><span class="line"><span class="comment">age:50 id:60 aaa</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>C++</category>
        <category>STL</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>STL</tag>
      </tags>
  </entry>
  <entry>
    <title>STL_迭代器</title>
    <url>/2021/05/07/STL%EF%BC%9A%E8%BF%AD%E4%BB%A3%E5%99%A8/</url>
    <content><![CDATA[<h3 id="一、迭代器基本原理"><a href="#一、迭代器基本原理" class="headerlink" title="一、迭代器基本原理"></a>一、迭代器基本原理</h3><p>&ensp;&ensp;&ensp;&ensp;迭代器是一个“可遍历STL容器内全部或部分元素”的对象。</p>
<span id="more"></span>

<p>&ensp;&ensp;&ensp;&ensp;迭代器指出容器中的一个特定位置。</p>
<p>&ensp;&ensp;&ensp;&ensp;迭代器就如同一个指针。</p>
<p>&ensp;&ensp;&ensp;&ensp;迭代器提供对一个容器中的对象的访问方法，并且可以定义了容器中对象的范围。</p>
<p><strong>迭代器的类别</strong>：</p>
<ul>
<li><p><strong>输入迭代器</strong>：也有叫法称之为“只读迭代器”，它从容器中读取元素，只能一次读入一个元素向前移动，只支持一遍算法，同一个输入迭代器不能两遍遍历一个序列。</p>
</li>
<li><p><strong>输出迭代器</strong>：也有叫法称之为“只写迭代器”，它往容器中写入元素，只能一次写入一个元素向前移动，只支持一遍算法，同一个输出迭代器不能两遍遍历一个序列。</p>
</li>
<li><p><strong>正向迭代器</strong>：组合输入迭代器和输出迭代器的功能，还可以多次解析一个迭代器指定的位置，可以对一个值进行多次读/写。</p>
</li>
<li><p><strong>双向迭代器</strong>：组合正向迭代器的功能，还可以通过–操作符向后移动位置。</p>
</li>
<li><p><strong>随机访问迭代器</strong>：组合双向迭代器的功能，还可以向前向后跳过任意个位置，可以直接访问容器中任何位置的元素。</p>
</li>
</ul>
<p>目前本系列教程所用到的容器，都支持双向迭代器或随机访问迭代器，下面将会详细介绍这两个类别的迭代器。</p>
<h3 id="二、双向迭代器与随机访问迭代器"><a href="#二、双向迭代器与随机访问迭代器" class="headerlink" title="二、双向迭代器与随机访问迭代器"></a>二、双向迭代器与随机访问迭代器</h3><p>&ensp;&ensp;&ensp;&ensp;双向迭代器支持的操作：it++, ++it,  it–,  –it，*it， itA = itB，itA == itB，itA != itB，其中list,set,multiset,map,multimap支持双向迭代器。</p>
<p>&ensp;&ensp;&ensp;&ensp;随机访问迭代器支持的操作：在双向迭代器的操作基础上添加it+=i， it-=i， it+i(或it=it+i)，it[i],itA&lt;itB,  itA&lt;=itB, itA&gt;itB, itA&gt;=itB 的功能。其中vector，deque支持随机访问迭代器。</p>
<h3 id="三、vector与迭代器的配合使用"><a href="#三、vector与迭代器的配合使用" class="headerlink" title="三、vector与迭代器的配合使用"></a>三、vector与迭代器的配合使用</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">vector&lt;<span class="keyword">int</span>&gt; vecInt; <span class="comment">//假设包含1,3,5,7,9元素</span></span><br><span class="line"></span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt;::iterator it;      <span class="comment">//声明容器vector&lt;int&gt;的迭代器。</span></span><br><span class="line"></span><br><span class="line">it = vecInt.<span class="built_in">begin</span>();  <span class="comment">// *it == 1</span></span><br><span class="line"></span><br><span class="line">++it;             <span class="comment">//或者it++; *it == 3 ，前++的效率比后++的效率高，前++返回引用，后++返回值。</span></span><br><span class="line"></span><br><span class="line">it += <span class="number">2</span>;       <span class="comment">//*it == 7</span></span><br><span class="line"></span><br><span class="line">it = it+<span class="number">1</span>;      <span class="comment">//*it == 9</span></span><br><span class="line"></span><br><span class="line">++it;             <span class="comment">// it == vecInt.end(); 此时不能再执行*it,会出错!</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//正向遍历：</span></span><br><span class="line"><span class="keyword">for</span>(vector&lt;<span class="keyword">int</span>&gt;::iterator it=vecInt.<span class="built_in">begin</span>(); it!=vecInt.<span class="built_in">end</span>(); ++it)&#123;</span><br><span class="line">   	<span class="keyword">int</span> iItem = *it; </span><br><span class="line">	cout &lt;&lt; iItem;  <span class="comment">//或直接使用 cout &lt;&lt; *it;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//这样子便打印出1 3 5 7 9</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//逆向遍历：</span></span><br><span class="line"><span class="keyword">for</span>(vector&lt;<span class="keyword">int</span>&gt;::reverse_iterator rit=vecInt.<span class="built_in">rbegin</span>(); rit!=vecInt.<span class="built_in">rend</span>(); ++rit)  <span class="comment">//注意，小括号内仍是++rit</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="keyword">int</span> iItem = *rit;</span><br><span class="line">   cout &lt;&lt; iItem;   <span class="comment">//或直接使用cout &lt;&lt; *rit;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//此时将打印出9,7,5,3,1</span></span><br></pre></td></tr></table></figure>

<p>&ensp;&ensp;&ensp;&ensp;注意，这里迭代器的声明采用vector&lt;int&gt;::reverse_iterator，而非vector&lt;int&gt;::iterator。 </p>
<p>迭代器还有其它两种声明方法：</p>
<ul>
<li>vector&lt;int&gt;::const_iterator </li>
<li>vector&lt;int&gt;::const_reverse_iterator</li>
</ul>
<p>&ensp;&ensp;&ensp;&ensp; 以上两种分别是vector&lt;int&gt;::iterator 与vector&lt;int&gt;::reverse_iterator 的只读形式，使用这两种迭代器时，不会修改到容器中的值。</p>
<p>&ensp;&ensp;&ensp;&ensp;备注：不过容器中的insert和erase方法仅接受这四种类型中的iterator，其它三种不支持。《Effective STL》建议我们尽量使用iterator取代const_iterator、reverse_iterator和const_reverse_iterator。 </p>
]]></content>
      <categories>
        <category>C++</category>
        <category>STL</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>STL</tag>
        <tag>STL迭代器</tag>
      </tags>
  </entry>
  <entry>
    <title>STL_打分案例</title>
    <url>/2021/05/07/STL%EF%BC%9A%E6%89%93%E5%88%86%E6%A1%88%E4%BE%8B/</url>
    <content><![CDATA[<p>评委打分案例(sort 算法排序)</p>
<ul>
<li>创建 5 个选手(姓名，得分) ， 10 个评委对 5 个选手进行打分</li>
<li>得分规则：去除最高分，去除最低分，取出平均分</li>
<li>按得分对 5 名选手进行排名</li>
</ul>
<span id="more"></span>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _CRT_SECURE_NO_WARNINGS</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PLAYER_NUMBER 5</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;deque&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//选手类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Player</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Player</span>() &#123;&#125;;</span><br><span class="line">	<span class="built_in">Player</span>(string name, <span class="keyword">int</span> score)&#123;</span><br><span class="line">		<span class="keyword">this</span>-&gt;name = name;</span><br><span class="line">		<span class="keyword">this</span>-&gt;score = score;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function">string <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">this</span>-&gt;name;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">setName</span><span class="params">(string name)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>-&gt;name = name;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">getScore</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">this</span>-&gt;score;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">setScore</span><span class="params">(<span class="keyword">int</span> score)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>-&gt;score = score;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	string name;</span><br><span class="line">	<span class="keyword">int</span> score;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">creat_player</span><span class="params">(vector&lt;Player&gt; &amp;player_vector,<span class="keyword">int</span> number)</span> </span>&#123;</span><br><span class="line">	string name_seed = <span class="string">&quot;ABCDE&quot;</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; number; i++) &#123;</span><br><span class="line">		Player player;</span><br><span class="line">		string tmp = name_seed.<span class="built_in">substr</span>(i,<span class="number">1</span>);</span><br><span class="line">		player.<span class="built_in">setName</span>(<span class="string">&quot;选手&quot;</span>+tmp);</span><br><span class="line">		player.<span class="built_in">setScore</span>(<span class="number">0</span>);</span><br><span class="line">		player_vector.<span class="built_in">push_back</span>(player);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">set_score</span><span class="params">(vector&lt;Player&gt;&amp; player_vector)</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">srand</span>(<span class="built_in">time</span>(<span class="literal">nullptr</span>));</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (vector&lt;Player&gt;::iterator it=player_vector.<span class="built_in">begin</span>();it!=player_vector.<span class="built_in">end</span>();it++) &#123;</span><br><span class="line">		</span><br><span class="line">		deque&lt;<span class="keyword">int</span>&gt; player_score_list;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;<span class="number">10</span>;i++) &#123;</span><br><span class="line">			<span class="keyword">int</span> score = <span class="built_in">rand</span>() % <span class="number">41</span> + <span class="number">60</span>;</span><br><span class="line">			player_score_list.<span class="built_in">push_back</span>(score);</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="built_in">sort</span>(player_score_list.<span class="built_in">begin</span>(),player_score_list.<span class="built_in">end</span>());</span><br><span class="line">		</span><br><span class="line">		player_score_list.<span class="built_in">pop_back</span>();</span><br><span class="line">		player_score_list.<span class="built_in">pop_front</span>();</span><br><span class="line"></span><br><span class="line">		<span class="keyword">int</span> total_score = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (deque&lt;<span class="keyword">int</span>&gt;::iterator dit = player_score_list.<span class="built_in">begin</span>(); dit != player_score_list.<span class="built_in">end</span>(); dit++) &#123;</span><br><span class="line">			total_score += (*dit);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">int</span> avg_score = total_score / player_score_list.<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line">		(*it).<span class="built_in">setScore</span>(avg_score);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">mycompare</span><span class="params">(Player&amp; p1, Player&amp; p2)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> p1.<span class="built_in">getScore</span>() &gt; p2.<span class="built_in">getScore</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print_rank</span><span class="params">(vector&lt;Player&gt;&amp; player_vector)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">sort</span>(player_vector.<span class="built_in">begin</span>(),player_vector.<span class="built_in">end</span>(),mycompare);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (vector&lt;Player&gt;::iterator it = player_vector.<span class="built_in">begin</span>(); it != player_vector.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line"></span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;姓名：&quot;</span>&lt;&lt;(*it).<span class="built_in">getName</span>()&lt;&lt;<span class="string">&quot;  得分：&quot;</span>&lt;&lt;(*it).<span class="built_in">getScore</span>()&lt;&lt;endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	vector&lt;Player&gt; player_vector;</span><br><span class="line">	<span class="built_in">creat_player</span>(player_vector,PLAYER_NUMBER);</span><br><span class="line">	<span class="built_in">set_score</span>(player_vector);</span><br><span class="line">	<span class="built_in">print_rank</span>(player_vector);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>C++</category>
        <category>STL</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>STL</tag>
        <tag>STL案例</tag>
      </tags>
  </entry>
  <entry>
    <title>STL_常用的算法</title>
    <url>/2021/05/07/STL%EF%BC%9A%E5%B8%B8%E7%94%A8%E7%9A%84%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<p>&ensp;&ensp;&ensp;&ensp;总结了常用的算法并举例。</p>
<span id="more"></span>

<h3 id="一、常用的查找算法"><a href="#一、常用的查找算法" class="headerlink" title="一、常用的查找算法"></a>一、常用的查找算法</h3><h4 id="adjacent-find"><a href="#adjacent-find" class="headerlink" title="adjacent_find()"></a>adjacent_find()</h4><p>&ensp;&ensp;&ensp;&ensp;adjacent_find(iterator beg, iterator end, _callback);</p>
<p>&ensp;&ensp;&ensp;&ensp;在iterator对标识元素范围内，查找一对相邻重复元素，找到则返回指向这对元素的第一个元素的迭代器。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">vector&lt;<span class="keyword">int</span>&gt; vecInt;</span><br><span class="line">vecInt.<span class="built_in">push_back</span>(<span class="number">1</span>);</span><br><span class="line">vecInt.<span class="built_in">push_back</span>(<span class="number">2</span>);</span><br><span class="line">   vecInt.<span class="built_in">push_back</span>(<span class="number">2</span>);</span><br><span class="line">   vecInt.<span class="built_in">push_back</span>(<span class="number">4</span>);</span><br><span class="line">   vecInt.<span class="built_in">push_back</span>(<span class="number">5</span>);</span><br><span class="line">vecInt.<span class="built_in">push_back</span>(<span class="number">5</span>);</span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt;::iterator it = <span class="built_in">adjacent_find</span>(vecInt.<span class="built_in">begin</span>(), vecInt.<span class="built_in">end</span>()); </span><br><span class="line">   <span class="comment">//*it = 2</span></span><br></pre></td></tr></table></figure>



<h4 id="binary-search（）"><a href="#binary-search（）" class="headerlink" title="binary_search（）"></a>binary_search（）</h4><p>&ensp;&ensp;&ensp;&ensp;bool binary_search(iterator beg, iterator end, value);</p>
<p>&ensp;&ensp;&ensp;&ensp;在有序序列中查找value,找到则返回true。注意：在无序序列中，不可使用。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">set&lt;<span class="keyword">int</span>&gt; setInt;</span><br><span class="line">setInt.<span class="built_in">insert</span>(<span class="number">3</span>);</span><br><span class="line">   setInt.<span class="built_in">insert</span>(<span class="number">1</span>);</span><br><span class="line">setInt.<span class="built_in">insert</span>(<span class="number">7</span>);</span><br><span class="line">setInt.<span class="built_in">insert</span>(<span class="number">5</span>);</span><br><span class="line">setInt.<span class="built_in">insert</span>(<span class="number">9</span>);</span><br><span class="line"><span class="keyword">bool</span> bFind = <span class="built_in">binary_search</span>(setInt.<span class="built_in">begin</span>(), setInt.<span class="built_in">end</span>(), <span class="number">5</span>);<span class="comment">//nFind=true</span></span><br></pre></td></tr></table></figure>



<h4 id="count"><a href="#count" class="headerlink" title="count()"></a>count()</h4><p>&ensp;&ensp;&ensp;&ensp;count(iterator beg, iterator end, value);</p>
<p>&ensp;&ensp;&ensp;&ensp;利用等于操作符，把标志范围内的元素与输入值比较，返回相等的个数。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">vector&lt;<span class="keyword">int</span>&gt; vecInt;</span><br><span class="line">vecInt.<span class="built_in">push_back</span>(<span class="number">1</span>);</span><br><span class="line">vecInt.<span class="built_in">push_back</span>(<span class="number">2</span>);</span><br><span class="line">vecInt.<span class="built_in">push_back</span>(<span class="number">2</span>);</span><br><span class="line">vecInt.<span class="built_in">push_back</span>(<span class="number">4</span>);</span><br><span class="line">vecInt.<span class="built_in">push_back</span>(<span class="number">2</span>);</span><br><span class="line">vecInt.<span class="built_in">push_back</span>(<span class="number">5</span>);</span><br><span class="line"><span class="keyword">int</span> iCount = <span class="built_in">count</span>(vecInt.<span class="built_in">begin</span>(),vecInt.<span class="built_in">end</span>(),<span class="number">2</span>);  <span class="comment">//iCount==3</span></span><br></pre></td></tr></table></figure>

<p>​    </p>
<h4 id="count-if"><a href="#count-if" class="headerlink" title="count_if()"></a>count_if()</h4><p>&ensp;&ensp;&ensp;&ensp;count_if(首迭代器，未迭代器，搜索值（要比较的值的结果）)(条件计数)</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//假设vector&lt;int&gt; vecIntA，vecIntA包含1,3,5,7,9元素</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//先定义比较函数</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">GreaterThree</span><span class="params">(<span class="keyword">int</span> iNum)</span></span>&#123;</span><br><span class="line">     <span class="keyword">if</span>(iNum&gt;=<span class="number">3</span>)&#123;</span><br><span class="line">     	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">else</span>&#123;</span><br><span class="line">	    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">     &#125;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> iCount = <span class="built_in">count_if</span>(vecIntA.<span class="built_in">begin</span>(), vecIntA.<span class="built_in">end</span>(), GreaterThree);</span><br><span class="line"><span class="comment">//此时iCount == 4</span></span><br></pre></td></tr></table></figure>



<h4 id="find"><a href="#find" class="headerlink" title="find()"></a>find()</h4><p>&ensp;&ensp;&ensp;&ensp;find(iterator beg, iterator end, value)</p>
<p>&ensp;&ensp;&ensp;&ensp;find: 利用底层元素的等于操作符，对指定范围内的元素与输入值进行比较。当匹配时，结束搜索，返回该元素的迭代器。 </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">vector&lt;<span class="keyword">int</span>&gt; vecInt;</span><br><span class="line">vecInt.<span class="built_in">push_back</span>(<span class="number">1</span>);</span><br><span class="line">vecInt.<span class="built_in">push_back</span>(<span class="number">3</span>);</span><br><span class="line">vecInt.<span class="built_in">push_back</span>(<span class="number">5</span>);</span><br><span class="line">vecInt.<span class="built_in">push_back</span>(<span class="number">7</span>);</span><br><span class="line">vecInt.<span class="built_in">push_back</span>(<span class="number">9</span>);</span><br><span class="line"></span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt;::iterator it = <span class="built_in">find</span>(vecInt.<span class="built_in">begin</span>(), vecInt.<span class="built_in">end</span>(), <span class="number">5</span>);        <span class="comment">//*it == 5</span></span><br></pre></td></tr></table></figure>



<h4 id="find-if"><a href="#find-if" class="headerlink" title="find_if()"></a>find_if()</h4><p>&ensp;&ensp;&ensp;&ensp;find_if(iterator beg, iterator end, _callback);（条件查找）</p>
<p>&ensp;&ensp;&ensp;&ensp;find_if:  使用输入的函数代替等于操作符执行find。返回被找到的元素的迭代器。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//假设vector&lt;int&gt; vecIntA，vecIntA包含1,3,5,3,9元素 </span></span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt;::it = <span class="built_in">find_if</span>(vecInt.<span class="built_in">begin</span>(),vecInt.<span class="built_in">end</span>(),GreaterThree);</span><br><span class="line"><span class="comment">//此时 *it==3, *(it+1)==5, *(it+2)==3, *(it+3)==9 </span></span><br></pre></td></tr></table></figure>



<h3 id="二、常用的排序算法"><a href="#二、常用的排序算法" class="headerlink" title="二、常用的排序算法"></a>二、常用的排序算法</h3><h4 id="merge"><a href="#merge" class="headerlink" title="merge()"></a>merge()</h4><p>&ensp;&ensp;&ensp;&ensp;以下是排序和通用算法：提供元素排序策略</p>
<p>&ensp;&ensp;&ensp;&ensp;merge:  合并两个有序序列，存放到另一个序列。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//例如：vecIntA,vecIntB,vecIntC是用vector\&lt;int&gt;声明的容器，vecIntA已包含1,3,5,7,9元素，vecIntB已包含2,4,6,8元素</span></span><br><span class="line">vecIntC.<span class="built_in">resize</span>(<span class="number">9</span>); <span class="comment">//扩大容量</span></span><br><span class="line"><span class="built_in">merge</span>(vecIntA.<span class="built_in">begin</span>(),vecIntA.<span class="built_in">end</span>(),vecIntB.<span class="built_in">begin</span>(),vecIntB.<span class="built_in">end</span>(),vecIntC.<span class="built_in">begin</span>());</span><br><span class="line"><span class="comment">//此时vecIntC就存放了按顺序的1,2,3,4,5,6,7,8,9九个元素</span></span><br></pre></td></tr></table></figure>



<h4 id="sort"><a href="#sort" class="headerlink" title="sort()"></a>sort()</h4><p>&ensp;&ensp;&ensp;&ensp;sort: 以默认升序的方式重新排列指定范围内的元素。若要改排序规则，可以输入比较函数。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//学生类</span></span><br><span class="line">Class CStudent:</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">CStudent</span>(<span class="keyword">int</span> iID, string strName)</span><br><span class="line">    &#123;</span><br><span class="line">		m_iID=iID; </span><br><span class="line">		m_strName=strName; </span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">public</span>:      </span><br><span class="line">    <span class="keyword">int</span> m_iID;</span><br><span class="line">    string m_strName;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//学号比较函数</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Compare</span><span class="params">(<span class="keyword">const</span> CStudent &amp;stuA,<span class="keyword">const</span> CStudent &amp;stuB)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> (stuA.m_iID&lt;strB.m_iID);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;CStudent&gt; vecStu;</span><br><span class="line">    vecStu.<span class="built_in">push_back</span>(<span class="built_in">CStudent</span>(<span class="number">2</span>,<span class="string">&quot;老二&quot;</span>));</span><br><span class="line">	vecStu.<span class="built_in">push_back</span>(<span class="built_in">CStudent</span>(<span class="number">1</span>,<span class="string">&quot;老大&quot;</span>));</span><br><span class="line">	vecStu.<span class="built_in">push_back</span>(<span class="built_in">CStudent</span>(<span class="number">3</span>,<span class="string">&quot;老三&quot;</span>));</span><br><span class="line">	vecStu.<span class="built_in">push_back</span>(<span class="built_in">CStudent</span>(<span class="number">4</span>,<span class="string">&quot;老四&quot;</span>));</span><br><span class="line">	<span class="built_in">sort</span>(vecStu.<span class="built_in">begin</span>(),vecStu.<span class="built_in">end</span>(),Compare);</span><br><span class="line">	<span class="comment">// 此时，vecStu容器包含了按顺序的&quot;老大对象&quot;,&quot;老二对象&quot;,&quot;老三对象&quot;,&quot;老四对象&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="random-shuffle"><a href="#random-shuffle" class="headerlink" title="random_shuffle()"></a>random_shuffle()</h4><p>&ensp;&ensp;&ensp;&ensp;random_shuffle:   对指定范围内的元素随机调整次序。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">srand</span>(<span class="built_in">time</span>(<span class="number">0</span>));             <span class="comment">//设置随机种子</span></span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; vecInt;</span><br><span class="line">vecInt.<span class="built_in">push_back</span>(<span class="number">1</span>);</span><br><span class="line">vecInt.<span class="built_in">push_back</span>(<span class="number">3</span>);</span><br><span class="line">vecInt.<span class="built_in">push_back</span>(<span class="number">5</span>);</span><br><span class="line">vecInt.<span class="built_in">push_back</span>(<span class="number">7</span>);</span><br><span class="line">vecInt.<span class="built_in">push_back</span>(<span class="number">9</span>);</span><br><span class="line"><span class="function">string <span class="title">str</span><span class="params">(<span class="string">&quot;itcastitcast &quot;</span>)</span></span>;</span><br><span class="line"><span class="built_in">random_shuffle</span>(vecInt.<span class="built_in">begin</span>(), vecInt.<span class="built_in">end</span>());  <span class="comment">//随机排序，结果比如：9,7,1,5,3</span></span><br><span class="line"><span class="built_in">random_shuffle</span>(str.<span class="built_in">begin</span>(), str.<span class="built_in">end</span>());        <span class="comment">//随机排序，结果比如：&quot; itstcasticat &quot;</span></span><br></pre></td></tr></table></figure>



<h4 id="reverse"><a href="#reverse" class="headerlink" title="reverse()"></a>reverse()</h4><p>&ensp;&ensp;&ensp;&ensp;reverse：反转指定范围的元素</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">vector&lt;<span class="keyword">int</span>&gt; vecInt;</span><br><span class="line">vecInt.<span class="built_in">push_back</span>(<span class="number">1</span>);</span><br><span class="line">vecInt.<span class="built_in">push_back</span>(<span class="number">3</span>);</span><br><span class="line">vecInt.<span class="built_in">push_back</span>(<span class="number">5</span>);</span><br><span class="line">vecInt.<span class="built_in">push_back</span>(<span class="number">7</span>);</span><br><span class="line">vecInt.<span class="built_in">push_back</span>(<span class="number">9</span>);</span><br><span class="line"><span class="built_in">reverse</span>(vecInt.<span class="built_in">begin</span>(), vecInt.<span class="built_in">end</span>());       <span class="comment">//&#123;9,7,5,3,1&#125;</span></span><br></pre></td></tr></table></figure>



<h3 id="三、常用的拷贝和替换算法"><a href="#三、常用的拷贝和替换算法" class="headerlink" title="三、常用的拷贝和替换算法"></a>三、常用的拷贝和替换算法</h3><h4 id="copy"><a href="#copy" class="headerlink" title="copy()"></a>copy()</h4><p>&ensp;&ensp;&ensp;&ensp;copy算法 将容器内指定范围的元素拷贝到另一容器中</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">vector&lt;<span class="keyword">int</span>&gt; vecIntA;</span><br><span class="line">vecIntA.<span class="built_in">push_back</span>(<span class="number">1</span>);</span><br><span class="line">vecIntA.<span class="built_in">push_back</span>(<span class="number">3</span>);</span><br><span class="line">vecIntA.<span class="built_in">push_back</span>(<span class="number">5</span>);</span><br><span class="line">vecIntA.<span class="built_in">push_back</span>(<span class="number">7</span>);</span><br><span class="line">vecIntA.<span class="built_in">push_back</span>(<span class="number">9</span>);</span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; vecIntB;</span><br><span class="line">vecIntB.<span class="built_in">resize</span>(<span class="number">5</span>);           <span class="comment">//扩大空间</span></span><br><span class="line"><span class="built_in">copy</span>(vecIntA.<span class="built_in">begin</span>(), vecIntA.<span class="built_in">end</span>(), vecIntB.<span class="built_in">begin</span>());  <span class="comment">//vecIntB: &#123;1,3,5,7,9&#125;</span></span><br></pre></td></tr></table></figure>



<h4 id="replace"><a href="#replace" class="headerlink" title="replace()"></a>replace()</h4><p>&ensp;&ensp;&ensp;&ensp;replace(beg,end,oldValue,newValue):  将指定范围内的所有等于oldValue的元素替换成newValue。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">vector&lt;<span class="keyword">int</span>&gt; vecIntA;</span><br><span class="line">vecIntA.<span class="built_in">push_back</span>(<span class="number">1</span>);</span><br><span class="line">vecIntA.<span class="built_in">push_back</span>(<span class="number">3</span>);</span><br><span class="line">vecIntA.<span class="built_in">push_back</span>(<span class="number">5</span>);</span><br><span class="line">vecIntA.<span class="built_in">push_back</span>(<span class="number">3</span>);</span><br><span class="line">vecIntA.<span class="built_in">push_back</span>(<span class="number">9</span>);</span><br><span class="line"><span class="built_in">replace</span>(vecIntA.<span class="built_in">begin</span>(), vecIntA.<span class="built_in">end</span>(), <span class="number">3</span>, <span class="number">8</span>);     <span class="comment">//&#123;1,8,5,8,9&#125;</span></span><br></pre></td></tr></table></figure>



<h4 id="replace-if"><a href="#replace-if" class="headerlink" title="replace_if()"></a>replace_if()</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	replace_if算法 将容器内指定范围满足条件的元素替换为新元素</span></span><br><span class="line"><span class="comment">	@param beg 容器开始迭代器</span></span><br><span class="line"><span class="comment">	@param end 容器结束迭代器</span></span><br><span class="line"><span class="comment">	@param callback函数回调或者谓词(返回Bool类型的函数对象)</span></span><br><span class="line"><span class="comment">	@param oldvalue 新元素</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="built_in">replace_if</span>(iterator beg, iterator end, _callback, newvalue)</span><br></pre></td></tr></table></figure>

<p>&ensp;&ensp;&ensp;&ensp;replace_if : 将指定范围内所有操作结果为true的元素用新值替换。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//把大于等于3的元素替换成8</span></span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; vecIntA;</span><br><span class="line">vecIntA.<span class="built_in">push_back</span>(<span class="number">1</span>);</span><br><span class="line">vecIntA.<span class="built_in">push_back</span>(<span class="number">3</span>);</span><br><span class="line">vecIntA.<span class="built_in">push_back</span>(<span class="number">5</span>);</span><br><span class="line">vecIntA.<span class="built_in">push_back</span>(<span class="number">3</span>);</span><br><span class="line">vecIntA.<span class="built_in">push_back</span>(<span class="number">9</span>);</span><br><span class="line"><span class="built_in">replace_if</span>(vecIntA.<span class="built_in">begin</span>(), vecIntA.<span class="built_in">end</span>(), GreaterThree, <span class="number">8</span>);     <span class="comment">// GreaterThree的定义在上面。</span></span><br></pre></td></tr></table></figure>



<h4 id="swap"><a href="#swap" class="headerlink" title="swap()"></a>swap()</h4><p>&ensp;&ensp;&ensp;&ensp;swap:  交换两个容器的元素</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">vector&lt;<span class="keyword">int</span>&gt; vecIntA;</span><br><span class="line">vecIntA.<span class="built_in">push_back</span>(<span class="number">1</span>);</span><br><span class="line">vecIntA.<span class="built_in">push_back</span>(<span class="number">3</span>);</span><br><span class="line">vecIntA.<span class="built_in">push_back</span>(<span class="number">5</span>);</span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; vecIntB;</span><br><span class="line">vecIntB.<span class="built_in">push_back</span>(<span class="number">2</span>);</span><br><span class="line">vecIntB.<span class="built_in">push_back</span>(<span class="number">4</span>);</span><br><span class="line"><span class="built_in">swap</span>(vecIntA, vecIntB); <span class="comment">//交换</span></span><br></pre></td></tr></table></figure>



<h3 id="四、常用的算术和生成算法"><a href="#四、常用的算术和生成算法" class="headerlink" title="四、常用的算术和生成算法"></a>四、常用的算术和生成算法</h3><h4 id="accumulate"><a href="#accumulate" class="headerlink" title="accumulate()"></a>accumulate()</h4><p>&ensp;&ensp;&ensp;&ensp;accumulate: 对指定范围内的元素求和，然后结果再加上一个由val指定的初始值。</p>
<p>    #include&lt;numeric&gt;</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">vector&lt;<span class="keyword">int</span>&gt; vecIntA;</span><br><span class="line">vecIntA.<span class="built_in">push_back</span>(<span class="number">1</span>);</span><br><span class="line">vecIntA.<span class="built_in">push_back</span>(<span class="number">3</span>);</span><br><span class="line">vecIntA.<span class="built_in">push_back</span>(<span class="number">5</span>);</span><br><span class="line">vecIntA.<span class="built_in">push_back</span>(<span class="number">7</span>);</span><br><span class="line">vecIntA.<span class="built_in">push_back</span>(<span class="number">9</span>);</span><br><span class="line"><span class="keyword">int</span> iSum = <span class="built_in">accumulate</span>(vecIntA.<span class="built_in">begin</span>(), vecIntA.<span class="built_in">end</span>(), <span class="number">100</span>);     <span class="comment">//iSum==125</span></span><br></pre></td></tr></table></figure>



<h4 id="fill"><a href="#fill" class="headerlink" title="fill()"></a>fill()</h4><p>    fill:  将输入值赋给标志范围内的所有元素。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">vector&lt;<span class="keyword">int</span>&gt; vecIntA;</span><br><span class="line">vecIntA.<span class="built_in">push_back</span>(<span class="number">1</span>);</span><br><span class="line">vecIntA.<span class="built_in">push_back</span>(<span class="number">3</span>);</span><br><span class="line">vecIntA.<span class="built_in">push_back</span>(<span class="number">5</span>);</span><br><span class="line">vecIntA.<span class="built_in">push_back</span>(<span class="number">7</span>);</span><br><span class="line">vecIntA.<span class="built_in">push_back</span>(<span class="number">9</span>);</span><br><span class="line"><span class="built_in">fill</span>(vecIntA.<span class="built_in">begin</span>(), vecIntA.<span class="built_in">end</span>(), <span class="number">8</span>);       <span class="comment">//8, 8, 8, 8, 8</span></span><br></pre></td></tr></table></figure>



<h3 id="五、常用的集合算法"><a href="#五、常用的集合算法" class="headerlink" title="五、常用的集合算法"></a>五、常用的集合算法</h3><h4 id="set-union-set-intersection-set-difference"><a href="#set-union-set-intersection-set-difference" class="headerlink" title="set_union(),set_intersection(),set_difference()"></a>set_union(),set_intersection(),set_difference()</h4><p>    set_union: 构造一个有序序列，包含两个有序序列的并集。</p>
<p>    set_intersection: 构造一个有序序列，包含两个有序序列的交集。</p>
<p>    set_difference: 构造一个有序序列，该序列保留第一个有序序列中存在而第二个有序序列中不存在的元素。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">vector&lt;<span class="keyword">int</span>&gt; vecIntA;</span><br><span class="line">vecIntA.<span class="built_in">push_back</span>(<span class="number">1</span>);</span><br><span class="line">vecIntA.<span class="built_in">push_back</span>(<span class="number">3</span>);</span><br><span class="line">vecIntA.<span class="built_in">push_back</span>(<span class="number">5</span>);</span><br><span class="line">vecIntA.<span class="built_in">push_back</span>(<span class="number">7</span>);</span><br><span class="line">vecIntA.<span class="built_in">push_back</span>(<span class="number">9</span>);</span><br><span class="line"> </span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; vecIntB;</span><br><span class="line">vecIntB.<span class="built_in">push_back</span>(<span class="number">1</span>);</span><br><span class="line">vecIntB.<span class="built_in">push_back</span>(<span class="number">3</span>);</span><br><span class="line">vecIntB.<span class="built_in">push_back</span>(<span class="number">5</span>);</span><br><span class="line">vecIntB.<span class="built_in">push_back</span>(<span class="number">6</span>);</span><br><span class="line">vecIntB.<span class="built_in">push_back</span>(<span class="number">8</span>);</span><br><span class="line"></span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; vecIntC;</span><br><span class="line">vecIntC.<span class="built_in">resize</span>(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//并集</span></span><br><span class="line"><span class="built_in">set_union</span>(vecIntA.<span class="built_in">begin</span>(), vecIntA.<span class="built_in">end</span>(), vecIntB.<span class="built_in">begin</span>(), vecIntB.<span class="built_in">end</span>(), vecIntC.<span class="built_in">begin</span>());       </span><br><span class="line"><span class="comment">//vecIntC : &#123;1,3,5,6,7,8,9,0,0,0&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//交集</span></span><br><span class="line"><span class="built_in">fill</span>(vecIntC.<span class="built_in">begin</span>(),vecIntC.<span class="built_in">end</span>(),<span class="number">0</span>);</span><br><span class="line"><span class="built_in">set_intersection</span>(vecIntA.<span class="built_in">begin</span>(), vecIntA.<span class="built_in">end</span>(), vecIntB.<span class="built_in">begin</span>(), vecIntB.<span class="built_in">end</span>(), vecIntC.<span class="built_in">begin</span>());   </span><br><span class="line"><span class="comment">//vecIntC: &#123;1,3,5,0,0,0,0,0,0,0&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//差集</span></span><br><span class="line"><span class="built_in">fill</span>(vecIntC.<span class="built_in">begin</span>(),vecIntC.<span class="built_in">end</span>(),<span class="number">0</span>);</span><br><span class="line"><span class="built_in">set_difference</span>(vecIntA.<span class="built_in">begin</span>(), vecIntA.<span class="built_in">end</span>(), vecIntB.<span class="built_in">begin</span>(), vecIntB.<span class="built_in">end</span>(), vecIntC.<span class="built_in">begin</span>());     </span><br><span class="line"><span class="comment">//vecIntC: &#123;7,9,0,0,0,0,0,0,0,0&#125;</span></span><br></pre></td></tr></table></figure>



<h3 id="六、常用的遍历算法"><a href="#六、常用的遍历算法" class="headerlink" title="六、常用的遍历算法"></a>六、常用的遍历算法</h3><h4 id="for-each"><a href="#for-each" class="headerlink" title="for_each()"></a>for_each()</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    遍历算法 遍历容器元素</span></span><br><span class="line"><span class="comment">	@param beg 开始迭代器</span></span><br><span class="line"><span class="comment">	@param end 结束迭代器</span></span><br><span class="line"><span class="comment">	@param _callback  函数回调或者函数对象</span></span><br><span class="line"><span class="comment">	@return 函数对象</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">for_each(iterator beg, iterator end, _callback);</span><br></pre></td></tr></table></figure>

<p>for_each: 用指定函数依次对指定范围内所有元素进行迭代访问。该函数不得修改序列中的元素。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> &amp;iItem)</span></span>&#123;</span><br><span class="line">    cout &lt;&lt; iItem;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">main</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> iArray[] = &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;;</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">vecInt</span><span class="params">(iArray,iArray+<span class="keyword">sizeof</span>(iArray)/<span class="keyword">sizeof</span>(iArray[<span class="number">0</span>]))</span></span>;</span><br><span class="line">	for_each(vecInt.<span class="built_in">begin</span>(), vecInt.<span class="built_in">end</span>(), show);</span><br><span class="line"><span class="comment">//结果打印出0 1 2 3 4</span></span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>



<h4 id="transform"><a href="#transform" class="headerlink" title="transform()"></a>transform()</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	transform算法 将指定容器区间元素搬运到另一容器中</span></span><br><span class="line"><span class="comment">	注意 : transform 不会给目标容器分配内存，所以需要我们提前分配好内存</span></span><br><span class="line"><span class="comment">	@param beg1 源容器开始迭代器</span></span><br><span class="line"><span class="comment">	@param end1 源容器结束迭代器</span></span><br><span class="line"><span class="comment">	@param beg2 目标容器开始迭代器</span></span><br><span class="line"><span class="comment">	@param _cakkback 回调函数或者函数对象</span></span><br><span class="line"><span class="comment">	@return 返回目标容器迭代器</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="built_in">transform</span>(iterator beg1, iterator end1, iterator beg2, _callbakc)</span><br></pre></td></tr></table></figure>

<p>    transform:  与for_each类似，遍历所有元素，但可对容器的元素进行修改</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">increase</span> <span class="params">(<span class="keyword">int</span> i)</span></span>&#123; </span><br><span class="line">    <span class="keyword">return</span> i+<span class="number">1</span>;  </span><br><span class="line">&#125; </span><br><span class="line"><span class="built_in">main</span>()</span><br><span class="line">&#123;</span><br><span class="line">	vector&lt;<span class="keyword">int</span>&gt; vecIntA;</span><br><span class="line">    vecIntA.<span class="built_in">push_back</span>(<span class="number">1</span>)；</span><br><span class="line">    vecIntA.<span class="built_in">push_back</span>(<span class="number">3</span>);</span><br><span class="line">	vecIntA.<span class="built_in">push_back</span>(<span class="number">5</span>);</span><br><span class="line">    vecIntA.<span class="built_in">push_back</span>(<span class="number">7</span>);</span><br><span class="line">    vecIntA.<span class="built_in">push_back</span>(<span class="number">9</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">transform</span>(vecIntA.<span class="built_in">begin</span>(),vecIntA.<span class="built_in">end</span>(),vecIntA.<span class="built_in">begin</span>(),increase);   </span><br><span class="line">    <span class="comment">//vecIntA : &#123;2,4,6,8,10&#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>C++</category>
        <category>STL</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>STL</tag>
        <tag>STL算法</tag>
      </tags>
  </entry>
  <entry>
    <title>STL_vector容器</title>
    <url>/2021/05/07/STL%EF%BC%9Avector%E5%AE%B9%E5%99%A8/</url>
    <content><![CDATA[<h3 id="一、Vector容器简介"><a href="#一、Vector容器简介" class="headerlink" title="一、Vector容器简介"></a>一、Vector容器简介</h3><p>    vector是将元素置于一个动态数组中加以管理的容器。</p>
<p>    vector可以随机存取元素（支持索引值直接存取， 用[]操作符或at()方法）。</p>
<p>    vector尾部添加或移除元素非常快速，但是在中部或头部插入元素或移除元素比较费时。</p>
<span id="more"></span>

<h3 id="二、vector对象的默认构造"><a href="#二、vector对象的默认构造" class="headerlink" title="二、vector对象的默认构造"></a>二、vector对象的默认构造</h3><p>    vector采用模板类实现，vector对象的默认构造形式：<strong>vector&lt;T&gt; vecT;</strong>  </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">vector&lt;<span class="keyword">int</span>&gt; vecInt;     <span class="comment">//一个存放int的vector容器。</span></span><br><span class="line"></span><br><span class="line">vector&lt;<span class="keyword">float</span>&gt; vecFloat;    <span class="comment">//一个存放float的vector容器。</span></span><br><span class="line"></span><br><span class="line">vector&lt;string&gt; vecString;   <span class="comment">//一个存放string的vector容器。</span></span><br><span class="line"></span><br><span class="line">...                  <span class="comment">//尖括号内还可以设置指针类型或自定义类型。</span></span><br><span class="line"></span><br><span class="line">Class CA&#123;&#125;;</span><br><span class="line"></span><br><span class="line">vector&lt;CA*&gt; vecpCA;      <span class="comment">//用于存放CA对象的指针的vector容器。</span></span><br><span class="line"></span><br><span class="line">vector&lt;CA&gt; vecCA;       <span class="comment">//用于存放CA对象的vector容器。由于容器元素的存放是按值复制的方式进行的，所以此时CA必须提供CA的拷贝构造函数，以保证CA对象间拷贝正常。</span></span><br></pre></td></tr></table></figure>



<h3 id="三、vector对象的带参数构造"><a href="#三、vector对象的带参数构造" class="headerlink" title="三、vector对象的带参数构造"></a>三、vector对象的带参数构造</h3><ul>
<li><p>  vector(beg,end);  //构造函数将[beg, end)区间中的元素拷贝给本身。注意该区间是左闭右开的区间。</p>
</li>
<li><p>  vector(n,elem);  //构造函数将n个elem拷贝给本身。</p>
</li>
<li><p>  vector(const vector &amp;vec); //拷贝构造函数</p>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printVector</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; v)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (vector&lt;<span class="keyword">int</span>&gt;::iterator it = v.<span class="built_in">begin</span>(); it != v.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">		cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">vector&lt;<span class="keyword">int</span>&gt; vl;<span class="comment">//默认构造</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> arr[] = &#123; <span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span> &#125;;</span><br><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">v2</span><span class="params">(arr, arr + <span class="keyword">sizeof</span>(arr) / <span class="keyword">sizeof</span>(<span class="keyword">int</span>))</span></span>;</span><br><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">v3</span><span class="params">(v2.begin(), v2.begin()+<span class="number">3</span>)</span></span>;</span><br><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">v4</span><span class="params">(v3)</span></span>;</span><br><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">v5</span><span class="params">(<span class="number">4</span>,<span class="number">5</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printVector</span>(v2);</span><br><span class="line"><span class="built_in">printVector</span>(v3);</span><br><span class="line"><span class="built_in">printVector</span>(v4);</span><br><span class="line"><span class="built_in">printVector</span>(v5);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">结果：</span></span><br><span class="line"><span class="comment">10 20 30 40</span></span><br><span class="line"><span class="comment">10 20 30</span></span><br><span class="line"><span class="comment">10 20 30</span></span><br><span class="line"><span class="comment">5 5 5 5</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h3 id="四、vector的赋值"><a href="#四、vector的赋值" class="headerlink" title="四、vector的赋值"></a>四、vector的赋值</h3><ul>
<li><p>  vector.assign(beg,end);  //将[beg, end)区间中的数据拷贝赋值给本身。注意该区间是左闭右开的区间。</p>
</li>
<li><p>  vector.assign(n,elem); //将n个elem拷贝赋值给本身。</p>
</li>
<li><p>  vector&amp; operator=(const vector &amp;vec); //重载等号操作符</p>
</li>
<li><p>  vector.swap(vec); // 将vec与本身的元素互换。 </p>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> arr[] = &#123; <span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span> &#125;;</span><br><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">v1</span><span class="params">(arr, arr + <span class="keyword">sizeof</span>(arr) / <span class="keyword">sizeof</span>(<span class="keyword">int</span>))</span></span>;<span class="comment">//默认构造</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//成员方法</span></span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; v2;</span><br><span class="line">v2.<span class="built_in">assign</span>(v1.<span class="built_in">begin</span>(), v1.<span class="built_in">end</span>());</span><br><span class="line"></span><br><span class="line"><span class="comment">//重载=</span></span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; v3;</span><br><span class="line">v3 = v2;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> arr1[] = &#123; <span class="number">100</span>, <span class="number">200</span>, <span class="number">300</span>, <span class="number">400</span> &#125;;</span><br><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">v4</span><span class="params">(arr1, arr1 + <span class="keyword">sizeof</span>(arr) / <span class="keyword">sizeof</span>(<span class="keyword">int</span>))</span></span>;<span class="comment">//默认构造</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">printVector</span>(v1);</span><br><span class="line"><span class="built_in">printVector</span>(v2);</span><br><span class="line"><span class="built_in">printVector</span>(v3);</span><br><span class="line"><span class="built_in">printVector</span>(v4);</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;------------------&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">v4.<span class="built_in">swap</span>(v1);</span><br><span class="line"><span class="built_in">printVector</span>(v1);</span><br><span class="line"><span class="built_in">printVector</span>(v2);</span><br><span class="line"><span class="built_in">printVector</span>(v3);</span><br><span class="line"><span class="built_in">printVector</span>(v4);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">结果：</span></span><br><span class="line"><span class="comment">10 20 30 40</span></span><br><span class="line"><span class="comment">10 20 30 40</span></span><br><span class="line"><span class="comment">10 20 30 40</span></span><br><span class="line"><span class="comment">100 200 300 400</span></span><br><span class="line"><span class="comment">------------------</span></span><br><span class="line"><span class="comment">100 200 300 400</span></span><br><span class="line"><span class="comment">10 20 30 40</span></span><br><span class="line"><span class="comment">10 20 30 40</span></span><br><span class="line"><span class="comment">10 20 30 40</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>



<h3 id="五、vector的大小"><a href="#五、vector的大小" class="headerlink" title="五、vector的大小"></a>五、vector的大小</h3><ul>
<li><p>  vector.size();      //返回容器中元素的个数</p>
</li>
<li><p>  vector.empty();   //判断容器是否为空</p>
</li>
<li><p>  vector.resize(num);  //重新指定容器的长度为num，若容器变长，则以默认值填充新位置。如果容器变短，则末尾超出容器长度的元素被删除。</p>
</li>
<li><p>  vector.resize(num, elem); //重新指定容器的长度为num，若容器变长，则以elem值填充新位置。如果容器变短，则末尾超出容器长度的元素被删除。</p>
</li>
<li><p>  capacity();<em>//容器的容量</em> </p>
</li>
<li><p>  reserve(int len);//容器预留len个元素长度，预留位置不初始化，元素不可访问。 </p>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> arr1[] = &#123; <span class="number">100</span>, <span class="number">200</span>, <span class="number">300</span>, <span class="number">400</span> &#125;;</span><br><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">v4</span><span class="params">(arr1, arr1 + <span class="keyword">sizeof</span>(arr1) / <span class="keyword">sizeof</span>(<span class="keyword">int</span>))</span></span>;<span class="comment">//默认构造</span></span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;size：&quot;</span> &lt;&lt; v4.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line"><span class="keyword">if</span> (v4.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;空！&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;不空！&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printVector</span>(v4);</span><br><span class="line">v4.<span class="built_in">resize</span>(<span class="number">2</span>);</span><br><span class="line"><span class="built_in">printVector</span>(v4);</span><br><span class="line">v4.<span class="built_in">resize</span>(<span class="number">6</span>);</span><br><span class="line"><span class="built_in">printVector</span>(v4);</span><br><span class="line">v4.<span class="built_in">resize</span>(<span class="number">8</span>, <span class="number">1</span>);</span><br><span class="line"><span class="built_in">printVector</span>(v4);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++) &#123;</span><br><span class="line">    v4.<span class="built_in">push_back</span>(i);</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;size：&quot;</span> &lt;&lt; v4.<span class="built_in">size</span>() &lt;&lt; endl;  </span><br><span class="line">cout &lt;&lt; <span class="string">&quot;容量:&quot;</span> &lt;&lt; v4.<span class="built_in">capacity</span>() &lt;&lt; endl;<span class="comment">//容量不一定等于size</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">结果：</span></span><br><span class="line"><span class="comment">size：4</span></span><br><span class="line"><span class="comment">不空！</span></span><br><span class="line"><span class="comment">100 200 300 400</span></span><br><span class="line"><span class="comment">100 200</span></span><br><span class="line"><span class="comment">100 200 0 0 0 0</span></span><br><span class="line"><span class="comment">100 200 0 0 0 0 1 1</span></span><br><span class="line"><span class="comment">size：10008</span></span><br><span class="line"><span class="comment">容量:12138</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>



<h3 id="六、vector末尾的添加移除操作"><a href="#六、vector末尾的添加移除操作" class="headerlink" title="六、vector末尾的添加移除操作"></a>六、vector末尾的添加移除操作</h3><ul>
<li><p>  vector.push_back(); //在容器尾部加入一个元素</p>
</li>
<li><p>  vector.pop_back();; //移除容器中最后一个元素</p>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> arr1[] = &#123; <span class="number">100</span>, <span class="number">200</span>, <span class="number">300</span>, <span class="number">400</span> &#125;;</span><br><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">v1</span><span class="params">(arr1, arr1 + <span class="keyword">sizeof</span>(arr1) / <span class="keyword">sizeof</span>(<span class="keyword">int</span>))</span></span>;<span class="comment">//默认构造</span></span><br><span class="line"></span><br><span class="line">v1.<span class="built_in">push_back</span>(<span class="number">500</span>);</span><br><span class="line">v1.<span class="built_in">push_back</span>(<span class="number">600</span>);</span><br><span class="line">v1.<span class="built_in">push_back</span>(<span class="number">700</span>);</span><br><span class="line">v1.<span class="built_in">pop_back</span>();</span><br><span class="line"><span class="built_in">printVector</span>(v1);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">结果：</span></span><br><span class="line"><span class="comment">100 200 300 400 500 600100 200 300 400 500 600</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>



<h3 id="七、vector的数据存取"><a href="#七、vector的数据存取" class="headerlink" title="七、vector的数据存取"></a>七、vector的数据存取</h3><ul>
<li><p>  vector.at(int idx); //返回索引idx所指的数据，如果idx越界，抛出out_of_range异常。</p>
</li>
<li><p>  vector[int idx];//返回索引idx所指的数据，越界时，运行直接报错</p>
</li>
<li><p>  vector.front();//返回容器中第一个数据元素</p>
</li>
<li><p>  vector.back();//返回容器中最后一个数据元素</p>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> arr1[] = &#123; <span class="number">100</span>, <span class="number">200</span>, <span class="number">300</span>, <span class="number">400</span> &#125;;</span><br><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">v4</span><span class="params">(arr1, arr1 + <span class="keyword">sizeof</span>(arr1) / <span class="keyword">sizeof</span>(<span class="keyword">int</span>))</span></span>;<span class="comment">//默认构造</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//区别: at抛异常 []不抛异常</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; v4.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">    cout &lt;&lt; v4[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; v4.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">    cout &lt;&lt; v4.<span class="built_in">at</span>(i) &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;front:&quot;</span> &lt;&lt; v4.<span class="built_in">front</span>() &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;back:&quot;</span> &lt;&lt; v4.<span class="built_in">back</span>() &lt;&lt; endl;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">结果：</span></span><br><span class="line"><span class="comment">100 200 300 400</span></span><br><span class="line"><span class="comment">100 200 300 400</span></span><br><span class="line"><span class="comment">front:100</span></span><br><span class="line"><span class="comment">back:400</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>



<h3 id="八、vector的插入和删除"><a href="#八、vector的插入和删除" class="headerlink" title="八、vector的插入和删除"></a>八、vector的插入和删除</h3><ul>
<li><p>  vector.insert(pos,elem);  //在pos位置插入一个elem元素的拷贝，返回新数据的位置。</p>
</li>
<li><p>  vector.insert(pos,n,elem);  //在pos位置插入n个elem数据，无返回值。</p>
</li>
<li><p>  vector.insert(pos,beg,end);  //在pos位置插入[beg,end)区间的数据，无返回值</p>
</li>
<li><p>  vector.clear();   //移除容器的所有数据</p>
</li>
<li><p>  vector.erase(beg,end); //删除[beg,end)区间的数据，返回下一个数据的位置。</p>
</li>
<li><p>  vector.erase(pos);  //删除pos位置的数据，返回下一个数据的位置。</p>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">vector&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line">v.<span class="built_in">push_back</span>(<span class="number">10</span>);</span><br><span class="line">v.<span class="built_in">push_back</span>(<span class="number">20</span>);</span><br><span class="line"><span class="comment">//头插法</span></span><br><span class="line">v.<span class="built_in">insert</span>(v.<span class="built_in">begin</span>(), <span class="number">30</span>);</span><br><span class="line">v.<span class="built_in">insert</span>(v.<span class="built_in">end</span>(), <span class="number">40</span>);</span><br><span class="line"></span><br><span class="line">v.<span class="built_in">insert</span>(v.<span class="built_in">begin</span>() + <span class="number">2</span>, <span class="number">100</span>); <span class="comment">//vector支持随机访问</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//支持数组下标，一般都支持随机访问</span></span><br><span class="line"><span class="comment">//迭代器可以直接+2 +3 -2 -5操作</span></span><br><span class="line"><span class="built_in">printVector</span>(v);</span><br><span class="line"></span><br><span class="line"><span class="comment">//删除</span></span><br><span class="line">v.<span class="built_in">erase</span>(v.<span class="built_in">begin</span>());</span><br><span class="line"><span class="built_in">printVector</span>(v);</span><br><span class="line">v.<span class="built_in">erase</span>(v.<span class="built_in">begin</span>() + <span class="number">1</span>, v.<span class="built_in">end</span>());</span><br><span class="line"><span class="built_in">printVector</span>(v);</span><br><span class="line">v.<span class="built_in">clear</span>();</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;size:&quot;</span> &lt;&lt; v.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">结果：</span></span><br><span class="line"><span class="comment">30 10 100 20 40</span></span><br><span class="line"><span class="comment">10 100 20 40</span></span><br><span class="line"><span class="comment">10</span></span><br><span class="line"><span class="comment">size:0</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h3 id="九、巧用swap，收缩内存空间"><a href="#九、巧用swap，收缩内存空间" class="headerlink" title="九、巧用swap，收缩内存空间"></a>九、巧用swap，收缩内存空间</h3><p>    vector&lt;T&gt;(x).swap(x);    //其中，x 指当前要操作的容器，T 为该容器存储元素的类型。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//vector添加元素 他会自动增长 你删除元素时候，不会自动减少</span></span><br><span class="line"></span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100000</span>; i++) &#123;</span><br><span class="line">    v.<span class="built_in">push_back</span>(i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;size:&quot;</span> &lt;&lt; v.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;capacity:&quot;</span> &lt;&lt; v.<span class="built_in">capacity</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">v.<span class="built_in">resize</span>(<span class="number">10</span>);</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;--------------&quot;</span> &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;size:&quot;</span> &lt;&lt; v.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;capacity:&quot;</span> &lt;&lt; v.<span class="built_in">capacity</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">//收缩空间</span></span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt;(v).<span class="built_in">swap</span>(v);</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;--------------&quot;</span> &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;size:&quot;</span> &lt;&lt; v.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;capacity:&quot;</span> &lt;&lt; v.<span class="built_in">capacity</span>() &lt;&lt; endl;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">结果：</span></span><br><span class="line"><span class="comment">size:100000</span></span><br><span class="line"><span class="comment">capacity:138255</span></span><br><span class="line"><span class="comment">--------------</span></span><br><span class="line"><span class="comment">size:10</span></span><br><span class="line"><span class="comment">capacity:138255</span></span><br><span class="line"><span class="comment">--------------</span></span><br><span class="line"><span class="comment">size:10</span></span><br><span class="line"><span class="comment">capacity:10</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h3 id="十、reserve-预留空间"><a href="#十、reserve-预留空间" class="headerlink" title="十、reserve 预留空间"></a>十、reserve 预留空间</h3><p>    vector的reserve增加了vector的capacity，但是它的size没有改变！而resize改变了vector的capacity同时也增加了它的size！</p>
<p>原因如下：</p>
<ul>
<li>reserve是容器预留空间，但在空间内不真正创建元素对象，所以在没有添加新的对象之前，不能引用容器内的元素。加入新的元素时，要调用push_back()/insert()函数。</li>
<li> resize是改变容器的大小，且在创建对象，因此，调用这个函数之后，就可以引用容器内的对象了，因此当加入新的元素时，用operator[]操作符，或者用迭代器来引用元素对象。此时再调用push_back()函数，是加在这个新的空间后面的。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span>* address = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line">v.<span class="built_in">reserve</span>(<span class="number">100000</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100000</span>; i++) &#123;</span><br><span class="line">    v.<span class="built_in">push_back</span>(i);</span><br><span class="line">    <span class="keyword">if</span> (address != &amp;(v[<span class="number">0</span>])) &#123;</span><br><span class="line">        address = &amp;(v[<span class="number">0</span>]);</span><br><span class="line">        num++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;num:&quot;</span> &lt;&lt; num &lt;&lt; endl;<span class="comment">//申请num次空间</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">结果：</span></span><br><span class="line"><span class="comment">num:1</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>    如果一个vector使用默认的capacity，那么在push_back操作的时候，会根据添加元素的数量，动态的自动分配空间，2^n递增；<strong>如果声明vector的时候，显式的使用capacity(size_type n)来指定vector的容量，那么在push_back的过程中（元素数量不超过n），vector不会自动分配空间，提高程序效率。</strong></p>
]]></content>
      <categories>
        <category>C++</category>
        <category>STL</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>STL</tag>
        <tag>STL容器</tag>
      </tags>
  </entry>
  <entry>
    <title>STL_ map和unordered_map的差别</title>
    <url>/2021/05/07/STL%EF%BC%9Aunordered_%E7%AD%89%E5%AE%B9%E5%99%A8/</url>
    <content><![CDATA[<h3 id="需要引入的头文件不同"><a href="#需要引入的头文件不同" class="headerlink" title="需要引入的头文件不同"></a>需要引入的头文件不同</h3><span id="more"></span>

<ul>
<li>  map:     #include &lt; map &gt;</li>
<li>  unordered_map:     #include &lt; unordered_map &gt;</li>
</ul>
<h3 id="内部实现机理不同"><a href="#内部实现机理不同" class="headerlink" title="内部实现机理不同"></a>内部实现机理不同</h3><p>    map： map内部实现了一个红黑树（红黑树是非严格平衡二叉搜索树，而AVL是严格平衡二叉搜索树），红黑树具有自动排序的功能，因此map内部的所有元素都是有序的，红黑树的每一个节点都代表着map的一个元素。因此，对于map进行的查找，删除，添加等一系列的操作都相当于是对红黑树进行的操作。map中的元素是按照二叉搜索树（又名二叉查找树、二叉排序树，特点就是左子树上所有节点的键值都小于根节点的键值，右子树所有节点的键值都大于根节点的键值）存储的，使用中序遍历可将键值按照从小到大遍历出来。</p>
<p>    unordered_map: unordered_map内部实现了一个哈希表（也叫散列表，通过把关键码值映射到Hash表中一个位置来访问记录，查找的时间复杂度可达到O(1)，其在海量数据处理中有着广泛应用）。因此，其元素的排列顺序是无序的。哈希表详细介绍</p>
<h3 id="优缺点以及适用处"><a href="#优缺点以及适用处" class="headerlink" title="优缺点以及适用处"></a>优缺点以及适用处</h3><h5 id="map："><a href="#map：" class="headerlink" title="map："></a>map：</h5><p>    优点：有序性，这是map结构最大的优点，其元素的有序性在很多应用中都会简化很多的操作红黑树，内部实现一个红黑书使得map的很多操作在lgn的时间复杂度下就可以实现，因此效率非常的高。</p>
<p>    缺点： 空间占用率高，因为map内部实现了红黑树，虽然提高了运行效率，但是因为每一个节点都需要额外保存父节点、孩子节点和红/黑性质，使得每一个节点都占用大量的空间。</p>
<p>    适用处：对于那些有顺序要求的问题，用map会更高效一些</p>
<h5 id="unordered-map："><a href="#unordered-map：" class="headerlink" title="unordered_map："></a>unordered_map：</h5><p>    优点： 因为内部实现了哈希表，因此其查找速度非常的快</p>
<p>    缺点： 哈希表的建立比较耗费时间</p>
<p>    适用处：对于查找问题，unordered_map会更加高效一些，因此遇到查找问题，常会考虑一下用unordered_map</p>
<h5 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h5><ol>
<li> 内存占有率的问题就转化成红黑树 VS hash表 , 还是unorder_map占用的内存要高。</li>
<li> 但是unordered_map执行效率要比map高很多</li>
<li> 对于unordered_map或unordered_set容器，其遍历顺序与创建该容器时输入的顺序不一定相同，因为遍历是按照哈希表从前往后依次遍历的</li>
</ol>
<p>map和unordered_map的使用</p>
<p>    unordered_map的用法和map是一样的，提供了 insert，size，count等操作，并且里面的元素也是以pair类型来存贮的。其底层实现是完全不同的，上方已经解释了，但是就外部使用来说却是一致的。</p>
<p>    set与unordered_set、multiset与unordered_multiset、multimap与unordered_map之间类似。</p>
]]></content>
      <categories>
        <category>C++</category>
        <category>STL</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>STL</tag>
        <tag>STL容器</tag>
      </tags>
  </entry>
  <entry>
    <title>STL_tuple容器</title>
    <url>/2021/05/07/STL%EF%BC%9Atuple%E5%AE%B9%E5%99%A8/</url>
    <content><![CDATA[<h3 id="一、元组简介"><a href="#一、元组简介" class="headerlink" title="一、元组简介"></a>一、元组简介</h3><p>    tuple是一个固定大小的不同类型值的集合，是泛化的std::pair。我们也可以把他当做一个通用的结构体来用，不需要创建结构体又获取结构体的特征，在某些情况下可以取代结构体使程序更简洁，直观。std::tuple理论上可以有无数个任意类型的成员变量，而std::pair只能是2个成员，因此在需要保存3个及以上的数据时就需要使用tuple元组了。</p>
<span id="more"></span>

<p>    tuple（元组）在c++11中开始引用的。tuple看似简单，其实它是简约而不简单，可以说它是c++11中一个既简单又复杂的东东，关于它简单的一面是它很容易使用，复杂的一面是它内部隐藏了太多细节，要揭开它神秘的面纱时又比较困难。</p>
<p>    #include &lt;tuple&gt;   </p>
<h3 id="二、tuple的创建和初始化"><a href="#二、tuple的创建和初始化" class="headerlink" title="二、tuple的创建和初始化"></a>二、tuple的创建和初始化</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">std::tuple&lt;T1, T2, TN&gt; t1;            </span><br><span class="line"><span class="comment">//创建一个空的tuple对象（使用默认构造），它对应的元素分别是T1和T2...Tn类型，采用值初始化。</span></span><br><span class="line">std::tuple&lt;T1, T2, TN&gt; t2(v1, v2, ... TN);    </span><br><span class="line"><span class="comment">//创建一个tuple对象，它的两个元素分别是T1和T2 ...Tn类型; 要获取元素的值需要通过tuple的成员get&lt;Ith&gt;(obj)进行获取(Ith是指获取在tuple中的第几个元素，请看后面具体实例)。</span></span><br><span class="line"><span class="function">std::tuple&lt;T1&amp;&gt; <span class="title">t3</span><span class="params">(ref&amp;)</span></span>; <span class="comment">// tuple的元素类型可以是一个引用</span></span><br><span class="line">std::<span class="built_in">make_tuple</span>(v1, v2); <span class="comment">// 像pair一样也可以通过make_tuple进行创建一个tuple对象</span></span><br></pre></td></tr></table></figure>


<p>     tuple的元素类型为引用：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">std::string name;</span><br><span class="line">std::tuple&lt;string &amp;, int&gt; tpRef(name, 30);</span><br><span class="line"><span class="comment">// 对tpRef第一个元素赋值，同时name也被赋值 - 引用</span></span><br><span class="line">std::get&lt;<span class="number">0</span>&gt;(tpRef) = <span class="string">&quot;Sven&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// name输出也是Sven</span></span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;name: &quot;</span> &lt;&lt; name &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br></pre></td></tr></table></figure>

<h3 id="三、有关tuple元素的操作"><a href="#三、有关tuple元素的操作" class="headerlink" title="三、有关tuple元素的操作"></a>三、有关tuple元素的操作</h3><h5 id="1-等价结构体"><a href="#1-等价结构体" class="headerlink" title="1.等价结构体"></a>1.等价结构体</h5><p>    开篇讲过在某些时候tuple可以等同于结构体一样使用，这样既方便又快捷。如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">struct person &#123;</span><br><span class="line">    char *m_name;</span><br><span class="line">    char *m_addr;</span><br><span class="line">    int  *m_ages;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;可以用tuple来表示这样的一个结构类型，作用是一样的。</span><br><span class="line">std::tuple&lt;const char *, const char *, int&gt;</span><br></pre></td></tr></table></figure>



<h5 id="2-如何获取tuple元素个数"><a href="#2-如何获取tuple元素个数" class="headerlink" title="2.如何获取tuple元素个数"></a>2.如何获取tuple元素个数</h5><p>    当有一个tuple对象但不知道有多少元素可以通过如下查询：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">std::tuple&lt;int, char, double&gt; mytuple (10, &#x27;a&#x27;, 3.14);</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;mytuple has &quot;</span>;</span><br><span class="line">std::cout &lt;&lt; std::tuple_size&lt;<span class="keyword">decltype</span>(mytuple)&gt;::value;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot; elements.&quot;</span> &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line"><span class="comment">//输出结果：</span></span><br><span class="line"><span class="comment">//mytuple has 3 elements</span></span><br></pre></td></tr></table></figure>



<h5 id="3-获取元素的值"><a href="#3-获取元素的值" class="headerlink" title="3. 获取元素的值"></a>3. 获取元素的值</h5><p>    获取tuple对象元素的值可以通过get&lt;Ith&gt;(obj)方法进行获取；</p>
<p>    Ith - 是想获取的元素在tuple对象中的位置。</p>
<p>    obj - 是想获取tuple的对象</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">std::tuple&lt;int, char, double&gt; mytuple (10, &#x27;a&#x27;, 3.14);</span><br><span class="line"><span class="comment">//获取元素</span></span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;the elements is: &quot;</span>;</span><br><span class="line">std::cout &lt;&lt; std::get&lt;<span class="number">0</span>&gt;(mytuple) &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">std::cout &lt;&lt; std::get&lt;<span class="number">1</span>&gt;(mytuple) &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">std::cout &lt;&lt; std::get&lt;<span class="number">2</span>&gt;(mytuple) &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line"><span class="comment">//输出结果：</span></span><br><span class="line"><span class="comment">//the elements is: 10 a 3.14 </span></span><br></pre></td></tr></table></figure>


<p>   tuple不支持迭代，只能通过元素索引(或tie解包)进行获取元素的值。但是<strong>给定的索引必须是在编译器就已经给定，不能在运行期进行动态传递，否则将发生编译错误</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">3</span>; i++)</span><br><span class="line">std::cout &lt;&lt; std::get&lt;i&gt;(mytuple) &lt;&lt; <span class="string">&quot; &quot;</span>; <span class="comment">//将引发编译错误</span></span><br></pre></td></tr></table></figure>



<h5 id="4-获取元素的类型"><a href="#4-获取元素的类型" class="headerlink" title="4.获取元素的类型"></a>4.获取元素的类型</h5><p>     要想得到元素类型可以通过tuple_element方法获取，如有以下元组对象：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">std::tuple&lt;std::string, int&gt; tp(&quot;Sven&quot;, 20);</span><br><span class="line"><span class="comment">// 得到第二个元素类型</span></span><br><span class="line">std::tuple_element&lt;<span class="number">1</span>, <span class="keyword">decltype</span>(tp)&gt;::type ages;  <span class="comment">// ages就为int类型</span></span><br><span class="line">ages = std::get&lt;<span class="number">1</span>&gt;(tp);</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;ages: &quot;</span> &lt;&lt; ages &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line"><span class="comment">//输出结果： </span></span><br><span class="line">ages: <span class="number">20</span></span><br></pre></td></tr></table></figure>



<h5 id="5-利用tie进行解包元素的值"><a href="#5-利用tie进行解包元素的值" class="headerlink" title="5.利用tie进行解包元素的值"></a>5.利用tie进行解包元素的值</h5><p>     如同pair一样也是可以通过tie进行解包tuple的各个元素的值。如下tuple对象有4个元素，通过tie解包将会把这4个元素的值分别赋值给tie提供的4个变量中。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;tuple&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;utility&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span> </span>&#123;</span><br><span class="line">    std::tuple&lt;std::string, <span class="keyword">int</span>, std::string, <span class="keyword">int</span>&gt; tp;</span><br><span class="line">    tp = std::<span class="built_in">make_tuple</span>(<span class="string">&quot;Sven&quot;</span>, <span class="number">25</span>, <span class="string">&quot;Shanghai&quot;</span>, <span class="number">21</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义接收变量</span></span><br><span class="line">    std::string name;</span><br><span class="line">    std::string addr;</span><br><span class="line">    <span class="keyword">int</span> ages;</span><br><span class="line">    <span class="keyword">int</span> areaCode;</span><br><span class="line">     </span><br><span class="line">    std::<span class="built_in">tie</span>(name, ages, addr, areaCode) = tp;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Output: &quot;</span> &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;name: &quot;</span> &lt;&lt; name &lt;&lt;<span class="string">&quot;, &quot;</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;addr: &quot;</span> &lt;&lt; addr &lt;&lt; <span class="string">&quot;, &quot;</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;ages: &quot;</span> &lt;&lt; ages &lt;&lt; <span class="string">&quot;, &quot;</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;areaCode: &quot;</span> &lt;&lt; areaCode &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;     </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*输出结果：</span></span><br><span class="line"><span class="comment">Output: </span></span><br><span class="line"><span class="comment">name: Sven, addr: Shanghai, ages: 25, areaCode: 21</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>


<p>    但有时候tuple包含的多个元素时只需要其中的一个或两个元素，如此可以通过std::ignore进行变量占位，这样将会忽略提取对应的元素。可以修改上述例程：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;tuple&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;utility&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span> </span>&#123;</span><br><span class="line">    std::tuple&lt;std::string, <span class="keyword">int</span>, std::string, <span class="keyword">int</span>&gt; tp;</span><br><span class="line">    tp = std::<span class="built_in">make_tuple</span>(<span class="string">&quot;Sven&quot;</span>, <span class="number">25</span>, <span class="string">&quot;Shanghai&quot;</span>, <span class="number">21</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义接收变量</span></span><br><span class="line">    std::string name;</span><br><span class="line">    std::string addr;</span><br><span class="line">    <span class="keyword">int</span> ages;</span><br><span class="line">    <span class="keyword">int</span> areaCode = <span class="number">110</span>;</span><br><span class="line">     </span><br><span class="line">    std::<span class="built_in">tie</span>(name, ages, std::ignore, std::ignore) = tp;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Output: &quot;</span> &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;name: &quot;</span> &lt;&lt; name &lt;&lt;<span class="string">&quot;, &quot;</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;addr: &quot;</span> &lt;&lt; addr &lt;&lt; <span class="string">&quot;, &quot;</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;ages: &quot;</span> &lt;&lt; ages &lt;&lt; <span class="string">&quot;, &quot;</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;areaCode: &quot;</span> &lt;&lt; areaCode &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">     </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">输出结果：</span></span><br><span class="line"><span class="comment">Output: </span></span><br><span class="line"><span class="comment">name: Sven, addr: , ages: 25, areaCode: 110</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>


<h5 id="6-tuple元素的引用"><a href="#6-tuple元素的引用" class="headerlink" title="6.tuple元素的引用"></a>6.tuple元素的引用</h5><p>    前面已经列举了将引用作为tuple的元素类型。下面通过引用搭配make_tuple()可以提取tuple的元素值，将某些变量值设给它们，并通过改变这些变量来改变tuple元素的值：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;tuple&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;functional&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **agrv)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    std::tuple&lt;std::string, int, float&gt; tp1(&quot;Sven Cheng&quot;, 77, 66.1);</span><br><span class="line">     </span><br><span class="line">    std::string name;</span><br><span class="line">    <span class="keyword">int</span> weight;</span><br><span class="line">    <span class="keyword">float</span> f;</span><br><span class="line">     </span><br><span class="line">    <span class="keyword">auto</span> tp2 = std::<span class="built_in">make_tuple</span>(std::<span class="built_in">ref</span>(name), std::<span class="built_in">ref</span>(weight), std::<span class="built_in">ref</span>(f)) = tp1;</span><br><span class="line">     </span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Before change: &quot;</span> &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;name: &quot;</span> &lt;&lt; name &lt;&lt; <span class="string">&quot;, &quot;</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;weight: &quot;</span> &lt;&lt; weight &lt;&lt; <span class="string">&quot;, &quot;</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;f: &quot;</span> &lt;&lt; f &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">     </span><br><span class="line">    name = <span class="string">&quot;Sven&quot;</span>;</span><br><span class="line">    weight = <span class="number">80</span>;</span><br><span class="line">    f = <span class="number">3.14</span>;</span><br><span class="line">     </span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;After change: &quot;</span> &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;element 1st: &quot;</span> &lt;&lt; std::get&lt;<span class="number">0</span>&gt;(tp2) &lt;&lt; <span class="string">&quot;, &quot;</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;element 2nd: &quot;</span> &lt;&lt; std::get&lt;<span class="number">1</span>&gt;(tp2) &lt;&lt; <span class="string">&quot;, &quot;</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;element 3rd: &quot;</span> &lt;&lt; std::get&lt;<span class="number">2</span>&gt;(tp2) &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">     </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">输出结果：</span></span><br><span class="line"><span class="comment">Before change: </span></span><br><span class="line"><span class="comment">name: Sven Cheng, weight: 77, f: 66.1</span></span><br><span class="line"><span class="comment">After change: </span></span><br><span class="line"><span class="comment">element 1st: Sven, element 2nd: 80, element 3rd: 3.14</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>C++</category>
        <category>STL</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>STL</tag>
        <tag>STL容器</tag>
      </tags>
  </entry>
  <entry>
    <title>STL_string容器</title>
    <url>/2021/05/07/STL%EF%BC%9Astring%E5%AE%B9%E5%99%A8/</url>
    <content><![CDATA[<h3 id="一、string概念"><a href="#一、string概念" class="headerlink" title="一、string概念"></a>一、string概念</h3><p>    string是STL的字符串类型，通常用来表示字符串。而在使用string之前，字符串通常是用char*表示的。string与char*都可以用来表示字符串，那么二者有什么区别。</p>
<span id="more"></span>

<p>    string和char*的比较:</p>
<ul>
<li><p>string是一个类, char*是一个指向字符的指针。</p>
<p>​     string封装了char*，管理这个字符串，是一个char*型的容器。</p>
</li>
<li><p>string不用考虑内存释放和越界。</p>
<p>​     string管理char*所分配的内存。每一次string的复制，取值都由string类负责维护，不用担心复制越界和取值越界等。</p>
</li>
<li><p>string提供了一系列的字符串操作函数</p>
<p>​     查找find，拷贝copy，删除erase，替换replace，插入insert</p>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//string 转 char*</span></span><br><span class="line">string str_1=<span class="string">&quot;string&quot;</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>* cstr_1=str.<span class="built_in">c_str</span>();</span><br><span class="line"><span class="comment">//char* 转 string</span></span><br><span class="line"><span class="keyword">char</span>* cstr_2=<span class="string">&quot;char&quot;</span>;</span><br><span class="line"><span class="function">string <span class="title">str_2</span><span class="params">(cstr)</span></span>;</span><br></pre></td></tr></table></figure>



<h3 id="二、string的构造函数"><a href="#二、string的构造函数" class="headerlink" title="二、string的构造函数"></a>二、string的构造函数</h3><ol>
<li><p>默认构造函数：string();    //构造一个空的字符串string s1。</p>
</li>
<li><p>构造函数：string(const string &amp;str); //构造一个与str一样的string。如string s1(s2)。</p>
</li>
<li><p>带参数的构造函数：</p>
<p>string(const char *s);  //用字符串s初始化</p>
<p>string(int n,char c);  //用n个字符c初始化</p>
</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">string s1; <span class="comment">//调用无参构造</span></span><br><span class="line"><span class="function">string <span class="title">s2</span><span class="params">(<span class="number">10</span>, <span class="string">&#x27;a&#x27;</span>)</span></span>;</span><br><span class="line"><span class="function">string <span class="title">s3</span><span class="params">(<span class="string">&quot;abcdefg&quot;</span>)</span></span>;</span><br><span class="line"><span class="function">string <span class="title">s4</span><span class="params">(s3)</span></span>; <span class="comment">//拷贝构造</span></span><br><span class="line"></span><br><span class="line">cout &lt;&lt; s1 &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; s2 &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; s3 &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; s4 &lt;&lt; endl;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">结果：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">aaaaaaaaaa</span></span><br><span class="line"><span class="comment">abcdefg</span></span><br><span class="line"><span class="comment">abcdefg</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>



<h3 id="三、string的存取字符操作"><a href="#三、string的存取字符操作" class="headerlink" title="三、string的存取字符操作"></a>三、string的存取字符操作</h3><p>string类的字符操作：</p>
<ul>
<li>const char &amp;operator[] (int n) const;    //通过[]方式取字符</li>
<li>const char &amp;at(int n) const;     //通过at方法获取字符</li>
<li>char &amp;operator[] (int n);</li>
<li>char &amp;at(int n);</li>
</ul>
<p>    operator[]和at()均返回当前字符串中第n个字符，但二者是有区别的。</p>
<p>    主要区别在于at()在越界时会抛出异常，[]在刚好越界时会返回(char)0，再继续越界时，编译器直接出错。如果你的程序希望可以通过try,catch捕获异常，建议采用at()。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">string s1 = <span class="string">&quot;abcdefg&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//重载[]操作符</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s1.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">    cout &lt;&lt; s1[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">//at成员函数</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s1.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">    cout &lt;&lt; s1.<span class="built_in">at</span>(i) &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">//区别：[]方式 如果访问越界，直接挂了</span></span><br><span class="line"><span class="comment">//at方式 访问越界 抛异常out_of_range</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">//cout &lt;&lt; s1[100] &lt;&lt; endl;</span></span><br><span class="line">    cout &lt;&lt; s1.<span class="built_in">at</span>(<span class="number">100</span>) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in"><span class="keyword">catch</span></span> (...) &#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;越界!&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">结果：</span></span><br><span class="line"><span class="comment">a b c d e f g</span></span><br><span class="line"><span class="comment">a b c d e f g</span></span><br><span class="line"><span class="comment">越界!</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>



<h3 id="四、从string取得const-char-的操作"><a href="#四、从string取得const-char-的操作" class="headerlink" title="四、从string取得const char*的操作"></a>四、从string取得const char*的操作</h3><p>    const char *c_str() const;  //返回一个以’\0’结尾的字符串的首地址</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//string 转 char*</span></span><br><span class="line">string str_1=<span class="string">&quot;string&quot;</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *cstr_1=str.<span class="built_in">c_str</span>();</span><br></pre></td></tr></table></figure>



<h3 id="五、把string拷贝到char-指向的内存空间的操作"><a href="#五、把string拷贝到char-指向的内存空间的操作" class="headerlink" title="五、把string拷贝到char*指向的内存空间的操作"></a>五、把string拷贝到char*指向的内存空间的操作</h3><p>    int copy(char *s, int n, int pos=0) const; </p>
<p>    把当前串中以pos开始的n个字符拷贝到以s为起始位置的字符数组中，返回实际拷贝的数目。注意要保证s所指向的空间足够大以容纳当前字符串，不然会越界。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">string s1 = <span class="string">&quot;abcdefg&quot;</span>;</span><br><span class="line"><span class="keyword">int</span> n = <span class="number">5</span>;pose</span><br><span class="line">    <span class="keyword">int</span> pose = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span>* s2 = (<span class="keyword">char</span>*)<span class="built_in">malloc</span>(n*<span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">char</span>));</span><br><span class="line"><span class="keyword">if</span>(s1.<span class="built_in">copy</span>(s2, n, pose))</span><br><span class="line">    cout &lt;&lt; s2 ;</span><br><span class="line"><span class="keyword">else</span> cout&lt;&lt;<span class="string">&quot;error&quot;</span>&lt;&lt;endl;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">结果：</span></span><br><span class="line"><span class="comment">def</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>



<h3 id="六、string的长度"><a href="#六、string的长度" class="headerlink" title="六、string的长度"></a>六、string的长度</h3><p>    int length() const;  //返回当前字符串的长度。长度不包括字符串结尾的’\0’。</p>
<p>    bool empty() const;   //当前字符串是否为空</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">string s1 = <span class="string">&quot;abcdefg&quot;</span>;</span><br><span class="line">string s2 = <span class="string">&quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> s1_length=s1.<span class="built_in">length</span>();  </span><br><span class="line"><span class="keyword">bool</span> s1_empty = s1.<span class="built_in">empty</span>();</span><br><span class="line"><span class="keyword">int</span> s2_length = s2.<span class="built_in">length</span>();  </span><br><span class="line"><span class="keyword">bool</span> s2_empty = s2.<span class="built_in">empty</span>();</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; s1_length &lt;&lt; <span class="string">&quot;     &quot;</span> &lt;&lt; s1_empty &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; s2_length &lt;&lt; <span class="string">&quot;     &quot;</span> &lt;&lt; s2_empty &lt;&lt; endl;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">结果：</span></span><br><span class="line"><span class="comment">7     0</span></span><br><span class="line"><span class="comment">0     1</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>



<h3 id="七、string的赋值"><a href="#七、string的赋值" class="headerlink" title="七、string的赋值"></a>七、string的赋值</h3><ul>
<li><p>  string &amp;operator=(const string &amp;s);//把字符串s赋给当前的字符串</p>
</li>
<li><p>  string &amp;assign(const char *s); //把字符串s赋给当前的字符串</p>
</li>
<li><p>  string &amp;assign(const char *s, int n); //把字符串s的前n个字符赋给当前的字符串</p>
</li>
<li><p>  string &amp;assign(const string &amp;s); //把字符串s赋给当前字符串</p>
</li>
<li><p>  string &amp;assign(int n,char c); //用n个字符c赋给当前字符串</p>
</li>
<li><p>  string &amp;assign(const string &amp;s,int start, int n); //把字符串s中从start开始的n个字符赋给当前字符串</p>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">string s1;</span><br><span class="line"><span class="function">string <span class="title">s2</span><span class="params">(<span class="string">&quot;appp&quot;</span>)</span></span>;</span><br><span class="line">s1 = <span class="string">&quot;abcdef&quot;</span>;</span><br><span class="line">cout &lt;&lt; s1 &lt;&lt; endl;</span><br><span class="line">s1 = s2;</span><br><span class="line">cout &lt;&lt; s1 &lt;&lt; endl;</span><br><span class="line">s1 = <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">cout &lt;&lt; s1 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">//成员方法assign</span></span><br><span class="line">s1.<span class="built_in">assign</span>(<span class="string">&quot;jkl&quot;</span>);</span><br><span class="line">cout &lt;&lt; s1 &lt;&lt; endl;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">结果：</span></span><br><span class="line"><span class="comment">abcdef</span></span><br><span class="line"><span class="comment">appp</span></span><br><span class="line"><span class="comment">a</span></span><br><span class="line"><span class="comment">jkl</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>



<h3 id="八、string字符串连接"><a href="#八、string字符串连接" class="headerlink" title="八、string字符串连接"></a>八、string字符串连接</h3><ul>
<li><p>  string &amp;operator+=(const string &amp;s); //把字符串s连接到当前字符串结尾</p>
</li>
<li><p>  string &amp;operator+=(const char *s);//把字符串s连接到当前字符串结尾</p>
</li>
<li><p>  string &amp;append(const char *s);  //把字符串s连接到当前字符串结尾</p>
</li>
<li><p>  string &amp;append(const char *s,int n); //把字符串s的前n个字符连接到当前字符串结尾</p>
</li>
<li><p>  string &amp;append(const string &amp;s);  //同operator+=()</p>
</li>
<li><p>  string &amp;append(const string &amp;s,int pos, int n);//把字符串s中从pos开始的n个字符连接到当前字符串结尾</p>
</li>
<li><p>  string &amp;append(int n, char c);  //在当前字符串结尾添加n个字符c</p>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">string s = <span class="string">&quot;abcd&quot;</span>;</span><br><span class="line">string s2 = <span class="string">&quot;1111&quot;</span>;</span><br><span class="line">s += <span class="string">&quot;abcd&quot;</span>;</span><br><span class="line">s += s2;</span><br><span class="line">cout &lt;&lt; s &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">string s3 = <span class="string">&quot;2222&quot;</span>;</span><br><span class="line">s2.<span class="built_in">append</span>(s3);</span><br><span class="line">cout &lt;&lt; s2 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">string s4 = s2 + s3;</span><br><span class="line">cout &lt;&lt; s4 &lt;&lt; endl;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">结果：</span></span><br><span class="line"><span class="comment">abcdabcd1111</span></span><br><span class="line"><span class="comment">11112222</span></span><br><span class="line"><span class="comment">111122222222</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>



<h3 id="九、string的比较"><a href="#九、string的比较" class="headerlink" title="九、string的比较"></a>九、string的比较</h3><ul>
<li><p>  int compare(const string &amp;s) const; //与字符串s比较</p>
</li>
<li><p>  int compare(const char *s) const;  //与字符串s比较</p>
</li>
<li><p>  compare函数在&gt;时返回 1，&lt;时返回 -1，==时返回 0。比较区分大小写，比较时参考字典顺序，排越前面的越小。大写的A比小写的a小。</p>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">string s1 = <span class="string">&quot;abcd&quot;</span>;</span><br><span class="line">string s2 = <span class="string">&quot;abce&quot;</span>;</span><br><span class="line"><span class="keyword">if</span> (s1.<span class="built_in">compare</span>(s2)==<span class="number">0</span>) &#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;字符串相等!&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;字符串不相等!&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="十、string的子串"><a href="#十、string的子串" class="headerlink" title="十、string的子串"></a>十、string的子串</h3><p>    string substr(int pos=0, int n=npos) const;  //返回由pos开始的n个字符组成的子字符串</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">string s = <span class="string">&quot;abcdefg&quot;</span>;</span><br><span class="line">string mysubstr = s.<span class="built_in">substr</span>(<span class="number">1</span>, <span class="number">3</span>);</span><br><span class="line">cout &lt;&lt; mysubstr &lt;&lt; endl;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">结果：</span></span><br><span class="line"><span class="comment">bcd</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>



<h3 id="十一、string的查找和替换"><a href="#十一、string的查找和替换" class="headerlink" title="十一、string的查找和替换"></a>十一、string的查找和替换</h3><h5 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h5><ul>
<li><p>  int find(char c,int pos=0) const; //从pos开始查找字符c在当前字符串的位置 </p>
</li>
<li><p>  int find(const char *s, int pos=0) const; //从pos开始查找字符串s在当前字符串的位置</p>
</li>
<li><p>int find(const string &amp;s, int pos=0) const; //从pos开始查找字符串s在当前字符串中的位置</p>
<p>  //find函数如果查找不到，就返回-1</p>
</li>
<li><p>  int rfind(char c, int pos=npos) const;  //从pos开始从后向前查找字符c在当前字符串中的位置 </p>
</li>
<li><p>  int rfind(const char *s, int pos=npos) const;</p>
</li>
<li><p>int rfind(const string &amp;s, int pos=npos) const;</p>
<p>  //rfind是反向查找的意思，如果查找不到， 返回-1 </p>
</li>
</ul>
<h5 id="替换"><a href="#替换" class="headerlink" title="替换"></a>替换</h5><ul>
<li><p>  string &amp;replace(int pos, int n, const char *s);//删除从pos开始的n个字符，然后在pos处插入串s</p>
</li>
<li><p>  string &amp;replace(int pos, int n, const string &amp;s); //删除从pos开始的n个字符，然后在pos处插入串s</p>
</li>
<li><p>  void swap(string &amp;s2);  //交换当前字符串与s2的值 </p>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 字符串的查找和替换</span></span><br><span class="line">string s1 = <span class="string">&quot;wbm hello wbm 111 wbm 222 wbm 333&quot;</span>;</span><br><span class="line"><span class="keyword">size_t</span> index = s1.<span class="built_in">find</span>(<span class="string">&quot;wbm&quot;</span>, <span class="number">0</span>);</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;index: &quot;</span> &lt;&lt; index;  </span><br><span class="line"></span><br><span class="line"><span class="comment">//求itcast出现的次数</span></span><br><span class="line"><span class="keyword">size_t</span> offindex = s1.<span class="built_in">find</span>(<span class="string">&quot;wbm&quot;</span>, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">while</span> (offindex != string::npos)&#123;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;在下标index: &quot;</span> &lt;&lt; offindex &lt;&lt; <span class="string">&quot;找到wbm\n&quot;</span>;</span><br><span class="line">    offindex = offindex + <span class="number">1</span>;</span><br><span class="line">    offindex = s1.<span class="built_in">find</span>(<span class="string">&quot;wbm&quot;</span>, offindex);</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">//替换 </span></span><br><span class="line">string s2 = <span class="string">&quot;wbm hello wbm 111 wbm 222 wbm 333&quot;</span>;</span><br><span class="line">s2.<span class="built_in">replace</span>(<span class="number">0</span>, <span class="number">3</span>, <span class="string">&quot;wbm&quot;</span>);</span><br><span class="line">cout &lt;&lt; s2 &lt;&lt; endl; </span><br><span class="line"></span><br><span class="line"><span class="comment">//求itcast出现的次数</span></span><br><span class="line">offindex = s2.<span class="built_in">find</span>(<span class="string">&quot;wbm&quot;</span>, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">while</span> (offindex != string::npos)&#123;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;在下标index: &quot;</span> &lt;&lt; offindex &lt;&lt; <span class="string">&quot;找到wbm\n&quot;</span>;</span><br><span class="line">    s2.<span class="built_in">replace</span>(offindex, <span class="number">3</span>, <span class="string">&quot;WBM&quot;</span>);</span><br><span class="line">    offindex = offindex + <span class="number">1</span>;</span><br><span class="line">    offindex = s1.<span class="built_in">find</span>(<span class="string">&quot;wbm&quot;</span>, offindex);</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;替换以后的s2：&quot;</span> &lt;&lt; s2 &lt;&lt; endl; </span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">结果：</span></span><br><span class="line"><span class="comment">index: 0在下标index: 0找到wbm</span></span><br><span class="line"><span class="comment">在下标index: 10找到wbm</span></span><br><span class="line"><span class="comment">在下标index: 18找到wbm</span></span><br><span class="line"><span class="comment">在下标index: 26找到wbm</span></span><br><span class="line"><span class="comment">wbm hello wbm 111 wbm 222 wbm 333</span></span><br><span class="line"><span class="comment">在下标index: 0找到wbm</span></span><br><span class="line"><span class="comment">在下标index: 10找到wbm</span></span><br><span class="line"><span class="comment">在下标index: 18找到wbm</span></span><br><span class="line"><span class="comment">在下标index: 26找到wbm</span></span><br><span class="line"><span class="comment">替换以后的s2：WBM hello WBM 111 WBM 222 WBM 333</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>



<h3 id="十二、String的区间删除和插入"><a href="#十二、String的区间删除和插入" class="headerlink" title="十二、String的区间删除和插入"></a>十二、String的区间删除和插入</h3><ul>
<li><p>  string &amp;insert(int pos, const char *s);</p>
</li>
<li><p>  string &amp;insert(int pos, const string &amp;s);//在pos位置插入字符串s</p>
</li>
<li><p>  string &amp;insert(int pos, int n, char c); //在pos位置 插入n个字符c </p>
</li>
<li><p>  string &amp;erase(int pos=0, int n=npos); //删除pos开始的n个字符，返回修改后的字符串</p>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">string s = <span class="string">&quot;abcdefg&quot;</span>;</span><br><span class="line">s.<span class="built_in">insert</span>(<span class="number">3</span>, <span class="string">&quot;111&quot;</span>);</span><br><span class="line">cout &lt;&lt; s &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">s.<span class="built_in">erase</span>(<span class="number">0</span>, <span class="number">2</span>);</span><br><span class="line">cout &lt;&lt; s &lt;&lt; endl;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">结果：</span></span><br><span class="line"><span class="comment">abc111defg</span></span><br><span class="line"><span class="comment">c111defg</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>C++</category>
        <category>STL</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>STL</tag>
        <tag>STL容器</tag>
      </tags>
  </entry>
  <entry>
    <title>STL_stack容器</title>
    <url>/2021/05/07/STL%EF%BC%9Astack%E5%AE%B9%E5%99%A8/</url>
    <content><![CDATA[<h3 id="一、stack简介"><a href="#一、stack简介" class="headerlink" title="一、stack简介"></a>一、stack简介</h3><p>    stack是一种先进后出(First In Last Out,FILO)的数据结构，它只有一个出口。stack容器允许新增元素，移除元素，取得栈顶元素，但是除了最顶端外，没有任何其他方法可以存取stack的其他元素。换言之，stack不允许有遍历行为。</p>
<span id="more"></span>

<ul>
<li>有元素推入栈的操作称为:push</li>
<li>将元素推出stack的操作称为pop</li>
</ul>
<p>    stack是简单地装饰deque容器而成为另外的一种容器。</p>
<p>    #include&lt;stack&gt; </p>
<h3 id="二、stack对象的默认构造"><a href="#二、stack对象的默认构造" class="headerlink" title="二、stack对象的默认构造"></a>二、stack对象的默认构造</h3><p>    stack采用模板类实现， stack对象的默认构造形式： stack <T> stkT; </T></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">stack &lt;<span class="keyword">int</span>&gt; stkInt;      <span class="comment">//一个存放int的stack容器。</span></span><br><span class="line">stack &lt;<span class="keyword">float</span>&gt; stkFloat;   <span class="comment">//一个存放float的stack容器。</span></span><br><span class="line">stack &lt;string&gt; stkString;   <span class="comment">//一个存放string的stack容器。</span></span><br><span class="line"><span class="comment">//尖括号内还可以设置指针类型或自定义类型。</span></span><br></pre></td></tr></table></figure>



<h3 id="三、stack的push-与pop-方法"><a href="#三、stack的push-与pop-方法" class="headerlink" title="三、stack的push()与pop()方法"></a>三、stack的push()与pop()方法</h3><p>    stack.push(elem);  //往栈头添加元素</p>
<p>    stack.pop();  //从栈头移除第一个元素 </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">stack&lt;<span class="keyword">int</span>&gt; stkInt;  </span><br><span class="line"></span><br><span class="line">stkInt.<span class="built_in">push</span>(<span class="number">1</span>);</span><br><span class="line">stkInt.<span class="built_in">push</span>(<span class="number">3</span>);</span><br><span class="line">stkInt.<span class="built_in">pop</span>();  </span><br><span class="line"><span class="comment">//此时stkInt存放的元素是1</span></span><br></pre></td></tr></table></figure>



<h3 id="四、stack对象的拷贝构造与赋值"><a href="#四、stack对象的拷贝构造与赋值" class="headerlink" title="四、stack对象的拷贝构造与赋值"></a>四、stack对象的拷贝构造与赋值</h3><p>    stack(const stack &amp;stk);         //拷贝构造函数</p>
<p>    stack&amp; operator=(const stack &amp;stk);    //重载等号操作符         </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">stack&lt;<span class="keyword">int</span>&gt; stkIntA;</span><br><span class="line">stkIntA.<span class="built_in">push</span>(<span class="number">9</span>);</span><br><span class="line"><span class="function">stack&lt;<span class="keyword">int</span>&gt; <span class="title">stkIntB</span><span class="params">(stkIntA)</span></span>;       <span class="comment">//拷贝构造</span></span><br><span class="line">stack&lt;<span class="keyword">int</span>&gt; stkIntC;</span><br><span class="line">stkIntC = stkIntA;               <span class="comment">//赋值</span></span><br></pre></td></tr></table></figure>



<h3 id="五、stack的数据存取"><a href="#五、stack的数据存取" class="headerlink" title="五、stack的数据存取"></a>五、stack的数据存取</h3><p>    stack.top();  //返回最后一个压入栈元素，即栈顶元素        </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">stack&lt;<span class="keyword">int</span>&gt; stkIntA;</span><br><span class="line">stkIntA.<span class="built_in">push</span>(<span class="number">1</span>);</span><br><span class="line">stkIntA.<span class="built_in">push</span>(<span class="number">7</span>);</span><br><span class="line">stkIntA.<span class="built_in">push</span>(<span class="number">9</span>); </span><br><span class="line"><span class="keyword">int</span> iTop = stkIntA.<span class="built_in">top</span>();      <span class="comment">//9</span></span><br></pre></td></tr></table></figure>

<h3 id="六、stack的大小"><a href="#六、stack的大小" class="headerlink" title="六、stack的大小"></a>六、stack的大小</h3><p>    stack.empty();  //判断堆栈是否为空</p>
<p>    stack.size();       //返回堆栈的大小         </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">stack&lt;<span class="keyword">int</span>&gt; stkIntA;</span><br><span class="line">stkIntA.<span class="built_in">push</span>(<span class="number">1</span>);</span><br><span class="line">stkIntA.<span class="built_in">push</span>(<span class="number">3</span>);</span><br><span class="line"><span class="keyword">if</span> (!stkIntA.<span class="built_in">empty</span>())&#123;</span><br><span class="line">	<span class="keyword">int</span> iSize = stkIntA.<span class="built_in">size</span>();      <span class="comment">//2</span></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>C++</category>
        <category>STL</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>STL</tag>
        <tag>STL容器</tag>
      </tags>
  </entry>
  <entry>
    <title>STL_set和multiset容器</title>
    <url>/2021/05/07/STL%EF%BC%9Aset%E5%92%8Cmultiset%E5%AE%B9%E5%99%A8/</url>
    <content><![CDATA[<h3 id="一、set-multiset的简介"><a href="#一、set-multiset的简介" class="headerlink" title="一、set/multiset的简介"></a>一、set/multiset的简介</h3><p>    set是一个<strong>集合</strong>容器，其中所包含的元素是<strong>唯一</strong>的，<strong>集合中的元素按一定的顺序排列</strong>。<strong>元素插入过程是按排序规则插入</strong>，所以不能指定插入位置。</p>
<span id="more"></span>

<p>    set采用<strong>红黑树</strong>变体的数据结构实现，红黑树属于平衡二叉树。<strong>在插入操作和删除操作上比vector快</strong>。</p>
<p>    set不可以直接存取元素。（不可以使用at.(pos)与[]操作符）。</p>
<p>    multiset与set的区别：</p>
<ul>
<li>set支持唯一键值，<strong>每个元素值只能出现一次</strong>；</li>
<li>multiset中<strong>同一值可以出现多次</strong>。</li>
</ul>
<p>    不可以直接修改set或multiset容器中的元素值，因为该类容器是自动排序的。如果希望修改一个元素值，必须先删除原有的元素，再插入新的元素。</p>
<p>    #include &lt;set&gt; </p>
<p>​                               </p>
<h3 id="二、set-multiset构造函数"><a href="#二、set-multiset构造函数" class="headerlink" title="二、set/multiset构造函数"></a>二、set/multiset构造函数</h3><p>    set&lt;T&gt; st;//set默认构造函数：</p>
<p>    mulitset&lt;T&gt; mst; //multiset默认构造函数</p>
<p>    set(const set &amp;st);         //拷贝构造函数</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">set&lt;<span class="keyword">int</span>&gt; setInt;      <span class="comment">//一个存放int的set容器。</span></span><br><span class="line">multiset&lt;<span class="keyword">int</span>&gt; mulsetInt;      <span class="comment">//一个存放int的multiset容器。</span></span><br><span class="line"><span class="function">set&lt;<span class="keyword">int</span>&gt; <span class="title">setIntB</span><span class="params">(setIntA)</span></span>; <span class="comment">//1 3 5 7 9</span></span><br></pre></td></tr></table></figure>



<h3 id="三、set的插入与迭代器"><a href="#三、set的插入与迭代器" class="headerlink" title="三、set的插入与迭代器"></a>三、set的插入与迭代器</h3><p>    set.insert(elem);   //在容器中插入元素。</p>
<p>    set.begin(); //返回容器中第一个数据的迭代器。</p>
<p>    set.end(); //返回容器中最后一个数据之后的迭代器。</p>
<p>    set.rbegin(); //返回容器中倒数第一个元素的迭代器。</p>
<p>    set.rend();  //返回容器中倒数最后一个元素的后面的迭代器。 </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">set&lt;<span class="keyword">int</span>&gt; setInt;</span><br><span class="line">setInt.<span class="built_in">insert</span>(<span class="number">3</span>); </span><br><span class="line">setInt.<span class="built_in">insert</span>(<span class="number">1</span>);</span><br><span class="line">setInt.<span class="built_in">insert</span>(<span class="number">5</span>);</span><br><span class="line">setInt.<span class="built_in">insert</span>(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(set&lt;<span class="keyword">int</span>&gt;::iterator it=setInt.<span class="built_in">begin</span>(); it!=setInt.<span class="built_in">end</span>(); ++it)&#123;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">int</span> iItem = *it;</span><br><span class="line">   cout &lt;&lt; iItem;  <span class="comment">//或直接使用cout &lt;&lt; *it</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//这样子便顺序输出 1 2 3 5(默认排序，从小到大)</span></span><br></pre></td></tr></table></figure>

<h3 id="四、set集合的元素排序"><a href="#四、set集合的元素排序" class="headerlink" title="四、set集合的元素排序"></a>四、set集合的元素排序</h3><p>    set&lt;int,less&lt;int&gt; &gt; setIntA; //该容器是按升序方式排列元素。</p>
<p>    set&lt;int,greater&lt;int&gt;&gt; setIntB;  //该容器是按降序方式排列元素。</p>
<p>    set&lt;int&gt; 相当于 set&lt;int,less&lt;int&gt;&gt;。</p>
<p>    less&lt;int&gt;与greater&lt;int&gt;中的int可以改成其它类型，该类型主要要跟set容纳的数据类型一致。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">set&lt;<span class="keyword">int</span>,greater&lt;<span class="keyword">int</span>&gt;&gt; setIntB;</span><br><span class="line">setIntB.<span class="built_in">insert</span>(<span class="number">3</span>);</span><br><span class="line">setIntB.<span class="built_in">insert</span>(<span class="number">1</span>);</span><br><span class="line">setIntB.<span class="built_in">insert</span>(<span class="number">5</span>);</span><br><span class="line">setIntB.<span class="built_in">insert</span>(<span class="number">2</span>);</span><br><span class="line"><span class="comment">//此时容器setIntB就包含了按顺序的5,3,2,1元素</span></span><br></pre></td></tr></table></figure>



<h3 id="五、函数对象functor的用法"><a href="#五、函数对象functor的用法" class="headerlink" title="五、函数对象functor的用法"></a>五、函数对象functor的用法</h3><p>    尽管函数指针被广泛用于实现函数回调，但C++还提供了一个重要的实现回调函数的方法，那就是函数对象。</p>
<p>    functor，翻译成函数对象，伪函数，算符，是重载了“()”操作符的普通类对象。从语法上讲，它与普通函数行为类似。</p>
<p>    greater&lt;&gt;与less&lt;&gt;就是函数对象。 </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//下面举出greater&lt;int&gt;的简易实现原理。</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">greater</span>&#123;</span></span><br><span class="line">	<span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span> <span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>&amp; iLeft, <span class="keyword">const</span> <span class="keyword">int</span>&amp; iRight)</span></span>&#123;</span><br><span class="line">   		<span class="keyword">return</span> (iLeft&gt;iRight);  <span class="comment">//如果是实现less&lt;int&gt;的话，这边是写return (iLeft&lt;iRight);</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//容器就是调用函数对象的operator()方法去比较两个值的大小。</span></span><br></pre></td></tr></table></figure>

<h3 id="六、set对象赋值"><a href="#六、set对象赋值" class="headerlink" title="六、set对象赋值"></a>六、set对象赋值</h3><p>    set&amp; operator=(const set &amp;st);    //重载等号操作符</p>
<p>    set.swap(st);               //交换两个集合容器</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">set&lt;<span class="keyword">int</span>&gt; setIntA;</span><br><span class="line">set&lt;<span class="keyword">int</span>&gt; setIntC;</span><br><span class="line"></span><br><span class="line">setIntA.<span class="built_in">insert</span>(<span class="number">3</span>);</span><br><span class="line">setIntA.<span class="built_in">insert</span>(<span class="number">1</span>);</span><br><span class="line">setIntA.<span class="built_in">insert</span>(<span class="number">7</span>);</span><br><span class="line">setIntA.<span class="built_in">insert</span>(<span class="number">5</span>);</span><br><span class="line">setIntA.<span class="built_in">insert</span>(<span class="number">9</span>);    </span><br><span class="line"></span><br><span class="line">setIntC = setIntA;       <span class="comment">//1 3 5 7 9 </span></span><br><span class="line">setIntC.<span class="built_in">insert</span>(<span class="number">6</span>);</span><br><span class="line">setIntC.<span class="built_in">swap</span>(setIntA);    <span class="comment">//交换</span></span><br></pre></td></tr></table></figure>



<h3 id="七、set的大小"><a href="#七、set的大小" class="headerlink" title="七、set的大小"></a>七、set的大小</h3><p>    set.size();  //返回容器中元素的数目</p>
<p>    set.empty();//判断容器是否为空 </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">set&lt;<span class="keyword">int</span>&gt; setIntA;</span><br><span class="line">setIntA.<span class="built_in">insert</span>(<span class="number">3</span>);</span><br><span class="line">setIntA.<span class="built_in">insert</span>(<span class="number">1</span>);</span><br><span class="line">setIntA.<span class="built_in">insert</span>(<span class="number">7</span>);</span><br><span class="line"><span class="keyword">if</span> (!setIntA.<span class="built_in">empty</span>())&#123;</span><br><span class="line">   <span class="keyword">int</span> iSize = setIntA.<span class="built_in">size</span>();      <span class="comment">//3</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="八、set的删除"><a href="#八、set的删除" class="headerlink" title="八、set的删除"></a>八、set的删除</h3><p>    set.clear();     //清除所有元素</p>
<p>    set.erase(pos);  //删除pos迭代器所指的元素，返回下一个元素的迭代器。</p>
<p>    set.erase(beg,end);    //删除区间[beg,end)的所有元素 ，返回下一个元素的迭代器。</p>
<p>    set.erase(elem);   //删除容器中值为elem的元素。 </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//删除区间内的元素</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//setInt是用set&lt;int&gt;声明的容器，现已包含按顺序的1,3,5,6,9,11元素。</span></span><br><span class="line">set&lt;<span class="keyword">int</span>&gt;::iterator itBegin=setInt.<span class="built_in">begin</span>();</span><br><span class="line">++ itBegin;</span><br><span class="line">set&lt;<span class="keyword">int</span>&gt;::iterator itEnd=setInt.<span class="built_in">begin</span>();</span><br><span class="line">++ itEnd;</span><br><span class="line">++ itEnd;</span><br><span class="line">++ itEnd;</span><br><span class="line">setInt.<span class="built_in">erase</span>(itBegin,itEnd);</span><br><span class="line"><span class="comment">//此时容器setInt包含按顺序的1,6,9,11四个元素。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//删除容器中第一个元素</span></span><br><span class="line">setInt.<span class="built_in">erase</span>(setInt.<span class="built_in">begin</span>());       <span class="comment">//6,9,11</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//删除容器中值为9的元素</span></span><br><span class="line">set.<span class="built_in">erase</span>(<span class="number">9</span>);   </span><br><span class="line"></span><br><span class="line"><span class="comment">//删除setInt的所有元素</span></span><br><span class="line">setInt.<span class="built_in">clear</span>();          <span class="comment">//容器为空</span></span><br></pre></td></tr></table></figure>

<h3 id="九、set的查找"><a href="#九、set的查找" class="headerlink" title="九、set的查找"></a>九、set的查找</h3><p>    set.find(elem);  //查找elem元素，返回指向elem元素的迭代器；若不存在，返回set.end()</p>
<p>    set.count(elem);  //返回容器中值为elem的元素个数。对set来说，要么是0，要么是1。对multiset来说，值可能大于1。</p>
<p>    set.lower_bound(elem); //返回第一个&gt;=elem元素的迭代器。</p>
<p>    set.upper_bound(elem);    // 返回第一个&gt;elem元素的迭代器。</p>
<p>    set.equal_range(elem);       //返回容器中与elem相等的上下限的两个迭代器。上限是闭区间，下限是开区间，如[beg,end)。返回两个迭代器，而这两个迭代器被封装在pair中。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">set&lt;<span class="keyword">int</span>&gt; s1;</span><br><span class="line">s1.<span class="built_in">insert</span>(<span class="number">7</span>);</span><br><span class="line">s1.<span class="built_in">insert</span>(<span class="number">2</span>);</span><br><span class="line">s1.<span class="built_in">insert</span>(<span class="number">4</span>);</span><br><span class="line">s1.<span class="built_in">insert</span>(<span class="number">5</span>);</span><br><span class="line">s1.<span class="built_in">insert</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">set&lt;<span class="keyword">int</span>&gt;::iterator ret = s1.<span class="built_in">find</span>(<span class="number">14</span>);</span><br><span class="line"><span class="keyword">if</span> (ret == s1.<span class="built_in">end</span>()) &#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;没有找到!&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;ret:&quot;</span> &lt;&lt; *ret &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//找第一个大于等于key的元素</span></span><br><span class="line">ret = s1.<span class="built_in">lower_bound</span>(<span class="number">2</span>);</span><br><span class="line"><span class="keyword">if</span> (ret == s1.<span class="built_in">end</span>()) &#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;没有找到!&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;ret:&quot;</span> &lt;&lt; *ret &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//找第一个大于key的值</span></span><br><span class="line">ret = s1.<span class="built_in">upper_bound</span>(<span class="number">2</span>);</span><br><span class="line"><span class="keyword">if</span> (ret == s1.<span class="built_in">end</span>()) &#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;没有找到!&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;ret:&quot;</span> &lt;&lt; *ret &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//equal_range 返回Lower_bound 和 upper_bound值</span></span><br><span class="line">pair&lt;set&lt;<span class="keyword">int</span>&gt;::iterator, set&lt;<span class="keyword">int</span>&gt;::iterator&gt; myret = s1.<span class="built_in">equal_range</span>(<span class="number">2</span>);</span><br><span class="line"><span class="keyword">if</span> (myret.first == s1.<span class="built_in">end</span>()) &#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;没有找到！&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;myret:&quot;</span> &lt;&lt; *(myret.first) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (myret.second == s1.<span class="built_in">end</span>()) &#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;没有找到！&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;myret:&quot;</span> &lt;&lt; *(myret.second) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">结果：</span></span><br><span class="line"><span class="comment">没有找到!</span></span><br><span class="line"><span class="comment">ret:2</span></span><br><span class="line"><span class="comment">ret:4</span></span><br><span class="line"><span class="comment">myret:2</span></span><br><span class="line"><span class="comment">myret:4</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>C++</category>
        <category>STL</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>STL</tag>
        <tag>STL容器</tag>
      </tags>
  </entry>
  <entry>
    <title>STL_queue容器</title>
    <url>/2021/05/07/STL%EF%BC%9Aqueue%E5%AE%B9%E5%99%A8/</url>
    <content><![CDATA[<h3 id="一、queue简介"><a href="#一、queue简介" class="headerlink" title="一、queue简介"></a>一、queue简介</h3><p>    queue所有元素的进出都必须符合”先进先出”的条件，只有queue的顶端元素，才有机会被外界取用。queue不提供遍历功能，也不提供迭代器。</p>
<span id="more"></span>

<p>    queue是简单地装饰deque容器而成为另外的一种容器。</p>
<p>    #include &lt;queue&gt; </p>
<h3 id="二、queue对象的默认构造"><a href="#二、queue对象的默认构造" class="headerlink" title="二、queue对象的默认构造"></a>二、queue对象的默认构造</h3><p>    queue采用模板类实现，queue对象的默认构造形式：queue&lt;T&gt; queT; </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">queue&lt;<span class="keyword">int</span>&gt; queInt;      <span class="comment">//一个存放int的queue容器。</span></span><br><span class="line">queue&lt;<span class="keyword">float</span>&gt; queFloat;   <span class="comment">//一个存放float的queue容器。</span></span><br><span class="line">queue&lt;string&gt; queString;   <span class="comment">//一个存放string的queue容器。</span></span><br><span class="line"><span class="comment">//尖括号内还可以设置指针类型或自定义类型。          </span></span><br></pre></td></tr></table></figure>

<h3 id="三、queue的push-与pop-方法"><a href="#三、queue的push-与pop-方法" class="headerlink" title="三、queue的push()与pop()方法"></a>三、queue的push()与pop()方法</h3><p>    queue.push(elem);  //往队尾添加元素</p>
<p>    queue.pop();  //从队头移除第一个元素 </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">queue&lt;<span class="keyword">int</span>&gt; queInt;</span><br><span class="line"></span><br><span class="line">queInt.<span class="built_in">push</span>(<span class="number">1</span>);</span><br><span class="line">queInt.<span class="built_in">push</span>(<span class="number">3</span>);</span><br><span class="line">queInt.<span class="built_in">push</span>(<span class="number">5</span>);</span><br><span class="line">queInt.<span class="built_in">push</span>(<span class="number">7</span>);</span><br><span class="line">queInt.<span class="built_in">push</span>(<span class="number">9</span>);</span><br><span class="line">queInt.<span class="built_in">pop</span>();</span><br><span class="line">queInt.<span class="built_in">pop</span>();</span><br><span class="line"><span class="comment">//此时queInt存放的元素是5,7,9</span></span><br></pre></td></tr></table></figure>



<h3 id="四、queue对象的拷贝构造与赋值"><a href="#四、queue对象的拷贝构造与赋值" class="headerlink" title="四、queue对象的拷贝构造与赋值"></a>四、queue对象的拷贝构造与赋值</h3><p>    queue(const queue &amp;que);          //拷贝构造函数</p>
<p>    queue&amp; operator=(const queue &amp;que); //重载等号操作符        </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">queue&lt;<span class="keyword">int</span>&gt; queIntA;</span><br><span class="line">queIntA.<span class="built_in">push</span>(<span class="number">1</span>);</span><br><span class="line">queIntA.<span class="built_in">push</span>(<span class="number">3</span>); </span><br><span class="line"><span class="function">queue&lt;<span class="keyword">int</span>&gt; <span class="title">queIntB</span><span class="params">(queIntA)</span></span>;    <span class="comment">//拷贝构造</span></span><br><span class="line">queue&lt;<span class="keyword">int</span>&gt; queIntC;</span><br><span class="line">queIntC = queIntA;              <span class="comment">//赋值</span></span><br></pre></td></tr></table></figure>



<h3 id="五、queue的数据存取"><a href="#五、queue的数据存取" class="headerlink" title="五、queue的数据存取"></a>五、queue的数据存取</h3><p>    queue.back();  //返回最后一个元素</p>
<p>    queue.front();  //返回第一个元素        </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">queue&lt;<span class="keyword">int</span>&gt; queIntA;</span><br><span class="line">queIntA.<span class="built_in">push</span>(<span class="number">1</span>);</span><br><span class="line">queIntA.<span class="built_in">push</span>(<span class="number">3</span>);</span><br><span class="line">queIntA.<span class="built_in">push</span>(<span class="number">5</span>);</span><br><span class="line">queIntA.<span class="built_in">push</span>(<span class="number">7</span>);</span><br><span class="line">queIntA.<span class="built_in">push</span>(<span class="number">9</span>);</span><br><span class="line"><span class="keyword">int</span> iFront = queIntA.<span class="built_in">front</span>();       <span class="comment">//1</span></span><br><span class="line"><span class="keyword">int</span> iBack = queIntA.<span class="built_in">back</span>();       <span class="comment">//9</span></span><br></pre></td></tr></table></figure>

<h3 id="六、queue的大小"><a href="#六、queue的大小" class="headerlink" title="六、queue的大小"></a>六、queue的大小</h3><p>    queue.empty();  //判断队列是否为空</p>
<p>    queue.size();      //返回队列的大小         </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">queue&lt;<span class="keyword">int</span>&gt; queIntA;    </span><br><span class="line">queIntA.<span class="built_in">push</span>(<span class="number">1</span>);      </span><br><span class="line">queIntA.<span class="built_in">push</span>(<span class="number">3</span>);      </span><br><span class="line">queIntA.<span class="built_in">push</span>(<span class="number">5</span>);       </span><br><span class="line">queIntA.<span class="built_in">push</span>(<span class="number">7</span>);       </span><br><span class="line">queIntA.<span class="built_in">push</span>(<span class="number">9</span>);       </span><br><span class="line"><span class="keyword">if</span> (!queIntA.<span class="built_in">empty</span>())&#123;</span><br><span class="line">   <span class="keyword">int</span> iSize = queIntA.<span class="built_in">size</span>();     <span class="comment">//5</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>C++</category>
        <category>STL</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>STL</tag>
        <tag>STL容器</tag>
      </tags>
  </entry>
  <entry>
    <title>STL_优先队列</title>
    <url>/2021/05/07/STL%EF%BC%9Apriority_queue/</url>
    <content><![CDATA[<h3 id="一、简介"><a href="#一、简介" class="headerlink" title="一、简介"></a>一、简介</h3><p>    优先队列容器与队列一样，只能从队尾插入元素，从队首删除元素。但是它有一个特性，就是队列中最大的元素总是位于队首，所以出队时，并非按照先进先出的原则进行，而是将当前队列中最大的元素出队。</p>
<span id="more"></span>

<p>    元素的比较规则默认按元素值由大到小排序，可以重载“&lt;”操作符来重新定义比较规则。</p>
<p>    优先级队列可以用向量(vector)或双向队列(deque)来实现</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">priority_queue&lt;int, vector&lt;int&gt;, less&lt;int&gt; &gt; pq1; 　　　 &#x2F;&#x2F; 使用递增less&lt;int&gt;函数对象排序</span><br><span class="line">priority_queue&lt;int, deque&lt;int&gt;, greater&lt;int&gt; &gt; pq2; 　　&#x2F;&#x2F; 使用递减greater&lt;int&gt;函数对象排序</span><br></pre></td></tr></table></figure>

<h3 id="二、基本操作"><a href="#二、基本操作" class="headerlink" title="二、基本操作"></a>二、基本操作</h3><p>    #include &lt;queue&gt;</p>
<table>
<thead>
<tr>
<th>函数接口</th>
<th align="center">功能</th>
</tr>
</thead>
<tbody><tr>
<td>empty()</td>
<td align="center">如果队列为空，则返回真</td>
</tr>
<tr>
<td>pop()</td>
<td align="center">删除对顶元素，删除第一个元素</td>
</tr>
<tr>
<td>push(elem)</td>
<td align="center">加入一个元素</td>
</tr>
<tr>
<td>size()</td>
<td align="center">返回优先队列中拥有的元素个数</td>
</tr>
<tr>
<td>top()</td>
<td align="center">返回优先队列对顶元素，返回优先队列中有最高优先级的元素</td>
</tr>
</tbody></table>
<h3 id="三、代码示例"><a href="#三、代码示例" class="headerlink" title="三、代码示例"></a>三、代码示例</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span> </span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    priority_queue&lt;<span class="keyword">int</span>&gt; p1; <span class="comment">//默认是 最大值优先级队列 </span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//priority_queue&lt;int, vector&lt;int&gt;, less&lt;int&gt; &gt; p1**; //相当于这样写</span></span><br><span class="line"></span><br><span class="line">    priority_queue&lt;<span class="keyword">int</span>, vector&lt;<span class="keyword">int</span>&gt;, greater&lt;<span class="keyword">int</span>&gt;&gt; p2; <span class="comment">//最小值优先级队列</span></span><br><span class="line"></span><br><span class="line">    p1.<span class="built_in">push</span>(<span class="number">33</span>);</span><br><span class="line">    p1.<span class="built_in">push</span>(<span class="number">11</span>);</span><br><span class="line">    p1.<span class="built_in">push</span>(<span class="number">55</span>);</span><br><span class="line">    p1.<span class="built_in">push</span>(<span class="number">22</span>);</span><br><span class="line">    cout &lt;&lt;<span class="string">&quot;队列大小&quot;</span> &lt;&lt; p1.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt;<span class="string">&quot;队头&quot;</span> &lt;&lt; p1.<span class="built_in">top</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (p1.<span class="built_in">size</span>() &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">         cout &lt;&lt; p1.<span class="built_in">top</span>() &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">         p1.<span class="built_in">pop</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;测试 最小值优先级队列&quot;</span> &lt;&lt; endl;</span><br><span class="line">    p2.<span class="built_in">push</span>(<span class="number">33</span>);</span><br><span class="line">    p2.<span class="built_in">push</span>(<span class="number">11</span>);</span><br><span class="line">    p2.<span class="built_in">push</span>(<span class="number">55</span>);</span><br><span class="line">    p2.<span class="built_in">push</span>(<span class="number">22</span>);</span><br><span class="line">    <span class="keyword">while</span> (p2.<span class="built_in">size</span>() &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">         cout &lt;&lt; p2.<span class="built_in">top</span>() &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">         p2.<span class="built_in">pop</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">队列大小4</span></span><br><span class="line"><span class="comment">队头55</span></span><br><span class="line"><span class="comment">55 33 22 11</span></span><br><span class="line"><span class="comment">测试 最小值优先级队列</span></span><br><span class="line"><span class="comment">11 22 33 55</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h3 id="四、优先队列与堆"><a href="#四、优先队列与堆" class="headerlink" title="四、优先队列与堆"></a>四、优先队列与堆</h3><p>    这里面说的堆默认我们最常使用的二叉堆，而二叉堆只是优先队列的一种是实现方式而已。</p>
<p>    优先队列还有哪些实现方式：二项堆 平衡树 线段树 甚至用二进制分组的vector来实现一个优先对列。</p>
<p><a href="https://mp.weixin.qq.com/s?__biz=MzAxODQxMDM0Mw==&mid=2247484495&idx=1&sn=bbfeba9bb5cfd50598e2a4d08c839ee9&chksm=9bd7fa47aca073512e094110a7fe7d9bac052be114d1db72fe07b7efa6beb915f51b3f19291e&scene=21#wechat_redirect">图文详解二叉堆，实现优先级队列</a></p>
]]></content>
      <categories>
        <category>C++</category>
        <category>STL</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>STL</tag>
        <tag>STL容器</tag>
      </tags>
  </entry>
  <entry>
    <title>STL_map和multimap容器</title>
    <url>/2021/05/07/STL%EF%BC%9Amap%E5%92%8Cmultimap%E5%AE%B9%E5%99%A8/</url>
    <content><![CDATA[<h3 id="一、map-multimap的简介"><a href="#一、map-multimap的简介" class="headerlink" title="一、map/multimap的简介"></a>一、map/multimap的简介</h3><p>    map是标准的<strong>关联式</strong>容器，一个map是一个键值对序列，即(key,value)对。它提供基于key的快速检索能力。</p>
<span id="more"></span>

<p>    map中<strong>key</strong>值是唯一的<strong>。集合中的元素按一定的顺序</strong>排列。元素插入过程是按排序规则插入，所以不能指定插入位置。</p>
<p>    map的具体实现采用红黑树变体的平衡二叉树的数据结构，在插入操作和删除操作上比vector快。</p>
<p>    map可以直接存取key所对应的value，支持[]操作符，如map[key]=value。</p>
<p>    multimap与map的区别：map支持唯一键值，每个键只能出现一次；而multimap中相同键可以出现多次。multimap不支持[]操作符。</p>
<p>    #include &lt;map&gt; </p>
<p>​                         </p>
<h3 id="二、map-multimap对象的默认构造"><a href="#二、map-multimap对象的默认构造" class="headerlink" title="二、map/multimap对象的默认构造"></a>二、map/multimap对象的默认构造</h3><p>    map/multimap采用模板类实现，对象的默认构造形式：</p>
<ul>
<li>map&lt;T1,T2&gt; mapTT; </li>
<li>multimap&lt;T1,T2&gt; multimapTT; </li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">map&lt;<span class="keyword">int</span>, <span class="keyword">char</span>&gt; mapA;</span><br><span class="line">map&lt;string,<span class="keyword">float</span>&gt; mapB;</span><br><span class="line"><span class="comment">//其中T1,T2还可以用各种指针类型或自定义类型</span></span><br></pre></td></tr></table></figure>



<h3 id="三、map的插入与迭代器"><a href="#三、map的插入与迭代器" class="headerlink" title="三、map的插入与迭代器"></a>三、map的插入与迭代器</h3><p>    map.insert(…);  //往容器插入元素，返回pair&lt;iterator,bool&gt;</p>
<p>    假设map&lt;int, int&gt; mymap，在map中插入元素的方式：</p>
<ol>
<li><p>通过pair的方式插入对象：mymap.insert(pair&lt;int, int&gt;(10, 10));</p>
</li>
<li><p>通过pair的方式插入对象：mymap.insert(make_pair(20, 20));</p>
</li>
<li><p>通过value_type的方式插入对象：mymap.insert(map&lt;int, int&gt;::value_type(30, 30));</p>
</li>
<li><p>通过数组的方式插入值：mymap[40] = 40。</p>
</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//map容器模板参数，第一个参数key的类型，第二参数value类型</span></span><br><span class="line">map&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; mymap;</span><br><span class="line"></span><br><span class="line"><span class="comment">//插入数据  pair.first key值 piar.second value值</span></span><br><span class="line"><span class="comment">//第一种</span></span><br><span class="line">pair&lt;map&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;::iterator, <span class="keyword">bool</span>&gt; ret = mymap.<span class="built_in">insert</span>(pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;(<span class="number">10</span>, <span class="number">10</span>));</span><br><span class="line"><span class="comment">//第二种</span></span><br><span class="line">mymap.<span class="built_in">insert</span>(<span class="built_in">make_pair</span>(<span class="number">20</span>, <span class="number">20</span>));</span><br><span class="line"><span class="comment">//第三种</span></span><br><span class="line">mymap.<span class="built_in">insert</span>(map&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;::<span class="built_in">value_type</span>(<span class="number">30</span>, <span class="number">30</span>));</span><br><span class="line"><span class="comment">//第四种，发现如果key不存在，创建pair插入到map容器中；如果发现key存在，那么会修改key对应的value。</span></span><br><span class="line">mymap[<span class="number">40</span>] = <span class="number">40</span>;</span><br><span class="line">mymap[<span class="number">10</span>] = <span class="number">20</span>;</span><br><span class="line">mymap[<span class="number">50</span>] = <span class="number">50</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (map&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;::iterator it = mymap.<span class="built_in">begin</span>(); it != mymap.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;key:&quot;</span> &lt;&lt; (*it).first &lt;&lt; <span class="string">&quot; value:&quot;</span> &lt;&lt; it-&gt;second &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">结果：</span></span><br><span class="line"><span class="comment">key:10 value:20</span></span><br><span class="line"><span class="comment">key:20 value:20</span></span><br><span class="line"><span class="comment">key:30 value:30</span></span><br><span class="line"><span class="comment">key:40 value:40</span></span><br><span class="line"><span class="comment">key:50 value:50</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>    前三种方法，采用的是insert()方法，该方法返回值为pair&lt;iterator,bool&gt;</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">	pair&lt;map&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;::iterator, <span class="keyword">bool</span>&gt; ret = mymap.<span class="built_in">insert</span>(pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;(<span class="number">10</span>, <span class="number">10</span>));</span><br><span class="line">	<span class="keyword">if</span> (ret.second) &#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;第一次插入成功!&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;插入失败!&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">结果：</span></span><br><span class="line"><span class="comment">第一次插入成功!</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>    第四种方法非常直观，但存在一个性能的问题。插入3时，先在mapStu中查找主键为3的项，若没发现，则将一个键为3，值为初始化值的对组插入到mapStu中，然后再将值<strong>修改</strong>。若发现已存在3这个键，则修改这个键对应的value。  </p>
<p>    map&lt;T1,T2,less&lt;T1&gt; &gt; mapA; //该容器是按键的升序方式排列元素。未指定函数对象，默认采用less&lt;T1&gt;函数对象。</p>
<p>    map&lt;T1,T2,greater&lt;T1&gt;&gt; mapB;  //该容器是按键的降序方式排列元素。</p>
<p>    less&lt;T1&gt;与greater&lt;T1&gt; 可以替换成其它的函数对象functor。</p>
<p>    可编写自定义函数对象以进行自定义类型的比较，使用方法与set构造时所用的函数对象一样。</p>
<h3 id="四、map对象的拷贝构造与赋值"><a href="#四、map对象的拷贝构造与赋值" class="headerlink" title="四、map对象的拷贝构造与赋值"></a>四、map对象的拷贝构造与赋值</h3><p>    map(const map &amp;mp);         //拷贝构造函数</p>
<p>    map&amp; operator=(const map &amp;mp);    //重载等号操作符</p>
<p>    map.swap(mp);                //交换两个集合容器       </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">map&lt;<span class="keyword">int</span>, string&gt; mapA;</span><br><span class="line">mapA.<span class="built_in">insert</span>(pair&lt;<span class="keyword">int</span>,string&gt;(<span class="number">3</span>,<span class="string">&quot;小张&quot;</span>));</span><br><span class="line">mapA.<span class="built_in">insert</span>(pair&lt;<span class="keyword">int</span>,string&gt;(<span class="number">1</span>,<span class="string">&quot;小杨&quot;</span>));    </span><br><span class="line">mapA.<span class="built_in">insert</span>(pair&lt;<span class="keyword">int</span>,string&gt;(<span class="number">7</span>,<span class="string">&quot;小赵&quot;</span>));    </span><br><span class="line">mapA.<span class="built_in">insert</span>(pair&lt;<span class="keyword">int</span>,string&gt;(<span class="number">5</span>,<span class="string">&quot;小王&quot;</span>));    </span><br><span class="line">map&lt;int ,string&gt; mapB(mapA);            //拷贝构造</span><br><span class="line">map&lt;<span class="keyword">int</span>, string&gt; mapC;</span><br><span class="line">mapC = mapA;                              <span class="comment">//赋值</span></span><br><span class="line">mapC[<span class="number">3</span>] = <span class="string">&quot;老张&quot;</span>;</span><br><span class="line">mapC.<span class="built_in">swap</span>(mapA);         <span class="comment">//交换</span></span><br></pre></td></tr></table></figure>



<h3 id="五、map的大小"><a href="#五、map的大小" class="headerlink" title="五、map的大小"></a>五、map的大小</h3><p>    map.size(); //返回容器中元素的数目</p>
<p>    map.empty();//判断容器是否为空         </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">map&lt;<span class="keyword">int</span>, string&gt; mapA;</span><br><span class="line">mapA.<span class="built_in">insert</span>(pair&lt;<span class="keyword">int</span>,string&gt;(<span class="number">3</span>,<span class="string">&quot;小张&quot;</span>));    </span><br><span class="line">mapA.<span class="built_in">insert</span>(pair&lt;<span class="keyword">int</span>,string&gt;(<span class="number">1</span>,<span class="string">&quot;小杨&quot;</span>));    </span><br><span class="line"><span class="keyword">if</span> (mapA.<span class="built_in">empty</span>())</span><br><span class="line">&#123;</span><br><span class="line">   <span class="keyword">int</span> iSize = mapA.<span class="built_in">size</span>();       <span class="comment">//iSize == 4</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="六、map的删除"><a href="#六、map的删除" class="headerlink" title="六、map的删除"></a>六、map的删除</h3><p>    map.clear();        //删除所有元素</p>
<p>    map.erase(pos); //删除pos迭代器所指的元素，返回下一个元素的迭代器。</p>
<p>    map.erase(beg,end);   //删除区间[beg,end)的所有元素 ，返回下一个元素的迭代器。</p>
<p>    map.erase(keyElem);   //删除容器中key为keyElem的对组。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">map&lt;<span class="keyword">int</span>, string&gt; mapA;</span><br><span class="line">mapA.<span class="built_in">insert</span>(pair&lt;<span class="keyword">int</span>,string&gt;(<span class="number">3</span>,<span class="string">&quot;小张&quot;</span>));   </span><br><span class="line">mapA.<span class="built_in">insert</span>(pair&lt;<span class="keyword">int</span>,string&gt;(<span class="number">1</span>,<span class="string">&quot;小杨&quot;</span>));   </span><br><span class="line">mapA.<span class="built_in">insert</span>(pair&lt;<span class="keyword">int</span>,string&gt;(<span class="number">7</span>,<span class="string">&quot;小赵&quot;</span>));   </span><br><span class="line">mapA.<span class="built_in">insert</span>(pair&lt;<span class="keyword">int</span>,string&gt;(<span class="number">5</span>,<span class="string">&quot;小王&quot;</span>));    </span><br><span class="line"> <span class="comment">//删除区间内的元素</span></span><br><span class="line">map&lt;<span class="keyword">int</span>,string&gt;::iterator itBegin=mapA.<span class="built_in">begin</span>();</span><br><span class="line">++ itBegin;</span><br><span class="line">++ itBegin;</span><br><span class="line"></span><br><span class="line">map&lt;<span class="keyword">int</span>,string&gt;::iterator itEnd=mapA.<span class="built_in">end</span>();</span><br><span class="line">mapA.<span class="built_in">erase</span>(itBegin,itEnd);         <span class="comment">//此时容器mapA包含按顺序的&#123;1,&quot;小杨&quot;&#125;&#123;3,&quot;小张&quot;&#125;两个元素。</span></span><br><span class="line"></span><br><span class="line">mapA.<span class="built_in">insert</span>(pair&lt;<span class="keyword">int</span>,string&gt;(<span class="number">7</span>,<span class="string">&quot;小赵&quot;</span>));    </span><br><span class="line">mapA.<span class="built_in">insert</span>(pair&lt;<span class="keyword">int</span>,string&gt;(<span class="number">5</span>,<span class="string">&quot;小王&quot;</span>));    </span><br><span class="line"></span><br><span class="line"><span class="comment">//删除容器中第一个元素</span></span><br><span class="line">mapA.<span class="built_in">erase</span>(mapA.<span class="built_in">begin</span>());  <span class="comment">//此时容器mapA包含了按顺序的&#123;3,&quot;小张&quot;&#125;&#123;5,&quot;小王&quot;&#125;&#123;7,&quot;小赵&quot;&#125;三个元素</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//删除容器中key为5的元素</span></span><br><span class="line">mapA.<span class="built_in">erase</span>(<span class="number">5</span>);  </span><br><span class="line"></span><br><span class="line"><span class="comment">//删除mapA的所有元素</span></span><br><span class="line">mapA.<span class="built_in">clear</span>();          <span class="comment">//容器为空</span></span><br></pre></td></tr></table></figure>



<h3 id="七、map的查找"><a href="#七、map的查找" class="headerlink" title="七、map的查找"></a>七、map的查找</h3><p>    map.find(key);  //查找键key是否存在，若存在，返回该键的元素的迭代器；若不存在，返回map.end();</p>
<p>    map.count(keyElem);  //返回容器中key为keyElem的对组个数。对map来说，要么是0，要么是1。对multimap来说，值可能大于1。</p>
<p>    map.begin(); //返回容器中第一个数据的迭代器。</p>
<p>    map.end(); //返回容器中最后一个数据之后的迭代器。</p>
<p>    map.rbegin(); //返回容器中倒数第一个元素的迭代器。</p>
<p>    map.rend();  //返回容器中倒数最后一个元素的后面的迭代器。</p>
<p>    map.lower_bound(keyElem); //返回第一个key&gt;=keyElem元素的迭代器。</p>
<p>    map.upper_bound(keyElem);   // 返回第一个key&gt;keyElem元素的迭代器      </p>
<p>    map.equal_range(keyElem);       //返回容器中key与keyElem相等的上下限的两个迭代器。上限是闭区间，下限是开区间，如[beg,end)。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">	map&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; mymap;</span><br><span class="line">	mymap.<span class="built_in">insert</span>(<span class="built_in">make_pair</span>(<span class="number">1</span>, <span class="number">4</span>));</span><br><span class="line">	mymap.<span class="built_in">insert</span>(<span class="built_in">make_pair</span>(<span class="number">2</span>, <span class="number">5</span>));</span><br><span class="line">	mymap.<span class="built_in">insert</span>(<span class="built_in">make_pair</span>(<span class="number">3</span>, <span class="number">6</span>));</span><br><span class="line"></span><br><span class="line">	pair&lt;map&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;::iterator, map&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;::iterator&gt; ret = mymap.<span class="built_in">equal_range</span>(<span class="number">2</span>);</span><br><span class="line">	<span class="keyword">if</span> (ret.first != mymap.<span class="built_in">end</span>()) &#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;找到lower_bound！&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;没有找到&quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (ret.second != mymap.<span class="built_in">end</span>()) &#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;找到upper_bound！&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;没有找到&quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">结果：</span></span><br><span class="line"><span class="comment">找到lower_bound！</span></span><br><span class="line"><span class="comment">找到upper_bound！</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>C++</category>
        <category>STL</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>STL</tag>
        <tag>STL容器</tag>
      </tags>
  </entry>
  <entry>
    <title>STL_list容器</title>
    <url>/2021/05/07/STL%EF%BC%9Alist%E5%AE%B9%E5%99%A8/</url>
    <content><![CDATA[<h3 id="一、List简介"><a href="#一、List简介" class="headerlink" title="一、List简介"></a>一、List简介</h3><p>    链表是一种物理存储单元上非连续、非顺序的存储结构，数据元素的逻辑顺序是通过链表中的指针链接次序实现的。</p>
<span id="more"></span>

<p>    链表由一系列结点（链表中每一个元素称为结点）组成，结点可以在运行时动态生成。每个结点包括两个部分：一个是存储数据元素的数据域，另一个是存储下一个结点地址的指针域。</p>
<p>    相较于vector的连续线性空间，list的好处是每次插入或者删除一个元素，就是配置或者释放一个元素的空间。因此，list对于空间的运用有绝对的精准，一点也不浪费。而且，对于任何位置的元素插入或元素的移除，list永远是常数时间。</p>
<p>    List和vector是两个最常被使用的容器。</p>
<p>    list容器是一个<strong>双向链表容器</strong>，可高效地进行插入删除元素。</p>
<p>    list不可以随机存取元素，所以不支持at.(pos)函数与[]操作符。</p>
<p>    #include &lt;list&gt; </p>
 <img src="/2021/05/07/STL%EF%BC%9Alist%E5%AE%B9%E5%99%A8/1.png" alt="image-20210125101251344" style="zoom:50%;">

<h3 id="二、list对象的默认构造"><a href="#二、list对象的默认构造" class="headerlink" title="二、list对象的默认构造"></a>二、list对象的默认构造</h3><p>    list采用采用模板类实现,对象的默认构造形式：list&lt;T&gt; LIST; 如：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">list&lt;<span class="keyword">int</span>&gt; lstInt;      <span class="comment">//定义一个存放int的list容器。</span></span><br><span class="line">list&lt;<span class="keyword">float</span>&gt; lstFloat;   <span class="comment">//定义一个存放float的list容器。</span></span><br><span class="line">list&lt;string&gt; lstString;   <span class="comment">//定义一个存放string的list容器。              </span></span><br><span class="line"><span class="comment">//尖括号内还可以设置指针类型或自定义类型。</span></span><br></pre></td></tr></table></figure>



<h3 id="三、list头尾的添加移除操作"><a href="#三、list头尾的添加移除操作" class="headerlink" title="三、list头尾的添加移除操作"></a>三、list头尾的添加移除操作</h3><p>    list.push_back(elem);      //在容器尾部加入一个元素</p>
<p>    list.pop_back();       //删除容器中最后一个元素</p>
<p>    list.push_front(elem);   //在容器开头插入一个元素</p>
<p>    list.pop_front();       //从容器开头移除第一个元素</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">list&lt;<span class="keyword">int</span>&gt; lstInt;</span><br><span class="line">lstInt.<span class="built_in">push_back</span>(<span class="number">1</span>);</span><br><span class="line">lstInt.<span class="built_in">push_back</span>(<span class="number">3</span>);</span><br><span class="line">lstInt.<span class="built_in">push_back</span>(<span class="number">5</span>);</span><br><span class="line">lstInt.<span class="built_in">push_back</span>(<span class="number">7</span>);</span><br><span class="line">lstInt.<span class="built_in">push_back</span>(<span class="number">9</span>);</span><br><span class="line">lstInt.<span class="built_in">pop_front</span>();</span><br><span class="line">lstInt.<span class="built_in">pop_front</span>();</span><br><span class="line">lstInt.<span class="built_in">push_front</span>(<span class="number">11</span>);</span><br><span class="line">lstInt.<span class="built_in">push_front</span>(<span class="number">13</span>);</span><br><span class="line">lstInt.<span class="built_in">pop_back</span>();</span><br><span class="line">lstInt.<span class="built_in">pop_back</span>();</span><br><span class="line"><span class="comment">// lstInt    &#123;13,11,5&#125;</span></span><br></pre></td></tr></table></figure>



<h3 id="四、list的数据存取"><a href="#四、list的数据存取" class="headerlink" title="四、list的数据存取"></a>四、list的数据存取</h3><p>    list.front();  //返回第一个元素。</p>
<p>    list.back(); //返回最后一个元素。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">list&lt;<span class="keyword">int</span>&gt; lstInt;</span><br><span class="line">lstInt.<span class="built_in">push_back</span>(<span class="number">1</span>);</span><br><span class="line">lstInt.<span class="built_in">push_back</span>(<span class="number">5</span>);</span><br><span class="line">lstInt.<span class="built_in">push_back</span>(<span class="number">9</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> iFront = lstInt.<span class="built_in">front</span>();	<span class="comment">//1</span></span><br><span class="line"><span class="keyword">int</span> iBack = lstInt.<span class="built_in">back</span>();		<span class="comment">//9</span></span><br></pre></td></tr></table></figure>



<h3 id="五、list与迭代器"><a href="#五、list与迭代器" class="headerlink" title="五、list与迭代器"></a>五、list与迭代器</h3><p>    list.begin();           //返回容器中第一个元素的迭代器。</p>
<p>    list.end();            //返回容器中最后一个元素之后的迭代器。</p>
<p>    list.rbegin();     //返回容器中倒数第一个元素的迭代器。</p>
<p>    list.rend();     //返回容器中倒数最后一个元素的后面的迭代器。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (list&lt;<span class="keyword">int</span>&gt;::iterator it=lstInt.<span class="built_in">begin</span>(); it!=lstInt.<span class="built_in">end</span>(); ++it)	&#123;</span><br><span class="line">		cout &lt;&lt; *it&lt;&lt;cout &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>



<h3 id="六、list对象的带参数构造"><a href="#六、list对象的带参数构造" class="headerlink" title="六、list对象的带参数构造"></a>六、list对象的带参数构造</h3><p>    list(beg,end);  //构造函数将[beg, end)区间中的元素拷贝给本身。注意该区间是左闭右开的区间。</p>
<p>    list(n,elem);  //构造函数将n个elem拷贝给本身。</p>
<p>    list(const list &amp;lst); //拷贝构造函数。 </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">list&lt;<span class="keyword">int</span>&gt; mlist1;</span><br><span class="line"><span class="function">list&lt;<span class="keyword">int</span>&gt; <span class="title">mlist2</span><span class="params">(<span class="number">10</span>, <span class="number">10</span>)</span></span>; <span class="comment">//有参构造</span></span><br><span class="line"><span class="function">list&lt;<span class="keyword">int</span>&gt; <span class="title">mlist3</span><span class="params">(mlist2)</span></span>;<span class="comment">//拷贝构造</span></span><br><span class="line"><span class="function">list&lt;<span class="keyword">int</span>&gt; <span class="title">mlist4</span><span class="params">(mlist2.begin(), mlist2.end())</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (list&lt;<span class="keyword">int</span>&gt;::iterator it = mlist4.<span class="built_in">begin</span>(); it != mlist4.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">    cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">结果：</span></span><br><span class="line"><span class="comment">10 10 10 10 10 10 10 10 10 10</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>



<h3 id="七、list的赋值"><a href="#七、list的赋值" class="headerlink" title="七、list的赋值"></a>七、list的赋值</h3><p>    list.assign(beg,end);  //将[beg, end)区间中的数据拷贝赋值给本身。注意该区间是左闭右开的区间。</p>
<p>    list.assign(n,elem); //将n个elem拷贝赋值给本身。</p>
<p>    list&amp; operator=(const list &amp;lst); //重载等号操作符</p>
<p>    list.swap(lst); // 将lst与本身的元素互换。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">list&lt;<span class="keyword">int</span>&gt; lstIntA,lstIntB,lstIntC,lstIntD;</span><br><span class="line">lstIntA.<span class="built_in">push_back</span>(<span class="number">1</span>);</span><br><span class="line">lstIntA.<span class="built_in">push_back</span>(<span class="number">5</span>);</span><br><span class="line">lstIntA.<span class="built_in">push_back</span>(<span class="number">9</span>);</span><br><span class="line"></span><br><span class="line">lstIntB.<span class="built_in">assign</span>(lstIntA.<span class="built_in">begin</span>(),lstIntA.<span class="built_in">end</span>());		<span class="comment">//1 5 9</span></span><br><span class="line">lstIntC.<span class="built_in">assign</span>(<span class="number">5</span>,<span class="number">8</span>);							<span class="comment">//8 8 8 8 8</span></span><br><span class="line">lstIntD = lstIntA;							<span class="comment">//1 5 9</span></span><br><span class="line">lstIntC.<span class="built_in">swap</span>(lstIntD);						<span class="comment">//互换</span></span><br></pre></td></tr></table></figure>

<h3 id="八、list的大小"><a href="#八、list的大小" class="headerlink" title="八、list的大小"></a>八、list的大小</h3><p>    list.size();    //返回容器中元素的个数</p>
<p>    list.empty();      //判断容器是否为空</p>
<p>    list.resize(num);  //重新指定容器的长度为num，若容器变长，则以默认值填充新位置。如果容器变短，则末尾超出容器长度的元素被删除。</p>
<p>    list.resize(num, elem); //重新指定容器的长度为num，若容器变长，则以elem值填充新位置。如果容器变短，则末尾超出容器长度的元素被删除。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">list&lt;<span class="keyword">int</span>&gt; lstIntA;</span><br><span class="line">lstIntA.<span class="built_in">push_back</span>(<span class="number">11</span>);</span><br><span class="line">lstIntA.<span class="built_in">push_back</span>(<span class="number">33</span>);</span><br><span class="line">lstIntA.<span class="built_in">push_back</span>(<span class="number">55</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!lstIntA.<span class="built_in">empty</span>())</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> iSize = lstIntA.<span class="built_in">size</span>();		<span class="comment">//3</span></span><br><span class="line">    lstIntA.<span class="built_in">resize</span>(<span class="number">5</span>);			<span class="comment">//11 33 55 0 0</span></span><br><span class="line">    lstIntA.<span class="built_in">resize</span>(<span class="number">7</span>,<span class="number">1</span>);			<span class="comment">//11 33 55 0 0 1 1</span></span><br><span class="line">    lstIntA.<span class="built_in">resize</span>(<span class="number">2</span>);			<span class="comment">//11 33</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="九、list的插入"><a href="#九、list的插入" class="headerlink" title="九、list的插入"></a>九、list的插入</h3><p>    list.insert(pos,elem);  //在pos位置插入一个elem元素的拷贝，返回新数据的位置。</p>
<p>    list.insert(pos,n,elem);  //在pos位置插入n个elem数据，无返回值。</p>
<p>    list.insert(pos,beg,end);  //在pos位置插入[beg,end)区间的数据，无返回值。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">list&lt;<span class="keyword">int</span>&gt; lstA;</span><br><span class="line">list&lt;<span class="keyword">int</span>&gt; lstB;</span><br><span class="line"></span><br><span class="line">lstA.<span class="built_in">push_back</span>(<span class="number">1</span>);</span><br><span class="line">lstA.<span class="built_in">push_back</span>(<span class="number">5</span>);</span><br><span class="line">lstA.<span class="built_in">push_back</span>(<span class="number">9</span>);</span><br><span class="line"></span><br><span class="line">lstB.<span class="built_in">push_back</span>(<span class="number">2</span>);</span><br><span class="line">lstB.<span class="built_in">push_back</span>(<span class="number">6</span>);</span><br><span class="line"></span><br><span class="line">lstA.<span class="built_in">insert</span>(lstA.<span class="built_in">begin</span>(), <span class="number">11</span>);		<span class="comment">//&#123;11, 1, 5, 9&#125;</span></span><br><span class="line">lstA.<span class="built_in">insert</span>(++lstA.<span class="built_in">begin</span>(),<span class="number">2</span>,<span class="number">33</span>);		<span class="comment">//&#123;11,33,33,1,5,9&#125;</span></span><br><span class="line">lstA.<span class="built_in">insert</span>(lstA.<span class="built_in">begin</span>() , lstB.<span class="built_in">begin</span>() , lstB.<span class="built_in">end</span>() );	<span class="comment">//&#123;2,6,11,33,33,1,5,9&#125;</span></span><br></pre></td></tr></table></figure>



<h3 id="十、list的删除"><a href="#十、list的删除" class="headerlink" title="十、list的删除"></a>十、list的删除</h3><p>    list.clear();     //移除容器的所有数据</p>
<p>    list.erase(beg,end); //**删除[beg,end)**区间的数据，返回下一个数据的位置。</p>
<p>    list.erase(pos);  //删除pos位置的数据，返回下一个数据的位置。</p>
<p>    lst.remove(elem);  //删除容器中所有与elem值匹配的元素。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//删除区间内的元素</span></span><br><span class="line"><span class="comment">//lstInt是用list&lt;int&gt;声明的容器，现已包含按顺序的1,3,5,6,9元素。</span></span><br><span class="line">list&lt;<span class="keyword">int</span>&gt;::iterator itBegin=lstInt.<span class="built_in">begin</span>();</span><br><span class="line">++ itBegin;</span><br><span class="line">list&lt;<span class="keyword">int</span>&gt;::iterator itEnd=lstInt.<span class="built_in">begin</span>();</span><br><span class="line">++ itEnd;</span><br><span class="line">++ itEnd;</span><br><span class="line">++ itEnd;</span><br><span class="line">lstInt.<span class="built_in">erase</span>(itBegin,itEnd);</span><br><span class="line"><span class="comment">//此时容器lstInt包含按顺序的1,6,9三个元素。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//假设 lstInt 包含1,3,2,3,3,3,4,3,5,3，删除容器中等于3的元素的方法一</span></span><br><span class="line"><span class="keyword">for</span>(list&lt;<span class="keyword">int</span>&gt;::iterator it=lstInt.<span class="built_in">being</span>(); it!=lstInt.<span class="built_in">end</span>(); )    <span class="comment">//小括号里不需写  ++it</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="keyword">if</span>(*it == <span class="number">3</span>)&#123;</span><br><span class="line">        it  =  lstInt.<span class="built_in">erase</span>(it);       <span class="comment">//以迭代器为参数，删除元素3，并把数据删除后的下一个元素位置返回给迭代器。</span></span><br><span class="line">         <span class="comment">//此时，不执行  ++it；  </span></span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">else</span>&#123;</span><br><span class="line">       ++it;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//删除容器中等于3的元素的方法二</span></span><br><span class="line">lstInt.<span class="built_in">remove</span>(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//删除lstInt的所有元素</span></span><br><span class="line">lstInt.<span class="built_in">clear</span>();			<span class="comment">//容器为空</span></span><br></pre></td></tr></table></figure>



<h3 id="十一、list的反序排列"><a href="#十一、list的反序排列" class="headerlink" title="十一、list的反序排列"></a>十一、list的反序排列</h3><p>    lst.reverse();   //反转链表  </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">list&lt;<span class="keyword">int</span>&gt; lstA;</span><br><span class="line"></span><br><span class="line">lstA.<span class="built_in">push_back</span>(<span class="number">1</span>);</span><br><span class="line">lstA.<span class="built_in">push_back</span>(<span class="number">3</span>);</span><br><span class="line">lstA.<span class="built_in">push_back</span>(<span class="number">5</span>);</span><br><span class="line">lstA.<span class="built_in">push_back</span>(<span class="number">7</span>);</span><br><span class="line">lstA.<span class="built_in">push_back</span>(<span class="number">9</span>);</span><br><span class="line"></span><br><span class="line">lstA.<span class="built_in">reverse</span>();			<span class="comment">//9 7 5 3 1</span></span><br></pre></td></tr></table></figure>

<h3 id="十二、拼接"><a href="#十二、拼接" class="headerlink" title="十二、拼接"></a>十二、拼接</h3><p>    list::splice实现list拼接的功能。将源list的内容部分或全部元素删除，拼插入到目的list。</p>
<p>    函数有以下三种声明：</p>
<ol>
<li><p> void splice ( iterator position, list&lt;T,Allocator&gt;&amp; x );  </p>
</li>
<li><p> void splice ( iterator position, list&lt;T,Allocator&gt;&amp; x, iterator it );</p>
</li>
<li><p> void splice ( iterator position, list&lt;T,Allocator&gt;&amp; x, iterator first, iterator last );</p>
</li>
</ol>
<p>解释：</p>
<p>    position 是要操作的list对象的迭代器；ist&lt;T Allocator&gt;&amp;x 被剪的对象</p>
<p>    对于一：会在position后把list&lt;T Allocator&gt;&amp;x所有的元素到剪接到要操作的list对象</p>
<p>    对于二：只会把it的值剪接到要操作的list对象中</p>
<p>    对于三：把first 到 last 剪接到要操作的list对象中 </p>
<p>样例：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	list&lt;<span class="keyword">int</span>&gt;li1,li2;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">4</span>;i++) li1.<span class="built_in">push_back</span>(i),li2.<span class="built_in">push_back</span>(i+<span class="number">10</span>);</span><br><span class="line">	<span class="comment">// li1 1 2 3 4</span></span><br><span class="line">	<span class="comment">// li2 11 12 13 14</span></span><br><span class="line">	list&lt;<span class="keyword">int</span>&gt;::iterator it=li1.<span class="built_in">begin</span>();</span><br><span class="line">	it++;</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	li1.<span class="built_in">splice</span>(it,li2);<span class="comment">//1 11 12 13 14 2 3 4</span></span><br><span class="line">	<span class="keyword">if</span>(li2.<span class="built_in">empty</span>()) cout&lt;&lt;<span class="string">&quot;li2 is empty&quot;</span>&lt;&lt;endl;</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	li2.<span class="built_in">splice</span>(li2.<span class="built_in">begin</span>(),li1,it);</span><br><span class="line">	cout&lt;&lt;*it&lt;&lt;<span class="string">&quot;   chen&quot;</span>&lt;&lt;endl;</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	li1 1 11 12 13 14 3 4</span></span><br><span class="line"><span class="comment">	li2 2</span></span><br><span class="line"><span class="comment">	这里的it的值还是2  但是指向的已经是li2中的了 </span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">	</span><br><span class="line">	it=li1.<span class="built_in">begin</span>();</span><br><span class="line">	<span class="built_in">advance</span>(it,<span class="number">3</span>);<span class="comment">//advance 的意思是增加的意思，就是相当于 it=it+3;这里指向13</span></span><br><span class="line">	li1.<span class="built_in">splice</span>(li1.<span class="built_in">begin</span>(),li1,it,li1.<span class="built_in">end</span>()); <span class="comment">//13 14 3 4 1 11 12 可以发现it到li1.end()被剪贴到li1.begin()前面了 </span></span><br><span class="line">	<span class="keyword">for</span>(list&lt;<span class="keyword">int</span>&gt;::iterator it=li1.<span class="built_in">begin</span>();it!=li1.<span class="built_in">end</span>();++it) cout&lt;&lt;*it&lt;&lt;<span class="string">&quot;  &quot;</span>;</span><br><span class="line">	cout&lt;&lt;endl;</span><br><span class="line">	<span class="keyword">for</span>(list&lt;<span class="keyword">int</span>&gt;::iterator it=li2.<span class="built_in">begin</span>();it!=li2.<span class="built_in">end</span>();++it) cout&lt;&lt;*it&lt;&lt;<span class="string">&quot;  &quot;</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>C++</category>
        <category>STL</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>STL</tag>
        <tag>STL容器</tag>
      </tags>
  </entry>
  <entry>
    <title>STL_deque容器</title>
    <url>/2021/05/07/STL%EF%BC%9Adeque%E5%AE%B9%E5%99%A8/</url>
    <content><![CDATA[<h3 id="一、deque简介"><a href="#一、deque简介" class="headerlink" title="一、deque简介"></a>一、deque简介</h3><p>&ensp;&ensp;&ensp;&ensp;deque是“double-ended queue”的缩写，和vector一样都是STL的容器，deque是双端数组，而vector是单端的。</p>
<p>&ensp;&ensp;&ensp;&ensp;deque在接口上和vector非常相似，在许多操作的地方可以直接替换。</p>
<span id="more"></span>

<p>&ensp;&ensp;&ensp;&ensp;deque可以随机存取元素（支持索引值直接存取， 用[]操作符或at()方法）。</p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>deque头部和尾部添加或移除元素都非常快速。</strong>但是在中部安插元素或移除元素比较费时。</p>
<p>&ensp;&ensp;&ensp;&ensp;#include &lt;deque&gt; </p>
<img src="/2021/05/07/STL%EF%BC%9Adeque%E5%AE%B9%E5%99%A8/1.png" alt="image-20210124101431485" style="zoom: 50%;">

<p>&ensp;&ensp;&ensp;&ensp;<strong>原理：</strong></p>
<img src="/2021/05/07/STL%EF%BC%9Adeque%E5%AE%B9%E5%99%A8/2.png" alt="image-20210124101954916" style="zoom:50%;">

<p>&ensp;&ensp;&ensp;&ensp;Deque容器是连续的空间，至少逻辑上看来如此，连续现行空间总是令我们联想到array和vector,array无法成长，vector虽可成长，却只能向尾端成长，而且其成长其实是一个假象，事实上(1) 申请更大空间 (2)原数据复制新空间 (3)释放原空间 三步骤，如果不是vector每次配置新的空间时都留有余裕，其成长假象所带来的代价是非常昂贵的。</p>
<p>&ensp;&ensp;&ensp;&ensp;Deque是由一段一段的定量的连续空间构成。一旦有必要在deque前端或者尾端增加新的空间，便配置一段连续定量的空间，串接在deque的头端或者尾端。Deque最大的工作就是维护这些分段连续的内存空间的整体性的假象，并提供随机存取的接口，避开了重新配置空间，复制，释放的轮回，代价就是复杂的迭代器架构。</p>
<p>&ensp;&ensp;&ensp;&ensp;既然deque是分段连续内存空间，那么就必须有中央控制，维持整体连续的假象，数据结构的设计及迭代器的前进后退操作颇为繁琐。<strong>Deque代码的实现远比vector或list都多得多</strong>。</p>
<p>&ensp;&ensp;&ensp;&ensp;Deque采取一块所谓的map(注意，不是STL的map容器)作为主控，这里所谓的map是一小块连续的内存空间，其中每一个元素(此处成为一个结点)都是一个指针，指向另一段连续性内存空间，称作缓冲区。缓冲区才是deque的存储空间的主体。</p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>与vector的差异：</strong></p>
<p>&ensp;&ensp;&ensp;&ensp;Deque容器和vector容器最大的差异，一在于deque允许使用常数项时间对头端进行元素的插入和删除操作。二在于deque没有容量的概念，因为它是动态的以分段连续空间组合而成，随时可以增加一段新的空间并链接起来，换句话说，像vector那样，”旧空间不足而重新配置一块更大空间，然后复制元素，再释放旧空间”这样的事情在deque身上是不会发生的。也因此，deque没有必须要提供所谓的空间保留(reserve)功能。</p>
<p>&ensp;&ensp;&ensp;&ensp;虽然deque容器也提供了Random Access Iterator，但是它的迭代器并不是普通的指针，其复杂度和vector不是一个量级，这当然影响各个运算的层面。因此，除非有必要，<strong>我们应该尽可能的使用vector，而不是deque</strong>。<strong>对deque进行的排序操作，为了最高效率，可将deque先完整的复制到一个vector中，对vector容器进行排序，再复制回deque</strong>。</p>
<h3 id="二、deque对象的构造"><a href="#二、deque对象的构造" class="headerlink" title="二、deque对象的构造"></a>二、deque对象的构造</h3><p>&ensp;&ensp;&ensp;&ensp;deque采用模板类实现，deque对象的默认构造形式：deque&lt;T&gt; deqT; </p>
<ul>
<li><p>deque &lt;int&gt; deqInt;       //一个存放int的deque容器。</p>
</li>
<li><p>deque &lt;float&gt; deqFloat;   //一个存放float的deque容器。</p>
</li>
<li><p>deque&lt;string&gt; deqString;   //一个存放string的deque容器。           </p>
</li>
<li><p> //尖括号内还可以设置指针类型或自定义类型。 </p>
</li>
</ul>
<p>&ensp;&ensp;&ensp;&ensp;deque(beg, end);//构造函数将[beg, end)区间中的元素拷贝给本身。</p>
<p>&ensp;&ensp;&ensp;&ensp;deque(n, elem);//构造函数将n个elem拷贝给本身。</p>
<p>&ensp;&ensp;&ensp;&ensp;deque(const deque &amp;deq);//拷贝构造函数。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">deque&lt;<span class="keyword">int</span>&gt; d1;</span><br><span class="line"><span class="function">deque&lt;<span class="keyword">int</span>&gt; <span class="title">d2</span><span class="params">(<span class="number">10</span>, <span class="number">5</span>)</span></span>;</span><br><span class="line"><span class="function">deque&lt;<span class="keyword">int</span>&gt; <span class="title">d3</span><span class="params">(d2.begin(), d2.end())</span></span>;</span><br><span class="line"><span class="function">deque&lt;<span class="keyword">int</span>&gt; <span class="title">d4</span><span class="params">(d3)</span></span>;</span><br></pre></td></tr></table></figure>



<h3 id="三、deque末尾的添加移除操作"><a href="#三、deque末尾的添加移除操作" class="headerlink" title="三、deque末尾的添加移除操作"></a>三、deque末尾的添加移除操作</h3><p>&ensp;&ensp;&ensp;&ensp;deque.push_back(elem);  //在容器尾部添加一个数据</p>
<p>&ensp;&ensp;&ensp;&ensp;deque.push_front(elem); //在容器头部插入一个数据</p>
<p>&ensp;&ensp;&ensp;&ensp;deque.pop_back();        //删除容器最后一个数据</p>
<p>&ensp;&ensp;&ensp;&ensp;deque.pop_front();      //删除容器第一个数据</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">deque&lt;<span class="keyword">int</span>&gt; deqInt;</span><br><span class="line"></span><br><span class="line">deqInt.<span class="built_in">push_back</span>(<span class="number">1</span>);</span><br><span class="line">deqInt.<span class="built_in">push_back</span>(<span class="number">3</span>);</span><br><span class="line">deqInt.<span class="built_in">push_back</span>(<span class="number">5</span>);</span><br><span class="line">deqInt.<span class="built_in">push_back</span>(<span class="number">7</span>);</span><br><span class="line"></span><br><span class="line">deqInt.<span class="built_in">pop_front</span>();</span><br><span class="line">deqInt.<span class="built_in">pop_front</span>();</span><br><span class="line"></span><br><span class="line">deqInt.<span class="built_in">push_front</span>(<span class="number">11</span>);</span><br><span class="line">deqInt.<span class="built_in">push_front</span>(<span class="number">13</span>);</span><br><span class="line"></span><br><span class="line">deqInt.<span class="built_in">pop_back</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">//deqInt &#123; 13,11,5&#125;</span></span><br></pre></td></tr></table></figure>



<h3 id="四、deque的数据存取"><a href="#四、deque的数据存取" class="headerlink" title="四、deque的数据存取"></a>四、deque的数据存取</h3><p>&ensp;&ensp;&ensp;&ensp;deque.at(idx); //返回索引idx所指的数据，如果idx越界，抛出out_of_range。</p>
<p>&ensp;&ensp;&ensp;&ensp;deque[idx]; //返回索引idx所指的数据，如果idx越界，不抛出异常，直接出错。</p>
<p>&ensp;&ensp;&ensp;&ensp;deque.front();  //返回第一个数据。</p>
<p>&ensp;&ensp;&ensp;&ensp;deque.back();  //返回最后一个数据     </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">deque&lt;<span class="keyword">int</span>&gt; deqInt;</span><br><span class="line"></span><br><span class="line">deqInt.<span class="built_in">push_back</span>(<span class="number">1</span>);</span><br><span class="line">deqInt.<span class="built_in">push_back</span>(<span class="number">3</span>);</span><br><span class="line">deqInt.<span class="built_in">push_back</span>(<span class="number">5</span>);</span><br><span class="line">deqInt.<span class="built_in">push_back</span>(<span class="number">7</span>);</span><br><span class="line">deqInt.<span class="built_in">push_back</span>(<span class="number">9</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> iA = deqInt.<span class="built_in">at</span>(<span class="number">0</span>);        <span class="comment">//1</span></span><br><span class="line"><span class="keyword">int</span> iB = deqInt[<span class="number">1</span>];           <span class="comment">//3</span></span><br><span class="line">deqInt.<span class="built_in">at</span>(<span class="number">0</span>) = <span class="number">99</span>;           <span class="comment">//99</span></span><br><span class="line">deqInt[<span class="number">1</span>] = <span class="number">88</span>;         <span class="comment">//88</span></span><br><span class="line"><span class="keyword">int</span> iFront = deqInt.<span class="built_in">front</span>();    <span class="comment">//99</span></span><br><span class="line"><span class="keyword">int</span> iBack = deqInt.<span class="built_in">back</span>();    <span class="comment">//9</span></span><br><span class="line">deqInt.<span class="built_in">front</span>() = <span class="number">77</span>;         <span class="comment">//77</span></span><br><span class="line">deqInt.<span class="built_in">back</span>() = <span class="number">66</span>;         <span class="comment">//66</span></span><br></pre></td></tr></table></figure>



<h3 id="五、deque与迭代器"><a href="#五、deque与迭代器" class="headerlink" title="五、deque与迭代器"></a>五、deque与迭代器</h3><p>&ensp;&ensp;&ensp;&ensp;deque.begin(); //返回容器中第一个元素的迭代器。</p>
<p>&ensp;&ensp;&ensp;&ensp;deque.end(); //返回容器中最后一个元素之后的迭代器。</p>
<p>&ensp;&ensp;&ensp;&ensp;deque.rbegin(); //返回容器中倒数第一个元素的迭代器。</p>
<p>&ensp;&ensp;&ensp;&ensp;deque.rend();  //返回容器中倒数最后一个元素之后的迭代器。 </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">deque&lt;<span class="keyword">int</span>&gt; deqInt;</span><br><span class="line"></span><br><span class="line">deqInt.<span class="built_in">push_back</span>(<span class="number">1</span>);</span><br><span class="line">deqInt.<span class="built_in">push_back</span>(<span class="number">3</span>);</span><br><span class="line">deqInt.<span class="built_in">push_back</span>(<span class="number">5</span>);</span><br><span class="line">deqInt.<span class="built_in">push_back</span>(<span class="number">7</span>);</span><br><span class="line">deqInt.<span class="built_in">push_back</span>(<span class="number">9</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (deque&lt;<span class="keyword">int</span>&gt;::iterator it=deqInt.<span class="built_in">begin</span>(); it!=deqInt.<span class="built_in">end</span>(); ++it)</span><br><span class="line">&#123;</span><br><span class="line">    cout &lt;&lt; *it;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 1 3 5 7 9</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (deque&lt;<span class="keyword">int</span>&gt;::reverse_iterator rit=deqInt.<span class="built_in">rbegin</span>(); rit!=deqInt.<span class="built_in">rend</span>(); ++rit)</span><br><span class="line">&#123;</span><br><span class="line">    cout &lt;&lt; *rit;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//9 7 5 3 1</span></span><br></pre></td></tr></table></figure>



<h3 id="六、deque的赋值"><a href="#六、deque的赋值" class="headerlink" title="六、deque的赋值"></a>六、deque的赋值</h3><p>&ensp;&ensp;&ensp;&ensp;deque.assign(beg,end);  //将[beg, end)区间中的数据拷贝赋值给本身。注意该区间是左闭右开的区间。</p>
<p>&ensp;&ensp;&ensp;&ensp;deque.assign(n,elem); //将n个elem拷贝赋值给本身。</p>
<p>&ensp;&ensp;&ensp;&ensp;deque&amp; operator=(const deque &amp;deq);  //重载等号操作符</p>
<p>&ensp;&ensp;&ensp;&ensp;deque.swap(deq); // 将vec与本身的元素互换 </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">deque&lt;<span class="keyword">int</span>&gt; deqIntA,deqIntB,deqIntC,deqIntD;</span><br><span class="line"></span><br><span class="line">deqIntA.<span class="built_in">push_back</span>(<span class="number">1</span>);</span><br><span class="line">deqIntA.<span class="built_in">push_back</span>(<span class="number">3</span>);</span><br><span class="line">deqIntA.<span class="built_in">push_back</span>(<span class="number">5</span>);</span><br><span class="line">deqIntA.<span class="built_in">push_back</span>(<span class="number">7</span>);</span><br><span class="line">deqIntA.<span class="built_in">push_back</span>(<span class="number">9</span>);</span><br><span class="line"></span><br><span class="line">deqIntB.<span class="built_in">assign</span>(deqIntA.<span class="built_in">begin</span>(),deqIntA.<span class="built_in">end</span>());   <span class="comment">// 1 3 5 7 9</span></span><br><span class="line"></span><br><span class="line">deqIntC.<span class="built_in">assign</span>(<span class="number">5</span>,<span class="number">8</span>);                         <span class="comment">//8 8 8 8 8</span></span><br><span class="line"></span><br><span class="line">deqIntD = deqIntA;                          <span class="comment">//1 3 5 7 9</span></span><br><span class="line"></span><br><span class="line">deqIntC.<span class="built_in">swap</span>(deqIntD);                      <span class="comment">//互换</span></span><br></pre></td></tr></table></figure>



<h3 id="七、deque的大小"><a href="#七、deque的大小" class="headerlink" title="七、deque的大小"></a>七、deque的大小</h3><p>&ensp;&ensp;&ensp;&ensp;deque.size();     //返回容器中元素的个数</p>
<p>&ensp;&ensp;&ensp;&ensp;deque.empty();   //判断容器是否为空</p>
<p>&ensp;&ensp;&ensp;&ensp;deque.resize(num);  //重新指定容器的长度为num，若容器变长，则以默认值填充新位置。如果容器变短，则末尾超出容器长度的元素被删除。</p>
<p>&ensp;&ensp;&ensp;&ensp;deque.resize(num, elem); //重新指定容器的长度为num，若容器变长，则以elem值填充新位置。如果容器变短，则末尾超出容器长度的元素被删除。      </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">deque&lt;<span class="keyword">int</span>&gt; deqIntA;</span><br><span class="line"></span><br><span class="line">deqIntA.<span class="built_in">push_back</span>(<span class="number">1</span>);</span><br><span class="line">deqIntA.<span class="built_in">push_back</span>(<span class="number">3</span>);</span><br><span class="line">deqIntA.<span class="built_in">push_back</span>(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> iSize = deqIntA.<span class="built_in">size</span>(); <span class="comment">//3</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!deqIntA.<span class="built_in">empty</span>())</span><br><span class="line">&#123;</span><br><span class="line">    deqIntA.<span class="built_in">resize</span>(<span class="number">5</span>);      <span class="comment">//1 3 5 0 0</span></span><br><span class="line">    deqIntA.<span class="built_in">resize</span>(<span class="number">7</span>,<span class="number">1</span>); 	<span class="comment">//1 3 5 0 0 1 1</span></span><br><span class="line">    deqIntA.<span class="built_in">resize</span>(<span class="number">2</span>);      <span class="comment">//1 3</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="八、deque的插入"><a href="#八、deque的插入" class="headerlink" title="八、deque的插入"></a>八、deque的插入</h3><p>&ensp;&ensp;&ensp;&ensp;deque.insert(pos,elem);  //在pos位置插入一个elem元素的拷贝，返回新数据的位置。</p>
<p>&ensp;&ensp;&ensp;&ensp;deque.insert(pos,n,elem);  //在pos位置插入n个elem数据，无返回值。</p>
<p>&ensp;&ensp;&ensp;&ensp;deque.insert(pos,beg,end);  //在pos位置插入[beg,end)区间的数据，无返回值。 </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">deque&lt;<span class="keyword">int</span>&gt; deqA;</span><br><span class="line">deque&lt;<span class="keyword">int</span>&gt; deqB;</span><br><span class="line"></span><br><span class="line">deqA.<span class="built_in">push_back</span>(<span class="number">1</span>);</span><br><span class="line">deqA.<span class="built_in">push_back</span>(<span class="number">3</span>);</span><br><span class="line">deqA.<span class="built_in">push_back</span>(<span class="number">5</span>);</span><br><span class="line">deqA.<span class="built_in">push_back</span>(<span class="number">7</span>);</span><br><span class="line">deqA.<span class="built_in">push_back</span>(<span class="number">9</span>);</span><br><span class="line"></span><br><span class="line">deqB.<span class="built_in">push_back</span>(<span class="number">2</span>);</span><br><span class="line">deqB.<span class="built_in">push_back</span>(<span class="number">4</span>);</span><br><span class="line">deqB.<span class="built_in">push_back</span>(<span class="number">6</span>);</span><br><span class="line">deqB.<span class="built_in">push_back</span>(<span class="number">8</span>);</span><br><span class="line"></span><br><span class="line">deqA.<span class="built_in">insert</span>(deqA.<span class="built_in">begin</span>(), <span class="number">11</span>);        <span class="comment">//&#123;11, 1, 3, 5, 7, 9&#125;</span></span><br><span class="line">deqA.<span class="built_in">insert</span>(deqA.<span class="built_in">begin</span>()+<span class="number">1</span>,<span class="number">2</span>,<span class="number">33</span>);     <span class="comment">//&#123;11,33,33,1,3,5,7,9&#125;</span></span><br><span class="line">deqA.<span class="built_in">insert</span>(deqA.<span class="built_in">begin</span>() , deqB.<span class="built_in">begin</span>() , deqB.<span class="built_in">end</span>() ); <span class="comment">//&#123;2,4,6,8,11,33,33,1,3,5,7,9&#125;</span></span><br></pre></td></tr></table></figure>



<h3 id="九、deque的删除"><a href="#九、deque的删除" class="headerlink" title="九、deque的删除"></a>九、deque的删除</h3><p>&ensp;&ensp;&ensp;&ensp;deque.clear();  //移除容器的所有数据</p>
<p>&ensp;&ensp;&ensp;&ensp;deque.erase(beg,end); //删除[beg,end)区间的数据，返回下一个数据的位置。</p>
<p>&ensp;&ensp;&ensp;&ensp;deque.erase(pos);  //删除pos位置的数据，返回下一个数据的位置。 </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//删除区间内的元素</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//deqInt是用deque&lt;int&gt;声明的容器，现已包含按顺序的1,3,5,6,9元素。</span></span><br><span class="line">deque&lt;<span class="keyword">int</span>&gt;::iterator itBegin=deqInt.<span class="built_in">begin</span>()+<span class="number">1</span>;</span><br><span class="line">deque&lt;<span class="keyword">int</span>&gt;::iterator itEnd=deqInt.<span class="built_in">begin</span>()+<span class="number">3</span>;</span><br><span class="line">deqInt.<span class="built_in">erase</span>(itBegin,itEnd);</span><br><span class="line"><span class="comment">//此时容器deqInt包含按顺序的1,6,9三个元素。 </span></span><br><span class="line"></span><br><span class="line"><span class="comment">//假设 deqInt 包含1,3,2,3,3,3,4,3,5,3，删除容器中等于3的元素</span></span><br><span class="line"><span class="keyword">for</span>(deque&lt;<span class="keyword">int</span>&gt;::iterator it=deqInt.<span class="built_in">being</span>(); it!=deqInt.<span class="built_in">end</span>(); )  &#123;</span><br><span class="line">    <span class="comment">//小括号里不需写 ++it	</span></span><br><span class="line">    <span class="keyword">if</span>(*it == <span class="number">3</span>)&#123;</span><br><span class="line">        it = deqInt.<span class="built_in">erase</span>(it);    </span><br><span class="line">        <span class="comment">//以迭代器为参数，删除元素3，并把数据删除后的下一个元素位置返回给迭代器。</span></span><br><span class="line">        <span class="comment">//此时，不执行 ++it； </span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        ++it;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//删除deqInt的所有元素</span></span><br><span class="line">deqInt.<span class="built_in">clear</span>();         <span class="comment">//容器为空</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>C++</category>
        <category>STL</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>STL</tag>
        <tag>STL容器</tag>
      </tags>
  </entry>
  <entry>
    <title>类模板</title>
    <url>/2021/05/07/C++%E6%B3%9B%E5%9E%8B%EF%BC%9A%E7%B1%BB%E6%A8%A1%E6%9D%BF/</url>
    <content><![CDATA[<h3 id="一、简介"><a href="#一、简介" class="headerlink" title="一、简介"></a>一、简介</h3><p>    类模板和函数模板的定义及使用类似。有时，有两个或多个类，其功能是相同的，仅仅是数据类型不同。</p>
<span id="more"></span>

<ul>
<li>类模板用于实现类所需数据的类型参数化</li>
<li>类模板在表示如数组、表、图等数据结构显得特别重要，这些数据结构的表示和算法不受所包含的数据类型的影响。</li>
</ul>
<h3 id="二、语法"><a href="#二、语法" class="headerlink" title="二、语法"></a>二、语法</h3><p>    C++ 中类模板的写法如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;类型参数表&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> 类模板名&#123;</span></span><br><span class="line">  成员函数和成员变量</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>    类型参数表的写法如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span>类塑参数1, <span class="keyword">class</span>类型参数2, ...</span></span><br></pre></td></tr></table></figure>

<p>    类模板中的成员函数放到类模板定义外面写时的语法如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;类型参数表&gt;</span><br><span class="line">返回值类型 类模板名&lt;类型参数名列表&gt;::成员函数名(参数表)</span><br><span class="line">&#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>    用类模板定义对象的写法如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">类模板名&lt;真实类型参数表&gt; 对象名(构造函数实际参数表);</span><br></pre></td></tr></table></figure>

<p>    如果类模板有无参构造函数，那么也可以使用如下写法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">类模板名 &lt;真实类型参数表&gt; 对象名;</span><br></pre></td></tr></table></figure>

<p>    例：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Person</span>(T id,T age)&#123;</span><br><span class="line">		<span class="keyword">this</span>-&gt;mAge = age;</span><br><span class="line">		<span class="keyword">this</span>-&gt;mId = id;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">Show</span><span class="params">()</span></span>&#123;	</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;ID:&quot;</span> &lt;&lt; mId &lt;&lt; <span class="string">&quot; Age:&quot;</span> &lt;&lt; mAge &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	T mId;</span><br><span class="line">	T mAge;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span>&#123;	</span><br><span class="line">	<span class="comment">//函数模板在调用的时候，可以自动类型推导</span></span><br><span class="line">	<span class="comment">//类模板必须显式指定类型</span></span><br><span class="line">	<span class="function">Person&lt;<span class="keyword">int</span>&gt; <span class="title">p</span><span class="params">(<span class="number">15</span>,<span class="number">22</span>)</span></span>;</span><br><span class="line">	p.<span class="built_in">Show</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="三、类模板的派生"><a href="#三、类模板的派生" class="headerlink" title="三、类模板的派生"></a>三、类模板的派生</h3><ol>
<li>普通类派生类模板</li>
<li>类模板也可以派生类模板，这时，派生类模板的参数表中应包含基类模板的参数。</li>
<li>模板类与普通类一样也具有多继承，即模板类之间允许有多继承。</li>
</ol>
<p>     可以从类模板派生出新的类，既可以派生类模板，也可以派生非模板类。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//类模板派生普通类</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Person</span>()&#123;</span><br><span class="line">		mAge = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	T mAge;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//类区定义对象，这个对象需要编译分配内存,要指定类型</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SubPerson</span> :</span> <span class="keyword">public</span> Person&lt;<span class="keyword">int</span>&gt;&#123;&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//类模板派生类模板</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">J</span><span class="params">()</span></span>&#123;</span><br><span class="line">		cout &lt;&lt; mAge &lt;&lt; <span class="string">&quot;动物在叫!&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	T mAge;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cat</span> :</span> <span class="keyword">public</span> Animal&lt;T&gt;&#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;	</span><br><span class="line">	Cat&lt;<span class="keyword">int</span>&gt; cat;<span class="comment">//指定类型</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="四、类模板外部实现成员函数"><a href="#四、类模板外部实现成员函数" class="headerlink" title="四、类模板外部实现成员函数"></a>四、类模板外部实现成员函数</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Person</span>(T age, T id);</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">Show</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	T mAge;</span><br><span class="line">	T mID;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//外部实现函数</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line">Person&lt;T&gt;::<span class="built_in">Person</span>(T age, T id)&#123;</span><br><span class="line">	<span class="keyword">this</span>-&gt;mID = id;</span><br><span class="line">	<span class="keyword">this</span>-&gt;mAge = age;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="keyword">void</span> Person&lt;T&gt;::<span class="built_in">Show</span>()&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;Age:&quot;</span> &lt;&lt; mAge &lt;&lt; <span class="string">&quot; ID:&quot;</span> &lt;&lt; mID &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="五、类模板的编译"><a href="#五、类模板的编译" class="headerlink" title="五、类模板的编译"></a>五、类模板的编译</h3><p>    首先，一个<em>编译单元</em>（<em>translation unit</em>）是指一个*.cpp<em>文件以及它所</em>#include<em>的所有</em>.h<em>文件，</em>.h<em>文件里的代码将会被扩展到包含它的</em>.cpp<em>文件里，然后编译器编译该</em>.cpp<em>文件为一个</em>.obj<em>文件（假定我们的平台是win32），后者拥有</em>PE<em>（</em>Portable Executable<em>，即</em>windows<em>可执行文件）文件格式，并且本身包含的就已经是二进制码，但是不一定能够执行，因为并不保证其中一定有</em>main<em>函数。当编译器将一个工程里的所有</em>.cpp<em>文件以分离的方式编译完毕后，再由连接器（</em>linker<em>）进行连接成为一个</em>.exe*文件。</p>
<p>    就像类一样，类模板是可以将其实现与声明放在一起的，或者也可以将接口与实现分离。但是呢，编译器由于历史原因对于分离式编译的支持非常弱，并且因平台的不同支持力度有所不同。</p>
<p>    STL 的类模板都是接口与实现放在一起的，随着主流走就可以。（文件保存为<em><strong>类模板.hpp</strong></em>,其实质就是将.cpp的实现代码混入.h头文件当中，定义与实现都包含在同一文件，则该类的调用者只需要include该hpp文件即可，无需再 将cpp加入到project中进行编译。）</p>
<h3 id="六、类模板中的static关键字"><a href="#六、类模板中的static关键字" class="headerlink" title="六、类模板中的static关键字"></a>六、类模板中的<strong>static</strong>关键字</h3><p>    不同的类型参数的类的静态成员变量是相互独立的，这是由类模板的实现机制决定的。</p>
<figure class="highlight hpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _CRT_SECURE_NO_WARNINGS</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">int</span> a;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span> <span class="keyword">int</span> Person&lt;T&gt;::a = <span class="number">0</span>;<span class="comment">//类外初始化</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Person&lt;<span class="keyword">int</span>&gt; p1, p2, p3;</span><br><span class="line">	Person&lt;<span class="keyword">char</span>&gt; pp1, pp2, pp3;</span><br><span class="line">	p1.a = <span class="number">10</span>;</span><br><span class="line">	pp1.a = <span class="number">100</span>;</span><br><span class="line">	cout &lt;&lt; p1.a &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; p2.a &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; p3.a &lt;&lt; endl;<span class="comment">//输出10 10 10</span></span><br><span class="line">	cout &lt;&lt; pp1.a &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; pp2.a &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; pp3.a &lt;&lt; endl;<span class="comment">//输出100 100 100</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>    可以看到相同类型如int对应的类模板的对象之间的static成员是共享的，不同类型之间如int,float,char对应的类模板的对象之间的static是不共享的。</p>
]]></content>
      <categories>
        <category>C++</category>
        <category>泛型</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>泛型</tag>
      </tags>
  </entry>
  <entry>
    <title>函数模板</title>
    <url>/2021/05/07/C++%E6%B3%9B%E5%9E%8B%EF%BC%9A%E5%87%BD%E6%95%B0%E6%A8%A1%E6%9D%BF/</url>
    <content><![CDATA[<h3 id="一、简介"><a href="#一、简介" class="headerlink" title="一、简介"></a>一、简介</h3><p>    在C++中，数据的类型也可以通过参数来传递，在函数定义时可以不指明具体的数据类型，当发生函数调用时，编译器可以根据传入的实参自动推断数据类型。这就是类型的参数化。</p>
<span id="more"></span>

<p>    函数模板是一种特殊的函数，可以使用不同的类型进行调用，对于功能相同的函数，不需要重复编写代码，并且函数模板与普通函数看起来很类似，区别就是类型可以被参数化。</p>
<h3 id="二、语法"><a href="#二、语法" class="headerlink" title="二、语法"></a>二、语法</h3><p>    函数模板的语法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">template &lt;typename 类型参数1 , typename 类型参数2 , ...&gt; 返回值类型  函数名(形参列表)&#123;</span><br><span class="line">  &#x2F;&#x2F;在函数体中可以使用类型参数</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>    类型参数可以有多个，它们之间以逗号<code>,</code>分隔。类型参数列表以<code>&lt; &gt;</code>包围，形式参数列表以<code>( )</code>包围。</p>
<p>    <code>typename</code>关键字也可以使用<code>class</code>关键字替代，它们没有任何区别。C++ 早期对模板的支持并不严谨，没有引入新的关键字，而是用 class 来指明类型参数，但是 class 关键字本来已经用在类的定义中了，这样做显得不太友好，所以后来 C++ 又引入了一个新的关键字 typename，专门用来定义类型参数。不过至今仍然有很多代码在使用 class 关键字，包括 C++ 标准库、一些开源程序等。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _CRT_SECURE_NO_WARNINGS</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> 0 </span></span><br><span class="line"><span class="comment">//int类型数据交换</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MySwap</span><span class="params">(<span class="keyword">int</span>&amp; a, <span class="keyword">int</span>&amp; b)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> temp = a;</span><br><span class="line">	a = b;</span><br><span class="line">	b = temp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//double类型</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MySwap</span><span class="params">(<span class="keyword">double</span>&amp; a, <span class="keyword">double</span>&amp; b)</span></span>&#123;</span><br><span class="line">	<span class="keyword">double</span> temp = a;</span><br><span class="line">	a = b;</span><br><span class="line">	b = temp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//模板技术 类型参数化 编写代码可以忽略类型</span></span><br><span class="line"><span class="comment">//为了让编译器区分是普通函数  模板函数</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T1</span>,<span class="keyword">class</span> <span class="title">T2</span>&gt;</span> <span class="comment">//template&lt;typename T&gt;告诉编译器 ，下面写模板函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MySwap</span><span class="params">(T&amp; a, T&amp; b)</span></span>&#123;</span><br><span class="line">	T temp = a;</span><br><span class="line">	a = b;</span><br><span class="line">	b = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> a = <span class="number">30</span>;</span><br><span class="line">	<span class="keyword">int</span> b = <span class="number">20</span>;</span><br><span class="line">	<span class="comment">//1 自动类型推导,编译器根据你传的值 进行类型自动推导</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;a:&quot;</span> &lt;&lt; a &lt;&lt; <span class="string">&quot; b:&quot;</span> &lt;&lt; b &lt;&lt; endl;</span><br><span class="line">	<span class="built_in">MySwap</span>(a, b); </span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;a:&quot;</span> &lt;&lt; a &lt;&lt; <span class="string">&quot; b:&quot;</span> &lt;&lt; b &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">double</span> da = <span class="number">12.3</span>;</span><br><span class="line">	<span class="keyword">double</span> db = <span class="number">21.1</span>;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;da:&quot;</span> &lt;&lt; da &lt;&lt; <span class="string">&quot; db:&quot;</span> &lt;&lt; db &lt;&lt; endl;</span><br><span class="line">	<span class="built_in">MySwap</span>(da, db);</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;da:&quot;</span> &lt;&lt; da &lt;&lt; <span class="string">&quot; db:&quot;</span> &lt;&lt; db &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//2. 显式的指定类型</span></span><br><span class="line">	MySwap&lt;<span class="keyword">int</span>&gt;(a, b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;	</span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="三、函数模板跟普通函数"><a href="#三、函数模板跟普通函数" class="headerlink" title="三、函数模板跟普通函数"></a>三、函数模板跟普通函数</h3><p>    函数模板跟普通函数一样，也可以被重载</p>
<ul>
<li>C++编译器优先考虑普通函数</li>
<li>如果函数模板可以产生一个更好的匹配，那么就选择函数模板</li>
<li>也可以通过空模板实参列表&lt;&gt;限定编译器只匹配函数模板</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _CRT_SECURE_NO_WARNINGS</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">MyAdd</span><span class="params">(T a,T b)</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//普通函数可以进行自动类型转换</span></span><br><span class="line"><span class="comment">//函数模板必须严格类型匹配</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">MyAdd</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> c)</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> a + c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span>&#123;	</span><br><span class="line">	<span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">	<span class="keyword">int</span> b = <span class="number">20</span>;</span><br><span class="line">	<span class="keyword">char</span> c1 = <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">	<span class="keyword">char</span> c2 = <span class="string">&#x27;b&#x27;</span>;</span><br><span class="line"></span><br><span class="line">	MyAdd&lt;&gt;(a,b);<span class="comment">//限定只使用函数模板</span></span><br><span class="line"> </span><br><span class="line">	<span class="built_in">MyAdd</span>(a,c1);<span class="comment">//这个调用，函数模板有更好的匹配，于是调用函数模板</span></span><br><span class="line">	<span class="built_in">MyAdd</span>(a, b);<span class="comment">//普通函数int MyAdd(int a,int c)已经能完美匹配，于是调用普通函数</span></span><br><span class="line">	<span class="built_in">MyAdd</span>(c1,b);<span class="comment">//这个调用，函数模板有更好的匹配，于是调用函数模板</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//函数模板被重载</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Print</span><span class="params">(T a)</span></span>&#123;	</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Print</span><span class="params">(T a , T b)</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">test01</span>();	</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="四、函数模板机制："><a href="#四、函数模板机制：" class="headerlink" title="四、函数模板机制："></a>四、函数模板机制：</h3><ul>
<li>编译器并不是把函数模板处理成能够处理任何类型的函数</li>
<li>函数模板通过具体类型产生不同的函数</li>
<li>编译器会对函数模板进行再次编译，在声明的地方对模板代码本身进行编译，在调用的地方对参数替换后的代码进行编译。</li>
</ul>
]]></content>
      <categories>
        <category>C++</category>
        <category>泛型</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>泛型</tag>
      </tags>
  </entry>
  <entry>
    <title>成员模板</title>
    <url>/2021/05/07/C++%E6%B3%9B%E5%9E%8B%EF%BC%9A%E6%88%90%E5%91%98%E6%A8%A1%E6%9D%BF/</url>
    <content><![CDATA[<h3 id="一、简介"><a href="#一、简介" class="headerlink" title="一、简介"></a>一、简介</h3><p>    任意类（模板或非模板）可以拥有本身为类模板或函数模板的成员，这种成员称为成员函数模板。STL中为什么要运用这种技术呢？考虑 vector 容器的 assign 成员函数，它可以接受两个迭代器为容器赋值，而这两个迭代器可以是 list 的迭代器、deque的迭代器、甚至是两个原生指针。也就是说成员函数 assign 的形参是不确定的。解决的方法是使用模板形参来表示迭代器形参的类型。</p>
<span id="more"></span>

<h3 id="二、语法"><a href="#二、语法" class="headerlink" title="二、语法"></a>二、语法</h3><p>    C++ 中成员模板的写法如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//在类内部</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">I</span>&gt;</span></span><br><span class="line">返回类型 函数名(模板参数表)</span><br><span class="line">&#123;  &#125;</span><br></pre></td></tr></table></figure>

<p>    在外面定义成员模板，必须包含两个模板形参表，类模板形参和自己的模板形参。首先是类模板形参表，然后是自己的模板形参表。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;类模板形参表&gt; <span class="keyword">template</span> &lt;模板形参表&gt;</span><br><span class="line">返回类型 类名&lt;类参数表&gt;::函数名(函数参数表)</span><br><span class="line">&#123; &#125;</span><br></pre></td></tr></table></figure>

<p>    例：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//自定义</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyAlloc</span>&#123;</span></span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="keyword">class</span> <span class="title">Alloc</span> =</span> MyAlloc&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyVector</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">typedef</span> T value_type;</span><br><span class="line">	<span class="keyword">typedef</span> value_type* iterator;</span><br><span class="line">	<span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">I</span>&gt;</span></span><br><span class="line">	<span class="built_in">MyVector</span>(I first, I last);</span><br><span class="line">	<span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">I</span>&gt;</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">assign</span><span class="params">(I first, I last)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="keyword">class</span> <span class="title">Alloc</span>&gt;</span> <span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">I</span>&gt;</span></span><br><span class="line">MyVector&lt;T, Alloc&gt;::<span class="built_in">MyVector</span>(I first, I last)</span><br><span class="line">&#123; </span><br><span class="line">	cout&lt;&lt;<span class="string">&quot;MyVector&quot;</span>&lt;&lt;endl; </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="keyword">class</span> <span class="title">Alloc</span>&gt;</span> <span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">I</span>&gt;</span></span><br><span class="line"><span class="keyword">void</span> MyVector&lt;T, Alloc&gt;::<span class="built_in">assign</span>(I first, I last)</span><br><span class="line">&#123; </span><br><span class="line">	cout&lt;&lt;<span class="string">&quot;assign&quot;</span>&lt;&lt;endl; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>C++</category>
        <category>泛型</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>泛型</tag>
      </tags>
  </entry>
  <entry>
    <title>构建二叉树</title>
    <url>/2021/05/07/%E4%BA%8C%E5%8F%89%E6%A0%91%EF%BC%9A%E6%9E%84%E5%BB%BA%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
    <content><![CDATA[<p>    构建二叉树的方式多种多样，可以从前序与中序遍历序列构造二叉树、从中序与后序遍历序列构造二叉树，还可以从有序数组和链表中构建二叉树。掌握构建的前提是理解遍历二叉树和二叉树的结构。</p>
<span id="more"></span>

<h3 id="105-从前序与中序遍历序列构造二叉树"><a href="#105-从前序与中序遍历序列构造二叉树" class="headerlink" title="105. 从前序与中序遍历序列构造二叉树"></a><a href="https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/">105. 从前序与中序遍历序列构造二叉树</a></h3><p>    根据一棵树的前序遍历与中序遍历构造二叉树。</p>
<p>    **注意:**你可以假设树中没有重复的元素。</p>
<p>    例如，给出</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">前序遍历 preorder &#x3D; [3,9,20,15,7]</span><br><span class="line">中序遍历 inorder &#x3D; [9,3,15,20,7]</span><br></pre></td></tr></table></figure>

<p>    返回如下的二叉树：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">  3</span><br><span class="line"> &#x2F; \</span><br><span class="line">9  20</span><br><span class="line">  &#x2F;  \</span><br><span class="line"> 15   7</span><br></pre></td></tr></table></figure>

<p><strong>思路与代码</strong>：</p>
<p>    首先要知道一个结论，前序/后序+中序序列可以唯一确定一棵二叉树，所以自然而然可以用来建树。</p>
<p>    看一下前序和中序有什么特点，前序<code>1,2,4,7,3,5,6,8</code> ，中序<code>4,7,2,1,5,3,8,6</code>；</p>
<p>    有如下特征：</p>
<ol>
<li> 前序中左起第一位<code>1</code>肯定是根结点，我们可以据此找到中序中根结点的位置<code>rootin</code>；</li>
<li> 中序中根结点左边就是左子树结点，右边就是右子树结点，即<code>[左子树结点，根结点，右子树结点]</code>，我们就可以得出左子树结点个数为<code>int left = rootin - leftin;</code>；</li>
<li> 前序中结点分布应该是：<code>[根结点，左子树结点，右子树结点]</code>；</li>
<li> 根据前一步确定的左子树个数，可以确定前序中左子树结点和右子树结点的范围；</li>
<li>如果我们要前序遍历生成二叉树的话，下一层递归应该是：<ul>
<li>  左子树：<code>root-&gt;left = pre_order(前序序列，前序左子树范围，中序序列，中序左子树范围);</code>；</li>
<li>  右子树：<code>root-&gt;right = pre_order(前序序列，前序右子树范围，中序序列，中序右子树范围);</code>。</li>
</ul>
</li>
<li> 每一层递归都要返回当前根结点<code>root</code>；</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">buildTree</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; preorder, vector&lt;<span class="keyword">int</span>&gt;&amp; inorder)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">help</span>(preorder, <span class="number">0</span>, preorder.<span class="built_in">size</span>() - <span class="number">1</span>, </span><br><span class="line">                    inorder, <span class="number">0</span>, inorder.<span class="built_in">size</span>() - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">TreeNode* <span class="title">help</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; preorder, <span class="keyword">int</span> low1, <span class="keyword">int</span> high1, </span></span></span><br><span class="line"><span class="function"><span class="params">                    vector&lt;<span class="keyword">int</span>&gt;&amp; inorder, <span class="keyword">int</span> low2, <span class="keyword">int</span> high2)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(low1 &gt; high1 || low2 &gt; high2)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> root = preorder.<span class="built_in">at</span>(low1);</span><br><span class="line">        <span class="keyword">int</span> mid = low2;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = low2; i &lt;= high2; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(inorder.<span class="built_in">at</span>(i) == root)</span><br><span class="line">            &#123;</span><br><span class="line">                mid = i;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        TreeNode* rootPtr = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(root);</span><br><span class="line"></span><br><span class="line">        rootPtr-&gt;left = <span class="built_in">help</span>(preorder, low1 + <span class="number">1</span>, low1 + mid - low2,</span><br><span class="line">                            inorder, low2, mid - <span class="number">1</span>);</span><br><span class="line">        rootPtr-&gt;right = <span class="built_in">help</span>(preorder, low1 + mid - low2 +<span class="number">1</span>, high1,</span><br><span class="line">                            inorder, mid + <span class="number">1</span>, high2);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> rootPtr;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h3 id="106-从中序与后序遍历序列构造二叉树"><a href="#106-从中序与后序遍历序列构造二叉树" class="headerlink" title="106. 从中序与后序遍历序列构造二叉树"></a><a href="https://leetcode-cn.com/problems/construct-binary-tree-from-inorder-and-postorder-traversal/">106. 从中序与后序遍历序列构造二叉树</a></h3><p>    根据一棵树的中序遍历与后序遍历构造二叉树。</p>
<p>    **注意:**你可以假设树中没有重复的元素。</p>
<p>    例如，给出</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">中序遍历 inorder &#x3D; [9,3,15,20,7]</span><br><span class="line">后序遍历 postorder &#x3D; [9,15,7,20,3]</span><br></pre></td></tr></table></figure>

<p>    返回如下的二叉树：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">  3</span><br><span class="line"> &#x2F; \</span><br><span class="line">9  20</span><br><span class="line">  &#x2F;  \</span><br><span class="line"> 15   7</span><br></pre></td></tr></table></figure>

<p><strong>思路与代码</strong>：</p>
<p>    首先要知道一个结论，前序/后序+中序序列可以唯一确定一棵二叉树，所以自然而然可以用来建树。</p>
<p>    看一下中序和后序有什么特点，中序<code>[9,3,15,20,7]</code> ，后序<code>[9,15,7,20,3]</code>；</p>
<p>    有如下特征：</p>
<ol>
<li> 后序中右起第一位<code>3</code>肯定是根结点，我们可以据此找到中序中根结点的位置<code>rootin</code>；</li>
<li> 中序中根结点左边就是左子树结点，右边就是右子树结点，即<code>[左子树结点，根结点，右子树结点]</code>，我们就可以得出左子树结点个数为<code>int left = rootin - leftin;</code>；</li>
<li> 后序中结点分布应该是：<code>[左子树结点，右子树结点，根结点]</code>；</li>
<li> 根据前一步确定的左子树个数，可以确定后序中左子树结点和右子树结点的范围；</li>
<li>如果我们要前序遍历生成二叉树的话，下一层递归应该是：<ul>
<li>  左子树：<code>root-&gt;left = pre_order(中序序列，中序左子树范围，后序序列，后序左子树范围);</code>；</li>
<li>  右子树：<code>root-&gt;right = pre_order(中序序列，中序右子树范围，后序序列，后序右子树范围);</code>。</li>
</ul>
</li>
<li> 每一层递归都要返回当前根结点<code>root</code>；</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">buildTree</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; inorder, vector&lt;<span class="keyword">int</span>&gt;&amp; postorder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">help</span>(inorder, <span class="number">0</span>, inorder.<span class="built_in">size</span>() - <span class="number">1</span>,</span><br><span class="line">                    postorder, <span class="number">0</span>, postorder.<span class="built_in">size</span>() - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">TreeNode* <span class="title">help</span><span class="params">(<span class="keyword">const</span> vector&lt;<span class="keyword">int</span>&gt;&amp; inorder, <span class="keyword">int</span> low1, <span class="keyword">int</span> high1,</span></span></span><br><span class="line"><span class="function"><span class="params">                   <span class="keyword">const</span> vector&lt;<span class="keyword">int</span>&gt;&amp; postorder, <span class="keyword">int</span> low2, <span class="keyword">int</span> high2)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(low1 &gt;high1 || low2 &gt; high2)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> rootVal = postorder.<span class="built_in">at</span>(high2);</span><br><span class="line">        <span class="keyword">int</span> mid = low1;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = low1; i &lt;= high1; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(inorder.<span class="built_in">at</span>(i) == rootVal)</span><br><span class="line">            &#123;</span><br><span class="line">                mid = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        TreeNode* root = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(rootVal);</span><br><span class="line"></span><br><span class="line">        root-&gt;left = <span class="built_in">help</span>(inorder, low1, mid - <span class="number">1</span>, </span><br><span class="line">                          postorder, low2, low2 + mid - low1 - <span class="number">1</span>);</span><br><span class="line">        root-&gt;right = <span class="built_in">help</span>(inorder, mid + <span class="number">1</span>, high1,</span><br><span class="line">                           postorder, low2 + mid - low1, high2 - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="108-将有序数组转换为二叉搜索树"><a href="#108-将有序数组转换为二叉搜索树" class="headerlink" title="108. 将有序数组转换为二叉搜索树"></a><a href="https://leetcode-cn.com/problems/convert-sorted-array-to-binary-search-tree/">108. 将有序数组转换为二叉搜索树</a></h3><p>    给你一个整数数组 <code>nums</code> ，其中元素已经按 <strong>升序</strong> 排列，请你将其转换为一棵 <strong>高度平衡</strong> 二叉搜索树。</p>
<p>    <strong>高度平衡</strong> 二叉树是一棵满足「每个节点的左右两个子树的高度差的绝对值不超过 1 」的二叉树。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：nums &#x3D; [-10,-3,0,5,9]</span><br><span class="line">输出：[0,-3,9,-10,null,5]</span><br><span class="line">        0</span><br><span class="line">       &#x2F; \</span><br><span class="line">     -3   9</span><br><span class="line">    &#x2F;    &#x2F;</span><br><span class="line">  10    5</span><br><span class="line">解释：[0,-10,5,null,-3,null,9] 也将被视为正确答案：</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：nums &#x3D; [1,3]</span><br><span class="line">输出：[3,1]</span><br><span class="line">   3   1</span><br><span class="line">  &#x2F;     \</span><br><span class="line"> 1       3</span><br><span class="line">解释：[1,3] 和 [3,1] 都是高度平衡二叉搜索树。</span><br></pre></td></tr></table></figure>

<p> <strong>提示：</strong></p>
<ul>
<li>  <code>1 &lt;= nums.length &lt;= 104</code></li>
<li>  <code>-104 &lt;= nums[i] &lt;= 104</code></li>
<li>  <code>nums</code> 按 <strong>严格递增</strong> 顺序排列</li>
</ul>
<p><strong>思路与代码</strong>：</p>
<p>    数组的中间节点即为当前”root”</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">sortedArrayToBST</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">help</span>(nums, <span class="number">0</span>, nums.<span class="built_in">size</span>() - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">TreeNode* <span class="title">help</span><span class="params">(<span class="keyword">const</span> vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(low &gt; high)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> mid = (low + high + <span class="number">1</span>) / <span class="number">2</span> ;</span><br><span class="line"></span><br><span class="line">        TreeNode* root = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(nums.<span class="built_in">at</span>(mid));</span><br><span class="line"></span><br><span class="line">        root-&gt;left = <span class="built_in">help</span>(nums, low, mid - <span class="number">1</span>);</span><br><span class="line">        root-&gt;right = <span class="built_in">help</span>(nums, mid + <span class="number">1</span>, high);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h3 id="109-有序链表转换二叉搜索树"><a href="#109-有序链表转换二叉搜索树" class="headerlink" title="109. 有序链表转换二叉搜索树"></a><a href="https://leetcode-cn.com/problems/convert-sorted-list-to-binary-search-tree/">109. 有序链表转换二叉搜索树</a></h3><p>    给定一个单链表，其中的元素按升序排序，将其转换为高度平衡的二叉搜索树。</p>
<p>    本题中，一个高度平衡二叉树是指一个二叉树<em>每个节点</em> 的左右两个子树的高度差的绝对值不超过 1。</p>
<p><strong>示例:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">给定的有序链表： [-10, -3, 0, 5, 9],</span><br><span class="line"></span><br><span class="line">一个可能的答案是：[0, -3, 9, -10, null, 5], 它可以表示下面这个高度平衡二叉搜索树：</span><br><span class="line"></span><br><span class="line">      0</span><br><span class="line">     &#x2F; \</span><br><span class="line">   -3   9</span><br><span class="line">   &#x2F;   &#x2F;</span><br><span class="line"> -10  5</span><br></pre></td></tr></table></figure>

<p><strong>思路与代码</strong>：</p>
<p>    还是找中间节点</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">sortedListToBST</span><span class="params">(ListNode* head)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">       </span><br><span class="line">        <span class="keyword">if</span>(!head)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(head-&gt;next == <span class="literal">nullptr</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">TreeNode</span>(head-&gt;val);</span><br><span class="line">    </span><br><span class="line">        <span class="comment">//双指针，找中点</span></span><br><span class="line">        ListNode* pre = head;</span><br><span class="line">        ListNode* p = head-&gt;next;</span><br><span class="line">        ListNode* q = p-&gt;next;        </span><br><span class="line">        <span class="keyword">while</span>(q != <span class="literal">nullptr</span> &amp;&amp; q-&gt;next != <span class="literal">nullptr</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            pre = pre-&gt;next;</span><br><span class="line">            p = pre-&gt;next;</span><br><span class="line">            q = q-&gt;next-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        pre-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">        TreeNode* root = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(p-&gt;val); </span><br><span class="line">        root-&gt;left = <span class="built_in">sortedListToBST</span>(head);</span><br><span class="line">        root-&gt;right = <span class="built_in">sortedListToBST</span>(p-&gt;next);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h3 id="654-最大二叉树"><a href="#654-最大二叉树" class="headerlink" title="654. 最大二叉树"></a><a href="https://leetcode-cn.com/problems/maximum-binary-tree/">654. 最大二叉树</a></h3><p>    给定一个不含重复元素的整数数组 <code>nums</code> 。一个以此数组直接递归构建的 <strong>最大二叉树</strong> 定义如下：</p>
<ol>
<li> 二叉树的根是数组 <code>nums</code> 中的最大元素。</li>
<li> 左子树是通过数组中 <strong>最大值左边部分</strong> 递归构造出的最大二叉树。</li>
<li> 右子树是通过数组中 <strong>最大值右边部分</strong> 递归构造出的最大二叉树。</li>
</ol>
<p>返回有给定数组 <code>nums</code> 构建的 <strong>最大二叉树</strong> 。 </p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：nums &#x3D; [3,2,1,6,0,5]</span><br><span class="line">输出：[6,3,5,null,2,0,null,null,1]</span><br><span class="line">            6</span><br><span class="line">          &#x2F;   \</span><br><span class="line">        3       5</span><br><span class="line">         \    &#x2F;</span><br><span class="line">          2  0</span><br><span class="line">           \</span><br><span class="line">            1</span><br><span class="line">解释：递归调用如下所示：</span><br><span class="line">- [3,2,1,6,0,5] 中的最大值是 6 ，左边部分是 [3,2,1] ，右边部分是 [0,5] 。</span><br><span class="line">    - [3,2,1] 中的最大值是 3 ，左边部分是 [] ，右边部分是 [2,1] 。</span><br><span class="line">        - 空数组，无子节点。</span><br><span class="line">        - [2,1] 中的最大值是 2 ，左边部分是 [] ，右边部分是 [1] 。</span><br><span class="line">            - 空数组，无子节点。</span><br><span class="line">            - 只有一个元素，所以子节点是一个值为 1 的节点。</span><br><span class="line">    - [0,5] 中的最大值是 5 ，左边部分是 [0] ，右边部分是 [] 。</span><br><span class="line">        - 只有一个元素，所以子节点是一个值为 0 的节点。</span><br><span class="line">        - 空数组，无子节点。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：nums &#x3D; [3,2,1]</span><br><span class="line">输出：[3,null,2,null,1]</span><br><span class="line">    3</span><br><span class="line">     \</span><br><span class="line">      2</span><br><span class="line">       \</span><br><span class="line">        1 </span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li>  <code>1 &lt;= nums.length &lt;= 1000</code></li>
<li>  <code>0 &lt;= nums[i] &lt;= 1000</code></li>
<li>  <code>nums</code> 中的所有整数 <strong>互不相同</strong></li>
</ul>
<p>代码</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">constructMaximumBinaryTree</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="built_in">build</span>(nums, <span class="number">0</span>, nums.<span class="built_in">size</span>() - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">TreeNode* <span class="title">build</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(low &gt; high)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">-1</span>, MAX = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = low; i &lt;= high; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(nums.<span class="built_in">at</span>(i) &gt;= MAX)</span><br><span class="line">            &#123;</span><br><span class="line">                MAX = nums.<span class="built_in">at</span>(i);</span><br><span class="line">                index = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        TreeNode* root = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(MAX);</span><br><span class="line">        <span class="comment">//TreeNode* root = &amp;rootNode;</span></span><br><span class="line"></span><br><span class="line">        root-&gt;left = <span class="built_in">build</span>(nums, low, index<span class="number">-1</span>);</span><br><span class="line">        root-&gt;right = <span class="built_in">build</span>(nums, index+<span class="number">1</span>, high);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><a href="https://mp.weixin.qq.com/s?__biz=MzAxODQxMDM0Mw==&mid=2247487270&idx=1&sn=2f7ad74aabc88b53d94012ceccbe51be&chksm=9bd7f12eaca078384733168971147866c140496cb257946f8170f05e46d16099f3eef98d39d9&scene=21#wechat_redirect">东哥手把手帮你刷通二叉树|第二期 (qq.com)</a></p>
]]></content>
      <categories>
        <category>算法</category>
        <category>二叉树</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>二叉树</tag>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>二叉树的遍历模板</title>
    <url>/2021/05/07/%E4%BA%8C%E5%8F%89%E6%A0%91%EF%BC%9A%E4%BA%8C%E5%8F%89%E6%A0%91%E9%81%8D%E5%8E%86%E6%A8%A1%E6%9D%BF/</url>
    <content><![CDATA[<p>&ensp;&ensp;&ensp;&ensp;总结的二叉树的遍历模板，其中前、中、后序遍历采用递归形式，层序遍历采用迭代。</p>
<span id="more"></span>

<h3 id="前序遍历模板"><a href="#前序遍历模板" class="headerlink" title="前序遍历模板"></a>前序遍历模板</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">traverse</span><span class="params">(TreeNode* root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//to do sth</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">traverse</span>(root-&gt;left)</span><br><span class="line">    <span class="built_in">traverse</span>(root-&gt;right)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="中序遍历模板"><a href="#中序遍历模板" class="headerlink" title="中序遍历模板"></a>中序遍历模板</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">traverse</span><span class="params">(TreeNode* root)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">traverse</span>(root-&gt;left)</span><br><span class="line">         </span><br><span class="line">    <span class="comment">//to do sth</span></span><br><span class="line">        </span><br><span class="line">    <span class="built_in">traverse</span>(root-&gt;right)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="后序遍历模板"><a href="#后序遍历模板" class="headerlink" title="后序遍历模板"></a>后序遍历模板</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">traverse</span><span class="params">(TreeNode* root)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="built_in">traverse</span>(root-&gt;left)</span><br><span class="line">    <span class="built_in">traverse</span>(root-&gt;right)</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//to do sth</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="层序遍历模板"><a href="#层序遍历模板" class="headerlink" title="层序遍历模板"></a>层序遍历模板</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">traverse</span><span class="params">(TreeNode* root)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!root) <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">// 初始化队列，将 root 加入队列</span></span><br><span class="line">    queue&lt;TreeNode*&gt; que;</span><br><span class="line">    que.<span class="built_in">push</span>(root);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!que.<span class="built_in">empty</span>()) </span><br><span class="line">    &#123;</span><br><span class="line">        TreeNode* cur = que.<span class="built_in">front</span>();</span><br><span class="line">        que.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//to do sth</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (cur-&gt;left) </span><br><span class="line">        	que.<span class="built_in">offer</span>(cur-&gt;left);        </span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (cur.right) </span><br><span class="line">            que.<span class="built_in">offer</span>(cur-&gt;right);</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="搜索二叉树的遍历模板"><a href="#搜索二叉树的遍历模板" class="headerlink" title="搜索二叉树的遍历模板"></a>搜索二叉树的遍历模板</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BST</span><span class="params">(TreeNode* root, <span class="keyword">int</span> target)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root-&gt;val == target)</span><br><span class="line">        <span class="comment">// 找到目标，做点什么</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (root-&gt;val &lt; target) </span><br><span class="line">        <span class="built_in">BST</span>(root-&gt;right, target);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (root-&gt;val &gt; target)</span><br><span class="line">        <span class="built_in">BST</span>(root.left, target);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法</category>
        <category>二叉树</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>二叉树</tag>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>遍历二叉树的几个算法题</title>
    <url>/2021/05/07/%E4%BA%8C%E5%8F%89%E6%A0%91%EF%BC%9A%E9%81%8D%E5%8E%86%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%87%A0%E4%B8%AA%E7%AE%97%E6%B3%95%E9%A2%98/</url>
    <content><![CDATA[<p>&ensp;&ensp;&ensp;&ensp;对于二叉树的遍历模板，运用到实际题目中才能熟练掌握其精髓，下面是以前做过的相关算法题，现在整理了出来。</p>
<span id="more"></span>

<h4 id="98-验证二叉搜索树"><a href="#98-验证二叉搜索树" class="headerlink" title="98. 验证二叉搜索树"></a><a href="https://leetcode-cn.com/problems/validate-binary-search-tree/">98. 验证二叉搜索树</a></h4><p>&ensp;&ensp;&ensp;&ensp;给定一个二叉树，判断其是否是一个有效的二叉搜索树。</p>
<p>&ensp;&ensp;&ensp;&ensp;假设一个二叉搜索树具有如下特征：</p>
<ul>
<li>  节点的左子树只包含<strong>小于</strong>当前节点的数。</li>
<li>  节点的右子树只包含<strong>大于</strong>当前节点的数。</li>
<li>  所有左子树和右子树自身必须也是二叉搜索树。</li>
</ul>
<p><strong>示例 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入:</span><br><span class="line">    2</span><br><span class="line">   &#x2F; \</span><br><span class="line">  1   3</span><br><span class="line">输出: true</span><br></pre></td></tr></table></figure>

<p><strong>示例 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入:</span><br><span class="line">    5</span><br><span class="line">   &#x2F; \</span><br><span class="line">  1   4</span><br><span class="line">     &#x2F; \</span><br><span class="line">    3   6</span><br><span class="line">输出: false</span><br><span class="line">解释: 输入为: [5,1,4,null,null,3,6]。</span><br><span class="line">     根节点的值为 5 ，但是其右子节点值为 4 。</span><br></pre></td></tr></table></figure>

<p><strong>思路与代码</strong>：</p>
<p>&ensp;&ensp;&ensp;&ensp;遍历每个节点，记录好它的边界值，比如对于<code>root</code>的左子节点，它的最大值小于<code>root-&gt;val</code>，对于<code>root</code>的右子节点，它的最小值大于<code>root-&gt;val</code>。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isValidBST</span><span class="params">(TreeNode* root)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">isValidBST</span>(root, <span class="literal">nullptr</span>, <span class="literal">nullptr</span>);</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">//min, max 负责记录边界值</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isValidBST</span><span class="params">(TreeNode* root, TreeNode* min, TreeNode* max)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(min != <span class="literal">nullptr</span> &amp;&amp; root-&gt;val &lt;= min-&gt;val)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(max != <span class="literal">nullptr</span> &amp;&amp; root-&gt;val &gt;= max-&gt;val)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">isValidBST</span>(root-&gt;left, min, root)</span><br><span class="line">                &amp;&amp; <span class="built_in">isValidBST</span>(root-&gt;right, root, max);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h4 id="102-二叉树的层序遍历"><a href="#102-二叉树的层序遍历" class="headerlink" title="102. 二叉树的层序遍历"></a><a href="https://leetcode-cn.com/problems/binary-tree-level-order-traversal/">102. 二叉树的层序遍历</a></h4><p>&ensp;&ensp;&ensp;&ensp;给你一个二叉树，请你返回其按 <strong>层序遍历</strong> 得到的节点值。 （即逐层地，从左到右访问所有节点）。</p>
<p><strong>示例：</strong><br>&ensp;&ensp;&ensp;&ensp;二叉树：<code>[3,9,20,null,null,15,7]</code>,</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">  3</span><br><span class="line"> &#x2F; \</span><br><span class="line">9  20</span><br><span class="line">  &#x2F;  \</span><br><span class="line"> 15   7</span><br></pre></td></tr></table></figure>

<p>&ensp;&ensp;&ensp;&ensp;返回其层序遍历结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[</span><br><span class="line">  [3],</span><br><span class="line">  [9,20],</span><br><span class="line">  [15,7]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p>&ensp;&ensp;&ensp;&ensp;思路与代码：有递归和迭代两种。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">levelOrder</span>(TreeNode* root) </span><br><span class="line">    &#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; ans;</span><br><span class="line">        <span class="built_in">pre</span>(root, <span class="number">0</span>, ans);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">pre</span><span class="params">(TreeNode* root, <span class="keyword">int</span> depth, vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; &amp;ans)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="comment">//先序遍历，遍历过程中记录层数</span></span><br><span class="line">        <span class="keyword">if</span> (depth &gt;= ans.<span class="built_in">size</span>())</span><br><span class="line">            ans.<span class="built_in">push_back</span>(vector&lt;<span class="keyword">int</span>&gt; &#123;&#125;);</span><br><span class="line">        ans[depth].<span class="built_in">push_back</span>(root-&gt;val);</span><br><span class="line">        <span class="built_in">pre</span>(root-&gt;left, depth + <span class="number">1</span>, ans);</span><br><span class="line">        <span class="built_in">pre</span>(root-&gt;right, depth + <span class="number">1</span>, ans);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>&ensp;&ensp;&ensp;&ensp;另一解法</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">levelOrder</span>(TreeNode* root) </span><br><span class="line">    &#123;</span><br><span class="line">        queue&lt;TreeNode*&gt; que;</span><br><span class="line">        que.<span class="built_in">push</span>(root);</span><br><span class="line">        vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">        <span class="keyword">while</span> (que.<span class="built_in">size</span>() != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> size = que.<span class="built_in">size</span>();</span><br><span class="line">            vector&lt;<span class="keyword">int</span>&gt; level;</span><br><span class="line">            <span class="keyword">while</span> (size --) &#123;</span><br><span class="line">                TreeNode* cur = que.<span class="built_in">front</span>();</span><br><span class="line">                que.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="keyword">if</span> (!cur) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                level.<span class="built_in">push_back</span>(cur-&gt;val);</span><br><span class="line">                que.<span class="built_in">push</span>(cur-&gt;left);</span><br><span class="line">                que.<span class="built_in">push</span>(cur-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (level.<span class="built_in">size</span>() != <span class="number">0</span>) &#123;</span><br><span class="line">                res.<span class="built_in">push_back</span>(level);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h4 id="230-二叉搜索树中第K小的元素"><a href="#230-二叉搜索树中第K小的元素" class="headerlink" title="230. 二叉搜索树中第K小的元素"></a><a href="https://leetcode-cn.com/problems/kth-smallest-element-in-a-bst/">230. 二叉搜索树中第K小的元素</a></h4><p>&ensp;&ensp;&ensp;&ensp;给定一个二叉搜索树的根节点 <code>root</code> ，和一个整数 <code>k</code> ，请你设计一个算法查找其中第 <code>k</code> 个最小元素（从 1 开始计数）。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">    3</span><br><span class="line">   &#x2F; \</span><br><span class="line">  1   4</span><br><span class="line">   \   </span><br><span class="line">    2   </span><br><span class="line">输入：root &#x3D; [3,1,4,null,2], k &#x3D; 1</span><br><span class="line">输出：1</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">        5</span><br><span class="line">       &#x2F; \</span><br><span class="line">      3   6</span><br><span class="line">     &#x2F; \  </span><br><span class="line">    2   4 </span><br><span class="line">   &#x2F;</span><br><span class="line">  1 </span><br><span class="line">输入：root &#x3D; [5,3,6,2,4,null,null,1], k &#x3D; 3</span><br><span class="line">输出：3</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li>  树中的节点数为 <code>n</code> 。</li>
<li>  <code>1 &lt;= k &lt;= n &lt;= 104</code></li>
<li>  <code>0 &lt;= Node.val &lt;= 104</code></li>
</ul>
<p><strong>进阶：</strong>如果二叉搜索树经常被修改（插入/删除操作）并且你需要频繁地查找第 <code>k</code> 小的值，你将如何优化算法？</p>
<p><strong>思路与代码</strong>：</p>
<p>&ensp;&ensp;&ensp;&ensp;BST的中序遍历为升序数组，所以一边中序遍历一边记录已查找的个数即可。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> rank = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">traves</span><span class="params">(TreeNode* root, <span class="keyword">int</span> k)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">traves</span>(root-&gt;left, k);</span><br><span class="line"></span><br><span class="line">        ++rank;</span><br><span class="line">        <span class="keyword">if</span>(rank == k)</span><br><span class="line">        &#123;</span><br><span class="line">            res = root-&gt;val;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;           </span><br><span class="line"></span><br><span class="line">        <span class="built_in">traves</span>(root-&gt;right, k);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">kthSmallest</span><span class="params">(TreeNode* root, <span class="keyword">int</span> k)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">traves</span>(root,k);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="236-二叉树的最近公共祖先"><a href="#236-二叉树的最近公共祖先" class="headerlink" title="236. 二叉树的最近公共祖先"></a><a href="https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-tree/">236. 二叉树的最近公共祖先</a></h4><p>    给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。</p>
<p>    最近公共祖先的定义为：“对于有根树 T 的两个节点 p、q，最近公共祖先表示为一个节点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（<strong>一个节点也可以是它自己的祖先</strong>）。” </p>
<p><strong>示例 1：</strong></p>
<p><img src="/2021/05/07/%E4%BA%8C%E5%8F%89%E6%A0%91%EF%BC%9A%E9%81%8D%E5%8E%86%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%87%A0%E4%B8%AA%E7%AE%97%E6%B3%95%E9%A2%98/1.png" alt="img"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：root &#x3D; [3,5,1,6,2,0,8,null,null,7,4], p &#x3D; 5, q &#x3D; 1</span><br><span class="line">输出：3</span><br><span class="line">解释：节点 5 和节点 1 的最近公共祖先是节点 3 。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<p><img src="/2021/05/07/%E4%BA%8C%E5%8F%89%E6%A0%91%EF%BC%9A%E9%81%8D%E5%8E%86%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%87%A0%E4%B8%AA%E7%AE%97%E6%B3%95%E9%A2%98/2.png" alt="img"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：root &#x3D; [3,5,1,6,2,0,8,null,null,7,4], p &#x3D; 5, q &#x3D; 4</span><br><span class="line">输出：5</span><br><span class="line">解释：节点 5 和节点 4 的最近公共祖先是节点 5 。因为根据定义最近公共祖先节点可以为节点本身。</span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：root &#x3D; [1,2], p &#x3D; 1, q &#x3D; 2</span><br><span class="line">输出：1</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li>  树中节点数目在范围 <code>[2, 105]</code> 内。</li>
<li>  <code>-109 &lt;= Node.val &lt;= 109</code></li>
<li>  所有 <code>Node.val</code> <code>互不相同</code> 。</li>
<li>  <code>p != q</code></li>
<li>  <code>p</code> 和 <code>q</code> 均存在于给定的二叉树中。</li>
</ul>
<p><strong>思路与代码</strong>：</p>
<p>    递归思想, 对以root为根的(子)树进行查找p和q, 如果root == null || p || q 直接返回root，表示对于当前树的查找已经完毕, 否则对左右子树进行查找, 根据左右子树的返回值判断:</p>
<ul>
<li>  左右子树的返回值都不为<code>nullptr</code>，由于值唯一左右子树的返回值就是<code>p</code>和<code>q</code>, 此时<code>root</code>为LCA</li>
<li>  左右子树返回值只有一个不为<code>nullptr</code>, 说明只有<code>p</code>和<code>q</code>存在与左或右子树中, 最先找到的那个节点为LCA</li>
<li>  左右子树返回值均为<code>nullptr</code>, <code>p</code>和<code>q</code>均不在树中, 返回<code>nullptr</code></li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">lowestCommonAncestor</span><span class="params">(TreeNode* root, TreeNode* p, TreeNode* q)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">if</span>(root == p || root == q)</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line"></span><br><span class="line">        TreeNode* left = <span class="built_in">lowestCommonAncestor</span>(root-&gt;left, p, q);</span><br><span class="line">        TreeNode* right = <span class="built_in">lowestCommonAncestor</span>(root-&gt;right, p, q);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(left != <span class="literal">nullptr</span> &amp;&amp; right != <span class="literal">nullptr</span>)</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        <span class="keyword">if</span>(left == <span class="literal">nullptr</span> &amp;&amp; right == <span class="literal">nullptr</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">return</span> left == <span class="literal">nullptr</span> ? right : left;          </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h4 id="538-把二叉搜索树转换为累加树"><a href="#538-把二叉搜索树转换为累加树" class="headerlink" title="538. 把二叉搜索树转换为累加树"></a><a href="https://leetcode-cn.com/problems/convert-bst-to-greater-tree/">538. 把二叉搜索树转换为累加树</a></h4><p>&ensp;&ensp;&ensp;&ensp;给出二叉 <strong>搜索</strong> 树的根节点，该树的节点值各不相同，请你将其转换为累加树（Greater Sum Tree），使每个节点 <code>node</code> 的新值等于原树中大于或等于 <code>node.val</code> 的值之和。</p>
<p>&ensp;&ensp;&ensp;&ensp;提醒一下，二叉搜索树满足下列约束条件：</p>
<ul>
<li>  节点的左子树仅包含键 <strong>小于</strong> 节点键的节点。</li>
<li>  节点的右子树仅包含键 <strong>大于</strong> 节点键的节点。</li>
<li>  左右子树也必须是二叉搜索树。</li>
</ul>
<p><strong>示例 1：</strong></p>
<p><strong><img src="/2021/05/07/%E4%BA%8C%E5%8F%89%E6%A0%91%EF%BC%9A%E9%81%8D%E5%8E%86%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%87%A0%E4%B8%AA%E7%AE%97%E6%B3%95%E9%A2%98/3.png" alt="img" style="zoom:33%;"></strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：[4,1,6,0,2,5,7,null,null,null,3,null,null,null,8]</span><br><span class="line">输出：[30,36,21,36,35,26,15,null,null,null,33,null,null,null,8]</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：root &#x3D; [0,null,1]</span><br><span class="line">输出：[1,null,1]</span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：root &#x3D; [1,0,2]</span><br><span class="line">输出：[3,3,2]</span><br></pre></td></tr></table></figure>

<p><strong>示例 4：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：root &#x3D; [3,2,4,1]</span><br><span class="line">输出：[7,9,4,10]</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li>  树中的节点数介于 <code>0</code> 和 <code>104</code> 之间。</li>
<li>  每个节点的值介于 <code>-104</code> 和 <code>104</code> 之间。</li>
<li>  树中的所有值 <strong>互不相同</strong> 。</li>
<li>  给定的树为二叉搜索树</li>
</ul>
<p><strong>思路与代码</strong>：</p>
<p>&ensp;&ensp;&ensp;&ensp;这不就是中序遍历中，每一个节点的值加上后面所有结点的值的遍历结果吗？为了方便累加，我们改变中序遍历的顺序，先遍历右子树，再遍历左子树。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="function">TreeNode* <span class="title">convertBST</span><span class="params">(TreeNode* root)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="built_in">travers</span>(root);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">travers</span><span class="params">(TreeNode* root)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="built_in">travers</span>(root-&gt;right);</span><br><span class="line"></span><br><span class="line">        sum += root-&gt;val;</span><br><span class="line">        root-&gt;val = sum;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">travers</span>(root-&gt;left);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h4 id="652-寻找重复的子树"><a href="#652-寻找重复的子树" class="headerlink" title="652. 寻找重复的子树"></a><a href="https://leetcode-cn.com/problems/find-duplicate-subtrees/">652. 寻找重复的子树</a></h4><p>&ensp;&ensp;&ensp;&ensp;给定一棵二叉树，返回所有重复的子树。对于同一类的重复子树，你只需要返回其中任意<strong>一棵</strong>的根结点即可。</p>
<p>&ensp;&ensp;&ensp;&ensp;两棵树重复是指它们具有相同的结构以及相同的结点值。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">    1</span><br><span class="line">   &#x2F; \</span><br><span class="line">  2   3</span><br><span class="line"> &#x2F;   &#x2F; \</span><br><span class="line">4   2   4</span><br><span class="line">   &#x2F;</span><br><span class="line">  4</span><br></pre></td></tr></table></figure>

<p>下面是两个重复的子树：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">  2</span><br><span class="line"> &#x2F;</span><br><span class="line">4</span><br></pre></td></tr></table></figure>

<p>和</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">4</span><br></pre></td></tr></table></figure>

<p>&ensp;&ensp;&ensp;&ensp;因此，你需要以列表的形式返回上述重复子树的根结点。</p>
<p><strong>思路与代码</strong>：</p>
<p>&ensp;&ensp;&ensp;&ensp;采用将二叉树序列化的形式，建立哈希表，统计每次出现的次数，添加到结果集当中。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;TreeNode*&gt; <span class="title">findDuplicateSubtrees</span><span class="params">(TreeNode* root)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">          vector&lt;TreeNode*&gt; result;</span><br><span class="line">          unordered_map&lt;string,<span class="keyword">int</span>&gt; mp;</span><br><span class="line">          <span class="built_in">helper</span>(root, result, mp);</span><br><span class="line"></span><br><span class="line">          <span class="keyword">return</span> result;  </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">string <span class="title">helper</span><span class="params">(TreeNode* root, </span></span></span><br><span class="line"><span class="function"><span class="params">                vector&lt;TreeNode*&gt; &amp;result, </span></span></span><br><span class="line"><span class="function"><span class="params">                unordered_map&lt;string,<span class="keyword">int</span>&gt; &amp;mp)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root)</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;#&quot;</span>;</span><br><span class="line"></span><br><span class="line">        string str = <span class="built_in">helper</span>(root-&gt;left, result, mp) + <span class="string">&quot;,&quot;</span> + </span><br><span class="line">                     <span class="built_in">helper</span>(root-&gt;right, result, mp) + <span class="string">&quot;,&quot;</span> + </span><br><span class="line">                     <span class="built_in">to_string</span>(root-&gt;val);</span><br><span class="line">                     </span><br><span class="line">        <span class="keyword">if</span>(mp[str] == <span class="number">1</span>)</span><br><span class="line">            result.<span class="built_in">push_back</span>(root);</span><br><span class="line">        mp[str]++;</span><br><span class="line">        <span class="keyword">return</span> str;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="700-二叉搜索树中的搜索"><a href="#700-二叉搜索树中的搜索" class="headerlink" title="700. 二叉搜索树中的搜索"></a><a href="https://leetcode-cn.com/problems/search-in-a-binary-search-tree/">700. 二叉搜索树中的搜索</a></h4><p>&ensp;&ensp;&ensp;&ensp;给定二叉搜索树（BST）的根节点和一个值。 你需要在BST中找到节点值等于给定值的节点。 返回以该节点为根的子树。 如果节点不存在，则返回 NULL。</p>
<p>&ensp;&ensp;&ensp;&ensp;例如，</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">给定二叉搜索树:</span><br><span class="line"></span><br><span class="line">        4</span><br><span class="line">       &#x2F; \</span><br><span class="line">      2   7</span><br><span class="line">     &#x2F; \</span><br><span class="line">    1   3</span><br><span class="line"></span><br><span class="line">和值: 2</span><br></pre></td></tr></table></figure>

<p>&ensp;&ensp;&ensp;&ensp;你应该返回如下子树:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">  2     </span><br><span class="line"> &#x2F; \   </span><br><span class="line">1   3</span><br></pre></td></tr></table></figure>

<p>&ensp;&ensp;&ensp;&ensp;在上述示例中，如果要找的值是 <code>5</code>，但因为没有节点值为 <code>5</code>，我们应该返回 <code>NULL</code>。</p>
<p><strong>思路与代码</strong>：</p>
<p>&ensp;&ensp;&ensp;&ensp;没什么好说的，直接遍历即可。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">searchBST</span><span class="params">(TreeNode* root, <span class="keyword">int</span> val)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">if</span>(val &gt; root-&gt;val)</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">searchBST</span>(root-&gt;right, val);</span><br><span class="line">        <span class="keyword">if</span>(val &lt; root-&gt;val)</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">searchBST</span>(root-&gt;left, val);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="701-二叉搜索树中的插入操作"><a href="#701-二叉搜索树中的插入操作" class="headerlink" title="701. 二叉搜索树中的插入操作"></a><a href="https://leetcode-cn.com/problems/insert-into-a-binary-search-tree/">701. 二叉搜索树中的插入操作</a></h4><p>&ensp;&ensp;&ensp;&ensp;给定二叉搜索树（BST）的根节点和要插入树中的值，将值插入二叉搜索树。 返回插入后二叉搜索树的根节点。 输入数据 <strong>保证</strong> ，新值和原始二叉搜索树中的任意节点值都不同。</p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>注意</strong>，可能存在多种有效的插入方式，只要树在插入后仍保持为二叉搜索树即可。 你可以返回 <strong>任意有效的结果</strong> 。</p>
<p><strong>示例 1：</strong></p>
<img src="/2021/05/07/%E4%BA%8C%E5%8F%89%E6%A0%91%EF%BC%9A%E9%81%8D%E5%8E%86%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%87%A0%E4%B8%AA%E7%AE%97%E6%B3%95%E9%A2%98/4.jpg" alt="img" style="zoom:50%;">

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：root &#x3D; [4,2,7,1,3], val &#x3D; 5</span><br><span class="line">输出：[4,2,7,1,3,5]</span><br><span class="line">解释：另一个满足题目要求可以通过的树是：</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：root &#x3D; [40,20,60,10,30,50,70], val &#x3D; 25</span><br><span class="line">输出：[40,20,60,10,30,50,70,null,null,25]</span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：root &#x3D; [4,2,7,1,3,null,null,null,null,null,null], val &#x3D; 5</span><br><span class="line">输出：[4,2,7,1,3,5]</span><br></pre></td></tr></table></figure>

<p> <strong>提示：</strong></p>
<ul>
<li>  给定的树上的节点数介于 <code>0</code> 和 <code>10^4</code> 之间</li>
<li>  每个节点都有一个唯一整数值，取值范围从 <code>0</code> 到 <code>10^8</code></li>
<li>  <code>-10^8 &lt;= val &lt;= 10^8</code></li>
<li>  新值和原始二叉搜索树中的任意节点值都不同</li>
</ul>
<p><strong>思路与代码</strong>：</p>
<p>&ensp;&ensp;&ensp;&ensp;遍历找到合适的位置，再插入。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">insertIntoBST</span><span class="params">(TreeNode* root, <span class="keyword">int</span> val)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">TreeNode</span>(val);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(val &gt; root-&gt;val)</span><br><span class="line">            root-&gt;right = <span class="built_in">insertIntoBST</span>(root-&gt;right, val);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            root-&gt;left = <span class="built_in">insertIntoBST</span>(root-&gt;left, val);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="450-删除二叉搜索树中的节点"><a href="#450-删除二叉搜索树中的节点" class="headerlink" title="450. 删除二叉搜索树中的节点"></a><a href="https://leetcode-cn.com/problems/delete-node-in-a-bst/">450. 删除二叉搜索树中的节点</a></h4><p>&ensp;&ensp;&ensp;&ensp;给定一个二叉搜索树的根节点 <strong>root</strong> 和一个值 <strong>key</strong>，删除二叉搜索树中的 <strong>key</strong> 对应的节点，并保证二叉搜索树的性质不变。返回二叉搜索树（有可能被更新）的根节点的引用。</p>
<p>&ensp;&ensp;&ensp;&ensp;一般来说，删除节点可分为两个步骤：</p>
<ol>
<li> 首先找到需要删除的节点；</li>
<li> 如果找到了，删除它。</li>
</ol>
<p><strong>说明：</strong> 要求算法时间复杂度为 O(h)，h 为树的高度。</p>
<p><strong>示例:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">root &#x3D; [5,3,6,2,4,null,7]</span><br><span class="line">key &#x3D; 3</span><br><span class="line"></span><br><span class="line">    5</span><br><span class="line">   &#x2F; \</span><br><span class="line">  3   6</span><br><span class="line"> &#x2F; \   \</span><br><span class="line">2   4   7</span><br><span class="line"></span><br><span class="line">给定需要删除的节点值是 3，所以我们首先找到 3 这个节点，然后删除它。</span><br><span class="line"></span><br><span class="line">一个正确的答案是 [5,4,6,2,null,null,7], 如下图所示。</span><br><span class="line"></span><br><span class="line">    5</span><br><span class="line">   &#x2F; \</span><br><span class="line">  4   6</span><br><span class="line"> &#x2F;     \</span><br><span class="line">2       7</span><br><span class="line"></span><br><span class="line">另一个正确答案是 [5,2,6,null,4,null,7]。</span><br><span class="line"></span><br><span class="line">    5</span><br><span class="line">   &#x2F; \</span><br><span class="line">  2   6</span><br><span class="line">   \   \</span><br><span class="line">    4   7</span><br></pre></td></tr></table></figure>

<p><strong>思路与代码</strong>：</p>
<p>&ensp;&ensp;&ensp;&ensp;要删除的节点<code>A</code>有三种情况：</p>
<p>&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;<code>A</code>恰好是末端节点，两个子节点都为空，那么它可以当场去世了。</p>
<p>&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;<code>A</code>只有一个非空子节点，那么它要让这个孩子接替自己的位置。</p>
<p>&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;<code>A</code>有两个子节点，麻烦了，为了不破坏 BST 的性质，<code>A</code>必须找到左子树中最大的那个节点，或者右子树中最小的那个节点来接替自己。我采用第二种方式。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">getMin</span><span class="params">(TreeNode* root)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(root-&gt;left)</span><br><span class="line">            root = root-&gt;left;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">TreeNode* <span class="title">deleteNode</span><span class="params">(TreeNode* root, <span class="keyword">int</span> key)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">if</span>(key &gt; root-&gt;val)</span><br><span class="line">            root-&gt;right = <span class="built_in">deleteNode</span>(root-&gt;right, key);</span><br><span class="line">        <span class="keyword">if</span>(key &lt; root-&gt;val)</span><br><span class="line">            root-&gt;left = <span class="built_in">deleteNode</span>(root-&gt;left, key);</span><br><span class="line">        <span class="keyword">if</span>(key == root-&gt;val)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(!root-&gt;left) <span class="keyword">return</span> root-&gt;right;</span><br><span class="line">            <span class="keyword">if</span>(!root-&gt;right) <span class="keyword">return</span> root-&gt;left;</span><br><span class="line"></span><br><span class="line">            TreeNode* minNode = <span class="built_in">getMin</span>(root-&gt;right);</span><br><span class="line">            root-&gt;val = minNode-&gt;val;</span><br><span class="line">            root-&gt;right = <span class="built_in">deleteNode</span>(root-&gt;right, minNode-&gt;val);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><a href="https://mp.weixin.qq.com/s?__biz=MzAxODQxMDM0Mw==&mid=2247488128&idx=2&sn=b8fb3fd2917f9ac86127054741cd5877&chksm=9bd7ec88aca0659ee0185b657663169169493e9df2063fa4d28b38a0b4d0dd698d0301937898&scene=21#wechat_redirect">原创 | 手把手刷二叉搜索树（第二期） (qq.com)</a></p>
]]></content>
      <categories>
        <category>算法</category>
        <category>二叉树</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>二叉树</tag>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode中的Shell习题</title>
    <url>/2021/05/06/Shell%EF%BC%9ALeetcode%E7%9A%84Shell%E4%B9%A0%E9%A2%98/</url>
    <content><![CDATA[<p>&ensp;&ensp;&ensp;&ensp;leetcode中的四道shell题</p>
<span id="more"></span>

<h4 id="192-统计词频"><a href="#192-统计词频" class="headerlink" title="192. 统计词频"></a><a href="https://leetcode-cn.com/problems/word-frequency/">192. 统计词频</a></h4><p>&ensp;&ensp;&ensp;&ensp;写一个 bash 脚本以统计一个文本文件 <code>words.txt</code> 中每个单词出现的频率。</p>
<p>&ensp;&ensp;&ensp;&ensp;为了简单起见，你可以假设：</p>
<ul>
<li><code>words.txt</code>只包括小写字母和 <code>&#39; &#39;</code> 。</li>
<li>每个单词只由小写字母组成。</li>
<li>单词间由一个或多个空格字符分隔。</li>
</ul>
<p><strong>示例:</strong></p>
<p>&ensp;&ensp;&ensp;&ensp;假设 <code>words.txt</code> 内容如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">the day is sunny the the</span><br><span class="line">the sunny is is</span><br></pre></td></tr></table></figure>

<p>&ensp;&ensp;&ensp;&ensp;你的脚本应当输出（以词频降序排列）：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">the 4</span><br><span class="line">is 3</span><br><span class="line">sunny 2</span><br><span class="line">day 1</span><br></pre></td></tr></table></figure>

<p><strong>说明:</strong></p>
<ul>
<li>不要担心词频相同的单词的排序问题，每个单词出现的频率都是唯一的。</li>
<li>你可以使用一行 Unix pipes实现吗？</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> Read from the file words.txt and output the word frequency list to stdout.</span></span><br><span class="line">cat words.txt |tr -s &#x27; &#x27; &#x27;\n&#x27; |sort|uniq -c|sort -r|awk &#x27;&#123;print $2,$1&#125;&#x27;</span><br></pre></td></tr></table></figure>

<p>&ensp;&ensp;&ensp;&ensp;1、首先cat命令查看words.txt<br>&ensp;&ensp;&ensp;&ensp;2、tr -s ‘ ‘ ‘\n’将空格都替换为换行 实现分词<br>&ensp;&ensp;&ensp;&ensp;3、sort排序 将分好的词按照顺序排序<br>&ensp;&ensp;&ensp;&ensp;4、uniq -c 统计重复次数（此步骤与上一步息息相关，-c原理是字符串相同则加一，如果不进行先排序的话将无法统计数目）<br>&ensp;&ensp;&ensp;&ensp;5、sort -r 将数目倒序排列<br>&ensp;&ensp;&ensp;&ensp;6、awk ‘{print $2,$1}’ 将词频和词语调换位置打印出来</p>
<h4 id="193-有效电话号码"><a href="#193-有效电话号码" class="headerlink" title="193. 有效电话号码"></a><a href="https://leetcode-cn.com/problems/valid-phone-numbers/">193. 有效电话号码</a></h4><p>&ensp;&ensp;&ensp;&ensp;给定一个包含电话号码列表（一行一个电话号码）的文本文件 <code>file.txt</code>，写一个单行 bash 脚本输出所有有效的电话号码。</p>
<p>&ensp;&ensp;&ensp;&ensp;你可以假设一个有效的电话号码必须满足以下两种格式： (xxx) xxx-xxxx 或 xxx-xxx-xxxx。（x 表示一个数字）</p>
<p>&ensp;&ensp;&ensp;&ensp;你也可以假设每行前后没有多余的空格字符。 </p>
<p><strong>示例：</strong></p>
<p>&ensp;&ensp;&ensp;&ensp;假设 <code>file.txt</code> 内容如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">987-123-4567</span><br><span class="line">123 456 7890</span><br><span class="line">(123) 456-7890</span><br></pre></td></tr></table></figure>

<p>&ensp;&ensp;&ensp;&ensp;你的脚本应当输出下列有效的电话号码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">987-123-4567</span><br><span class="line">(123) 456-7890</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">三种方法：</span><br><span class="line">grep -P <span class="string">&#x27;^(\d&#123;3&#125;-|\(\d&#123;3&#125;\) )\d&#123;3&#125;-\d&#123;4&#125;$&#x27;</span> file.txt</span><br><span class="line">sed -n -r <span class="string">&#x27;/^([0-9]&#123;3&#125;-|\([0-9]&#123;3&#125;\) )[0-9]&#123;3&#125;-[0-9]&#123;4&#125;$/p&#x27;</span> file.txt</span><br><span class="line">awk <span class="string">&#x27;/^([0-9]&#123;3&#125;-|\([0-9]&#123;3&#125;\) )[0-9]&#123;3&#125;-([0-9]&#123;4&#125;)$/&#x27;</span> file.txt</span><br></pre></td></tr></table></figure>

<h4 id="194-转置文件"><a href="#194-转置文件" class="headerlink" title="194. 转置文件"></a><a href="https://leetcode-cn.com/problems/transpose-file/">194. 转置文件</a></h4><p>&ensp;&ensp;&ensp;&ensp;给定一个文件 <code>file.txt</code>，转置它的内容。</p>
<p>&ensp;&ensp;&ensp;&ensp;你可以假设每行列数相同，并且每个字段由 <code>&#39; &#39;</code> 分隔。</p>
<p> <strong>示例：</strong></p>
<p>&ensp;&ensp;&ensp;&ensp;假设 <code>file.txt</code> 文件内容如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">name age</span><br><span class="line">alice 21</span><br><span class="line">ryan 30</span><br></pre></td></tr></table></figure>

<p>&ensp;&ensp;&ensp;&ensp;应当输出：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">name alice ryan</span><br><span class="line">age 21 30</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">awk <span class="string">&#x27;&#123; #这个大括号里的代码是 对正文的处理</span></span><br><span class="line"><span class="string">    # NF表示列数，NR表示已读的行数</span></span><br><span class="line"><span class="string">    # 注意for中的i从1开始，i前没有类型</span></span><br><span class="line"><span class="string">    for (i=1; i&lt;=NF; i++)&#123;#对每一列</span></span><br><span class="line"><span class="string">        if(NR==1)&#123;       #如果是第一行</span></span><br><span class="line"><span class="string">            #将第i列的值存入res[i],$i表示第i列的值，i为数组的下标，以列序号为下标，</span></span><br><span class="line"><span class="string">            #数组不用定义可以直接使用</span></span><br><span class="line"><span class="string">            res[i]=$i;   </span></span><br><span class="line"><span class="string">        &#125;</span></span><br><span class="line"><span class="string">        else&#123;</span></span><br><span class="line"><span class="string">            #不是第一行时，将该行对应i列的值拼接到res[i]</span></span><br><span class="line"><span class="string">            res[i]=res[i] &quot; &quot; $i</span></span><br><span class="line"><span class="string">        &#125;</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string"># BEGIN&#123;&#125; 文件进行扫描前要执行的操作；END&#123;&#125; 文件扫描结束后要执行的操作。</span></span><br><span class="line"><span class="string">END&#123;</span></span><br><span class="line"><span class="string">    #输出数组</span></span><br><span class="line"><span class="string">	for (i=1; i&lt;=NF; i++)&#123;</span></span><br><span class="line"><span class="string">		print res[i]</span></span><br><span class="line"><span class="string">	&#125;</span></span><br><span class="line"><span class="string">&#125;&#x27;</span> file.txt</span><br></pre></td></tr></table></figure>

<h4 id="195-第十行"><a href="#195-第十行" class="headerlink" title="195. 第十行"></a><a href="https://leetcode-cn.com/problems/tenth-line/">195. 第十行</a></h4><p>&ensp;&ensp;&ensp;&ensp;给定一个文本文件 <code>file.txt</code>，请只打印这个文件中的第十行。</p>
<p><strong>示例:</strong></p>
<p>&ensp;&ensp;&ensp;&ensp;假设 <code>file.txt</code> 有如下内容：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Line 1</span><br><span class="line">Line 2</span><br><span class="line">Line 3</span><br><span class="line">Line 4</span><br><span class="line">Line 5</span><br><span class="line">Line 6</span><br><span class="line">Line 7</span><br><span class="line">Line 8</span><br><span class="line">Line 9</span><br><span class="line">Line 10</span><br></pre></td></tr></table></figure>

<p>&ensp;&ensp;&ensp;&ensp;你的脚本应当显示第十行：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Line 10</span><br></pre></td></tr></table></figure>

<p><strong>说明:</strong></p>
<ol>
<li>如果文件少于十行，你应当输出什么？</li>
<li>至少有三种不同的解法，请尝试尽可能多的方法来解题</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">grep -n <span class="string">&quot;&quot;</span> file.txt | grep -w <span class="string">&#x27;10&#x27;</span> | cut -d: -f2</span><br><span class="line">sed -n <span class="string">&#x27;10p&#x27;</span> file.txt</span><br><span class="line">awk <span class="string">&#x27;&#123;if(NR==10)&#123;print $0&#125;&#125;&#x27;</span> file.txt</span><br></pre></td></tr></table></figure>

<p><a href="https://mp.weixin.qq.com/s/EI63RZZcPzJT4c0zl8XQSA">LeetCode上稀缺的四道shell编程题解析</a></p>
]]></content>
      <categories>
        <category>shell</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>shell</tag>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>shell入门</title>
    <url>/2021/05/06/Shell%EF%BC%9AShell%E5%85%A5%E9%97%A8%E7%9F%A5%E8%AF%86/</url>
    <content><![CDATA[<h3 id="Shell概述"><a href="#Shell概述" class="headerlink" title="Shell概述"></a>Shell概述</h3><p>&ensp;&ensp;&ensp;&ensp;Shell是一个命令行解释器，它接受应用程序/用户命令，然后调用操作系统内核。</p>
<span id="more"></span>

<p><img src="/2021/05/06/Shell%EF%BC%9AShell%E5%85%A5%E9%97%A8%E7%9F%A5%E8%AF%86/shell.png"></p>
<p>&ensp;&ensp;&ensp;&ensp;Shell还是一个功能相当强大的编程语言，易编写、易调试、灵活性强。</p>
<p><a href="https://www.runoob.com/linux/linux-shell.html">Shell 教程</a></p>
<h3 id="Shell解析器"><a href="#Shell解析器" class="headerlink" title="Shell解析器"></a>Shell解析器</h3><ul>
<li><p>Linux提供的shell解析器</p>
  <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">james@james-Vostro-5471:~$ sudo cat /etc/shells</span><br><span class="line">[sudo] james 的密码： </span><br><span class="line"><span class="meta">#</span><span class="bash"> /etc/shells: valid login shells</span></span><br><span class="line">/bin/sh</span><br><span class="line">/bin/bash</span><br><span class="line">/bin/rbash</span><br><span class="line">/bin/dash</span><br></pre></td></tr></table></figure>
</li>
<li><p>bash和sh的关系（sh调用bash）</p>
  <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">root@james-Vostro-5471:/bin# ll | grep bash</span><br><span class="line">-rwxr-xr-x  1 root root 1113504 6月   7  2019 bash*</span><br><span class="line">lrwxrwxrwx  1 root root       4 3月  11  2020 rbash -&gt; bash*</span><br></pre></td></tr></table></figure></li>
<li><p>SUSE默认的shell解析器是bash</p>
  <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">james@james-Vostro-5471:~$ echo $SHELL</span><br><span class="line">/bin/bash</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="Shell脚本入门"><a href="#Shell脚本入门" class="headerlink" title="Shell脚本入门"></a>Shell脚本入门</h3><h4 id="脚本格式"><a href="#脚本格式" class="headerlink" title="脚本格式"></a>脚本格式</h4><p>&ensp;&ensp;&ensp;&ensp;脚本以#！/bin/bash开头（指定解析器）</p>
<p>&ensp;&ensp;&ensp;&ensp;范例：创建一个shell脚本，输出helloworld</p>
<p>&ensp;&ensp;&ensp;&ensp;创建文件</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">james@james-Vostro-5471:~/datas$ touch helloworld.sh</span><br><span class="line">james@james-Vostro-5471:~/datas$ vim helloworld.sh</span><br></pre></td></tr></table></figure>

<p>&ensp;&ensp;&ensp;&ensp;文件内容:</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">!/bin/bash</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;hello world&quot;</span></span><br></pre></td></tr></table></figure>

<p>&ensp;&ensp;&ensp;&ensp;执行：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">james@james-Vostro-5471:~/datas$ sh helloworld.sh</span><br><span class="line">hello world</span><br><span class="line">james@james-Vostro-5471:~/datas$ bash helloworld.sh</span><br><span class="line">hello world</span><br></pre></td></tr></table></figure>

<h4 id="脚本的常用执行方式"><a href="#脚本的常用执行方式" class="headerlink" title="脚本的常用执行方式"></a>脚本的常用执行方式</h4><p>&ensp;&ensp;&ensp;&ensp;第一种：采用bash或sh+脚本的相对路径或绝对路径（不用赋予脚本+x权限）</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">root@james-Vostro-5471:/home/james/datas# sh helloworld.sh</span><br><span class="line">hello world</span><br><span class="line">root@james-Vostro-5471:/home/james/datas# sh /home/james/datas/helloworld.sh</span><br><span class="line">hello world</span><br></pre></td></tr></table></figure>

<p>&ensp;&ensp;&ensp;&ensp;第二种：采用输入脚本的绝对路径或相对路径执行脚本（必须具有可执行权限+x）</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">root@james-Vostro-5471:/home/james/datas# ./helloworld.sh</span><br><span class="line">bash: ./helloworld.sh: 权限不够</span><br><span class="line">root@james-Vostro-5471:/home/james/datas# ll | grep helloworld.sh</span><br><span class="line">-rw-r--r--  1 james james   32 5月   6 13:06 helloworld.sh</span><br><span class="line">root@james-Vostro-5471:/home/james/datas# chmod 777 helloworld.sh</span><br><span class="line">root@james-Vostro-5471:/home/james/datas# ll |grep helloworld.sh</span><br><span class="line">-rwxrwxrwx  1 james james   32 5月   6 13:06 helloworld.sh*</span><br><span class="line">root@james-Vostro-5471:/home/james/datas# ./helloworld.sh</span><br><span class="line">hello world</span><br><span class="line">root@james-Vostro-5471:/home/james/datas# /home/james/datas/helloworld.sh</span><br><span class="line">hello world</span><br></pre></td></tr></table></figure>

<p>&ensp;&ensp;&ensp;&ensp;第一种执行方法，本质是bash解析器帮你执行脚本，所以脚本本身不需要执行权限。第二种方法，本质是脚本需要自己执行，所以需要执行权限。</p>
<h4 id="多命令处理"><a href="#多命令处理" class="headerlink" title="多命令处理"></a>多命令处理</h4><p>&ensp;&ensp;&ensp;&ensp;在/home/james/datas目录下创建一个demo.txt 在demo.txt文件中增加“this is a demo”：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">root@james-Vostro-5471:/home/james/datas# touch batch.sh</span><br><span class="line">root@james-Vostro-5471:/home/james/datas# vim batch.sh</span><br><span class="line">root@james-Vostro-5471:/home/james/datas# ll</span><br><span class="line">总用量 16</span><br><span class="line">drwxr-xr-x  2 james james 4096 5月   6 13:27 ./</span><br><span class="line">drwxr-xr-x 22 james james 4096 5月   6 13:06 ../</span><br><span class="line">-rw-r--r--  1 root  root    84 5月   6 13:27 batch.sh</span><br><span class="line">-rwxrwxrwx  1 james james   32 5月   6 13:06 helloworld.sh*</span><br><span class="line">root@james-Vostro-5471:/home/james/datas# bash batch.sh</span><br><span class="line">root@james-Vostro-5471:/home/james/datas# ll</span><br><span class="line">总用量 20</span><br><span class="line">drwxr-xr-x  2 james james 4096 5月   6 13:29 ./</span><br><span class="line">drwxr-xr-x 22 james james 4096 5月   6 13:06 ../</span><br><span class="line">-rw-r--r--  1 root  root    84 5月   6 13:27 batch.sh</span><br><span class="line">-rw-r--r--  1 root  root    15 5月   6 13:29 demo.txt</span><br><span class="line">-rwxrwxrwx  1 james james   32 5月   6 13:06 helloworld.sh*</span><br><span class="line">root@james-Vostro-5471:/home/james/datas# cat demo.txt</span><br><span class="line">this is a demo</span><br><span class="line">root@james-Vostro-5471:/home/james/datas# cat batch.sh</span><br><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line"></span><br><span class="line">cd /home/james/datas</span><br><span class="line">touch demo.txt</span><br><span class="line">echo &quot;this is a demo&quot; &gt;&gt; demo.txt</span><br></pre></td></tr></table></figure>



<h3 id="Shell中的变量"><a href="#Shell中的变量" class="headerlink" title="Shell中的变量"></a>Shell中的变量</h3><h4 id="常用系统变量"><a href="#常用系统变量" class="headerlink" title="常用系统变量"></a>常用系统变量</h4><p>&ensp;&ensp;&ensp;&ensp;$HOME(根目录) 、$PWD(当前目录)、 $SHELL(shell解析器目录)、 $USER(当前用户)等</p>
<p>&ensp;&ensp;&ensp;&ensp;范例：查看系统变量的值</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">james@james-Vostro-5471:~$ echo $HOME</span><br><span class="line">/home/james</span><br><span class="line">james@james-Vostro-5471:~$ echo $PWD</span><br><span class="line">/home/james</span><br><span class="line">james@james-Vostro-5471:~$ echo $SHELL</span><br><span class="line">/bin/bash</span><br><span class="line">james@james-Vostro-5471:~$ echo $USER</span><br><span class="line">james</span><br></pre></td></tr></table></figure>

<h4 id="自定义变量"><a href="#自定义变量" class="headerlink" title="自定义变量"></a>自定义变量</h4><ul>
<li><p>定义变量 ： 变量=值（声明变量时等号左右不能有空格）</p>
  <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">james@james-Vostro-5471:~$ M=1</span><br><span class="line">james@james-Vostro-5471:~$ echo $M</span><br><span class="line">1</span><br></pre></td></tr></table></figure></li>
<li><p>撤销变量：unset 变量</p>
  <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">james@james-Vostro-5471:~$ unset M</span><br><span class="line">james@james-Vostro-5471:~$ echo $M</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li><p>声明静态变量：readonly 变量，注意：不能unset</p>
  <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">james@james-Vostro-5471:~$ readonly B=3</span><br><span class="line">james@james-Vostro-5471:~$ echo $B</span><br><span class="line">3</span><br><span class="line">james@james-Vostro-5471:~$ unset B</span><br><span class="line">bash: unset: B: 无法取消设定: 只读 variable</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="变量定义规则"><a href="#变量定义规则" class="headerlink" title="变量定义规则"></a>变量定义规则</h4><ul>
<li>变量名称可以由字母、数字、下划线组成，但是不能以数字开头，环境变量名建议大写。</li>
<li>等号两侧不能有空格</li>
<li>在bash中，变量默认类型都是字符串类型，无法直接进行数值运算</li>
<li>变量的值如果有空格，需要使用双引号或单引号括起来</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">james@james-Vostro-5471:~$ S=1+1</span><br><span class="line">james@james-Vostro-5471:~$ echo $S</span><br><span class="line">1+1</span><br><span class="line">james@james-Vostro-5471:~$ d=zx 12 3</span><br><span class="line">12：未找到命令</span><br><span class="line">james@james-Vostro-5471:~$ d=&#x27;zx 12 3&#x27;</span><br><span class="line">james@james-Vostro-5471:~$ echo $d</span><br><span class="line">zx 12 3</span><br><span class="line">james@james-Vostro-5471:~$ </span><br></pre></td></tr></table></figure>

<h4 id="提升全局变量"><a href="#提升全局变量" class="headerlink" title="提升全局变量"></a>提升全局变量</h4><p>&ensp;&ensp;&ensp;&ensp;把局部变量提升为全局变量，可供其他shell程序使用。</p>
<p>&ensp;&ensp;&ensp;&ensp;export 变量名</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">james@james-Vostro-5471:~/datas$ vim helloworld.sh</span><br><span class="line">james@james-Vostro-5471:~/datas$ cat helloworld.sh</span><br><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line"></span><br><span class="line">echo &quot;hello world&quot;</span><br><span class="line"></span><br><span class="line">echo $D</span><br><span class="line">james@james-Vostro-5471:~/datas$ D=&#x27;bian liang&#x27;</span><br><span class="line">james@james-Vostro-5471:~/datas$ echo $D</span><br><span class="line">bian liang</span><br><span class="line">james@james-Vostro-5471:~/datas$ sh helloworld.sh</span><br><span class="line">hello world</span><br><span class="line"></span><br><span class="line">james@james-Vostro-5471:~/datas$ export D</span><br><span class="line">james@james-Vostro-5471:~/datas$ sh helloworld.sh</span><br><span class="line">hello world</span><br><span class="line">bian liang</span><br><span class="line">james@james-Vostro-5471:~/datas$ </span><br></pre></td></tr></table></figure>

<h4 id="特殊变量"><a href="#特殊变量" class="headerlink" title="特殊变量"></a>特殊变量</h4><p>1、$n</p>
<p>&ensp;&ensp;&ensp;&ensp;功能描述：n为数字，$0代表该脚本名称，包含完整路径。$1- 9 代表第一到第九个参数 ，十 以上的参数需要用大括号包含，如{10}。</p>
<p>&ensp;&ensp;&ensp;&ensp;范例：输出该脚本文件名称，输入参数1和输入参数2的值</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">james@james-Vostro-5471:~/datas$ touch parameter.sh</span><br><span class="line">james@james-Vostro-5471:~/datas$ vim parameter.sh</span><br><span class="line">james@james-Vostro-5471:~/datas$ cat parameter.sh</span><br><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line"></span><br><span class="line">echo &quot;$0 $1 $2 $3&quot;</span><br><span class="line">james@james-Vostro-5471:~/datas$ bash parameter.sh</span><br><span class="line">parameter.sh   </span><br><span class="line">james@james-Vostro-5471:~/datas$ bash parameter.sh first</span><br><span class="line">parameter.sh first  </span><br><span class="line">james@james-Vostro-5471:~/datas$ bash parameter.sh first second</span><br><span class="line">parameter.sh first second </span><br><span class="line">james@james-Vostro-5471:~/datas$ bash parameter.sh first second third</span><br><span class="line">parameter.sh first second third</span><br><span class="line">james@james-Vostro-5471:~/datas$ bash parameter.sh first second third fourth</span><br><span class="line">parameter.sh first second third</span><br><span class="line">james@james-Vostro-5471:~/datas$ </span><br></pre></td></tr></table></figure>

<p>2、$#</p>
<p>&ensp;&ensp;&ensp;&ensp;功能描述：获取所有输入参数个数，常用于循环。</p>
<p>&ensp;&ensp;&ensp;&ensp;范例：获取输入参数的个数</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">james@james-Vostro-5471:~/datas$ vim parameter.sh</span><br><span class="line">james@james-Vostro-5471:~/datas$ cat parameter.sh</span><br><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line"></span><br><span class="line">echo &quot;$0 $1 $2 $3&quot;</span><br><span class="line"></span><br><span class="line">echo $#</span><br><span class="line">james@james-Vostro-5471:~/datas$ bash parameter.sh first second third</span><br><span class="line">parameter.sh first second third</span><br><span class="line">3</span><br><span class="line">james@james-Vostro-5471:~/datas$ </span><br></pre></td></tr></table></figure>

<p>3、$*和$@</p>
<p>&ensp;&ensp;&ensp;&ensp;$* : 这个变量代表命令行中所有的参数，$*把所有的参数看成一个整体</p>
<p>&ensp;&ensp;&ensp;&ensp;$@ : 这个变量也代表命令行中所有的参数，不过$@把每个参数区分对待</p>
<p>&ensp;&ensp;&ensp;&ensp;范例：打印输出所有参数</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">james@james-Vostro-5471:~/datas$ vim parameter.sh</span><br><span class="line">james@james-Vostro-5471:~/datas$ cat parameter.sh</span><br><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line"></span><br><span class="line">echo &quot;$0 $1 $2 $3&quot;</span><br><span class="line"></span><br><span class="line">echo $#</span><br><span class="line">echo $*</span><br><span class="line">echo $@</span><br><span class="line">james@james-Vostro-5471:~/datas$ bash parameter.sh first second third</span><br><span class="line">parameter.sh first second third</span><br><span class="line">3</span><br><span class="line">first second third</span><br><span class="line">first second third</span><br><span class="line">james@james-Vostro-5471:~/datas$ </span><br></pre></td></tr></table></figure>

<p>4、$?</p>
<p>&ensp;&ensp;&ensp;&ensp;功能描述：最后一次执行的命令的返回状态。如果这个变量的值为0，证明上一个命令正确执行；如果这个变量的值为非0（具体哪个数，由命令自己来决定），则证明上一个命令执行不正确了。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">james@james-Vostro-5471:~/datas$ $?</span><br><span class="line">0：未找到命令</span><br><span class="line">james@james-Vostro-5471:~/datas$ echo $?</span><br><span class="line">127</span><br><span class="line">james@james-Vostro-5471:~/datas$ bash helloworld.sh</span><br><span class="line">hello world</span><br><span class="line">bian liang</span><br><span class="line">james@james-Vostro-5471:~/datas$ echo $?</span><br><span class="line">0</span><br></pre></td></tr></table></figure>

<h3 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h3><h4 id="1、基本语法："><a href="#1、基本语法：" class="headerlink" title="1、基本语法："></a>1、基本语法：</h4><ol>
<li><p>“$((运算式))”或“$[运算式]”</p>
</li>
<li><p>expr  +，-，*，/，%  加，减，乘，除，取余</p>
</li>
</ol>
<p>&ensp;&ensp;&ensp;&ensp;注意：expr运算符间要有空格</p>
<h4 id="2、范例：计算3-2"><a href="#2、范例：计算3-2" class="headerlink" title="2、范例：计算3+2"></a>2、范例：计算3+2</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">james@james-Vostro-5471:~/datas$ expr 3 + 2</span><br><span class="line">5</span><br><span class="line">james@james-Vostro-5471:~/datas$ s=$((3+2))</span><br><span class="line">james@james-Vostro-5471:~/datas$ echo $s</span><br><span class="line">5</span><br></pre></td></tr></table></figure>

<p>范例：计算（2+3）*4</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">james@james-Vostro-5471:~/datas$ d=$[(2+3)*4]</span><br><span class="line">james@james-Vostro-5471:~/datas$ echo $d</span><br><span class="line">20</span><br><span class="line">james@james-Vostro-5471:~/datas$ expr `expr 2 + 3` \* 4</span><br><span class="line">20</span><br></pre></td></tr></table></figure>

<h3 id="条件判断"><a href="#条件判断" class="headerlink" title="条件判断"></a>条件判断</h3><h4 id="1、语法："><a href="#1、语法：" class="headerlink" title="1、语法："></a>1、语法：</h4><p>[ condition ] (<strong>condition前后要有空格</strong>)</p>
<p>注意：条件非空即为true，如[z]返回true，[] 返回false</p>
<h4 id="2、常用条件判断"><a href="#2、常用条件判断" class="headerlink" title="2、常用条件判断"></a>2、常用条件判断</h4><p>（1）两个整数之间比较</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x3D; 字符串比较</span><br><span class="line">-lt 小于（less than） -le 小于等于 （less equal）</span><br><span class="line">-eq 等于 （equal） -gt 大于 （greater than）</span><br><span class="line">-ge 大于等于 （greater equal） -ne不等于 （Not equal）</span><br></pre></td></tr></table></figure>

<p>（2）按照文件权限进行判断</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-r 有读的权限（read） -w 有写的权限 （write）</span><br><span class="line">-x 有执行的权限 （execute）</span><br></pre></td></tr></table></figure>

<p>（3）按照文件类型进行判断</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-f 文件存在并且是一个常规文件（file）</span><br><span class="line">-e 文件存在 （existence）</span><br><span class="line">-d 文件存在并是一个目录（directory）</span><br></pre></td></tr></table></figure>

<p>范例：23是否大于等于22</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">james@james-Vostro-5471:~/datas$ [ 23 -ge 22 ]</span><br><span class="line">james@james-Vostro-5471:~/datas$ echo $?</span><br><span class="line">0</span><br><span class="line">james@james-Vostro-5471:~/datas$ [ 23 -le 22 ]</span><br><span class="line">james@james-Vostro-5471:~/datas$ echo $?</span><br><span class="line">1</span><br></pre></td></tr></table></figure>

<p>范例：查看helloworld.sh 是否具有执行权限</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">james@james-Vostro-5471:~/datas$ [ -x /home/james/datas/helloworld.sh ]</span><br><span class="line">james@james-Vostro-5471:~/datas$ echo $?</span><br><span class="line">0</span><br></pre></td></tr></table></figure>

<p>范例：判断/home/james/datas/hello.txt是否存在</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">james@james-Vostro-5471:~/datas$ [ -e /home/james/datas/hello.txt ]</span><br><span class="line">james@james-Vostro-5471:~/datas$ echo $?</span><br><span class="line">1</span><br><span class="line">james@james-Vostro-5471:~/datas$ [ -e /home/james/datas/helloworld.sh ]</span><br><span class="line">james@james-Vostro-5471:~/datas$ echo $?</span><br><span class="line">0</span><br></pre></td></tr></table></figure>

<p>（4）多条件判断（&amp;&amp;表示前一条命令执行成功时，才执行后一条命令，|| 表示上一条命令执行失败后，才执行下一条命令）[]</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">james@james-Vostro-5471:~/datas$ [ 3 -ge 2 ] &amp;&amp; echo ok || echo notok</span><br><span class="line">ok</span><br><span class="line">james@james-Vostro-5471:~/datas$ [ 3 -ge 2 ] &amp;&amp; [ ] || echo notok</span><br><span class="line">notok</span><br><span class="line">james@james-Vostro-5471:~/datas$ [ 3 -ge 2 ] &amp; echo ok</span><br><span class="line">[1] 27351</span><br><span class="line">ok</span><br></pre></td></tr></table></figure>

<h3 id="流程控制"><a href="#流程控制" class="headerlink" title="流程控制"></a>流程控制</h3><h4 id="1、if判断"><a href="#1、if判断" class="headerlink" title="1、if判断"></a>1、if判断</h4><p>语法：</p>
<pre><code>if [ 条件判断式 ]；then
 程序
 fi
 或者
 if [ 条件判断式 ]
 then
 程序
 fi
</code></pre>
<p>注意事项：</p>
<ul>
<li>[ 条件判断式 ] ，中括号和条件判断式之间必须有空格</li>
<li>if后要有空格</li>
</ul>
<p>范例：输入一个数字，如果是1，则输出one，如果是2，则输出two，如果是其他，什么也不输出。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">james@james-Vostro-5471:~/datas$ cat testIf.sh</span><br><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line"></span><br><span class="line">if [ $1 -eq 1 ];then</span><br><span class="line">    echo &quot;one&quot;</span><br><span class="line">elif [ $1 -eq 2 ]</span><br><span class="line">then</span><br><span class="line">    echo &quot;two&quot;</span><br><span class="line">fi</span><br><span class="line">james@james-Vostro-5471:~/datas$ bash testIf.sh</span><br><span class="line">testIf.sh: 第 3 行: [: -eq: 需要一元表达式</span><br><span class="line">testIf.sh: 第 5 行: [: -eq: 需要一元表达式</span><br><span class="line">james@james-Vostro-5471:~/datas$ bash testIf.sh 1</span><br><span class="line">one</span><br><span class="line">james@james-Vostro-5471:~/datas$ bash testIf.sh 2</span><br><span class="line">two</span><br><span class="line">james@james-Vostro-5471:~/datas$ bash testIf.sh 3</span><br></pre></td></tr></table></figure>

<h4 id="2、case语句"><a href="#2、case语句" class="headerlink" title="2、case语句"></a>2、case语句</h4><p>语法：</p>
<pre><code>case $变量名 in
“值1”）
如果变量的值等于1，则执行程序1
;;
“值2”）
 如果变量的值等于2，则执行程序2
;;
…省略其他分支…
*)
 如果变量的值都不是以上的值，则执行此程序
;;
esac
</code></pre>
<p>注意事项：</p>
<ul>
<li><p>case行尾必须为单词“in”，每一个模式匹配必须以右括号“）”结束。</p>
</li>
<li><p>双分号“;;”表示命令序列结束，相当于java中的break。</p>
</li>
<li><p>最后的“*）”表示默认模式，相当于java中的default</p>
</li>
</ul>
<p>范例：输入一个数字，如果是1，则输出one，如果是2，则输出two，如果是其他，输出hello</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">james@james-Vostro-5471:~/datas$ cat testCase.sh</span><br><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line"></span><br><span class="line">case $1 in</span><br><span class="line">1)</span><br><span class="line">    echo &quot;one&quot;</span><br><span class="line">;;</span><br><span class="line">2)</span><br><span class="line">    echo &quot;two&quot;</span><br><span class="line">;;</span><br><span class="line">*)</span><br><span class="line">    echo &quot;hello&quot;</span><br><span class="line">;;</span><br><span class="line">esac</span><br><span class="line">james@james-Vostro-5471:~/datas$ bash testCase.sh 1</span><br><span class="line">one</span><br><span class="line">james@james-Vostro-5471:~/datas$ bash testCase.sh 2</span><br><span class="line">two</span><br><span class="line">james@james-Vostro-5471:~/datas$ bash testCase.sh 3</span><br><span class="line">hello</span><br></pre></td></tr></table></figure>

<h4 id="3、for循环"><a href="#3、for循环" class="headerlink" title="3、for循环"></a>3、for循环</h4><p>语法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">for ((初始值；循环控制条件；变量变化))</span><br><span class="line"> do</span><br><span class="line"> 程序</span><br><span class="line"> done</span><br></pre></td></tr></table></figure>

<p>范例：从1加到100</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">james@james-Vostro-5471:~/datas$ cat testFor.sh</span><br><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line"></span><br><span class="line">s=0</span><br><span class="line">for ((i=1;i&lt;=100;++i))</span><br><span class="line">do</span><br><span class="line">    s=$[$s+$i] </span><br><span class="line">done</span><br><span class="line"></span><br><span class="line">echo $s</span><br><span class="line">james@james-Vostro-5471:~/datas$ bash testFor.sh</span><br><span class="line">5050</span><br></pre></td></tr></table></figure>

<p>语法2：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">for 变量 in 值1 值2 值3…</span><br><span class="line"> do</span><br><span class="line"> 程序</span><br><span class="line"> done</span><br></pre></td></tr></table></figure>

<p>范例：打印所有输入参数（观察 ∗ 与 *与 ∗与@的区别）</p>
<p>使用$*</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">james@james-Vostro-5471:~/datas$ cat testFor.sh</span><br><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line"></span><br><span class="line">s=0</span><br><span class="line">for i in $* </span><br><span class="line">do</span><br><span class="line">    echo &quot;打印所有参数：$i&quot; </span><br><span class="line">done</span><br><span class="line"></span><br><span class="line">james@james-Vostro-5471:~/datas$ bash testFor.sh a c v r </span><br><span class="line">打印所有参数：a</span><br><span class="line">打印所有参数：c</span><br><span class="line">打印所有参数：v</span><br><span class="line">打印所有参数：r</span><br></pre></td></tr></table></figure>

<p>使用$@</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">james@james-Vostro-5471:~/datas$ cat testFor.sh</span><br><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line"></span><br><span class="line">s=0</span><br><span class="line">for i in $@ </span><br><span class="line">do</span><br><span class="line">    echo &quot;打印所有参数：$i&quot; </span><br><span class="line">done</span><br><span class="line"></span><br><span class="line">james@james-Vostro-5471:~/datas$ bash testFor.sh</span><br><span class="line">james@james-Vostro-5471:~/datas$ bash testFor.sh adda sda</span><br><span class="line">打印所有参数：adda</span><br><span class="line">打印所有参数：sda</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">james@james-Vostro-5471:~/datas$ cat testFor.sh</span><br><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line"></span><br><span class="line">for i in &quot;$*&quot; </span><br><span class="line">do</span><br><span class="line">    echo &quot;打印所有参数：$i&quot; </span><br><span class="line">done</span><br><span class="line"></span><br><span class="line">for j in &quot;$@&quot;</span><br><span class="line">do</span><br><span class="line">    echo &quot;打印参数：$j&quot;</span><br><span class="line">done    </span><br><span class="line">james@james-Vostro-5471:~/datas$ bash testFor.sh a b c</span><br><span class="line">打印所有参数：a b c</span><br><span class="line">打印参数：a</span><br><span class="line">打印参数：b</span><br><span class="line">打印参数：c</span><br></pre></td></tr></table></figure>



<p>&ensp;&ensp;&ensp;&ensp;总结：由上图可以看出” ∗ “ 将 所 有 参 数 看 做 一 个 整 体 输 出 ， 只 循 环 一 次 ； 而 “ *”将所有参数看做一个整体输出，只循环一次；而” ∗”将所有参数看做一个整体输出，只循环一次；而”@”将输出参数分开输出，执行三次循环。</p>
<h4 id="4、while循环"><a href="#4、while循环" class="headerlink" title="4、while循环"></a>4、while循环</h4><p>语法： </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">while [ 条件判断式 ]</span><br><span class="line"> do</span><br><span class="line"> 程序</span><br><span class="line"> done</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>范例：从1加到100</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">james@james-Vostro-5471:~/datas$ cat testWhile.sh</span><br><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line"></span><br><span class="line">s=0</span><br><span class="line">i=1</span><br><span class="line">while [ $i -le 100 ]</span><br><span class="line">do</span><br><span class="line">    s=$[$s + $i]</span><br><span class="line">    i=$[$i + 1]</span><br><span class="line">done</span><br><span class="line"></span><br><span class="line">echo $s</span><br><span class="line">james@james-Vostro-5471:~/datas$ bash testWhile.sh</span><br><span class="line">5050</span><br></pre></td></tr></table></figure>

<h3 id="read读取控制台输入"><a href="#read读取控制台输入" class="headerlink" title="read读取控制台输入"></a>read读取控制台输入</h3><p>语法：read 选项 参数</p>
<p>选项：</p>
<ul>
<li>-p：指定读取值时的提示符</li>
<li>-t ：指定读取值时的时间（秒）</li>
</ul>
<p>参数：</p>
<ul>
<li>变量：指定读取值的变量名</li>
</ul>
<p>范例：提示7秒内，读取控制台输入的名称</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">james@james-Vostro-5471:~/datas$ cat testRead.sh</span><br><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line"></span><br><span class="line">read -t 7 -p &quot;input your name: &quot; NAME</span><br><span class="line">echo $NAME</span><br><span class="line">james@james-Vostro-5471:~/datas$ bash testRead.sh</span><br><span class="line">input your name: 123456</span><br><span class="line">123456</span><br></pre></td></tr></table></figure>

<h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><h4 id="系统函数"><a href="#系统函数" class="headerlink" title="系统函数"></a>系统函数</h4><p>1、basename基本语法</p>
<p>&ensp;&ensp;&ensp;&ensp;basename [string/pathname] suffix </p>
<p>&ensp;&ensp;&ensp;&ensp;功能描述：basename命令会删掉所有的前缀包括最后一个（‘/’）字符，然后将字符显示出来。</p>
<p>&ensp;&ensp;&ensp;&ensp;选项：suffix为后缀，如果suffix被指定了，basename会将pathname或string中的suffix去掉</p>
<p>范例：截取/home/zby/read.sh路径的文件名称</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">james@james-Vostro-5471:~/datas$ basename /home/james/datas/helloworld.sh</span><br><span class="line">helloworld.sh</span><br><span class="line">james@james-Vostro-5471:~/datas$ basename /home/james/datas/testIf.sh .sh</span><br><span class="line">testIf</span><br></pre></td></tr></table></figure>



<p>2、dirrame基本语法</p>
<p>&ensp;&ensp;&ensp;&ensp;dirname 文件绝对路径 </p>
<p>&ensp;&ensp;&ensp;&ensp;功能描述：从给定的包含绝对路径的文件名中去除文件名（非目录的部分），然后返回剩下的路径（目录的部分）</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">james@james-Vostro-5471:~/datas$ dirname /home/james/datas/testIf.sh</span><br><span class="line">/home/james/datas</span><br></pre></td></tr></table></figure>

<h4 id="自定义函数"><a href="#自定义函数" class="headerlink" title="自定义函数"></a>自定义函数</h4><p>1、基本语法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[function] funname [()]</span><br><span class="line">&#123;</span><br><span class="line"> Action;</span><br><span class="line"> [return int;]</span><br><span class="line">&#125;</span><br><span class="line">funname</span><br></pre></td></tr></table></figure>


<p>2、经验技巧</p>
<p>&ensp;&ensp;&ensp;&ensp;必须在调用函数的地方之前，先声明函数，shell脚本是逐行运行。不会像其他语言一样先编译。<br>&ensp;&ensp;&ensp;&ensp;函数返回值，只能通过<code>$?</code>系统变量获得，可以显示加：return返回，如果不加，将以最后一条命令运行结果，作为返回值。return后跟数值n（0-255）</p>
<p>范例：计算两个输入参数的和</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">james@james-Vostro-5471:~/datas$ cat fun.sh</span><br><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line"></span><br><span class="line">function sum()</span><br><span class="line">&#123;</span><br><span class="line">    s=0;</span><br><span class="line">    s=$[$1+$2]</span><br><span class="line">    echo $s</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">read -p &quot;input parameter1:&quot; p1</span><br><span class="line">read -p &quot;input parameter2:&quot; p2</span><br><span class="line"></span><br><span class="line">sum $p1 $p2</span><br><span class="line">james@james-Vostro-5471:~/datas$ bash fun.sh</span><br><span class="line">input parameter1:1</span><br><span class="line">input parameter2:2</span><br><span class="line">3</span><br></pre></td></tr></table></figure>

<h3 id="Shell工具"><a href="#Shell工具" class="headerlink" title="Shell工具"></a>Shell工具</h3><h4 id="cut"><a href="#cut" class="headerlink" title="cut"></a>cut</h4><p>&ensp;&ensp;&ensp;&ensp;cut的工作就是“剪”，具体地说就是在文件中负责剪切数据用的。cut命令从文件中的每一行剪切文字、字符和字段并将这些字节、字符和字段输出。</p>
<p>1、基本用法：</p>
<ul>
<li>cut [选项参数] filename</li>
<li>说明：默认分隔符是制表符</li>
</ul>
<p>2、参数说明：</p>
<ul>
<li>-f  列号，提取第几列</li>
<li>-d 分隔符，按照指定分隔符分割lie</li>
</ul>
<p>范例：数据准备</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">james@james-Vostro-5471:~/datas$ vim cut.txt</span><br><span class="line">james@james-Vostro-5471:~/datas$ cat cut.txt</span><br><span class="line">bei jing sheng yang</span><br><span class="line">shang hai xiang gang</span><br><span class="line">tian jin xia men</span><br><span class="line">wu han tai bei</span><br><span class="line">zheng zhou</span><br><span class="line">fu zhou</span><br></pre></td></tr></table></figure>

<p>&ensp;&ensp;&ensp;&ensp;切割<code>cut.txt</code>的第一列</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">james@james-Vostro-5471:~/datas$ cut -d &quot; &quot; -f 1 cut.txt</span><br><span class="line">bei</span><br><span class="line">shang</span><br><span class="line">tian</span><br><span class="line">wu</span><br><span class="line">zheng</span><br><span class="line">fu</span><br></pre></td></tr></table></figure>

<p>&ensp;&ensp;&ensp;&ensp;切割<code>cut.txt</code>的第2，3列</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">james@james-Vostro-5471:~/datas$ cut -d &quot; &quot; -f 2,3 cut.txt</span><br><span class="line">jing sheng</span><br><span class="line">hai xiang</span><br><span class="line">jin xia</span><br><span class="line">han tai</span><br><span class="line">zhou</span><br><span class="line">zhou</span><br></pre></td></tr></table></figure>

<p>&ensp;&ensp;&ensp;&ensp;切割<code>cut.txt</code>文件中的<code>shang</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">james@james-Vostro-5471:~/datas$ cat cut.txt | grep shang</span><br><span class="line">shang hai xiang gang</span><br><span class="line">james@james-Vostro-5471:~/datas$ cat cut.txt | grep shang | cut -d &quot; &quot; -f 1</span><br><span class="line">shang</span><br></pre></td></tr></table></figure>

<p>&ensp;&ensp;&ensp;&ensp;选取系统<code>PATH</code>变量值，第二个“：”开始后的所有路径：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">james@james-Vostro-5471:~/datas$ echo $PATH</span><br><span class="line">/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games:/usr/local/games:/snap/bin</span><br><span class="line">james@james-Vostro-5471:~/datas$ echo $PATH | cut -d : -f 3-</span><br><span class="line">/usr/sbin:/usr/bin:/sbin:/bin:/usr/games:/usr/local/games:/snap/bin</span><br></pre></td></tr></table></figure>

<p>&ensp;&ensp;&ensp;&ensp;切割<code>ifconfig</code>后打印<code>IP</code>地址</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">james@james-Vostro-5471:~$ ifconfig lo</span><br><span class="line">lo: flags=73&lt;UP,LOOPBACK,RUNNING&gt;  mtu 65536</span><br><span class="line">        inet 127.0.0.1  netmask 255.0.0.0</span><br><span class="line">        inet6 ::1  prefixlen 128  scopeid 0x10&lt;host&gt;</span><br><span class="line">        loop  txqueuelen 1000  (本地环回)</span><br><span class="line">        RX packets 44305  bytes 5010333 (5.0 MB)</span><br><span class="line">        RX errors 0  dropped 0  overruns 0  frame 0</span><br><span class="line">        TX packets 44305  bytes 5010333 (5.0 MB)</span><br><span class="line">        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0</span><br><span class="line"></span><br><span class="line">james@james-Vostro-5471:~$ ifconfig lo | grep &quot;inet &quot;</span><br><span class="line">        inet 127.0.0.1  netmask 255.0.0.0</span><br><span class="line">james@james-Vostro-5471:~$ ifconfig lo | grep &quot;inet &quot; | cut -d &quot; &quot; -f 10</span><br><span class="line">127.0.0.1</span><br></pre></td></tr></table></figure>

<h4 id="sed"><a href="#sed" class="headerlink" title="sed"></a>sed</h4><p>&ensp;&ensp;&ensp;&ensp;<code>sed</code>是一种流编辑器，它一次处理一行内容。处理时，把当前处理的行存储在临时缓冲区中，称为“模式空间”，接着用<code>sed</code>命令处理缓存区中的内容，处理完成后，把缓冲区的内容送往屏幕。接着处理下一行，这样不断重复，知道文件末尾。文件内容并没有改变，除非你使用重定向存储输出。</p>
<ul>
<li><p>基本用法：</p>
<p>  sed [选项参数] ‘command’ filename</p>
</li>
<li><p>参数说明</p>
<p>  -e 直接在命令模式上进行sed的动作编辑</p>
</li>
<li><p>命令功能描述</p>
<p>  a 新增，a的后面可以接字符串，在下一行出现</p>
<p>  d 删除</p>
<p>  s 查找并替换</p>
</li>
</ul>
<p>范例：数据准备</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">james@james-Vostro-5471:~$ vim sed.txt</span><br><span class="line">james@james-Vostro-5471:~$ cat sed.txt</span><br><span class="line">abcd aaaa</span><br><span class="line">zxcv aaas</span><br><span class="line">dasd qwdd</span><br><span class="line">ad ad</span><br><span class="line">dc da</span><br><span class="line">da ee</span><br></pre></td></tr></table></figure>

<p>&ensp;&ensp;&ensp;&ensp;将<code>aa cc</code>这个字符串插入到<code>sed.txt</code>第二行下打印</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">james@james-Vostro-5471:~$ sed &quot;2a aa cc&quot; sed.txt</span><br><span class="line">abcd aaaa</span><br><span class="line">zxcv aaas</span><br><span class="line">aa cc</span><br><span class="line">dasd qwdd</span><br><span class="line">ad ad</span><br><span class="line">dc da</span><br><span class="line">da ee</span><br><span class="line">james@james-Vostro-5471:~$ cat sed.txt</span><br><span class="line">abcd aaaa</span><br><span class="line">zxcv aaas</span><br><span class="line">dasd qwdd</span><br><span class="line">ad ad</span><br><span class="line">dc da</span><br><span class="line">da ee</span><br></pre></td></tr></table></figure>

<p>&ensp;&ensp;&ensp;&ensp;删除 <code>sed.txt</code> 中包含<code>d</code>的行</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">james@james-Vostro-5471:~$ sed &quot;/d/d&quot; sed.txt</span><br><span class="line">zxcv aaas</span><br></pre></td></tr></table></figure>

<p>&ensp;&ensp;&ensp;&ensp;将<code>sed.txt</code>文件中的<code>aa</code>替换为<code>pp</code>(<code>g</code>表示global，全部替换)</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">james@james-Vostro-5471:~$ sed &quot;s/aa/pp/g&quot; sed.txt</span><br><span class="line">abcd pppp</span><br><span class="line">zxcv ppas</span><br><span class="line">dasd qwdd</span><br><span class="line">ad ad</span><br><span class="line">dc da</span><br><span class="line">da ee</span><br></pre></td></tr></table></figure>

<p>&ensp;&ensp;&ensp;&ensp;将<code>sed.txt</code>文件中的第二行删除并将<code>aaa</code>替换为<code>qf</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">james@james-Vostro-5471:~$ sed -e &quot;2d&quot; -e &quot;s/aaa/qf/g&quot; sed.txt</span><br><span class="line">abcd qfa</span><br><span class="line">dasd qwdd</span><br><span class="line">ad ad</span><br><span class="line">dc da</span><br><span class="line">da ee</span><br></pre></td></tr></table></figure>

<h4 id="awk"><a href="#awk" class="headerlink" title="awk"></a>awk</h4><p>&ensp;&ensp;&ensp;&ensp;一个强大的文本分析工具，把文件逐行的读入，以空格为默认的分割符并将每行切片，切开的部分再进行分析处理。<br>1.基本用法</p>
<p>&ensp;&ensp;&ensp;&ensp;awk [选项参数] ‘pattern1 {action} pattern2 {action}…’ filename</p>
<p>&ensp;&ensp;&ensp;&ensp;pattern :  表示AWK在数据中查找的内容，就是匹配模式</p>
<p>&ensp;&ensp;&ensp;&ensp;action：在找到匹配内容时所执行的一系列命令。</p>
<p>参数说明</p>
<ul>
<li>-F   指定输入文件拆分隔离</li>
<li>-v   赋值一个用户定义变量</li>
</ul>
<p>范例：数据准备(/etc/passwd文件)</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">james@james-Vostro-5471:~/datas$ sudo cp /etc/passwd ./</span><br><span class="line">[sudo] james 的密码： </span><br><span class="line">james@james-Vostro-5471:~/datas$ ls</span><br><span class="line">batch.sh  demo.txt  helloworsudold.sh  passwd       testFor.sh  testRead.sh</span><br><span class="line">cut.txt   fun.sh    parameter.sh   testCase.sh  testIf.sh   testWhile.sh</span><br><span class="line">james@james-Vostro-5471:~/datas$ cat passwd</span><br><span class="line">root:x:0:0:root:/root:/bin/bash</span><br><span class="line">daemon:x:1:1:daemon:/usr/sbin:/usr/sbin/nologin</span><br><span class="line">bin:x:2:2:bin:/bin:/usr/sbin/nologin</span><br><span class="line">sys:x:3:3:sys:/dev:/usr/sbin/nologin</span><br><span class="line">sync:x:4:65534:sync:/bin:/bin/sync</span><br><span class="line">games:x:5:60:games:/usr/games:/usr/sbin/nologin</span><br><span class="line">man:x:6:12:man:/var/cache/man:/usr/sbin/nologin</span><br><span class="line">lp:x:7:7:lp:/var/spool/lpd:/usr/sbin/nologin</span><br><span class="line">mail:x:8:8:mail:/var/mail:/usr/sbin/nologin</span><br><span class="line">news:x:9:9:news:/var/spool/news:/usr/sbin/nologin</span><br><span class="line">uucp:x:10:10:uucp:/var/spool/uucp:/usr/sbin/nologin</span><br><span class="line">proxy:x:13:13:proxy:/bin:/usr/sbin/nologin</span><br><span class="line">www-data:x:33:33:www-data:/var/www:/usr/sbin/nologin</span><br><span class="line">backup:x:34:34:backup:/var/backups:/usr/sbin/nologin</span><br><span class="line">list:x:38:38:Mailing List Manager:/var/list:/usr/sbin/nologin</span><br><span class="line">irc:x:39:39:ircd:/var/run/ircd:/usr/sbin/nologin</span><br><span class="line">gnats:x:41:41:Gnats Bug-Reporting System (admin):/var/lib/gnats:/usr/sbin/nologin</span><br><span class="line">nobody:x:65534:65534:nobody:/nonexistent:/usr/sbin/nologin</span><br><span class="line">systemd-network:x:100:102:systemd Network Management,,,:/run/systemd/netif:/usr/sbin/nologin</span><br><span class="line">systemd-resolve:x:101:103:systemd Resolver,,,:/run/systemd/resolve:/usr/sbin/nologin</span><br><span class="line">syslog:x:102:106::/home/syslog:/usr/sbin/nologin</span><br><span class="line">messagebus:x:103:107::/nonexistent:/usr/sbin/nologin</span><br><span class="line">_apt:x:104:65534::/nonexistent:/usr/sbin/nologin</span><br><span class="line">uuidd:x:105:111::/run/uuidd:/usr/sbin/nologin</span><br><span class="line">avahi-autoipd:x:106:112:Avahi autoip daemon,,,:/var/lib/avahi-autoipd:/usr/sbin/nologin</span><br><span class="line">usbmux:x:107:46:usbmux daemon,,,:/var/lib/usbmux:/usr/sbin/nologin</span><br><span class="line">dnsmasq:x:108:65534:dnsmasq,,,:/var/lib/misc:/usr/sbin/nologin</span><br><span class="line">rtkit:x:109:114:RealtimeKit,,,:/proc:/usr/sbin/nologin</span><br><span class="line">cups-pk-helper:x:110:116:user for cups-pk-helper service,,,:/home/cups-pk-helper:/usr/sbin/nologin</span><br><span class="line">speech-dispatcher:x:111:29:Speech Dispatcher,,,:/var/run/speech-dispatcher:/bin/false</span><br><span class="line">whoopsie:x:112:117::/nonexistent:/bin/false</span><br><span class="line">kernoops:x:113:65534:Kernel Oops Tracking Daemon,,,:/:/usr/sbin/nologin</span><br><span class="line">saned:x:114:119::/var/lib/saned:/usr/sbin/nologin</span><br><span class="line">pulse:x:115:120:PulseAudio daemon,,,:/var/run/pulse:/usr/sbin/nologin</span><br><span class="line">avahi:x:116:122:Avahi mDNS daemon,,,:/var/run/avahi-daemon:/usr/sbin/nologin</span><br><span class="line">colord:x:117:123:colord colour management daemon,,,:/var/lib/colord:/usr/sbin/nologin</span><br><span class="line">hplip:x:118:7:HPLIP system user,,,:/var/run/hplip:/bin/false</span><br><span class="line">geoclue:x:119:124::/var/lib/geoclue:/usr/sbin/nologin</span><br><span class="line">gnome-initial-setup:x:120:65534::/run/gnome-initial-setup/:/bin/false</span><br><span class="line">gdm:x:121:125:Gnome Display Manager:/var/lib/gdm3:/bin/false</span><br><span class="line">james:x:1000:1000:James,,,:/home/james:/bin/bash</span><br></pre></td></tr></table></figure>

<p>&ensp;&ensp;&ensp;&ensp;搜索<code>passwd</code>文件以<code>root</code>关键字开头的所有行，并输出该行的第一列和第七列，中间以“，”号分割。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">james@james-Vostro-5471:~/datas$ awk -F : &#x27;/^root/ &#123;print $7&#125;&#x27; passwd</span><br><span class="line">/bin/bash</span><br><span class="line">james@james-Vostro-5471:~/datas$ awk -F : &#x27;/^root/ &#123;print $1&quot;,&quot;$7&#125;&#x27; passwd</span><br><span class="line">root,/bin/bash</span><br><span class="line">james@james-Vostro-5471:~/datas$ </span><br></pre></td></tr></table></figure>

<p>&ensp;&ensp;&ensp;&ensp;只显示<code>passwd</code>的第一列和第七列，以逗号分割，且在所有行前面添加列名<code>user</code>，<code>shell</code> 在最后一行添加<code>gqw, /bin/zuihsuai</code>。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">james@james-Vostro-5471:~/datas$ awk -F : &#x27;BEGIN&#123;print &quot;user,shell&quot;&#125;&#123;print $1&quot;,&quot;$7&#125; END&#123;print &quot;gqw,/bin/zuihuai&quot;&#125;&#x27; passwd</span><br><span class="line">user,shell</span><br><span class="line">root,/bin/bash</span><br><span class="line">daemon,/usr/sbin/nologin</span><br><span class="line">bin,/usr/sbin/nologin</span><br><span class="line">sys,/usr/sbin/nologin</span><br><span class="line">sync,/bin/sync</span><br><span class="line">games,/usr/sbin/nologin</span><br><span class="line">man,/usr/sbin/nologin</span><br><span class="line">lp,/usr/sbin/nologin</span><br><span class="line">mail,/usr/sbin/nologin</span><br><span class="line">news,/usr/sbin/nologin</span><br><span class="line">uucp,/usr/sbin/nologin</span><br><span class="line">…………………………………………………………………………………………</span><br></pre></td></tr></table></figure>

<p>注意：</p>
<ul>
<li><code>BEGIN</code>在所有数据读取行之前执行</li>
<li><code>END</code> 在所有数据执行之后执行</li>
</ul>
<p>&ensp;&ensp;&ensp;&ensp;将passwd文件中的用户id增加数值1并输出</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">james@james-Vostro-5471:~/datas$ awk -F : &#x27;&#123;print $3&#125;&#x27; passwd</span><br><span class="line">0</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">………………………………………………………………………………………………………………</span><br><span class="line">james@james-Vostro-5471:~/datas$ awk -F : -v i=1 &#x27;&#123;print $3+i&#125;&#x27; passwd</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">…………………………………………………………………………………………………………………………</span><br></pre></td></tr></table></figure>

<p>2.<code>awk</code>的内置变量 </p>
<table>
<thead>
<tr>
<th align="center">变量</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">FILENAME</td>
<td align="center">文件名</td>
</tr>
<tr>
<td align="center">NR</td>
<td align="center">已读的记录数</td>
</tr>
<tr>
<td align="center">NF</td>
<td align="center">浏览记录的域的个数（切割后，列的个数）</td>
</tr>
</tbody></table>
<p>范例：统计<code>passwd</code>文件名，每行的行号，每行的列数。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">james@james-Vostro-5471:~/datas$ awk -F : &#x27;&#123;print FILENAME&quot;,&quot;NR&quot;,&quot;NF&#125;&#x27; passwd</span><br><span class="line">passwd,1,7</span><br><span class="line">passwd,2,7</span><br><span class="line">passwd,3,7</span><br><span class="line">passwd,4,7</span><br><span class="line">passwd,5,7</span><br><span class="line">passwd,6,7</span><br><span class="line">passwd,7,7</span><br><span class="line">passwd,8,7</span><br><span class="line">………………………………………………………………</span><br></pre></td></tr></table></figure>

<p>&ensp;&ensp;&ensp;&ensp;切割<code>inet</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">james@james-Vostro-5471:~/datas$ ifconfig lo |grep &quot;inet &quot;</span><br><span class="line">        inet 127.0.0.1  netmask 255.0.0.0</span><br><span class="line">james@james-Vostro-5471:~/datas$ ifconfig lo |grep &quot;inet &quot; | awk -F &quot; &quot; &#x27;&#123;print $2&#125;&#x27;</span><br><span class="line">127.0.0.1</span><br></pre></td></tr></table></figure>

<p>&ensp;&ensp;&ensp;&ensp;查询<code>cut.txt</code>中空行所在的行号</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">james@james-Vostro-5471:~/datas$ cat cut.txt</span><br><span class="line"></span><br><span class="line">bei jing sheng yang</span><br><span class="line"></span><br><span class="line">shang hai xiang gang</span><br><span class="line">tian jin xia men</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">wu han tai bei</span><br><span class="line">zheng zhou</span><br><span class="line">fu zhou</span><br><span class="line">james@james-Vostro-5471:~/datas$ awk &#x27;/^$/&#123;print NR&#125;&#x27; cut.txt</span><br><span class="line">1</span><br><span class="line">3</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td></tr></table></figure>

<h4 id="sort"><a href="#sort" class="headerlink" title="sort"></a>sort</h4><p>&ensp;&ensp;&ensp;&ensp;sort命令是在Linux里非常有用，它将文件进行排序，并将排序的结果标准输出。</p>
<p>基本语法： sort 选项 参数</p>
<ul>
<li>-n 依照数值大小排序</li>
<li>-r 以相反的顺序来排序</li>
<li>-t 设置排序时所用的分隔字符</li>
<li>-k 指定需要排序的列</li>
</ul>
<p>&ensp;&ensp;&ensp;&ensp;参数： 指定待排序的文件列表</p>
<p>范例：</p>
<p>数据准备：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">james@james-Vostro-5471:~/datas$ vim sort.txt</span><br><span class="line">james@james-Vostro-5471:~/datas$ cat sort.txt</span><br><span class="line">aa:12:5.4</span><br><span class="line">ba:14:67</span><br><span class="line">kl:421:4</span><br><span class="line">er:00:5</span><br><span class="line">hj:213:00</span><br></pre></td></tr></table></figure>

<p>按照 “:” 分割后的第三列倒序排序</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">james@james-Vostro-5471:~/datas$ sort -t : -k 3 -n sort.txt</span><br><span class="line">hj:213:00</span><br><span class="line">kl:421:4</span><br><span class="line">er:00:5</span><br><span class="line">aa:12:5.4</span><br><span class="line">ba:14:67</span><br></pre></td></tr></table></figure>

<p>用第二列的数值进行倒序排序</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">james@james-Vostro-5471:~/datas$ sort -t : -nrk 2 sort.txt</span><br><span class="line">kl:421:4</span><br><span class="line">hj:213:00</span><br><span class="line">ba:14:67</span><br><span class="line">aa:12:5.4</span><br><span class="line">er:00:5</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>shell</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>shell</tag>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>二叉树中的序列化和反序列化</title>
    <url>/2021/05/05/%E4%BA%8C%E5%8F%89%E6%A0%91%EF%BC%9A%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%BA%8F%E5%88%97%E5%8C%96%E5%92%8C%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/</url>
    <content><![CDATA[<h3 id="一、题目"><a href="#一、题目" class="headerlink" title="一、题目"></a>一、题目</h3><p>&ensp;&ensp;&ensp;&ensp;序列化是将一个数据结构或者对象转换为连续的比特位的操作，进而可以将转换后的数据存储在一个文件或者内存中，同时也可以通过网络传输到另一个计算机环境，采取相反方式重构得到原数据。</p>
<span id="more"></span>

<p>&ensp;&ensp;&ensp;&ensp;请设计一个算法来实现二叉树的序列化与反序列化。这里不限定你的序列 / 反序列化算法执行逻辑，你只需要保证一个二叉树可以被序列化为一个字符串并且将这个字符串反序列化为原始的树结构。 </p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">     1</span><br><span class="line">   &#x2F;   \</span><br><span class="line">  2     3</span><br><span class="line">       &#x2F; \</span><br><span class="line">      4   5</span><br><span class="line">输入：root &#x3D; [1,2,3,null,null,4,5]</span><br><span class="line">输出：[1,2,3,null,null,4,5]</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：root &#x3D; []</span><br><span class="line">输出：[]</span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：root &#x3D; [1]</span><br><span class="line">输出：[1]</span><br></pre></td></tr></table></figure>

<p><strong>示例 4：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：root &#x3D; [1,2]</span><br><span class="line">输出：[1,2]</span><br></pre></td></tr></table></figure>

<p> <strong>提示：</strong></p>
<ul>
<li>树中结点数在范围 <code>[0, 104]</code> 内</li>
<li><code>-1000 &lt;= Node.val &lt;= 1000</code></li>
</ul>
<h3 id="二、思路与代码"><a href="#二、思路与代码" class="headerlink" title="二、思路与代码"></a>二、思路与代码</h3><p>&ensp;&ensp;&ensp;&ensp;说白了，这不就是先按照一定的规则遍历二叉树，再用与之对应的规则把相应的字符串构建成二叉树。</p>
<p>&ensp;&ensp;&ensp;&ensp;序列化与反序列化主要分为两个流派：dfs和bfs；由于二叉树的特殊性，dfs分为前序、中序、后序遍历，但<strong>只有前序和后序遍历才可以在线性复杂度下进行反序列化</strong>。</p>
<p>&ensp;&ensp;&ensp;&ensp;前序、后序、层序都能够很好的找到根节点，而且不同于一般构造二叉树的问题，为了区分子树，此处将空指针的地方指出，相当于比较完整的给出了树的结构。而且为了区分每个节点的值，不管是空节点还是普通节点，都必须以“,”或其他标记结尾。</p>
<p>&ensp;&ensp;&ensp;&ensp;反序列化时，在确定根节点后，紧接着确定某一子树，对当前子树采用递归，形成了相同的问题，类似于序列化过程中的递归问题。</p>
<p>&ensp;&ensp;&ensp;&ensp;反序列化中值得注意的是，前序是利用序列化结果，依次从前往后构造节点，类似于队列；后序依次从后往前，类似于栈；中序时，由于无法从序列化结果中找到根节点位置，也就无法准确划分左右子树，无法形成递归的结构，这种方式不能反序列化！</p>
<p>&ensp;&ensp;&ensp;&ensp;层序遍历思路类似，相对要麻烦一点，拿新结点一层一层的往后面接，这里可以考虑直接用vector加上索引（也可以用queue，但是vector访问简洁一点）。</p>
<h5 id="先序遍历序列化与反序列化"><a href="#先序遍历序列化与反序列化" class="headerlink" title="先序遍历序列化与反序列化"></a>先序遍历序列化与反序列化</h5><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Codec</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    string treeStr;</span><br><span class="line">    <span class="comment">// Encodes a tree to a single string.</span></span><br><span class="line">    <span class="function">string <span class="title">serialize</span><span class="params">(TreeNode* root)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">preorder</span>(root);</span><br><span class="line">        treeStr.<span class="built_in">pop_back</span>();</span><br><span class="line">        <span class="keyword">return</span> treeStr;</span><br><span class="line">    &#125;  </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">preorder</span><span class="params">(TreeNode* root)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!root)</span><br><span class="line">        &#123;</span><br><span class="line">            treeStr += <span class="string">&quot;#,&quot;</span>;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        treeStr += (<span class="built_in">to_string</span>(root-&gt;val) + <span class="string">&quot;,&quot;</span>);</span><br><span class="line">        <span class="built_in">preorder</span>(root-&gt;left);</span><br><span class="line">        <span class="built_in">preorder</span>(root-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">queue&lt;string&gt; <span class="title">split</span><span class="params">(string&amp; str)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        queue&lt;string&gt; treeNodeQue;</span><br><span class="line">        <span class="keyword">if</span> (str.<span class="built_in">empty</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> treeNodeQue;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> strLength = str.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> pre = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= strLength; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (i == strLength || str[i] == <span class="string">&#x27;,&#x27;</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                treeNodeQue.<span class="built_in">emplace</span>(str.<span class="built_in">substr</span>(pre, i - pre));</span><br><span class="line">                pre = i + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> treeNodeQue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">TreeNode* <span class="title">deserialize</span><span class="params">(queue&lt;string&gt;&amp; treeNodeQue)</span></span></span><br><span class="line"><span class="function">    </span>&#123;        </span><br><span class="line">        <span class="keyword">if</span> (treeNodeQue.<span class="built_in">empty</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        string first = treeNodeQue.<span class="built_in">front</span>();</span><br><span class="line">        treeNodeQue.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">if</span> (first == <span class="string">&quot;#&quot;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        TreeNode* root = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(<span class="built_in">stoi</span>(first));</span><br><span class="line">        root-&gt;left = <span class="built_in">deserialize</span>(treeNodeQue);</span><br><span class="line">        root-&gt;right = <span class="built_in">deserialize</span>(treeNodeQue);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Decodes your encoded data to tree.</span></span><br><span class="line">    <span class="function">TreeNode* <span class="title">deserialize</span><span class="params">(string data)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        queue&lt;string&gt; temp = <span class="built_in">split</span>(data);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">deserialize</span>(temp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="后序遍历序列化与反序列化"><a href="#后序遍历序列化与反序列化" class="headerlink" title="后序遍历序列化与反序列化"></a>后序遍历序列化与反序列化</h5><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Codec</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    string treeStr;</span><br><span class="line">    <span class="comment">// Encodes a tree to a single string.</span></span><br><span class="line">    <span class="function">string <span class="title">serialize</span><span class="params">(TreeNode* root)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">preorder</span>(root);</span><br><span class="line">        treeStr.<span class="built_in">pop_back</span>();</span><br><span class="line">        <span class="keyword">return</span> treeStr;</span><br><span class="line">    &#125;  </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">preorder</span><span class="params">(TreeNode* root)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!root)</span><br><span class="line">        &#123;</span><br><span class="line">            treeStr += <span class="string">&quot;#,&quot;</span>;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">preorder</span>(root-&gt;left);</span><br><span class="line">        <span class="built_in">preorder</span>(root-&gt;right);</span><br><span class="line">        treeStr += (<span class="built_in">to_string</span>(root-&gt;val) + <span class="string">&quot;,&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">stack&lt;string&gt; <span class="title">split</span><span class="params">(string&amp; str)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        stack&lt;string&gt; treeNodeStk;</span><br><span class="line">        <span class="keyword">if</span> (str.<span class="built_in">empty</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> treeNodeStk;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> strLength = str.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> pre = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= strLength; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (i == strLength || str[i] == <span class="string">&#x27;,&#x27;</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                treeNodeStk.<span class="built_in">emplace</span>(str.<span class="built_in">substr</span>(pre, i - pre));</span><br><span class="line">                pre = i + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> treeNodeStk;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">TreeNode* <span class="title">deserialize</span><span class="params">(stack&lt;string&gt;&amp; treeNodeStk)</span></span></span><br><span class="line"><span class="function">    </span>&#123;        </span><br><span class="line">        <span class="keyword">if</span> (treeNodeStk.<span class="built_in">empty</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        string first = treeNodeStk.<span class="built_in">top</span>();</span><br><span class="line">        treeNodeStk.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">if</span> (first == <span class="string">&quot;#&quot;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        TreeNode* root = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(<span class="built_in">stoi</span>(first));</span><br><span class="line">        root-&gt;right = <span class="built_in">deserialize</span>(treeNodeStk);</span><br><span class="line">        root-&gt;left = <span class="built_in">deserialize</span>(treeNodeStk);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Decodes your encoded data to tree.</span></span><br><span class="line">    <span class="function">TreeNode* <span class="title">deserialize</span><span class="params">(string data)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        stack&lt;string&gt; temp = <span class="built_in">split</span>(data);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">deserialize</span>(temp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h5 id="层序遍历序列化与反序列化"><a href="#层序遍历序列化与反序列化" class="headerlink" title="层序遍历序列化与反序列化"></a>层序遍历序列化与反序列化</h5><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Codec</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// Encodes a tree to a single string.</span></span><br><span class="line">    <span class="function">string <span class="title">serialize</span><span class="params">(TreeNode* root)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!root)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        &#125;    </span><br><span class="line">        string str;</span><br><span class="line">        queue&lt;TreeNode*&gt; q;</span><br><span class="line">        q.<span class="built_in">push</span>(root);</span><br><span class="line">        <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) </span><br><span class="line">        &#123;</span><br><span class="line">            TreeNode* node = q.<span class="built_in">front</span>();</span><br><span class="line">            q.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">if</span> (node)</span><br><span class="line">            &#123;</span><br><span class="line">                str += (<span class="built_in">to_string</span>(node-&gt;val) + <span class="string">&quot;,&quot;</span>);</span><br><span class="line">            &#125;                </span><br><span class="line">            <span class="keyword">else</span> </span><br><span class="line">            &#123;</span><br><span class="line">                str += <span class="string">&quot;#,&quot;</span>;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            q.<span class="built_in">push</span>(node-&gt;left);</span><br><span class="line">            q.<span class="built_in">push</span>(node-&gt;right);</span><br><span class="line">        &#125;</span><br><span class="line">        str.<span class="built_in">pop_back</span>();</span><br><span class="line">        <span class="keyword">return</span> str;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">split</span><span class="params">(string&amp; str)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        vector&lt;string&gt; ans;</span><br><span class="line">        <span class="keyword">if</span> (str.<span class="built_in">empty</span>()) <span class="keyword">return</span> ans;</span><br><span class="line">        <span class="keyword">int</span> size = str.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> pre = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= size; ++i) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (i == size || str[i] == <span class="string">&#x27;,&#x27;</span>) </span><br><span class="line">            &#123;</span><br><span class="line">                ans.<span class="built_in">emplace_back</span>(str.<span class="built_in">substr</span>(pre, i - pre));</span><br><span class="line">                pre = i + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">TreeNode* <span class="title">deserialize</span><span class="params">(vector&lt;string&gt;&amp; data)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (data.<span class="built_in">empty</span>())   </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        string node = data[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">        TreeNode* root = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(<span class="built_in">stoi</span>(node));</span><br><span class="line">        queue&lt;TreeNode*&gt; q;</span><br><span class="line">        q.<span class="built_in">push</span>(root);</span><br><span class="line">        <span class="keyword">int</span> i =<span class="number">1</span>; </span><br><span class="line">        <span class="keyword">while</span> (i &lt; data.<span class="built_in">size</span>()) </span><br><span class="line">        &#123;</span><br><span class="line">            TreeNode* node = q.<span class="built_in">front</span>();</span><br><span class="line">            q.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">if</span> (node == <span class="literal">nullptr</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;    </span><br><span class="line">            string s_left = data[i++];</span><br><span class="line">            <span class="keyword">if</span> (s_left == <span class="string">&quot;#&quot;</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                node-&gt;left = <span class="literal">nullptr</span>;</span><br><span class="line">            &#125;                </span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                node-&gt;left = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(<span class="built_in">stoi</span>(s_left));</span><br><span class="line">            &#125;                </span><br><span class="line">            q.<span class="built_in">push</span>(node-&gt;left);</span><br><span class="line">            string s_right = data[i++];</span><br><span class="line">            <span class="keyword">if</span> (s_right == <span class="string">&quot;#&quot;</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                node-&gt;right = <span class="literal">nullptr</span>;</span><br><span class="line">            &#125;                </span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                node-&gt;right = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(<span class="built_in">stoi</span>(s_right));</span><br><span class="line">            &#125;</span><br><span class="line">            q.<span class="built_in">push</span>(node-&gt;right);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Decodes your encoded data to tree.</span></span><br><span class="line">    <span class="function">TreeNode* <span class="title">deserialize</span><span class="params">(string data)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        vector&lt;string&gt; iters = <span class="built_in">split</span>(data);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">deserialize</span>(iters);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><a href="https://leetcode-cn.com/problems/serialize-and-deserialize-binary-tree/solution/ji-chong-bu-tong-bian-li-fang-shi-xia-de-0eap/">参考</a></p>
<p><a href="https://mp.weixin.qq.com/s?__biz=MzAxODQxMDM0Mw==&mid=2247485871&idx=1&sn=bcb24ea8927995b585629a8b9caeed01&chksm=9bd7f7a7aca07eb1b4c330382a4e0b916ef5a82ca48db28908ab16563e28a376b5ca6805bec2&scene=21#wechat_redirect">二叉树的序列化</a></p>
]]></content>
      <categories>
        <category>算法</category>
        <category>二叉树</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>二叉树</tag>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>二叉树中路径和相关习题</title>
    <url>/2021/05/05/%E4%BA%8C%E5%8F%89%E6%A0%91%EF%BC%9A%E8%B7%AF%E5%BE%84%E5%92%8C%E7%9B%B8%E5%85%B3/</url>
    <content><![CDATA[<p>&ensp;&ensp;&ensp;&ensp;本文有四道二叉树路径和相关的题目，前两道给出了详解。求路径和相关，说到底还是遍历问题，只不过有全局变量或者参数做记录。</p>
<span id="more"></span>

<h2 id="二叉树的最大路径和"><a href="#二叉树的最大路径和" class="headerlink" title="二叉树的最大路径和"></a><strong>二叉树的最大路径和</strong></h2><h3 id="一、题目"><a href="#一、题目" class="headerlink" title="一、题目"></a>一、题目</h3><p>&ensp;&ensp;&ensp;&ensp;<strong>路径</strong>被定义为一条从树中任意节点出发，沿父节点-子节点连接，达到任意节点的序列。同一个节点在一条路径序列中 <strong>至多出现一次</strong> 。该路径 <strong>至少包含一个</strong> 节点，且不一定经过根节点。</p>
<!-- more -->

<p>&ensp;&ensp;&ensp;&ensp;<strong>路径和</strong> 是路径中各节点值的总和。</p>
<p>&ensp;&ensp;&ensp;&ensp;给你一个二叉树的根节点 <code>root</code> ，返回其 <strong>最大路径和</strong> 。 </p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">   1</span><br><span class="line">  &#x2F; \</span><br><span class="line"> 2   3</span><br><span class="line">输入：root &#x3D; [1,2,3]</span><br><span class="line">输出：6</span><br><span class="line">解释：最优路径是 2 -&gt; 1 -&gt; 3 ，路径和为 2 + 1 + 3 &#x3D; 6</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">       -10</span><br><span class="line">      &#x2F;   \</span><br><span class="line">     9     20</span><br><span class="line">          &#x2F;  \</span><br><span class="line">         15   7</span><br><span class="line">输入：root &#x3D; [-10,9,20,null,null,15,7]</span><br><span class="line">输出：42</span><br><span class="line">解释：最优路径是 15 -&gt; 20 -&gt; 7 ，路径和为 15 + 20 + 7 &#x3D; 42</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li>树中节点数目范围是 <code>[1, 3 * 104]</code></li>
<li><code>-1000 &lt;= Node.val &lt;= 1000</code></li>
</ul>
<h3 id="二、思路与代码"><a href="#二、思路与代码" class="headerlink" title="二、思路与代码"></a>二、思路与代码</h3><p>&ensp;&ensp;&ensp;&ensp;对于一个结点，需要向上层节点提供“最大路径和“：即目标最大路径和上的每个节点，它的下层节点是最优的。有三种情况：只有当其那节点值（root-&gt;val）、当前节点值加最大左子树节点和（max(0, help(root-&gt;left))）、当前节点值加最大右子树节点和（max(0, help(root-&gt;right))）。</p>
<p>&ensp;&ensp;&ensp;&ensp;最大左子树节点和不能小于0，可以返回0，最大右子树节点和也是如此。</p>
<p>&ensp;&ensp;&ensp;&ensp;对父节点而言的三种选择，最大收益取最大值：root-&gt;val + max(help(root-&gt;left), help(root-&gt;right))。（获取左右后才判定最大收益，故采用后序遍历）</p>
<p>&ensp;&ensp;&ensp;&ensp;遍历每一个节点过程中，使用全局变量记录最大路径和。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> ans = INT_MIN;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxPathSum</span><span class="params">(TreeNode* root)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">help</span>(root);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">help</span><span class="params">(TreeNode* root)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">//节点为空，返回 0</span></span><br><span class="line">        <span class="keyword">if</span> (!root)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//获取当前节点的最大左子树路径和和最大右子树路径和</span></span><br><span class="line">        <span class="keyword">int</span> left = <span class="built_in">max</span>(<span class="number">0</span>, <span class="built_in">help</span>(root-&gt;left));</span><br><span class="line">        <span class="keyword">int</span> right = <span class="built_in">max</span>(<span class="number">0</span>, <span class="built_in">help</span>(root-&gt;right));</span><br><span class="line">        <span class="comment">//更新全局变量</span></span><br><span class="line">        ans = <span class="built_in">max</span>(ans, left + right + root-&gt;val);</span><br><span class="line">        <span class="comment">//返回当前节点的最优情况</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(left, right) + root-&gt;val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><a href="https://blog.csdn.net/m0_53157173/article/details/116399871">参考</a></p>
<h2 id="路径总和III"><a href="#路径总和III" class="headerlink" title="路径总和III"></a><strong>路径总和III</strong></h2><h3 id="一、题目-1"><a href="#一、题目-1" class="headerlink" title="一、题目"></a>一、题目</h3><p>&ensp;&ensp;&ensp;&ensp;给定一个二叉树，它的每个结点都存放着一个整数值。找出路径和等于给定数值的路径总数。路径不需要从根节点开始，也不需要在叶子节点结束，但是路径方向必须是向下的（只能从父节点到子节点）。</p>
<!-- more -->

<p>&ensp;&ensp;&ensp;&ensp;二叉树不超过1000个节点，且节点数值范围是 [-1000000,1000000] 的整数。</p>
<p><strong>示例：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">root &#x3D; [10,5,-3,3,2,null,11,3,-2,null,1], sum &#x3D; 8</span><br><span class="line"></span><br><span class="line">      10</span><br><span class="line">     &#x2F;  \</span><br><span class="line">    5   -3</span><br><span class="line">   &#x2F; \    \</span><br><span class="line">  3   2   11</span><br><span class="line"> &#x2F; \   \</span><br><span class="line">3  -2   1</span><br><span class="line"></span><br><span class="line">返回 3。和等于 8 的路径有:</span><br><span class="line"></span><br><span class="line">1.  5 -&gt; 3</span><br><span class="line">2.  5 -&gt; 2 -&gt; 1</span><br><span class="line">3.  -3 -&gt; 11</span><br></pre></td></tr></table></figure>

<h3 id="二、思路与代码-1"><a href="#二、思路与代码-1" class="headerlink" title="二、思路与代码"></a>二、思路与代码</h3><p>&ensp;&ensp;&ensp;&ensp;遍历每个节点，对各个节点，获取每个其不同路径和（再进行一次前序遍历），注意初始值为0。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">pathSum</span><span class="params">(TreeNode* root, <span class="keyword">int</span> targetSum)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!root)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">traver</span>(root, targetSum);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">traver</span><span class="params">(TreeNode* root, <span class="keyword">const</span> <span class="keyword">int</span> targetSum)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!root)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">traver</span>(root, targetSum, <span class="number">0</span>);</span><br><span class="line">        <span class="built_in">traver</span>(root-&gt;left, targetSum);</span><br><span class="line">        <span class="built_in">traver</span>(root-&gt;right, targetSum);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">traver</span><span class="params">(TreeNode* root, <span class="keyword">const</span> <span class="keyword">int</span> targetSum, <span class="keyword">int</span> cur)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!root)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (root-&gt;val + cur == targetSum)</span><br><span class="line">        &#123;</span><br><span class="line">            ans++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">traver</span>(root-&gt;left, targetSum, cur + root-&gt;val);</span><br><span class="line">        <span class="built_in">traver</span>(root-&gt;right, targetSum, cur + root-&gt;val);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h2 id="路径总和"><a href="#路径总和" class="headerlink" title="路径总和"></a>路径总和</h2><p>&ensp;&ensp;&ensp;&ensp;给你二叉树的根节点 <code>root</code> 和一个表示目标和的整数 <code>targetSum</code> ，判断该树中是否存在 <strong>根节点到叶子节点</strong> 的路径，这条路径上所有节点值相加等于目标和 <code>targetSum</code> 。</p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>叶子节点</strong> 是指没有子节点的节点。</p>
<p> <strong>示例 1：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">                  5</span><br><span class="line">                &#x2F;   \</span><br><span class="line">               4     8</span><br><span class="line">              &#x2F;     &#x2F; \</span><br><span class="line">            11     13  4</span><br><span class="line">           &#x2F;  \         \</span><br><span class="line">          7    2          1</span><br><span class="line">输入：root &#x3D; [5,4,8,11,null,13,4,7,2,null,null,null,1], targetSum &#x3D; 22</span><br><span class="line">输出：true</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">   1</span><br><span class="line">  &#x2F; \</span><br><span class="line"> 2   3</span><br><span class="line">输入：root &#x3D; [1,2,3], targetSum &#x3D; 5</span><br><span class="line">输出：false</span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：root &#x3D; [1,2], targetSum &#x3D; 0</span><br><span class="line">输出：false</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li>  树中节点的数目在范围 <code>[0, 5000]</code> 内</li>
<li>  <code>-1000 &lt;= Node.val &lt;= 1000</code></li>
<li>  <code>-1000 &lt;= targetSum &lt;= 1000</code></li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">hasPathSum</span><span class="params">(TreeNode* root, <span class="keyword">int</span> targetSum)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!root)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (root-&gt;val == targetSum &amp;&amp; !root-&gt;left &amp;&amp; !root-&gt;right)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">hasPathSum</span>(root-&gt;left, targetSum - root-&gt;val) || <span class="built_in">hasPathSum</span>(root-&gt;right, targetSum - root-&gt;val );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h2 id="路径总和-II"><a href="#路径总和-II" class="headerlink" title="路径总和 II"></a>路径总和 II</h2><p>&ensp;&ensp;&ensp;&ensp;给你二叉树的根节点 <code>root</code> 和一个整数目标和 <code>targetSum</code> ，找出所有 <strong>从根节点到叶子节点</strong> 路径总和等于给定目标和的路径。</p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>叶子节点</strong> 是指没有子节点的节点。</p>
<p> <strong>示例 1：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">                  5</span><br><span class="line">                &#x2F;   \</span><br><span class="line">               4     8</span><br><span class="line">              &#x2F;     &#x2F; \</span><br><span class="line">            11     13  4</span><br><span class="line">           &#x2F;  \         \</span><br><span class="line">          7    2          1</span><br><span class="line">输入：root &#x3D; [5,4,8,11,null,13,4,7,2,null,null,5,1], targetSum &#x3D; 22</span><br><span class="line">输出：[[5,4,11,2],[5,8,4,5]]</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">   1</span><br><span class="line">  &#x2F; \</span><br><span class="line"> 2   3</span><br><span class="line">输入：root &#x3D; [1,2,3], targetSum &#x3D; 5</span><br><span class="line">输出：[]</span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：root &#x3D; [1,2], targetSum &#x3D; 0</span><br><span class="line">输出：[]</span><br></pre></td></tr></table></figure>

<p> <strong>提示：</strong></p>
<ul>
<li>  树中节点总数在范围 <code>[0, 5000]</code> 内</li>
<li>  <code>-1000 &lt;= Node.val &lt;= 1000</code></li>
<li>  <code>-1000 &lt;= targetSum &lt;= 1000</code></li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; ans;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; temp;</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">pathSum</span>(TreeNode* root, <span class="keyword">int</span> targetSum) </span><br><span class="line">    &#123;        </span><br><span class="line">        <span class="built_in">help</span>(root, targetSum);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">help</span> <span class="params">(TreeNode* root, <span class="keyword">int</span> targetSum)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!root)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        temp.<span class="built_in">push_back</span>(root-&gt;val);</span><br><span class="line">        <span class="keyword">if</span> (root-&gt;val == targetSum &amp;&amp; !root-&gt;left &amp;&amp; !root-&gt;right)</span><br><span class="line">        &#123;</span><br><span class="line">            ans.<span class="built_in">push_back</span>(temp);</span><br><span class="line">        &#125;        </span><br><span class="line">        <span class="built_in">help</span>(root-&gt;left, targetSum - root-&gt;val);</span><br><span class="line">        <span class="built_in">help</span>(root-&gt;right, targetSum - root-&gt;val);</span><br><span class="line">        temp.<span class="built_in">pop_back</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法</category>
        <category>二叉树</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>二叉树</tag>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>makedown语法</title>
    <url>/2021/05/01/makedown%EF%BC%9Amakedown%E8%AF%AD%E6%B3%95/</url>
    <content><![CDATA[<p>    介绍一些<code>makedown语法</code>，在<code>Typora</code>可以完美显示，在其它makedown编辑器或网页上可能显示不成功。这篇文章并不是总结性质的，是搜集性质的（需要用到时搜的）。</p>
<span id="more"></span>

<h5 id="空格"><a href="#空格" class="headerlink" title="空格"></a>空格</h5><figure class="highlight tex"><table><tr><td class="code"><pre><span class="line"><span class="built_in">&amp;</span>ensp;<span class="built_in">&amp;</span>ensp;<span class="built_in">&amp;</span>ensp;<span class="built_in">&amp;</span>ensp;          空格</span><br></pre></td></tr></table></figure>

<h5 id="折叠文章"><a href="#折叠文章" class="headerlink" title="折叠文章"></a>折叠文章</h5><figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">&lt;!-- more --&gt;					折叠文章</span><br></pre></td></tr></table></figure>

<h5 id="上标与下标"><a href="#上标与下标" class="headerlink" title="上标与下标"></a>上标与下标</h5><p>x^2^                    x<del>0</del></p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">输入上标，如：x2，则输入 x<span class="built_in">^</span>2<span class="built_in">^</span></span><br><span class="line">输入下标，如：x0，则输入 x~0~</span><br></pre></td></tr></table></figure>

<h5 id="箭头"><a href="#箭头" class="headerlink" title="箭头"></a>箭头</h5><table>
<thead>
<tr>
<th align="center">$\longleftrightarrow$</th>
<th align="center">$\longleftrightarrow$</th>
</tr>
</thead>
<tbody><tr>
<td align="center">$\Longrightarrow$</td>
<td align="center">$\Longrightarrow$</td>
</tr>
<tr>
<td align="center">$\Longleftrightarrow$</td>
<td align="center">$\Longleftrightarrow$</td>
</tr>
<tr>
<td align="center">$\Longleftarrow$</td>
<td align="center">$\Longleftarrow$</td>
</tr>
<tr>
<td align="center">$\Updownarrow$</td>
<td align="center">$\Updownarrow$</td>
</tr>
<tr>
<td align="center">$\circlearrowleft$</td>
<td align="center">$\circlearrowleft$</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>makedown</category>
      </categories>
      <tags>
        <tag>makedown</tag>
      </tags>
  </entry>
  <entry>
    <title>设计链表</title>
    <url>/2021/04/30/%E9%93%BE%E8%A1%A8%EF%BC%9A%E8%AE%BE%E8%AE%A1%E9%93%BE%E8%A1%A8%EF%BC%88%E5%8D%95%E9%93%BE%E8%A1%A8%EF%BC%89/</url>
    <content><![CDATA[<h3 id="一、题目描述"><a href="#一、题目描述" class="headerlink" title="一、题目描述"></a>一、题目描述</h3><p>&ensp;&ensp;&ensp;&ensp;设计链表的实现。您可以选择使用单链表或双链表。单链表中的节点应该具有两个属性：val 和 next。val 是当前节点的值，next 是指向下一个节点的指针/引用。如果要使用双向链表，则还需要一个属性 prev 以指示链表中的上一个节点。假设链表中的所有节点都是 0-index 的。</p>
<span id="more"></span>

<p>&ensp;&ensp;&ensp;&ensp;在链表类中实现这些功能：</p>
<p>&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;get(index)：获取链表中第 index 个节点的值。如果索引无效，则返回-1。<br>&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;addAtHead(val)：在链表的第一个元素之前添加一个值为 val 的节点。插入后，新节点将成为链表的第一个节点。<br>&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;addAtTail(val)：将值为 val 的节点追加到链表的最后一个元素。<br>&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;addAtIndex(index,val)：在链表中的第 index 个节点之前添加值为 val  的节点。如果 index 等于链表的长度，则该节点将附加到链表的末尾。如果 index 大于链表长度，则不会插入节点。如果index小于0，则在头部插入节点。<br>&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;deleteAtIndex(index)：如果索引 index 有效，则删除链表中的第 index 个节点。</p>
<p>&ensp;&ensp;&ensp;&ensp;示例：</p>
<pre><code>MyLinkedList linkedList = new MyLinkedList();
linkedList.addAtHead(1);
linkedList.addAtTail(3);
linkedList.addAtIndex(1,2);   //链表变为1-&gt; 2-&gt; 3
linkedList.get(1);            //返回2
linkedList.deleteAtIndex(1);  //现在链表是1-&gt; 3
linkedList.get(1);            //返回3
</code></pre>
<p>&ensp;&ensp;&ensp;&ensp;提示：</p>
<p>&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;所有val值都在 [1, 1000] 之内。<br>&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;操作次数将在  [1, 1000] 之内。<br>&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;请不要使用内置的 LinkedList 库。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyLinkedList</span> &#123;</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/** Initialize your data structure here. */</span></span><br><span class="line">    <span class="built_in">MyLinkedList</span>() &#123;</span><br><span class="line">       </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Get the value of the index-th node in the linked list. If the index is invalid, return -1. */</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Add a node of value val before the first element of the linked list. After the insertion, the new node will be the first node of the linked list. */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addAtHead</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">       </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Append a node of value val to the last element of the linked list. */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addAtTail</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Add a node of value val before the index-th node in the linked list. If index equals to the length of linked list, the node will be appended to the end of linked list. If index is greater than the length, the node will not be inserted. */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addAtIndex</span><span class="params">(<span class="keyword">int</span> index, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Delete the index-th node in the linked list, if the index is valid. */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">deleteAtIndex</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your MyLinkedList object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * MyLinkedList* obj = new MyLinkedList();</span></span><br><span class="line"><span class="comment"> * int param_1 = obj-&gt;get(index);</span></span><br><span class="line"><span class="comment"> * obj-&gt;addAtHead(val);</span></span><br><span class="line"><span class="comment"> * obj-&gt;addAtTail(val);</span></span><br><span class="line"><span class="comment"> * obj-&gt;addAtIndex(index,val);</span></span><br><span class="line"><span class="comment"> * obj-&gt;deleteAtIndex(index);</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>
<h3 id="二、解题思路"><a href="#二、解题思路" class="headerlink" title="二、解题思路"></a>二、解题思路</h3><p>&ensp;&ensp;&ensp;&ensp;首先定义链表节点（Node）的结构，它有一个值val，和指向下个节点的指针<em>next；故有Node(int x):val(x),next(NULL){}：定义一个节点，它的值为x，下个节点为空。<br>&ensp;&ensp;&ensp;&ensp;链表的属性、成员有链表的长度（size），指向链表头结点的指针（</em>dummy），其作用域标记为private。<br>&ensp;&ensp;&ensp;&ensp; MyLinkedList() ，初始化一个链表，长度为0，只有个dummy。<br>&ensp;&ensp;&ensp;&ensp;get(index)：先判断index是否有效：index&gt;(size-1)||index&lt;0则无效，然后生成一个指针，移到目标节点即可。<br>&ensp;&ensp;&ensp;&ensp;addAtHead(val)：初始化一个节点head，将head指向头节点，dummy指向head。<br>&ensp;&ensp;&ensp;&ensp;addAtTail(val)：遍历到尾节点，加上去即可<br>&ensp;&ensp;&ensp;&ensp;addAtIndex(index,val)：先判断index是否有效：size&lt;index则返回空值；然后将指针移到第 index 个节点之前的那个节点，插入即可（使之成为第index个节点）<br>&ensp;&ensp;&ensp;&ensp;deleteAtIndex(index)：先判断index是否有效：index&gt;=size||index&lt;0则返回空值；然后将指针移到第 index 个节点之前的那个节点，删除后面那个节点，再连接后面节点的后面节点即可。（老套娃了🐶🐶🐶）</p>
<h5 id="全场最佳：将指针移到第-index-个节点之前的那个节点"><a href="#全场最佳：将指针移到第-index-个节点之前的那个节点" class="headerlink" title="全场最佳：将指针移到第 index 个节点之前的那个节点"></a>全场最佳：将指针移到第 index 个节点之前的那个节点</h5><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//index从0开始，第一个结点的index为0，题目是这么要求的🐶</span></span><br><span class="line">	Node *head=dummy;</span><br><span class="line">      <span class="keyword">while</span>(index--)&#123;</span><br><span class="line">          head=head-&gt;next;</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure>

<h3 id="三、我的代码"><a href="#三、我的代码" class="headerlink" title="三、我的代码"></a>三、我的代码</h3><p>&ensp;&ensp;&ensp;&ensp;直接在力扣上写的。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyLinkedList</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">        <span class="keyword">int</span> val;</span><br><span class="line">        Node *next;</span><br><span class="line">        <span class="built_in">Node</span>(<span class="keyword">int</span> x):<span class="built_in">val</span>(x),<span class="built_in">next</span>(<span class="literal">NULL</span>)&#123;&#125;</span><br><span class="line">    &#125;;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> size;</span><br><span class="line">    Node *dummy;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/** Initialize your data structure here. */</span></span><br><span class="line">    <span class="built_in">MyLinkedList</span>() &#123;</span><br><span class="line">        dummy=<span class="keyword">new</span> <span class="built_in">Node</span>(<span class="number">0</span>);</span><br><span class="line">        size=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Get the value of the index-th node in the linked list. If the index is invalid, return -1. */</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(index&gt;(size<span class="number">-1</span>)||index&lt;<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        Node *head=dummy-&gt;next;</span><br><span class="line">        <span class="keyword">while</span>(index--)&#123;</span><br><span class="line">            head=head-&gt;next;            </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> head-&gt;val;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Add a node of value val before the first element of the linked list. After the insertion, the new node will be the first node of the linked list. */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addAtHead</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        Node *head=<span class="keyword">new</span> <span class="built_in">Node</span>(val);</span><br><span class="line">        head-&gt;next=dummy-&gt;next;</span><br><span class="line">        dummy-&gt;next=head;</span><br><span class="line">        size++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Append a node of value val to the last element of the linked list. */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addAtTail</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        Node *tailNode=dummy;</span><br><span class="line">        Node *newTailNode=<span class="keyword">new</span> <span class="built_in">Node</span>(val);</span><br><span class="line">        <span class="keyword">while</span>(tailNode-&gt;next!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">            tailNode=tailNode-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        tailNode-&gt;next=newTailNode;</span><br><span class="line">        size++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Add a node of value val before the index-th node in the linked list. If index equals to the length of linked list, the node will be appended to the end of linked list. If index is greater than the length, the node will not be inserted. */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addAtIndex</span><span class="params">(<span class="keyword">int</span> index, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(size&lt;index)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        Node *head=dummy;</span><br><span class="line">        Node *t=<span class="keyword">new</span> <span class="built_in">Node</span>(val);</span><br><span class="line">        <span class="keyword">while</span>(index--)&#123;</span><br><span class="line">            head=head-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        t-&gt;next=head-&gt;next;</span><br><span class="line">        head-&gt;next=t;</span><br><span class="line">        size++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Delete the index-th node in the linked list, if the index is valid. */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">deleteAtIndex</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(index&gt;=size||index&lt;<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        Node *head=dummy;</span><br><span class="line">        <span class="keyword">while</span>(index--)&#123;</span><br><span class="line">            head=head-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        Node *t=head-&gt;next;</span><br><span class="line">        head-&gt;next=head-&gt;next-&gt;next;</span><br><span class="line">        <span class="keyword">delete</span> t;</span><br><span class="line">        size--;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your MyLinkedList object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * MyLinkedList* obj = new MyLinkedList();</span></span><br><span class="line"><span class="comment"> * int param_1 = obj-&gt;get(index);</span></span><br><span class="line"><span class="comment"> * obj-&gt;addAtHead(val);</span></span><br><span class="line"><span class="comment"> * obj-&gt;addAtTail(val);</span></span><br><span class="line"><span class="comment"> * obj-&gt;addAtIndex(index,val);</span></span><br><span class="line"><span class="comment"> * obj-&gt;deleteAtIndex(index);</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法</category>
        <category>链表</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>leetcode</tag>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title>扁平化多级双向链表</title>
    <url>/2021/04/30/%E9%93%BE%E8%A1%A8%EF%BC%9A%E6%89%81%E5%B9%B3%E5%8C%96%E5%A4%9A%E7%BA%A7%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<h3 id="一、题目描述"><a href="#一、题目描述" class="headerlink" title="一、题目描述"></a>一、题目描述</h3><p>    多级双向链表中，除了指向下一个节点和前一个节点指针之外，它还有一个子链表指针，可能指向单独的双向链表。这些子列表也可能会有一个或多个自己的子项，依此类推，生成多级数据结构，如下面的示例所示。</p>
<span id="more"></span>

<p>    给你位于列表第一级的头节点，请你扁平化列表，使所有结点出现在单级双链表中。 </p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：head &#x3D; [1,2,3,4,5,6,null,null,null,7,8,9,10,null,null,11,12]</span><br><span class="line">输出：[1,2,3,7,8,11,12,9,10,4,5,6]</span><br></pre></td></tr></table></figure>

<p>解释：</p>
<p>    输入的多级列表如下图所示：</p>
<p><img src="/2021/04/30/%E9%93%BE%E8%A1%A8%EF%BC%9A%E6%89%81%E5%B9%B3%E5%8C%96%E5%A4%9A%E7%BA%A7%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8/1.png" alt="image-20201213163356430"></p>
<p>    扁平化后的链表如下图：</p>
<p><img src="/2021/04/30/%E9%93%BE%E8%A1%A8%EF%BC%9A%E6%89%81%E5%B9%B3%E5%8C%96%E5%A4%9A%E7%BA%A7%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8/2.png" alt="image-20201213163430536"></p>
<p><strong>示例 2：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：head &#x3D; [1,2,null,3]</span><br><span class="line">输出：[1,3,2]</span><br><span class="line">解释：</span><br><span class="line"></span><br><span class="line">输入的多级列表如下图所示：</span><br><span class="line"></span><br><span class="line">  1---2---NULL</span><br><span class="line">  |</span><br><span class="line">  3---NULL</span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：head &#x3D; []</span><br><span class="line">输出：[]</span><br></pre></td></tr></table></figure>

<p>    <strong>如何表示测试用例中的多级链表？</strong></p>
<p>    以 <strong>示例 1</strong> 为例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1---2---3---4---5---6--NULL</span><br><span class="line">        |</span><br><span class="line">        7---8---9---10--NULL</span><br><span class="line">            |</span><br><span class="line">            11--12--NULL</span><br></pre></td></tr></table></figure>

<p>    序列化其中的每一级之后：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[1,2,3,4,5,6,null]</span><br><span class="line">[7,8,9,10,null]</span><br><span class="line">[11,12,null]</span><br></pre></td></tr></table></figure>

<p>    为了将每一级都序列化到一起，我们需要每一级中添加值为 null 的元素，以表示没有节点连接到上一级的上级节点。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[1,2,3,4,5,6,null]</span><br><span class="line">[null,null,7,8,9,10,null]</span><br><span class="line">[null,11,12,null]</span><br></pre></td></tr></table></figure>

<p>    合并所有序列化结果，并去除末尾的 null 。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[1,2,3,4,5,6,null,null,null,7,8,9,10,null,null,11,12]</span><br></pre></td></tr></table></figure>

<p> <strong>提示：</strong></p>
<ul>
<li>节点数目不超过 1000</li>
<li>1 &lt;= Node.val &lt;= 10^5</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">// Definition for a Node.</span></span><br><span class="line"><span class="comment">class Node &#123;</span></span><br><span class="line"><span class="comment">public:</span></span><br><span class="line"><span class="comment">    int val;</span></span><br><span class="line"><span class="comment">    Node* prev;</span></span><br><span class="line"><span class="comment">    Node* next;</span></span><br><span class="line"><span class="comment">    Node* child;</span></span><br><span class="line"><span class="comment">&#125;;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Node* <span class="title">flatten</span><span class="params">(Node* head)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//to do</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="二、解题思路"><a href="#二、解题思路" class="headerlink" title="二、解题思路"></a>二、解题思路</h3><ol>
<li><p>对于每个节点，先用双指针：p，pNext=p-&gt;next，当p-&gt;child为空时，p指针向后移动。</p>
</li>
<li><p>当p-&gt;child不为空</p>
<p>2.1将p与p-&gt;child连接为双向链表结构，并将p-&gt;child置为空；</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Node* pChild=p-&gt;child;</span><br><span class="line">p-&gt;next=pChild;</span><br><span class="line">pChild-&gt;prev=p;</span><br><span class="line">p-&gt;child=<span class="literal">nullptr</span>;</span><br></pre></td></tr></table></figure>

<p>2.2找到p-&gt;child那条子链的尾节点，并与pNext连为双向链表结构</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Node* tail=pChild;</span><br><span class="line"><span class="keyword">while</span>(tail-&gt;next!=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">	tail=tail-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line">tail-&gt;next=pNext;</span><br><span class="line"><span class="keyword">if</span>(pNext!=<span class="literal">nullptr</span>)</span><br><span class="line">	pNext-&gt;prev=tail;  </span><br></pre></td></tr></table></figure></li>
</ol>
<p><img src="/2021/04/30/%E9%93%BE%E8%A1%A8%EF%BC%9A%E6%89%81%E5%B9%B3%E5%8C%96%E5%A4%9A%E7%BA%A7%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8/3.png" alt="image-20201213205439630"></p>
<p><img src="/2021/04/30/%E9%93%BE%E8%A1%A8%EF%BC%9A%E6%89%81%E5%B9%B3%E5%8C%96%E5%A4%9A%E7%BA%A7%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8/4.png" alt="image-20201213205445673"></p>
<p><img src="/2021/04/30/%E9%93%BE%E8%A1%A8%EF%BC%9A%E6%89%81%E5%B9%B3%E5%8C%96%E5%A4%9A%E7%BA%A7%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8/5.png" alt="image-20201213205450099"></p>
<p>    以上三图是消除一条子链的情况。</p>
<h3 id="三、我的代码"><a href="#三、我的代码" class="headerlink" title="三、我的代码"></a>三、我的代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">// Definition for a Node.</span></span><br><span class="line"><span class="comment">class Node &#123;</span></span><br><span class="line"><span class="comment">public:</span></span><br><span class="line"><span class="comment">    int val;</span></span><br><span class="line"><span class="comment">    Node* prev;</span></span><br><span class="line"><span class="comment">    Node* next;</span></span><br><span class="line"><span class="comment">    Node* child;</span></span><br><span class="line"><span class="comment">&#125;;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Node* <span class="title">flatten</span><span class="params">(Node* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head==<span class="literal">nullptr</span>)</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        Node* p=head;</span><br><span class="line">        <span class="keyword">while</span>(p!=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">            Node* pNext=p-&gt;next;</span><br><span class="line">            <span class="keyword">if</span>(p-&gt;child!=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">                Node* pChild=p-&gt;child;</span><br><span class="line">                p-&gt;next=pChild;</span><br><span class="line">                pChild-&gt;prev=p;</span><br><span class="line">                p-&gt;child=<span class="literal">nullptr</span>;</span><br><span class="line">                Node* tail=pChild;</span><br><span class="line">                <span class="keyword">while</span>(tail-&gt;next!=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">                    tail=tail-&gt;next;</span><br><span class="line">                &#125;</span><br><span class="line">                tail-&gt;next=pNext;</span><br><span class="line">                <span class="keyword">if</span>(pNext!=<span class="literal">nullptr</span>)</span><br><span class="line">                    pNext-&gt;prev=tail;                </span><br><span class="line">            &#125;</span><br><span class="line">            p=p-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法</category>
        <category>链表</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>leetcode</tag>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title>奇偶链表</title>
    <url>/2021/04/30/%E9%93%BE%E8%A1%A8%EF%BC%9A%E5%A5%87%E5%81%B6%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<h1 id="LeetCode328：奇偶链表"><a href="#LeetCode328：奇偶链表" class="headerlink" title="LeetCode328：奇偶链表"></a>LeetCode328：奇偶链表</h1><h3 id="一、题目描述"><a href="#一、题目描述" class="headerlink" title="一、题目描述"></a>一、题目描述</h3><p>&ensp;&ensp;&ensp;&ensp;给定一个单链表，把所有的奇数节点和偶数节点分别排在一起。请注意，这里的奇数节点和偶数节点指的是节点编号的奇偶性，而不是节点的值的奇偶性。</p>
<span id="more"></span>

<p>&ensp;&ensp;&ensp;&ensp;请尝试使用原地算法完成。你的算法的空间复杂度应为 O(1)，时间复杂度应为 O(nodes)，nodes 为节点总数。<br>示例 1:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL</span><br><span class="line">输出: 1-&gt;3-&gt;5-&gt;2-&gt;4-&gt;NULL</span><br></pre></td></tr></table></figure>
<p>示例 2:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: 2-&gt;1-&gt;3-&gt;5-&gt;6-&gt;4-&gt;7-&gt;NULL </span><br><span class="line">输出: 2-&gt;3-&gt;6-&gt;7-&gt;1-&gt;5-&gt;4-&gt;NULL</span><br></pre></td></tr></table></figure>
<p>说明:<br>&ensp;&ensp;&ensp;&ensp;应当保持奇数节点和偶数节点的相对顺序。<br>&ensp;&ensp;&ensp;&ensp;链表的第一个节点视为奇数节点，第二个节点视为偶数节点，以此类推。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">oddEvenList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="二、解题思路"><a href="#二、解题思路" class="headerlink" title="二、解题思路"></a>二、解题思路</h3><p>&ensp;&ensp;&ensp;&ensp;看图</p>
<img src="/2021/04/30/%E9%93%BE%E8%A1%A8%EF%BC%9A%E5%A5%87%E5%81%B6%E9%93%BE%E8%A1%A8/1.png" alt="image-20210430234220085" style="zoom:80%;">

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(p-&gt;next!=<span class="literal">nullptr</span>&amp;&amp;q-&gt;next!=<span class="literal">nullptr</span>)&#123;        </span><br><span class="line">               p-&gt;next=q-&gt;next;</span><br><span class="line">               p=p-&gt;next;</span><br><span class="line">               q-&gt;next=p-&gt;next;</span><br><span class="line">               q=q-&gt;next;</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure>

<h3 id="三、我的代码"><a href="#三、我的代码" class="headerlink" title="三、我的代码"></a>三、我的代码</h3><p>&ensp;&ensp;&ensp;&ensp;直接在力扣上写的。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">oddEvenList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head==<span class="literal">nullptr</span>)</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        ListNode* p=head;</span><br><span class="line">        ListNode* head1=head-&gt;next;</span><br><span class="line">        ListNode* q=head-&gt;next;</span><br><span class="line">        <span class="keyword">while</span>(p-&gt;next!=<span class="literal">nullptr</span>&amp;&amp;q-&gt;next!=<span class="literal">nullptr</span>)&#123;        </span><br><span class="line">                p-&gt;next=q-&gt;next;</span><br><span class="line">                p=p-&gt;next;</span><br><span class="line">                q-&gt;next=p-&gt;next;</span><br><span class="line">                q=q-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        p-&gt;next=head1;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法</category>
        <category>链表</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>leetcode</tag>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title>反转链表</title>
    <url>/2021/04/30/%E9%93%BE%E8%A1%A8%EF%BC%9A%E5%9B%9E%E6%96%87%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<h3 id="一、题目描述"><a href="#一、题目描述" class="headerlink" title="一、题目描述"></a>一、题目描述</h3><p>&ensp;&ensp;&ensp;&ensp;请判断一个链表是否为回文链表。</p>
<span id="more"></span>

<p>示例 1:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: 1-&gt;2</span><br><span class="line">输出: false</span><br></pre></td></tr></table></figure>
<p>示例 2:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: 1-&gt;2-&gt;2-&gt;1</span><br><span class="line">输出: true</span><br></pre></td></tr></table></figure>
<p>进阶：<br>&ensp;&ensp;&ensp;&ensp;你能否用 O(n) 时间复杂度和 O(1) 空间复杂度解决此题？</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isPalindrome</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="二、解题思路"><a href="#二、解题思路" class="headerlink" title="二、解题思路"></a>二、解题思路</h3><p>&ensp;&ensp;&ensp;&ensp;先判断链表长度</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> length=<span class="number">0</span>;</span><br><span class="line">   ListNode* p=head;</span><br><span class="line">    <span class="keyword">while</span>(p!=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">        length++;</span><br><span class="line">        p=p-&gt;next;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>&ensp;&ensp;&ensp;&ensp;创建一个与链表等长的数组，再把每个节点对应的值放入数组中</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a[length];</span><br><span class="line">   <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;length;i++)&#123;</span><br><span class="line">       a[i]=p-&gt;val;</span><br><span class="line">       p=p-&gt;next;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>&ensp;&ensp;&ensp;&ensp;比较数组中对应的值</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;length/<span class="number">2</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(a[i]!=a[length-i<span class="number">-1</span>])</span><br><span class="line">             <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure>
<h3 id="三、我的代码"><a href="#三、我的代码" class="headerlink" title="三、我的代码"></a>三、我的代码</h3><p>&ensp;&ensp;&ensp;&ensp;直接在力扣上写的。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isPalindrome</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> length=<span class="number">0</span>;</span><br><span class="line">        ListNode* p=head;</span><br><span class="line">        <span class="keyword">while</span>(p!=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">            length++;</span><br><span class="line">            p=p-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(length==<span class="number">0</span>||length==<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        p=head;</span><br><span class="line">        <span class="keyword">int</span> a[length];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;length;i++)&#123;</span><br><span class="line">            a[i]=p-&gt;val;</span><br><span class="line">            p=p-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;length/<span class="number">2</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(a[i]!=a[length-i<span class="number">-1</span>])</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法</category>
        <category>链表</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>leetcode</tag>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title>移除链表元素</title>
    <url>/2021/04/30/%E9%93%BE%E8%A1%A8%EF%BC%9A%E7%A7%BB%E9%99%A4%E9%93%BE%E8%A1%A8%E5%85%83%E7%B4%A0/</url>
    <content><![CDATA[<h3 id="一、题目描述"><a href="#一、题目描述" class="headerlink" title="一、题目描述"></a>一、题目描述</h3><p>&ensp;&ensp;&ensp;&ensp;删除链表中等于给定值 val 的所有节点。</p>
<span id="more"></span>

<p>示例:</p>
<pre><code>输入: 1-&gt;2-&gt;6-&gt;3-&gt;4-&gt;5-&gt;6, val = 6
输出: 1-&gt;2-&gt;3-&gt;4-&gt;5
</code></pre>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">removeElements</span><span class="params">(ListNode* head, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">		<span class="comment">//to do</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="二、解题思路"><a href="#二、解题思路" class="headerlink" title="二、解题思路"></a>二、解题思路</h3><p>&ensp;&ensp;&ensp;&ensp;当链表为空，返回nullptr;<br>&ensp;&ensp;&ensp;&ensp;确保头节点不是要删除的节点</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(head-&gt;val==val)&#123;</span><br><span class="line">         head=head-&gt;next;</span><br><span class="line">         <span class="keyword">if</span>(head==<span class="literal">nullptr</span>)</span><br><span class="line">             <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure>
<p>&ensp;&ensp;&ensp;&ensp;使用双指针p，q，两指针紧挨着，遇到目标节点则删除</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">ListNode* p=head;</span><br><span class="line">   ListNode* q=p-&gt;next;</span><br><span class="line">   <span class="keyword">while</span>(q!=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">       <span class="keyword">if</span>(q-&gt;val==val)&#123;</span><br><span class="line">           q=q-&gt;next;</span><br><span class="line">           p-&gt;next=q;</span><br><span class="line">           <span class="keyword">continue</span>;</span><br><span class="line">       &#125; </span><br><span class="line">       p=p-&gt;next;</span><br><span class="line">       q=p-&gt;next;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h3 id="三、我的代码"><a href="#三、我的代码" class="headerlink" title="三、我的代码"></a>三、我的代码</h3><p>&ensp;&ensp;&ensp;&ensp;直接在力扣上写的。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">removeElements</span><span class="params">(ListNode* head, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head==<span class="literal">nullptr</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">while</span>(head-&gt;val==val)&#123;</span><br><span class="line">            head=head-&gt;next;</span><br><span class="line">            <span class="keyword">if</span>(head==<span class="literal">nullptr</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(head-&gt;next==<span class="literal">nullptr</span>)</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        ListNode* p=head;</span><br><span class="line">        ListNode* q=p-&gt;next;</span><br><span class="line">        <span class="keyword">while</span>(q!=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(q-&gt;val==val)&#123;</span><br><span class="line">                q=q-&gt;next;</span><br><span class="line">                p-&gt;next=q;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125; </span><br><span class="line">            p=p-&gt;next;</span><br><span class="line">            q=p-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法</category>
        <category>链表</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>leetcode</tag>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title>神奇的双指针在链表中的应用</title>
    <url>/2021/04/30/%E9%93%BE%E8%A1%A8%EF%BC%9A%E7%A5%9E%E5%A5%87%E7%9A%84%E5%8F%8C%E6%8C%87%E9%92%88%E5%9C%A8%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8/</url>
    <content><![CDATA[<p>双指针在链表中的应用广泛，尤其涉及到有环的链表。</p>
<span id="more"></span>

<h2 id="141：环形链表1"><a href="#141：环形链表1" class="headerlink" title="141：环形链表1"></a>141：环形链表1</h2><h3 id="一、题目描述"><a href="#一、题目描述" class="headerlink" title="一、题目描述"></a>一、题目描述</h3><p>&ensp;&ensp;&ensp;&ensp;给定一个链表，判断链表中是否有环。<br>&ensp;&ensp;&ensp;&ensp;如果链表中有某个节点，可以通过连续跟踪 next 指针再次到达，则链表中存在环。为了表示给定链表中的环，我们使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。如果 pos 是 -1，则在该链表中没有环。注意：pos 不作为参数进行传递，仅仅是为了标识链表的实际情况。</p>
<p>&ensp;&ensp;&ensp;&ensp;如果链表中存在环，则返回 true 。 否则，返回 false 。<br><em>进阶</em>：<br>&ensp;&ensp;&ensp;&ensp;你能用 O(1)（即，常量）内存解决此问题吗？<br><em>提示</em>：<br>&ensp;&ensp;&ensp;&ensp;链表中节点的数目范围是 [0, 104]<br>&ensp;&ensp;&ensp;&ensp;-105 &lt;= Node.val &lt;= 105<br>&ensp;&ensp;&ensp;&ensp;pos 为 -1 或者链表中的一个 有效索引 。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">hasCycle</span><span class="params">(ListNode *head)</span> </span>&#123;</span><br><span class="line">       <span class="comment">//to do</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><img src="/2021/04/30/%E9%93%BE%E8%A1%A8%EF%BC%9A%E7%A5%9E%E5%A5%87%E7%9A%84%E5%8F%8C%E6%8C%87%E9%92%88%E5%9C%A8%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8/1.png"></p>
<h3 id="二、解题思路"><a href="#二、解题思路" class="headerlink" title="二、解题思路"></a>二、解题思路</h3><p>&ensp;&ensp;&ensp;&ensp;为了防止越界问题，每次都需提前判断指针是否为nullptr；两个指针，一快一慢，当二者相等，则有环（快指针在环中转了几圈后“追上”慢的）。</p>
<h3 id="三、我的代码"><a href="#三、我的代码" class="headerlink" title="三、我的代码"></a>三、我的代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">hasCycle</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        ListNode* p1 = head;</span><br><span class="line">        <span class="keyword">if</span> (p1 == <span class="literal">nullptr</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        ListNode* p2 = head;</span><br><span class="line">        <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (p1-&gt;next == <span class="literal">nullptr</span> || p2-&gt;next == <span class="literal">nullptr</span> || p2-&gt;next-&gt;next == <span class="literal">nullptr</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            p1 = p1-&gt;next;		<span class="comment">//跑的慢</span></span><br><span class="line">            p2 = p2-&gt;next-&gt;next;<span class="comment">//跑的快</span></span><br><span class="line">            <span class="keyword">if</span> (p1 == p2)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;            </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="142：环形链表2"><a href="#142：环形链表2" class="headerlink" title="142：环形链表2"></a>142：环形链表2</h2><h3 id="一、题目描述-1"><a href="#一、题目描述-1" class="headerlink" title="一、题目描述"></a>一、题目描述</h3><p>给定一个链表，返回链表开始入环的第一个节点。 如果链表无环，则返回 null。</p>
<p>为了表示给定链表中的环，我们使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。注意，pos 仅仅是用于标识环的情况，并不会作为参数传递到函数中。<br><em>说明：</em><br>&ensp;&ensp;&ensp;&ensp;不允许修改给定的链表。<br><em>进阶：</em><br>&ensp;&ensp;&ensp;&ensp;你是否可以使用 O(1) 空间解决此题？<br><img src="/2021/04/30/%E9%93%BE%E8%A1%A8%EF%BC%9A%E7%A5%9E%E5%A5%87%E7%9A%84%E5%8F%8C%E6%8C%87%E9%92%88%E5%9C%A8%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8/2.png" style="zoom:50%;"></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>: </span><br><span class="line">    <span class="function">ListNode *<span class="title">detectCycle</span><span class="params">(ListNode *head)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//to do</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="二、解题思路-1"><a href="#二、解题思路-1" class="headerlink" title="二、解题思路"></a>二、解题思路</h3><p>&ensp;&ensp;&ensp;&ensp;我们使用两个指针，fast 与 slow。它们起始都位于链表的头部。随后，slow 指针每次向后移动一个位置，而 fast 指针向后移动两个位置。如果链表中存在环，则 fast 指针最终将再次与slow 指针在环中相遇。</p>
<p>&ensp;&ensp;&ensp;&ensp;如下图所示，设链表中环外部分的长度为 a。slow 指针进入环后，又走了b 的距离与 fast 相遇。此时fast 指针已经走完了环的 n 圈，因此它走过的总距离为 a+n(b+c)+b=a+(n+1)b+nca+n(b+c)+b=a+(n+1)b+nc。<br><img src="/%E9%93%BE%E8%A1%A8%EF%BC%9A%E7%A5%9E%E5%A5%87%E7%9A%84%E5%8F%8C%E6%8C%87%E9%92%88%E5%9C%A8%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8/3.png"></p>
<p>&ensp;&ensp;&ensp;&ensp;根据题意，任意时刻，fast 指针走过的距离都为 slow 指针的 2 倍。因此，我们有<br>a+(n+1)b+nc=2(a+b)⟹a=c+(n−1)(b+c)<br>&ensp;&ensp;&ensp;&ensp;有了 a=c+(n-1)(b+c)a=c+(n−1)(b+c) 的等量关系，我们会发现：从相遇点到入环点的距离加上 n-1n−1 圈的环长，恰好等于从链表头部到入环点的距离。<br>&ensp;&ensp;&ensp;&ensp;因此，当发现 slow 与 fast 相遇时，我们再额外使用一个指针ptr。起始，它指向链表头部；随后，它和 slow 每次向后移动一个位置。最终，它们会在入环点相遇。<br>&ensp;&ensp;&ensp;&ensp;数学大法好！！！💀💀💀💀</p>
<h3 id="三、我的代码-1"><a href="#三、我的代码-1" class="headerlink" title="三、我的代码"></a>三、我的代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">   <span class="function">ListNode* <span class="title">detectCycle</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        ListNode* p1 = head;</span><br><span class="line">        <span class="keyword">if</span> (p1 == <span class="literal">nullptr</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        ListNode* p2 = head;</span><br><span class="line">        <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (p1-&gt;next == <span class="literal">nullptr</span> || p2-&gt;next == <span class="literal">nullptr</span> || p2-&gt;next-&gt;next == <span class="literal">nullptr</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">            p1 = p1-&gt;next;</span><br><span class="line">            p2 = p2-&gt;next-&gt;next;</span><br><span class="line">            <span class="keyword">if</span> (p1 == p2) &#123;</span><br><span class="line">                ListNode* ptr = head;</span><br><span class="line">                <span class="keyword">while</span> (ptr != p1) &#123;</span><br><span class="line">                    ptr = ptr-&gt;next;</span><br><span class="line">                    p1 = p1-&gt;next;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> ptr;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="160：相交链表"><a href="#160：相交链表" class="headerlink" title="160：相交链表"></a>160：相交链表</h2><h3 id="一、题目描述-2"><a href="#一、题目描述-2" class="headerlink" title="一、题目描述"></a>一、题目描述</h3><p>&ensp;&ensp;&ensp;&ensp;编写一个程序，找到两个单链表相交的起始节点。<br>&ensp;&ensp;&ensp;&ensp;如下面的两个链表：在节点 c1 开始相交。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">示例 1：</span><br><span class="line">输入：intersectVal &#x3D; 8, listA &#x3D; [4,1,8,4,5], listB &#x3D; [5,0,1,8,4,5], skipA &#x3D; 2, skipB &#x3D; 3</span><br><span class="line">输出：Reference of the node with value &#x3D; 8</span><br><span class="line">输入解释：相交节点的值为 8 （注意，如果两个链表相交则不能为 0）。从各自的表头开始算起，链表 A 为 [4,1,8,4,5]，链表 B 为 [5,0,1,8,4,5]。在 A 中，相交节点前有 2 个节点；在 B 中，相交节点前有 3 个节点。</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line">输入：intersectVal &#x3D; 2, listA &#x3D; [0,9,1,2,4], listB &#x3D; [3,2,4], skipA &#x3D; 3, skipB &#x3D; 1</span><br><span class="line">输出：Reference of the node with value &#x3D; 2</span><br><span class="line">输入解释：相交节点的值为 2 （注意，如果两个链表相交则不能为 0）。从各自的表头开始算起，链表 A 为 [0,9,1,2,4]，链表 B 为 [3,2,4]。在 A 中，相交节点前有 3 个节点；在 B 中，相交节点前有 1 个节点。</span><br><span class="line"></span><br><span class="line">示例 3：</span><br><span class="line">输入：intersectVal &#x3D; 0, listA &#x3D; [2,6,4], listB &#x3D; [1,5], skipA &#x3D; 3, skipB &#x3D; 2</span><br><span class="line">输出：null</span><br><span class="line">输入解释：从各自的表头开始算起，链表 A 为 [2,6,4]，链表 B 为 [1,5]。由于这两个链表不相交，所以 intersectVal 必须为 0，而 skipA 和 skipB 可以是任意值。</span><br><span class="line">解释：这两个链表不相交，因此返回 null。</span><br></pre></td></tr></table></figure>

<p>注意：<br>&ensp;&ensp;&ensp;&ensp;如果两个链表没有交点，返回 null.<br>&ensp;&ensp;&ensp;&ensp;在返回结果后，两个链表仍须保持原有的结构。<br>&ensp;&ensp;&ensp;&ensp;可假定整个链表结构中没有循环。<br>&ensp;&ensp;&ensp;&ensp;程序尽量满足 O(n) 时间复杂度，且仅用 O(1) 内存。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode *<span class="title">getIntersectionNode</span><span class="params">(ListNode *headA, ListNode *headB)</span> </span>&#123;</span><br><span class="line">    		<span class="comment">//to do</span></span><br><span class="line">       &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="二、解题思路-2"><a href="#二、解题思路-2" class="headerlink" title="二、解题思路"></a>二、解题思路</h3><p>&ensp;&ensp;&ensp;&ensp;方法一: 暴力法<br>&ensp;&ensp;&ensp;&ensp;对链表A中的每一个结点 a，遍历整个链表 B 并检查链表 B 中是否存在结点和 a相同。</p>
<p>&ensp;&ensp;&ensp;&ensp;方法二: 双指针法<br>&ensp;&ensp;&ensp;&ensp;创建两个指针 pA 和 pB，分别初始化为链表 A 和 B 的头结点，然后让它们向后逐结点遍历；当 pA 到达链表的尾部时，将它重定位到链表 B 的头结点 (你没看错，就是链表 B); 类似的，当 pB 到达链表的尾部时，将它重定位到链表 A 的头结点；若在某一时刻 pA 和 pB 相遇，则 pA/pB 为相交结点。<br>&ensp;&ensp;&ensp;&ensp;起点虽然不一样，但路程一样,终点一样,速度一样，必定同时到达。</p>
<h3 id="三、我的代码-2"><a href="#三、我的代码-2" class="headerlink" title="三、我的代码"></a>三、我的代码</h3><p>方法一：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">   <span class="function">ListNode* <span class="title">getIntersectionNode</span><span class="params">(ListNode* headA, ListNode* headB)</span> </span>&#123;</span><br><span class="line">        ListNode* pa = headA;</span><br><span class="line">        <span class="keyword">if</span> (pa == <span class="literal">nullptr</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        ListNode* pb = headB;</span><br><span class="line">        <span class="keyword">if</span> (pb == <span class="literal">nullptr</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (pa == pb)</span><br><span class="line">                    <span class="keyword">return</span> pa;</span><br><span class="line">                <span class="keyword">if</span> (pb-&gt;next == <span class="literal">nullptr</span>)</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                pb = pb-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (pa-&gt;next == <span class="literal">nullptr</span>)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            pa = pa-&gt;next;</span><br><span class="line">            pb = headB;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>方法二：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">getIntersectionNode</span><span class="params">(ListNode* headA, ListNode* headB)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = <span class="number">0</span>;</span><br><span class="line">        ListNode* pa = headA;</span><br><span class="line">        ListNode* pb = headB;</span><br><span class="line">        <span class="keyword">if</span> (pa == <span class="literal">nullptr</span> || pb == <span class="literal">nullptr</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">while</span> (n &lt; <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (pa == pb)</span><br><span class="line">                <span class="keyword">return</span> pa;</span><br><span class="line">            <span class="keyword">if</span> (pb-&gt;next == <span class="literal">nullptr</span>)</span><br><span class="line">                pb = headA, n++;<span class="comment">//不能用pb-&gt;next=headA,会改变链表结构</span></span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                pb = pb-&gt;next;</span><br><span class="line">            <span class="keyword">if</span> (pa-&gt;next == <span class="literal">nullptr</span>)</span><br><span class="line">                pa = headB;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                pa = pa-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法</category>
        <category>链表</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>leetcode</tag>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title>复制带随机指针的链表</title>
    <url>/2021/04/30/%E9%93%BE%E8%A1%A8%EF%BC%9A%E5%A4%8D%E5%88%B6%E5%B8%A6%E9%9A%8F%E6%9C%BA%E6%8C%87%E9%92%88%E7%9A%84%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<h3 id="一、题目描述"><a href="#一、题目描述" class="headerlink" title="一、题目描述"></a>一、题目描述</h3><p>给定一个链表，每个节点包含一个额外增加的随机指针，该指针可以指向链表中的任何节点或空节点。</p>
<p>要求返回这个链表的深拷贝。 </p>
<span id="more"></span>

<p>我们用一个由 n 个节点组成的链表来表示输入/输出中的链表。每个节点用一个 [val, random_index] 表示：</p>
<ul>
<li>val：一个表示 Node.val 的整数。</li>
<li>random_index：随机指针指向的节点索引（范围从 0 到 n-1）；如果不指向任何节点，则为  null 。</li>
</ul>
<p><strong>示例 1：</strong></p>
<p><img src="/2021/04/30/%E9%93%BE%E8%A1%A8%EF%BC%9A%E5%A4%8D%E5%88%B6%E5%B8%A6%E9%9A%8F%E6%9C%BA%E6%8C%87%E9%92%88%E7%9A%84%E9%93%BE%E8%A1%A8/1.png" alt="image-20201213164012901"></p>
<p>输入：head = [[7,null],[13,0],[11,4],[10,2],[1,0]]</p>
<p>输出：[[7,null],[13,0],[11,4],[10,2],[1,0]]</p>
<p><strong>示例 2：</strong></p>
<p><img src="/2021/04/30/%E9%93%BE%E8%A1%A8%EF%BC%9A%E5%A4%8D%E5%88%B6%E5%B8%A6%E9%9A%8F%E6%9C%BA%E6%8C%87%E9%92%88%E7%9A%84%E9%93%BE%E8%A1%A8/2.png" alt="image-20201213164032257"></p>
<p>输入：head = [[1,1],[2,1]]</p>
<p>输出：[[1,1],[2,1]]</p>
<p><strong>示例 3：</strong></p>
<p><img src="/2021/04/30/%E9%93%BE%E8%A1%A8%EF%BC%9A%E5%A4%8D%E5%88%B6%E5%B8%A6%E9%9A%8F%E6%9C%BA%E6%8C%87%E9%92%88%E7%9A%84%E9%93%BE%E8%A1%A8/3.png" alt="image-20201213164059316"></p>
<p>输入：head = [[3,null],[3,0],[3,null]]</p>
<p>输出：[[3,null],[3,0],[3,null]]</p>
<p><strong>示例 4：</strong></p>
<p>输入：head = []</p>
<p>输出：[]<br>解释：给定的链表为空（空指针），因此返回 null。</p>
<p><strong>提示：</strong></p>
<ul>
<li>-10000 &lt;= Node.val &lt;= 10000</li>
<li>Node.random 为空（null）或指向链表中的节点。</li>
<li>节点数目不超过 1000 。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">// Definition for a Node.</span></span><br><span class="line"><span class="comment">class Node &#123;</span></span><br><span class="line"><span class="comment">public:</span></span><br><span class="line"><span class="comment">    int val;</span></span><br><span class="line"><span class="comment">    Node* next;</span></span><br><span class="line"><span class="comment">    Node* random;</span></span><br><span class="line"><span class="comment">    </span></span><br><span class="line"><span class="comment">    Node(int _val) &#123;</span></span><br><span class="line"><span class="comment">        val = _val;</span></span><br><span class="line"><span class="comment">        next = NULL;</span></span><br><span class="line"><span class="comment">        random = NULL;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Node* <span class="title">copyRandomList</span><span class="params">(Node* head)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//to do</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h3 id="二、解题思路"><a href="#二、解题思路" class="headerlink" title="二、解题思路"></a>二、解题思路</h3><ol>
<li><p>使用哈希图，先生成与原来链表相同个数的节点</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">unordered_map&lt;Node*,Node*&gt;nodemap;</span><br><span class="line">   nodemap[<span class="literal">nullptr</span>]=<span class="literal">nullptr</span>;</span><br><span class="line">   Node* p=head;</span><br><span class="line">   <span class="keyword">while</span>(p)&#123;</span><br><span class="line">       nodemap[p]=<span class="keyword">new</span> <span class="built_in">Node</span>(p-&gt;val);</span><br><span class="line">       p=p-&gt;next;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></li>
<li><p>使哈希图中每个节点等于原节点</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">p=head;</span><br><span class="line">  <span class="keyword">while</span>(p!=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">      nodemap[p]-&gt;next=nodemap[p-&gt;next];</span><br><span class="line">      p=p-&gt;next;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li>
<li><p>再复制random指针</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">p=head;</span><br><span class="line"><span class="keyword">while</span>(p!=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">    nodemap[p]-&gt;random=nodemap[p-&gt;random];</span><br><span class="line">    p=p-&gt;next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="三、我的代码"><a href="#三、我的代码" class="headerlink" title="三、我的代码"></a>三、我的代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">// Definition for a Node.</span></span><br><span class="line"><span class="comment">class Node &#123;</span></span><br><span class="line"><span class="comment">public:</span></span><br><span class="line"><span class="comment">    int val;</span></span><br><span class="line"><span class="comment">    Node* next;</span></span><br><span class="line"><span class="comment">    Node* random;</span></span><br><span class="line"><span class="comment">    </span></span><br><span class="line"><span class="comment">    Node(int _val) &#123;</span></span><br><span class="line"><span class="comment">        val = _val;</span></span><br><span class="line"><span class="comment">        next = NULL;</span></span><br><span class="line"><span class="comment">        random = NULL;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Node* <span class="title">copyRandomList</span><span class="params">(Node* head)</span> </span>&#123;</span><br><span class="line">        unordered_map&lt;Node*,Node*&gt;nodemap;</span><br><span class="line">        nodemap[<span class="literal">nullptr</span>]=<span class="literal">nullptr</span>;</span><br><span class="line">        Node* p=head;</span><br><span class="line">        <span class="keyword">while</span>(p!=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">            nodemap[p]=<span class="keyword">new</span> <span class="built_in">Node</span>(p-&gt;val);</span><br><span class="line">            p=p-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        p=head;</span><br><span class="line">        <span class="keyword">while</span>(p!=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">            nodemap[p]-&gt;next=nodemap[p-&gt;next];</span><br><span class="line">            p=p-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        p=head;</span><br><span class="line">        <span class="keyword">while</span>(p!=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">            nodemap[p]-&gt;random=nodemap[p-&gt;random];</span><br><span class="line">            p=p-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nodemap[head];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法</category>
        <category>链表</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>leetcode</tag>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title>旋转链表</title>
    <url>/2021/04/30/%E9%93%BE%E8%A1%A8%EF%BC%9A%E6%97%8B%E8%BD%AC%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<h3 id="一、题目描述"><a href="#一、题目描述" class="headerlink" title="一、题目描述"></a>一、题目描述</h3><p>给定一个链表，旋转链表，将链表每个节点向右移动 <em>k</em> 个位置，其中 <em>k</em> 是非负数。</p>
<span id="more"></span>

<p><strong>示例 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL, k &#x3D; 2</span><br><span class="line">输出: 4-&gt;5-&gt;1-&gt;2-&gt;3-&gt;NULL</span><br><span class="line">解释:</span><br><span class="line">向右旋转 1 步: 5-&gt;1-&gt;2-&gt;3-&gt;4-&gt;NULL</span><br><span class="line">向右旋转 2 步: 4-&gt;5-&gt;1-&gt;2-&gt;3-&gt;NULL</span><br></pre></td></tr></table></figure>

<p><strong>示例 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: 0-&gt;1-&gt;2-&gt;NULL, k &#x3D; 4</span><br><span class="line">输出: 2-&gt;0-&gt;1-&gt;NULL</span><br><span class="line">解释:</span><br><span class="line">向右旋转 1 步: 2-&gt;0-&gt;1-&gt;NULL</span><br><span class="line">向右旋转 2 步: 1-&gt;2-&gt;0-&gt;NULL</span><br><span class="line">向右旋转 3 步: 0-&gt;1-&gt;2-&gt;NULL</span><br><span class="line">向右旋转 4 步: 2-&gt;0-&gt;1-&gt;NULL</span><br></pre></td></tr></table></figure>

<h3 id="二、解题思路"><a href="#二、解题思路" class="headerlink" title="二、解题思路"></a>二、解题思路</h3><ol>
<li><p>先确定链表的长度</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> length=<span class="number">0</span>;</span><br><span class="line">        ListNode* p=head;</span><br><span class="line">        <span class="keyword">while</span>(p!=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">            p=p-&gt;next;</span><br><span class="line">            length++;</span><br><span class="line">        &#125;       </span><br></pre></td></tr></table></figure></li>
<li><p>当链表为空或长度为一或移动零步或移动链表的整数倍步时，返回原链表头结点指针</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(length==<span class="number">0</span>||length==<span class="number">1</span>||k==<span class="number">0</span>||k%length==<span class="number">0</span>)</span><br><span class="line">           <span class="keyword">return</span> head;</span><br></pre></td></tr></table></figure></li>
<li><p>前两步之后，另k=k%length，再使一个指针移动到原链表末端</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">k=k%length;</span><br><span class="line">   p=head;</span><br><span class="line">   <span class="keyword">while</span>(p-&gt;next!=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">   	p=p-&gt;next;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></li>
<li><p>使用双指针法，从头开始向末端移动 length-k-1步，再见链表断为两个，重新连接</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">ListNode* t1=head;</span><br><span class="line">   ListNode* t2=head-&gt;next;</span><br><span class="line">   <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;length-k<span class="number">-1</span>;i++)&#123;</span><br><span class="line">   	t1=t1-&gt;next;</span><br><span class="line">       t2=t2-&gt;next;</span><br><span class="line">   &#125;</span><br><span class="line">   t1-&gt;next=<span class="literal">nullptr</span>;</span><br><span class="line">   p-&gt;next=head;</span><br></pre></td></tr></table></figure>

<img src="/2021/04/30/%E9%93%BE%E8%A1%A8%EF%BC%9A%E6%97%8B%E8%BD%AC%E9%93%BE%E8%A1%A8/1.png" style="zoom:80%;">

<img src="/2021/04/30/%E9%93%BE%E8%A1%A8%EF%BC%9A%E6%97%8B%E8%BD%AC%E9%93%BE%E8%A1%A8/2.png" style="zoom:80%;"></li>
</ol>
<h3 id="三、我的代码"><a href="#三、我的代码" class="headerlink" title="三、我的代码"></a>三、我的代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">rotateRight</span><span class="params">(ListNode* head, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> length=<span class="number">0</span>;</span><br><span class="line">        ListNode* p=head;</span><br><span class="line">        <span class="keyword">while</span>(p!=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">            p=p-&gt;next;</span><br><span class="line">            length++;</span><br><span class="line">        &#125;       </span><br><span class="line">        <span class="keyword">if</span>(length==<span class="number">0</span>||length==<span class="number">1</span>||k==<span class="number">0</span>||k%length==<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        k=k%length;</span><br><span class="line">        p=head;</span><br><span class="line">        <span class="keyword">while</span>(p-&gt;next!=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">            p=p-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode* t1=head;</span><br><span class="line">        ListNode* t2=head-&gt;next;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;length-k<span class="number">-1</span>;i++)&#123;</span><br><span class="line">            t1=t1-&gt;next;</span><br><span class="line">            t2=t2-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        t1-&gt;next=<span class="literal">nullptr</span>;</span><br><span class="line">        p-&gt;next=head;</span><br><span class="line">        <span class="keyword">return</span> t2;</span><br><span class="line">    &#125;c</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法</category>
        <category>链表</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>leetcode</tag>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title>合并两个有序链表</title>
    <url>/2021/04/30/%E9%93%BE%E8%A1%A8%EF%BC%9A%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<h3 id="一、题目描述"><a href="#一、题目描述" class="headerlink" title="一、题目描述"></a>一、题目描述</h3><p>&ensp;&ensp;&ensp;&ensp;将两个升序链表合并为一个新的 <strong>升序</strong> 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 </p>
<span id="more"></span>

<p><strong>示例：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：1-&gt;2-&gt;4, 1-&gt;3-&gt;4</span><br><span class="line">输出：1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4</span><br></pre></td></tr></table></figure>

<h3 id="二、解题思路"><a href="#二、解题思路" class="headerlink" title="二、解题思路"></a>二、解题思路</h3><ol>
<li><p>先判断有无空链表</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(l1==<span class="literal">nullptr</span>)</span><br><span class="line">	<span class="keyword">return</span> l2;</span><br><span class="line"><span class="keyword">if</span>(l2==<span class="literal">nullptr</span>)</span><br><span class="line">	<span class="keyword">return</span> l1;</span><br></pre></td></tr></table></figure></li>
<li><p>确定合并链表的头结点（整数值小的结点）</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">ListNode* head;</span><br><span class="line">l1-&gt;val&gt;l2-&gt;val ? (head=l2,l2=l2-&gt;next):(head=l1,l1=l1-&gt;next); </span><br></pre></td></tr></table></figure></li>
<li><p>连接后续结点</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(l1!=<span class="literal">nullptr</span>&amp;&amp;l2!=<span class="literal">nullptr</span>)&#123;            </span><br><span class="line">            l1-&gt;val&gt;l2-&gt;val ? (p-&gt;next=l2,l2=l2-&gt;next):(p-&gt;next=l1,l1=l1-&gt;next);            </span><br><span class="line">            p=p-&gt;next;            </span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="三、我的代码"><a href="#三、我的代码" class="headerlink" title="三、我的代码"></a>三、我的代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">mergeTwoLists</span><span class="params">(ListNode* l1, ListNode* l2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(l1==<span class="literal">nullptr</span>)</span><br><span class="line">            <span class="keyword">return</span> l2;</span><br><span class="line">        <span class="keyword">if</span>(l2==<span class="literal">nullptr</span>)</span><br><span class="line">            <span class="keyword">return</span> l1;</span><br><span class="line">        ListNode* head;</span><br><span class="line">        l1-&gt;val&gt;l2-&gt;val ? (head=l2,l2=l2-&gt;next):(head=l1,l1=l1-&gt;next);        </span><br><span class="line">        ListNode* p=head;</span><br><span class="line">        <span class="keyword">while</span>(l1!=<span class="literal">nullptr</span>&amp;&amp;l2!=<span class="literal">nullptr</span>)&#123;            </span><br><span class="line">            l1-&gt;val&gt;l2-&gt;val ? (p-&gt;next=l2,l2=l2-&gt;next):(p-&gt;next=l1,l1=l1-&gt;next);            </span><br><span class="line">            p=p-&gt;next;            </span><br><span class="line">        &#125;</span><br><span class="line">        p-&gt;next=(l1==<span class="literal">nullptr</span>)? l2:l1;        </span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法</category>
        <category>链表</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>leetcode</tag>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title>删除链表的倒数第n个节点</title>
    <url>/2021/04/30/%E9%93%BE%E8%A1%A8%EF%BC%9A%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E5%80%92%E6%95%B0%E7%AC%ACn%E4%B8%AA%E8%8A%82%E7%82%B9/</url>
    <content><![CDATA[<h3 id="一、题目描述"><a href="#一、题目描述" class="headerlink" title="一、题目描述"></a>一、题目描述</h3><p>&ensp;&ensp;&ensp;&ensp;给定一个链表，删除链表的倒数第 n 个节点，并且返回链表的头结点。</p>
<span id="more"></span>

<p>&ensp;&ensp;&ensp;&ensp;示例：<br>&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;给定一个链表: 1-&gt;2-&gt;3-&gt;4-&gt;5, 和 n = 2.<br>&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;当删除了倒数第二个节点后，链表变为 1-&gt;2-&gt;3-&gt;5.<br>&ensp;&ensp;&ensp;&ensp;说明：给定的 n 保证是有效的。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">removeNthFromEnd</span><span class="params">(ListNode* head, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    	<span class="comment">//to do            </span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="二、解题思路"><a href="#二、解题思路" class="headerlink" title="二、解题思路"></a>二、解题思路</h3><p>&ensp;&ensp;&ensp;&ensp;首先需要知道所给链表的长度</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> length=<span class="number">0</span>;</span><br><span class="line">ListNode *lengthptr=head;</span><br><span class="line">        <span class="keyword">while</span>(lengthptr!=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">            length++;</span><br><span class="line">            lengthptr=length1-&gt;next;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<p>&ensp;&ensp;&ensp;&ensp;然后将中间指针移动到所要删除的节点的前一个节点上，然后执行删除操作。<br>&ensp;&ensp;&ensp;&ensp;根据注释中链表的定义，我们创造了一个新的节点beforhead，它指向head；然后对beforehead后面的链表执行操作，最后返回beforhead-&gt;next，这样便于解决一些特殊情况，比如删除头结点时。</p>
<h3 id="三、我的代码"><a href="#三、我的代码" class="headerlink" title="三、我的代码"></a>三、我的代码</h3><p>&ensp;&ensp;&ensp;&ensp;直接在力扣上写的。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">removeNthFromEnd</span><span class="params">(ListNode* head, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> length=<span class="number">0</span>;</span><br><span class="line">        ListNode *beforhead=<span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">0</span>,head);</span><br><span class="line">        ListNode *begin=beforhead;</span><br><span class="line">        ListNode *lengthptr=head;</span><br><span class="line">        <span class="keyword">while</span>(lengthptr!=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">            length++;</span><br><span class="line">            lengthptr=length1-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;length-n+<span class="number">1</span>;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            begin=begin-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        begin-&gt;next=begin-&gt;next-&gt;next;</span><br><span class="line">        ListNode *ans=beforhead-&gt;next;</span><br><span class="line">        <span class="keyword">return</span> ans;                    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法</category>
        <category>链表</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>leetcode</tag>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title>反转链表</title>
    <url>/2021/04/30/%E9%93%BE%E8%A1%A8%EF%BC%9A%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<h3 id="一、题目描述"><a href="#一、题目描述" class="headerlink" title="一、题目描述"></a>一、题目描述</h3><p>&ensp;&ensp;&ensp;&ensp;反转一个单链表。</p>
<span id="more"></span>

<p>示例:</p>
<pre><code>输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL
输出: 5-&gt;4-&gt;3-&gt;2-&gt;1-&gt;NULL
</code></pre>
<p>进阶:<br>&ensp;&ensp;&ensp;&ensp;你可以迭代或递归地反转链表。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">reverseList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">		<span class="comment">//to do</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="二、解题思路"><a href="#二、解题思路" class="headerlink" title="二、解题思路"></a>二、解题思路</h3><p>&ensp;&ensp;&ensp;&ensp;当链表为空或者只有一个头结点时，直接返回head即可。<br>&ensp;&ensp;&ensp;&ensp;定义三个指针：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">ListNode* p=head;</span><br><span class="line">ListNode* q=head-&gt;next;</span><br><span class="line">ListNode* tmp;</span><br></pre></td></tr></table></figure>
<p>&ensp;&ensp;&ensp;&ensp;p是反转链表的头节点，q是老链表的头节点，tmp作为p，q移动时的中间节点。<br><img src="/2021/04/30/%E9%93%BE%E8%A1%A8%EF%BC%9A%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/1.png" alt="在这里插入图片描述"><br>&ensp;&ensp;&ensp;&ensp;移动一次</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">tmp=q;</span><br><span class="line">q=q-&gt;next;</span><br><span class="line">tmp-&gt;next=p;</span><br><span class="line">p=tmp;</span><br></pre></td></tr></table></figure>

<h3 id="三、我的代码"><a href="#三、我的代码" class="headerlink" title="三、我的代码"></a>三、我的代码</h3><p>&ensp;&ensp;&ensp;&ensp;直接在力扣上写的。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">reverseList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head==<span class="literal">nullptr</span>||head-&gt;next==<span class="literal">nullptr</span>)</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        ListNode* p=head;</span><br><span class="line">        ListNode* q=head-&gt;next;</span><br><span class="line">        ListNode* tmp;</span><br><span class="line">        p-&gt;next=<span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">while</span>(q!=<span class="literal">nullptr</span>)&#123;            </span><br><span class="line">            tmp=q;</span><br><span class="line">            q=q-&gt;next;</span><br><span class="line">            tmp-&gt;next=p;</span><br><span class="line">            p=tmp;          </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> p;          </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="25-K-个一组翻转链表"><a href="#25-K-个一组翻转链表" class="headerlink" title="25. K 个一组翻转链表"></a><a href="https://leetcode-cn.com/problems/reverse-nodes-in-k-group/">25. K 个一组翻转链表</a></h3><p>给你一个链表，每 <em>k</em> 个节点一组进行翻转，请你返回翻转后的链表。</p>
<p><em>k</em> 是一个正整数，它的值小于或等于链表的长度。</p>
<p>如果节点总数不是 <em>k</em> 的整数倍，那么请将最后剩余的节点保持原有顺序。</p>
<p><strong>进阶：</strong></p>
<ul>
<li>  你可以设计一个只使用常数额外空间的算法来解决此问题吗？</li>
<li>  <strong>你不能只是单纯的改变节点内部的值</strong>，而是需要实际进行节点交换。 </li>
</ul>
<p><strong>示例 1：</strong></p>
<p><img src="/2021/04/30/%E9%93%BE%E8%A1%A8%EF%BC%9A%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/2.jpg" alt="img"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：head &#x3D; [1,2,3,4,5], k &#x3D; 2</span><br><span class="line">输出：[2,1,4,3,5]</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<p><img src="/%E5%8F%8D%E8%BD%AC%E9%93%BE%EF%BF%BD.jpg" alt="img"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：head &#x3D; [1,2,3,4,5], k &#x3D; 3</span><br><span class="line">输出：[3,2,1,4,5]</span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：head &#x3D; [1,2,3,4,5], k &#x3D; 1</span><br><span class="line">输出：[1,2,3,4,5]</span><br></pre></td></tr></table></figure>

<p><strong>示例 4：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：head &#x3D; [1], k &#x3D; 1</span><br><span class="line">输出：[1]</span><br></pre></td></tr></table></figure>



<p><strong>提示：</strong></p>
<ul>
<li>  列表中节点的数量在范围 <code>sz</code> 内</li>
<li>  <code>1 &lt;= sz &lt;= 5000</code></li>
<li>  <code>0 &lt;= Node.val &lt;= 1000</code></li>
<li>  <code>1 &lt;= k &lt;= sz</code></li>
</ul>
<p>代码</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">reverse</span><span class="params">(ListNode* a, ListNode* b)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        ListNode* pre = <span class="literal">nullptr</span>;</span><br><span class="line">        ListNode* cur = a;</span><br><span class="line">        ListNode* nxt = a;</span><br><span class="line">        <span class="keyword">while</span>(cur != b)</span><br><span class="line">        &#123;</span><br><span class="line">            nxt = cur-&gt;next;</span><br><span class="line">            cur-&gt;next = pre;</span><br><span class="line">            pre = cur;</span><br><span class="line">            cur = nxt;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pre;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">ListNode* <span class="title">reverseKGroup</span><span class="params">(ListNode* head, <span class="keyword">int</span> k)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!head)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        </span><br><span class="line">        ListNode *a = head, *b = head;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(!b)</span><br><span class="line">                <span class="keyword">return</span> head;</span><br><span class="line">            b = b-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ListNode *newHead = <span class="built_in">reverse</span>(a, b);</span><br><span class="line"></span><br><span class="line">        a-&gt;next = <span class="built_in">reverseKGroup</span>(b, k);</span><br><span class="line">        <span class="keyword">return</span> newHead;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法</category>
        <category>链表</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>leetcode</tag>
        <tag>链表</tag>
        <tag>反转链表</tag>
      </tags>
  </entry>
  <entry>
    <title>模幂运算</title>
    <url>/2021/04/30/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E5%AD%A6%EF%BC%9A%E6%A8%A1%E5%B9%82%E8%BF%90%E7%AE%97/</url>
    <content><![CDATA[<p>&ensp;&ensp;&ensp;&ensp;由于格式原因可能文章显示有问题，a^1234^代表a的1234次幂</p>
<p>&ensp;&ensp;&ensp;&ensp;a^1234^  =  a^4^  *  (a^123^)^10^</p>
<p>&ensp;&ensp;&ensp;&ensp;(a * b) % mod = (a % mod)(b % mod) % mod</p>
<span id="more"></span>

<h4 id="50-Pow-x-n"><a href="#50-Pow-x-n" class="headerlink" title="50. Pow(x, n)"></a><a href="https://leetcode-cn.com/problems/powx-n/">50. Pow(x, n)</a></h4><p>&ensp;&ensp;&ensp;&ensp;实现 pow(<em>x</em>, <em>n</em>) ，即计算 x 的 n 次幂函数（即，x^n^）。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：x &#x3D; 2.00000, n &#x3D; 10</span><br><span class="line">输出：1024.00000</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：x &#x3D; 2.10000, n &#x3D; 3</span><br><span class="line">输出：9.26100</span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：x &#x3D; 2.00000, n &#x3D; -2</span><br><span class="line">输出：0.25000</span><br><span class="line">解释：2^(-2) &#x3D; 1&#x2F;22 &#x3D; 1&#x2F;4 &#x3D; 0.25</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li>  <code>-100.0 &lt; x &lt; 100.0</code></li>
<li>  <code>-231 &lt;= n &lt;= 231-1</code></li>
<li>  <code>-10^4 &lt;= x^n &lt;= 10^4</code></li>
</ul>
<p>&ensp;&ensp;&ensp;&ensp;递归：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">quickMul</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">long</span> <span class="keyword">long</span> N)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (N == <span class="number">0</span>) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1.0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">double</span> y = <span class="built_in">quickMul</span>(x, N / <span class="number">2</span>);</span><br><span class="line">        <span class="keyword">return</span> N % <span class="number">2</span> == <span class="number">0</span> ? y * y : y * y * x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">myPow</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">int</span> n)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> N = n;</span><br><span class="line">        <span class="keyword">return</span> N &gt;= <span class="number">0</span> ? <span class="built_in">quickMul</span>(x, N) : <span class="number">1.0</span> / <span class="built_in">quickMul</span>(x, -N);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>&ensp;&ensp;&ensp;&ensp;迭代：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">quickMul</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">long</span> <span class="keyword">long</span> N)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">double</span> ans = <span class="number">1.0</span>;</span><br><span class="line">        <span class="comment">// 贡献的初始值为 x</span></span><br><span class="line">        <span class="keyword">double</span> x_contribute = x;</span><br><span class="line">        <span class="comment">// 在对 N 进行二进制拆分的同时计算答案</span></span><br><span class="line">        <span class="keyword">while</span> (N &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (N &amp; <span class="number">1</span>) </span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 如果 N 二进制表示的最低位为 1，那么需要计入贡献</span></span><br><span class="line">                ans *= x_contribute;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 将贡献不断地平方</span></span><br><span class="line">            x_contribute *= x_contribute;</span><br><span class="line">            <span class="comment">// 舍弃 N 二进制表示的最低位，这样我们每次只要判断最低位即可</span></span><br><span class="line">            N /= <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">myPow</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">int</span> n)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> N = n;</span><br><span class="line">        <span class="keyword">return</span> N &gt;= <span class="number">0</span> ? <span class="built_in">quickMul</span>(x, N) : <span class="number">1.0</span> / <span class="built_in">quickMul</span>(x, -N);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>&ensp;&ensp;&ensp;&ensp;a^1234^  =  a^4^  *  (a^123^)^10^  $\Longrightarrow$ a^[1,2,3,4]^  =  a^4^  *  (a^[1,2,3]^)^10^ </p>
<h4 id="372-超级次方"><a href="#372-超级次方" class="headerlink" title="372. 超级次方"></a><a href="https://leetcode-cn.com/problems/super-pow/">372. 超级次方</a></h4><p>你的任务是计算  a^b^  对 <code>1337</code> 取模，<code>a</code> 是一个正整数，<code>b</code> 是一个非常大的正整数且会以数组形式给出。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：a &#x3D; 2, b &#x3D; [3]</span><br><span class="line">输出：8</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：a &#x3D; 2, b &#x3D; [1,0]</span><br><span class="line">输出：1024</span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：a &#x3D; 1, b &#x3D; [4,3,3,8,5,2]</span><br><span class="line">输出：1</span><br></pre></td></tr></table></figure>

<p><strong>示例 4：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：a &#x3D; 2147483647, b &#x3D; [2,0,0]</span><br><span class="line">输出：1198</span><br></pre></td></tr></table></figure>

<p> <strong>提示：</strong></p>
<ul>
<li>  <code>1 &lt;= a &lt;= 231 - 1</code></li>
<li>  <code>1 &lt;= b.length &lt;= 2000</code></li>
<li>  <code>0 &lt;= b[i] &lt;= 9</code></li>
<li>  <code>b</code> 不含前导 0</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> mod = <span class="number">1337</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">myPow</span> <span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        x %= mod;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (n) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (n &amp; <span class="number">1</span>) res = res * x % mod;</span><br><span class="line">            x = x * x % mod;</span><br><span class="line">            n &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">superPow</span><span class="params">(<span class="keyword">int</span> a, vector&lt;<span class="keyword">int</span>&gt;&amp; b)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (b.<span class="built_in">empty</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> lastValue = b.<span class="built_in">back</span>();</span><br><span class="line">        b.<span class="built_in">pop_back</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> part1 = <span class="built_in">myPow</span>(a, lastValue);</span><br><span class="line">        <span class="keyword">int</span> part2 = <span class="built_in">myPow</span>(<span class="built_in">superPow</span>(a, b), <span class="number">10</span>);</span><br><span class="line">        <span class="keyword">return</span> part1 * part2 % mod;  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><a href="https://mp.weixin.qq.com/s?__biz=MzAxODQxMDM0Mw==&mid=2247485035&idx=1&sn=c03c9056f412bf590480156e4357b433&chksm=9bd7f863aca07175eca0bd5e638c857969af1936cc2b7b4a01610809ba1d85a3272703e2b3a2&scene=21#wechat_redirect">Super Pow：如何高效进行模幂运算 (qq.com)</a></p>
<p><a href="https://mp.weixin.qq.com/s?__biz=MzA5MTM1NTc2Ng==&mid=2458321758&idx=1&sn=e92e7a72d245831c29acb3d2a29607da&scene=21#wechat_redirect">客户端基本不用的算法系列：快速幂 (qq.com)</a></p>
<p><a href="https://blog.csdn.net/FlushHip/article/details/82495034">右移一位和除二的区别</a></p>
]]></content>
      <categories>
        <category>算法</category>
        <category>数学</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>leetcode</tag>
        <tag>数学</tag>
        <tag>模幂运算</tag>
      </tags>
  </entry>
  <entry>
    <title>跳跃游戏</title>
    <url>/2021/04/29/%E7%AE%97%E6%B3%95%EF%BC%9A%E8%B7%B3%E8%B7%83%E6%B8%B8%E6%88%8F/</url>
    <content><![CDATA[<h3 id="一、介绍"><a href="#一、介绍" class="headerlink" title="一、介绍"></a>一、介绍</h3><p>&ensp;&ensp;&ensp;&ensp;2021年4月14日华为笔试题第四题，好像是一个有关信号塔传播的题，后来在刷Leetcode的时候碰见了原题，也就是《跳跃游戏2》；跳跃游戏1和2只是问法不一样，核心算法相同。</p>
<span id="more"></span>

<h3 id="二、题目"><a href="#二、题目" class="headerlink" title="二、题目"></a>二、题目</h3><p><a href="https://leetcode-cn.com/problems/jump-game/">跳跃游戏</a></p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">给定一个非负整数数组 nums ，你最初位于数组的第一个下标 。数组中的每个元素代表你在该位置可以跳跃的最大长度。判断你是否能够到达最后一个下标。 </span><br><span class="line"></span><br><span class="line">示例 1：</span><br><span class="line">输入：nums = [2,3,1,1,4]</span><br><span class="line">输出：true</span><br><span class="line">解释：可以先跳 1 步，从下标 0 到达下标 1, 然后再从下标 1 跳 3 步到达最后一个下标。</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line">输入：nums = [3,2,1,0,4]</span><br><span class="line">输出：false</span><br><span class="line">解释：无论怎样，总会到达下标为 3 的位置。但该下标的最大跳跃长度是 0 ， 所以永远不可能到达最后一个下标。</span><br><span class="line">提示：</span><br><span class="line">1 &lt;= nums.length &lt;= 3 * 10<span class="built_in">^</span>4</span><br><span class="line">0 &lt;= nums[i] &lt;= 105</span><br></pre></td></tr></table></figure>

<p><a href="https://leetcode-cn.com/problems/jump-game-ii/">跳跃游戏 II</a></p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">给定一个非负整数数组，你最初位于数组的第一个位置。数组中的每个元素代表你在该位置可以跳跃的最大长度。你的目标是使用最少的跳跃次数到达数组的最后一个位置。假设你总是可以到达数组的最后一个位置。</span><br><span class="line"></span><br><span class="line">示例 1:</span><br><span class="line">输入: [2,3,1,1,4]</span><br><span class="line">输出: 2</span><br><span class="line">解释: 跳到最后一个位置的最小跳跃数是 2。</span><br><span class="line">     从下标为 0 跳到下标为 1 的位置，跳 1 步，然后跳 3 步到达数组的最后一个位置。</span><br><span class="line"></span><br><span class="line">示例 2:</span><br><span class="line">输入: [2,3,0,1,4]</span><br><span class="line">输出: 2</span><br><span class="line"></span><br><span class="line">提示:</span><br><span class="line">1 &lt;= nums.length &lt;= 1000`</span><br><span class="line">0 &lt;= nums[i] &lt;= 105`</span><br></pre></td></tr></table></figure>

<h3 id="三、题解："><a href="#三、题解：" class="headerlink" title="三、题解："></a>三、题解：</h3><p>题一：</p>
<ol>
<li> 如果数组长度为<code>1</code>或数组中没有<code>0</code>，一定可以到达；</li>
<li>对于每一个元素，循环判断它前面的元素是否可以到达<ul>
<li>  如果可以到达，则跳出循环</li>
<li>  如果不可以到达：循环到该元素前面的一个元素，当那个值为<code>0</code></li>
</ul>
</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">canJump</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> numsLength = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span> (numsLength == <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;            </span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt;::iterator it = <span class="built_in">find</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>(), <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (it == nums.<span class="built_in">end</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; numsLength; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; ++j)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums[j] &gt;= i - j)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (nums[j] == <span class="number">0</span> &amp;&amp; i == j + <span class="number">1</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125; </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>题二：</p>
<ol>
<li> 用动态规划的思想，生成一数组<code>dp</code>，<code>dp[i]</code>用来记录<code>nums[0]</code>到达<code>nums[i]</code>的最小跳跃次数</li>
<li> dp[0] = 0</li>
<li> 遍历每个元素，当<code>nums[j]</code>可以到达<code>nums[i]</code>时，另<code>dp[i] = dp[j] + 1;</code>，立即跳出循环</li>
<li> 返回<code>dp[nums.size() - 1]</code></li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">jump</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> numsLength = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">dp</span><span class="params">(nums.size())</span></span>;</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; numsLength; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; ++j)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums[j] &gt;= i - j)</span><br><span class="line">                &#123;</span><br><span class="line">                    dp[i] = dp[j] + <span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125; </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[numsLength - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法</category>
        <category>遇到的笔试（面试）题</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>leetcode</tag>
        <tag>数组</tag>
        <tag>动态规划</tag>
        <tag>华为笔试题</tag>
      </tags>
  </entry>
  <entry>
    <title>位运算</title>
    <url>/2021/04/26/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E5%AD%A6%EF%BC%9A%E4%BD%8D%E8%BF%90%E7%AE%97/</url>
    <content><![CDATA[<p>&ensp;&ensp;本文介绍一些我在刷题时遇到的有关位运算的算法题。</p>
<span id="more"></span>

<h3 id="位异或："><a href="#位异或：" class="headerlink" title="位异或："></a><strong>位异或</strong>：</h3><p>&ensp;&ensp;&ensp;&ensp;一个数和它本身做异或运算结果为 0，即 <code>a ^ a = 0</code>；一个数和 0 做异或运算的结果为它本身，即 <code>a ^ 0 = a</code>。</p>
<p>&ensp;&ensp;&ensp;&ensp;例：</p>
<p>&ensp;&ensp;&ensp;&ensp;<a href="https://leetcode-cn.com/problems/single-number/">只出现一次的数字</a></p>
<p>&ensp;&ensp;&ensp;&ensp;给定一个<strong>非空</strong>整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。</p>
<p><strong>说明：</strong></p>
<p>&ensp;&ensp;&ensp;&ensp;你的算法应该具有线性时间复杂度。 你可以不使用额外空间来实现吗？</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [2,2,1]</span><br><span class="line">输出: 1</span><br></pre></td></tr></table></figure>

<p><strong>示例 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [4,1,2,1,2]</span><br><span class="line">输出: 4</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">singleNumber</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; nums.<span class="built_in">size</span>(); ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            ans = ans ^ nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h3 id="汉明权重"><a href="#汉明权重" class="headerlink" title="汉明权重"></a>汉明权重</h3><p>&ensp;&ensp;位与<code>&amp;</code>，<code>1 &amp; 1 = 1</code>，<code>1 &amp; 0 = 0 &amp; 1 = 0 &amp; 0 = 0</code></p>
<p>&ensp;&ensp;判断奇偶，n &amp; 1 == 1则为奇数，否则为偶数。</p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>汉明重量</strong>是一串符号中非零符号的个数。因此它等同于同样长度的全零符号串的<a href="https://baike.baidu.com/item/%E6%B1%89%E6%98%8E%E8%B7%9D%E7%A6%BB">汉明距离</a>。在最为常见的<a href="https://baike.baidu.com/item/%E6%95%B0%E6%8D%AE%E4%BD%8D">数据位</a>符号串中，它是1的个数。</p>
<p>&ensp;&ensp;&ensp;&ensp;<code>n&amp;(n-1)</code> 这个操作是算法中常见的，作用是消除数字 <code>n</code> 的二进制表示中的最后一个 1。</p>
<img src="/2021/04/26/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E5%AD%A6%EF%BC%9A%E4%BD%8D%E8%BF%90%E7%AE%97/2021-4-30-bit.png" alt="图片" style="zoom:50%;">

<p>&ensp;&ensp;&ensp;&ensp;其核心逻辑就是，<code>n - 1</code> 一定可以消除最后一个 1，同时把其后的 0 都变成 1，这样再和 <code>n</code> 做一次 <code>&amp;</code> 运算，就可以仅仅把最后一个 1 变成 0 了。</p>
<p>&ensp;&ensp;&ensp;&ensp;核心代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">hammingWeight</span><span class="params">(<span class="keyword">uint32_t</span> n)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (n != <span class="number">0</span>) </span><br><span class="line">    &#123;</span><br><span class="line">        n = n &amp; (n - <span class="number">1</span>);</span><br><span class="line">        res++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="338-比特位计数"><a href="#338-比特位计数" class="headerlink" title="338. 比特位计数"></a><a href="https://leetcode-cn.com/problems/counting-bits/">338. 比特位计数</a></h4><p>&ensp;&ensp;&ensp;&ensp;给定一个非负整数 <strong>num</strong>。对于 <strong>0 ≤ i ≤ num</strong> 范围中的每个数字 <strong>i</strong> ，计算其二进制数中的 1 的数目并将它们作为数组返回。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: 2</span><br><span class="line">输出: [0,1,1]</span><br></pre></td></tr></table></figure>

<p><strong>示例 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: 5</span><br><span class="line">输出: [0,1,1,2,1,2]</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">countBits</span><span class="params">(<span class="keyword">int</span> num)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt; ans;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= num; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            ans.<span class="built_in">push_back</span>(<span class="built_in">hammingWeight</span>(i));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">hammingWeight</span><span class="params">(<span class="keyword">int</span> n)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (n != <span class="number">0</span>) &#123;</span><br><span class="line">            n = n &amp; (n - <span class="number">1</span>);</span><br><span class="line">            res++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>另一解法：</p>
<p>&ensp;&ensp;&ensp;&ensp;对于所有的数字，只有两类：</p>
<p>&ensp;&ensp;&ensp;&ensp;奇数：二进制表示中，奇数一定比前面那个偶数多一个 1，因为多的就是最低位的 1。        </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">举例： </span><br><span class="line">    0 &#x3D; 0       1 &#x3D; 1</span><br><span class="line">    2 &#x3D; 10      3 &#x3D; 11</span><br></pre></td></tr></table></figure>

<p>&ensp;&ensp;&ensp;&ensp;偶数：二进制表示中，偶数中 1 的个数一定和除以 2 之后的那个数一样多。因为最低位是 0，除以 2 就是右移一位，也就是把那个 0 抹掉而已，所以 1 的个数是不变的。         </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">举例：</span><br><span class="line">    2 &#x3D; 10       4 &#x3D; 100       8 &#x3D; 1000</span><br><span class="line">    3 &#x3D; 11       6 &#x3D; 110       12 &#x3D; 1100</span><br></pre></td></tr></table></figure>

<p>&ensp;&ensp;&ensp;&ensp;另外，0 的 1 个数为 0，于是就可以根据奇偶性开始遍历计算了。</p>
<p>&ensp;&ensp;&ensp;&ensp;代码</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">countBits</span><span class="params">(<span class="keyword">int</span> num)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">result</span><span class="params">(num+<span class="number">1</span>)</span></span>;</span><br><span class="line">    result[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= num; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(i % <span class="number">2</span> == <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            result[i] = result[i<span class="number">-1</span>] + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            result[i] = result[i/<span class="number">2</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;        </span><br></pre></td></tr></table></figure>

<h4 id="461-汉明距离"><a href="#461-汉明距离" class="headerlink" title="461. 汉明距离"></a><a href="https://leetcode-cn.com/problems/hamming-distance/">461. 汉明距离</a></h4><p>两个整数之间的<a href="https://baike.baidu.com/item/%E6%B1%89%E6%98%8E%E8%B7%9D%E7%A6%BB">汉明距离</a>指的是这两个数字对应二进制位不同的位置的数目。</p>
<p>给出两个整数 <code>x</code> 和 <code>y</code>，计算它们之间的汉明距离。</p>
<p><strong>注意：</strong><br>0 ≤ <code>x</code>, <code>y</code> &lt; 231.</p>
<p><strong>示例:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: x &#x3D; 1, y &#x3D; 4</span><br><span class="line"></span><br><span class="line">输出: 2</span><br><span class="line"></span><br><span class="line">解释:</span><br><span class="line">1   (0 0 0 1)</span><br><span class="line">4   (0 1 0 0)</span><br><span class="line">       ↑   ↑</span><br><span class="line"></span><br><span class="line">上面的箭头指出了对应二进制位不同的位置。</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">hammingDistance</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = x ^ y;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (n != <span class="number">0</span>) </span><br><span class="line">        &#123;</span><br><span class="line">            n = n &amp; (n - <span class="number">1</span>);</span><br><span class="line">            ++res;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><a href="https://mp.weixin.qq.com/s?__biz=MzAxODQxMDM0Mw==&mid=2247486704&idx=2&sn=59b011722fe722551de8b56f234a4050&chksm=9bd7f2f8aca07bee47852e7bce72325157897ad0a3d5f383d18bca5379d66716518c2b968ae9&scene=21#wechat_redirect">原创 | 东哥教你几招常用的位运算技巧 (qq.com)</a></p>
]]></content>
      <categories>
        <category>算法</category>
        <category>数学</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>leetcode</tag>
        <tag>位运算</tag>
      </tags>
  </entry>
  <entry>
    <title>前缀和数组与差分数组</title>
    <url>/2021/04/23/%E6%95%B0%E7%BB%84%EF%BC%9A%E5%89%8D%E7%BC%80%E5%92%8C%E6%95%B0%E7%BB%84%E4%B8%8E%E5%B7%AE%E5%88%86%E6%95%B0%E7%BB%84/</url>
    <content><![CDATA[<p>&ensp;&ensp;&ensp;&ensp;当我们需要频繁地查询数组某个区间的累加和或频繁地对数组的某个区间的元素进行增减，便需要用到前缀和数组以及差分数组来提高效率</p>
<span id="more"></span>

<h3 id="一、概念简介"><a href="#一、概念简介" class="headerlink" title="一、概念简介"></a>一、概念简介</h3><p>&ensp;&ensp;&ensp;&ensp;<strong>前缀和数组</strong>：对于一个给定的数组 <code>nums</code>，额外开辟一个前缀和数组进行预处理：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">preSum</span><span class="params">(nums.size() + <span class="number">1</span>)</span></span>;</span><br><span class="line">preSum[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i++)</span><br><span class="line">&#123;</span><br><span class="line">    preSum[i + <span class="number">1</span>] = preSum[i] + nums[i];</span><br><span class="line">&#125;    </span><br></pre></td></tr></table></figure>

<p>&ensp;&ensp;&ensp;&ensp;前缀和数组 <code>preSum</code> 的含义很好理解，<code>preSum[i]</code> 就是 <code>nums[0..i-1]</code> 的和。那么如果我们想求 <code>nums[i...j]</code> 的和，只需要一步操作 <code>preSum[j+1] - preSum[i]</code> 即可，而不需要重新去遍历数组了。</p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>前缀和主要适用的场景是原始数组不会被修改的情况下，频繁查询某个区间的累加和</strong>。</p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>差分数组</strong>：对于一个给定的数组<code>nums</code>，额外开辟一个差分数组进行预处理：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">diff</span><span class="params">(nums.size())</span></span>;</span><br><span class="line">diff[<span class="number">0</span>] = diff[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; nums.<span class="built_in">size</span>(); ++i)</span><br><span class="line">&#123;</span><br><span class="line">    diff[i] = nums[i] - nums[i - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&ensp;&ensp;&ensp;&ensp;通过这个<code>diff</code>差分数组是可以反推出原始数组<code>nums</code>的，代码逻辑如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">nums</span><span class="params">(diff.size())</span></span>;</span><br><span class="line"><span class="comment">// 根据差分数组构造结果数组</span></span><br><span class="line">nums[<span class="number">0</span>] = diff[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; diff.<span class="built_in">size</span>(); ++i) </span><br><span class="line">&#123;</span><br><span class="line">    nums[i] = nums[i - <span class="number">1</span>] + diff[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&ensp;&ensp;&ensp;&ensp;这样构造差分数组<code>diff</code>，就可以快速进行区间增减的操作，如果你想对区间<code>nums[i..j]</code>的元素全部加 3，那么只需要让<code>diff[i] += 3</code>，然后再让<code>diff[j+1] -= 3</code>即可。</p>
<p>&ensp;&ensp;&ensp;&ensp;<code>diff[i] += 3</code>意味着给<code>nums[i..]</code>所有的元素都加了 3，然后<code>diff[j+1] -= 3</code>又意味着对于<code>nums[j+1..]</code>所有元素再减 3，那综合起来，就是对<code>nums[i..j]</code>中的所有元素都加 3 了。</p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>差分数组的主要适用场景是频繁对原始数组的某个区间的元素进行增减</strong>。</p>
<h3 id="二、举个例子"><a href="#二、举个例子" class="headerlink" title="二、举个例子"></a>二、举个例子</h3><p><a href="https://leetcode-cn.com/problems/subarray-sum-equals-k/">560. 和为K的子数组</a></p>
<p>&ensp;&ensp;&ensp;&ensp;给定一个整数数组和一个整数 <strong>k，</strong>你需要找到该数组中和为 <strong>k</strong> 的连续的子数组的个数。</p>
<p><strong>示例 1 :</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入:nums &#x3D; [1,1,1], k &#x3D; 2</span><br><span class="line">输出: 2 , [1,1] 与 [1,1] 为两种不同的情况。</span><br></pre></td></tr></table></figure>

<p><strong>说明 :</strong></p>
<ol>
<li> 数组的长度为 [1, 20,000]。</li>
<li> 数组中元素的范围是 [-1000, 1000] ，且整数 <strong>k</strong> 的范围是 [-1e7, 1e7]。</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">subarraySum</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt; nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">  <span class="comment">// 构造前缀和</span></span><br><span class="line">  <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">sum</span><span class="params">(n + <span class="number">1</span>)</span></span>;</span><br><span class="line">  sum[<span class="number">0</span>] = <span class="number">0</span>; </span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    sum[i + <span class="number">1</span>] = sum[i] + nums[i];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">  <span class="comment">// 穷举所有子数组</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">  &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; j++)</span><br><span class="line">      &#123;</span><br><span class="line">          <span class="comment">// sum of nums[j..i-1]</span></span><br><span class="line">          <span class="keyword">if</span> (sum[i] - sum[j] == k)</span><br><span class="line">          &#123;</span><br><span class="line">               ans++;</span><br><span class="line">          &#125;             </span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">    </span><br><span class="line">  <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&ensp;&ensp;&ensp;&ensp;前缀和进阶，与 unordered_map 结合。</p>
<p>&ensp;&ensp;&ensp;&ensp;前面的解法有嵌套的 for 循环：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line"> &#123;</span><br><span class="line">     <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; j++)</span><br><span class="line">     &#123;</span><br><span class="line">         <span class="comment">// sum of nums[j..i-1]</span></span><br><span class="line">         <span class="keyword">if</span> (sum[i] - sum[j] == k)</span><br><span class="line">         &#123;</span><br><span class="line">              ans++;</span><br><span class="line">         &#125;             </span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>&ensp;&ensp;&ensp;&ensp;第二层 for 循环在计算有几个<code>j</code>能够使得<code>sum[i]</code>和<code>sum[j]</code>的差为 k。毎找到一个这样的<code>j</code>，就把结果加一。</p>
<p>&ensp;&ensp;&ensp;&ensp;我们可以把 if 语句里的条件判断移项，这样写：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if (sum[j] &#x3D;&#x3D; sum[i] - k)</span><br><span class="line">    ans++;</span><br></pre></td></tr></table></figure>

<p>&ensp;&ensp;&ensp;&ensp;优化的思路是：<strong>我直接记录下有几个<code>sum[j]</code>和<code>sum[i]-k</code>相等，直接更新结果，就避免了内层的 for 循环</strong>。我们可以用哈希表，在记录前缀和的同时记录该前缀和出现的次数。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">subarraySum</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        unordered_map&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; mp;</span><br><span class="line">        mp[<span class="number">0</span>] = <span class="number">1</span>;			<span class="comment">//前缀和为 0 的子数组个数为 1</span></span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> pre = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; x : nums)</span><br><span class="line">        &#123;</span><br><span class="line">            pre += x;	<span class="comment">//前缀和，直接采用一个变量</span></span><br><span class="line">            <span class="keyword">if</span> (mp.<span class="built_in">find</span>(pre - k) != mp.<span class="built_in">end</span>()) <span class="comment">//pre - k 是目标区间前面数组元素的前缀和</span></span><br><span class="line">            &#123;</span><br><span class="line">                count += mp[pre - k];</span><br><span class="line">            &#125;</span><br><span class="line">            ++mp[pre];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="1109-航班预订统计"><a href="#1109-航班预订统计" class="headerlink" title="1109. 航班预订统计"></a><a href="https://leetcode-cn.com/problems/corporate-flight-bookings/">1109. 航班预订统计</a></h4><p>&ensp;&ensp;&ensp;&ensp;这里有 <code>n</code> 个航班，它们分别从 <code>1</code> 到 <code>n</code> 进行编号。</p>
<p>&ensp;&ensp;&ensp;&ensp;有一份航班预订表 <code>bookings</code> ，表中第 <code>i</code> 条预订记录 <code>bookings[i] = [firsti, lasti, seatsi]</code> 意味着在从 <code>firsti</code> 到 <code>lasti</code> （<strong>包含</strong> <code>firsti</code> 和 <code>lasti</code> ）的 <strong>每个航班</strong> 上预订了 <code>seatsi</code> 个座位。</p>
<p>&ensp;&ensp;&ensp;&ensp;请你返回一个长度为 <code>n</code> 的数组 <code>answer</code>，其中 <code>answer[i]</code> 是航班 <code>i</code> 上预订的座位总数。</p>
<p> <strong>示例 1：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：bookings &#x3D; [[1,2,10],[2,3,20],[2,5,25]], n &#x3D; 5</span><br><span class="line">输出：[10,55,45,25,25]</span><br><span class="line">解释：</span><br><span class="line">航班编号        1   2   3   4   5</span><br><span class="line">预订记录 1 ：   10  10</span><br><span class="line">预订记录 2 ：       20  20</span><br><span class="line">预订记录 3 ：       25  25  25  25</span><br><span class="line">总座位数：      10  55  45  25  25</span><br><span class="line">因此，answer &#x3D; [10,55,45,25,25]</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：bookings &#x3D; [[1,2,10],[2,2,15]], n &#x3D; 2</span><br><span class="line">输出：[10,25]</span><br><span class="line">解释：</span><br><span class="line">航班编号        1   2</span><br><span class="line">预订记录 1 ：   10  10</span><br><span class="line">预订记录 2 ：       15</span><br><span class="line">总座位数：      10  25</span><br><span class="line">因此，answer &#x3D; [10,25]</span><br></pre></td></tr></table></figure>

<p> <strong>提示：</strong></p>
<ul>
<li>  <code>1 &lt;= n &lt;= 2 * 104</code></li>
<li>  <code>1 &lt;= bookings.length &lt;= 2 * 104</code></li>
<li>  <code>bookings[i].length == 3</code></li>
<li>  <code>1 &lt;= firsti &lt;= lasti &lt;= n</code></li>
<li>  <code>1 &lt;= seatsi &lt;= 104</code></li>
</ul>
<p>&ensp;&ensp;&ensp;&ensp;直接上差分数组：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">corpFlightBookings</span><span class="params">(vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; bookings, <span class="keyword">int</span> n)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">res</span><span class="params">(n,<span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">diff</span><span class="params">(n+<span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; bookings.<span class="built_in">size</span>(); ++k)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> i = bookings[k][<span class="number">0</span>] - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">int</span> j = bookings[k][<span class="number">1</span>] - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">int</span> seat = bookings[k][<span class="number">2</span>];</span><br><span class="line">            diff[i] = diff[i] + seat;</span><br><span class="line">            diff[j+<span class="number">1</span>] = diff[j+<span class="number">1</span>] - seat;</span><br><span class="line">        &#125;</span><br><span class="line">        res[<span class="number">0</span>] = diff[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">1</span>; k &lt; n; k++)</span><br><span class="line">        &#123;</span><br><span class="line">            res[k] = res[k<span class="number">-1</span>] + diff[k];</span><br><span class="line">        &#125;          </span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>[参考：论那些小而美的算法技巧：差分数组/前缀和](<a href="https://mp.weixin.qq.com/s?__biz=MzAxODQxMDM0Mw==&mid=2247487011&idx=1&sn=5e2b00c1c736fd7afbf3ed35edc4aeec&chksm=9bd7f02baca0793d569a9633cc14117e708ccc9eb41b7f0add430ea78f22e4f2443f421c6841&scene=21#wechat_redirect">论那些小而美的算法技巧：差分数组/前缀和 (qq.com)</a>)</p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>leetcode</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title>缺失的第一个整数</title>
    <url>/2021/04/21/%E7%AE%97%E6%B3%95%EF%BC%9A%E7%BC%BA%E5%A4%B1%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E6%AD%A3%E6%95%B0/</url>
    <content><![CDATA[<h3 id="一、简介"><a href="#一、简介" class="headerlink" title="一、简介"></a>一、简介</h3><p>&ensp;&ensp;&ensp;&ensp;2021年拼多多暑期实习技术面一面时碰到了这道题，面试官直接告诉我这是道 hard 级别的题目，还问我要不要换一道，当时头铁，没想换，结果就是代码各种细节漏洞（拼多多面试平台不能运行代码，很痛苦），最后还是换了一道二叉树的 medium 题。</p>
 <span id="more"></span>

<p>&ensp;&ensp;&ensp;&ensp;题目描述：(<a href="https://leetcode-cn.com/problems/first-missing-positive/">leetcode: 41</a>)</p>
<p>&ensp;&ensp;&ensp;&ensp;给你一个未排序的整数数组 <code>nums</code> ，请你找出其中没有出现的最小的正整数要求时间复杂度O(n)，空间复杂度O(1)</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：nums &#x3D; [1,2,0]</span><br><span class="line">输出：3</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：nums &#x3D; [3,4,-1,1]</span><br><span class="line">输出：2</span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：nums &#x3D; [7,8,9,11,12]</span><br><span class="line">输出：1</span><br></pre></td></tr></table></figure>

<p> <strong>提示：</strong></p>
<ul>
<li>  <code>0 &lt;= nums.length &lt;= 300</code></li>
<li>  <code>-231 &lt;= nums[i] &lt;= 231 - 1</code></li>
</ul>
<h3 id="二、题目分析"><a href="#二、题目分析" class="headerlink" title="二、题目分析"></a>二、题目分析</h3><p>&ensp;&ensp;&ensp;&ensp;首先，我们可以确定给定数组的缺失的最小整数的范围：[1, nums.size() + 1]，因此我们可以把数组中的元素<strong>归位</strong>，比如数组中的 1 放在数组第1个位置， 2 放在数组第2个位置……</p>
<p>&ensp;&ensp;&ensp;&ensp;然后从头遍历该数组，当 <code>nums[i] - 1 != i</code>时，返回 <code>i + 1</code>即可；若遍历完仍然没返回值，则返回<code>nums.size() + 1</code>。</p>
<p>&ensp;&ensp;&ensp;&ensp;重点是<strong>归位</strong>元素，使数组中的元素 <code>a</code>，归位到 <code>nums[a - 1]</code>（a的范围有限制），还要考虑<code>a</code>的目标位置上的元素不被覆盖。</p>
<blockquote>
<p>  所以应该交换 a 和 目标位置的元素，这是原来 a 的位置有了新元素，再归位这个新元素。（不要以为只交换一次，新元素可能 ‘’德不配位’‘ ）</p>
</blockquote>
<p>&ensp;&ensp;&ensp;&ensp;例：[3, 4, -1, 1] → [-1, 4, 3, 1] → [-1, 1, 3, 4] → [1, -1, 3, 4]</p>
<ol>
<li> 归位 3， -1 换到 nums[0]，-1 不满足范围限制</li>
<li> 归位 4， 1 换到 nums[1]; 再归位 1，使nums[0] = 1, -1换到nums[1] 处</li>
<li> 再归位后面的元素</li>
</ol>
<p>代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">firstMissingPositive</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> length = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//范围限制</span></span><br><span class="line">            <span class="keyword">while</span> (nums[i] &gt; <span class="number">0</span> &amp;&amp; </span><br><span class="line">                   nums[i] &lt;= nums.<span class="built_in">size</span>() &amp;&amp; </span><br><span class="line">                   nums[nums[i] - <span class="number">1</span>] != nums[i]) </span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">swap</span>(nums[i], nums[nums[i] - <span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); ++i) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] - <span class="number">1</span> != i) </span><br><span class="line">                <span class="keyword">return</span> i + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums.<span class="built_in">size</span>() + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>&ensp;&ensp;&ensp;&ensp;更多博客，敬请期待。</p>
]]></content>
      <categories>
        <category>算法</category>
        <category>遇到的笔试（面试）题</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>leetcode</tag>
        <tag>数组</tag>
        <tag>拼多多实习面试</tag>
      </tags>
  </entry>
  <entry>
    <title>MySql8.0窗口函数</title>
    <url>/2021/04/21/%E6%95%B0%E6%8D%AE%E5%BA%93%EF%BC%9AMySql8.0%E7%AA%97%E5%8F%A3%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<h3 id="一、基本概念"><a href="#一、基本概念" class="headerlink" title="一、基本概念"></a>一、基本概念</h3><p>&ensp;&ensp;&ensp;&ensp;MySQL从<strong>8.0</strong>开始支持窗口函数，这个功能在大多商业数据库和部分开源数据库中早已支持，有的也叫分析函数。</p>
 <span id="more"></span>

<p>概念：</p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>窗口</strong>的概念可以理解为记录集合；<strong>窗口函数</strong>也就是在满足某种条件的记录集合上执行的特殊函数，对于每条记录都要在此窗口内执行函数，有的函数随着记录不同，窗口大小都是固定的，这种是静态窗口；有的函数则是不同的记录对应着不同的窗口，这种动态变化的窗口叫滑动窗口。</p>
<p>窗口函数与聚合函数：</p>
<ol>
<li>聚合函数是将多条记录聚合为一条；</li>
<li>窗口函数是每条记录都会执行，有几条记录执行完还是几条；</li>
<li>聚合函数也可以用于窗口函数。</li>
</ol>
<h3 id="二、基本格式"><a href="#二、基本格式" class="headerlink" title="二、基本格式"></a>二、基本格式</h3><p>基本语法：&lt;窗口函数&gt; over (子句)</p>
<ul>
<li><p>&lt;窗口函数&gt;的位置可以放专用窗口函数（rank()，percent_rank()，dense_rank()等），或者放聚合函数（sum()，avg()，max()等）。</p>
</li>
<li><p>窗口函数是对where或group by子句处理后的结果进行操作，故其原则上只写于SELECT子句中。</p>
</li>
<li><p>over 用来指定函数执行的窗口范围，<strong>若子句为空</strong>，则意味着窗口包含满足WHERE条件的所有行，窗口函数基于所有行进行计算。</p>
</li>
<li><p>若子句非空，则支持以下4中语法来设置窗口：</p>
<p>​        <strong>window_name</strong>：给窗口指定一个别名，如果SQL中涉及的窗口较多，采用别名可以看起来更清晰易读。        </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT</span><br><span class="line">	&#96;姓名&#96;,</span><br><span class="line">	&#96;班级&#96;,</span><br><span class="line">	&#96;人气&#96;,</span><br><span class="line">	rank() over w1 AS rak</span><br><span class="line">FROM</span><br><span class="line">	&#96;民工漫班级&#96; window w1 AS ( PARTITION BY &#96;班级&#96; ORDER BY &#96;人气&#96; DESC );</span><br></pre></td></tr></table></figure>

<p>​        结果：</p>
<img src="/2021/04/21/%E6%95%B0%E6%8D%AE%E5%BA%93%EF%BC%9AMySql8.0%E7%AA%97%E5%8F%A3%E5%87%BD%E6%95%B0/1.png" alt="image-20201217104056497" style="zoom:80%;">

<p>​        <strong>partition子句</strong>：窗口按照那些字段进行分组，窗口函数在不同的分组上分别执行。</p>
<p>​        <strong>order by子句</strong>：按照哪些字段进行排序，窗口函数将按照排序后的记录顺序进行编号。</p>
<p>​        frame子句：frame是当前分区的一个子集，子句用来定义子集的规则，通常用来作为滑动窗口使用。（本文暂不介绍）</p>
<p>​        用于操作示例新建的民工漫班级表：</p>
<img src="/2021/04/21/%E6%95%B0%E6%8D%AE%E5%BA%93%EF%BC%9AMySql8.0%E7%AA%97%E5%8F%A3%E5%87%BD%E6%95%B0/2.png" alt="民工漫班级" style="zoom: 67%;">

<p>​        </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT</span><br><span class="line">	*,</span><br><span class="line">	RANK() over ( PARTITION BY &#96;班级&#96; ORDER BY &#96;人气&#96; DESC ) AS ranking </span><br><span class="line">FROM</span><br><span class="line">	&#96;民工漫班级&#96;;</span><br><span class="line"># PARTITION BY &#96;班级&#96;：按班级分组（使用group by会改变表的行数，一个类别只保留一行；partition by则不会减少表的行数）</span><br><span class="line"># ORDER BY &#96;人气&#96; DESC：对按班级分组后的结果按人气降序排名，名次作为字段 ranking</span><br></pre></td></tr></table></figure>

<p>得到结果：</p>
<img src="/2021/04/21/%E6%95%B0%E6%8D%AE%E5%BA%93%EF%BC%9AMySql8.0%E7%AA%97%E5%8F%A3%E5%87%BD%E6%95%B0/3.png" alt="image-20201217000959621" style="zoom: 50%;"></li>
</ul>
<h3 id="三、mysql窗口函数"><a href="#三、mysql窗口函数" class="headerlink" title="三、mysql窗口函数"></a>三、mysql窗口函数</h3><p><strong>功能划分</strong>：</p>
<p> 按功能划分可将MySQL支持的窗口函数分为如下几类：</p>
<ol>
<li>序号函数：ROW_NUMBER()、RANK()、DENSE_RANK()</li>
<li>分布函数：PERCENT_RANK()、CUME_DIST()，PERCENT_RANK()</li>
<li>前后函数：LAG(expr,n)、LEAD(expr,n)</li>
<li>头尾函数：FIRST_VALUE(expr)、LAST_VALUE(expr)</li>
<li>其它函数：NTH_VALUE(expr, n)、NTILE(n)</li>
</ol>
<p><strong>分别介绍：</strong></p>
<p><strong>序号函数：ROW_NUMBER()、RANK()、DENSE_RANK()</strong></p>
<p>&ensp;&ensp;&ensp;&ensp;举个例子，还用上面的民工漫班级表，用三个函数按人气对其排序：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT</span><br><span class="line">	*,</span><br><span class="line">	RANK() over (  ORDER BY &#96;人气&#96; DESC ) AS &#96;rank&#96; ,</span><br><span class="line">	DENSE_RANK() over (  ORDER BY &#96;人气&#96; DESC ) AS &#96;dense_rank&#96; ,</span><br><span class="line">	ROW_NUMBER() over (  ORDER BY &#96;人气&#96; DESC ) AS &#96;row_number&#96; </span><br><span class="line">FROM</span><br><span class="line">	&#96;民工漫班级&#96;;</span><br></pre></td></tr></table></figure>

<p>&ensp;&ensp;&ensp;&ensp;结果：没有再用partition by对班级分组</p>
<img src="/2021/04/21/%E6%95%B0%E6%8D%AE%E5%BA%93%EF%BC%9AMySql8.0%E7%AA%97%E5%8F%A3%E5%87%BD%E6%95%B0/4.png" alt="image-20201217004449218" style="zoom: 67%;">

<p>由此可知：</p>
<ul>
<li>RANK()：并列排序，跳过重复序号——1、1、3</li>
<li>DENSE_RANK()：并列排序，不跳过重复序号——1、1、2</li>
<li>ROW_NUMBER()：顺序排序——1、2、3；相当于行号。</li>
</ul>
<p><strong>分布函数：PERCENT_RANK()、CUME_DIST()</strong></p>
<p><strong>percent_rank()</strong></p>
<p>&ensp;&ensp;&ensp;&ensp;用途：和之前的RANK()函数相关，每行按照如下公式进行计算：(rank - 1) / (rows - 1)， 其中，rank为RANK()函数产生的序号，rows为当前窗口的记录总行数 该函数可以用来计算分位数。</p>
<p>&ensp;&ensp;&ensp;&ensp;继续举例子（想不到实际生活的应用场景）：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT</span><br><span class="line">	*,</span><br><span class="line">	RANK() OVER w AS rankNo,</span><br><span class="line">	PERCENT_RANK() OVER w AS percent_rankNo </span><br><span class="line">FROM</span><br><span class="line">	&#96;民工漫班级&#96; WINDOW w AS ( ORDER BY &#96;人气&#96; DESC );</span><br></pre></td></tr></table></figure>

<p>结果：</p>
<img src="/2021/04/21/%E6%95%B0%E6%8D%AE%E5%BA%93%EF%BC%9AMySql8.0%E7%AA%97%E5%8F%A3%E5%87%BD%E6%95%B0/5.png" alt="image-20201217105136040" style="zoom: 50%;">

<p>&ensp;&ensp;&ensp;&ensp;对于路飞，percent_rankNo = (rank - 1) / (rows - 1) =(3 - 1) / (10 - 1) =0.22222222……</p>
<p><strong>CUME_DIST()</strong></p>
<p>&ensp;&ensp;&ensp;&ensp;用途：分组内小于、等于当前rank值的行数 / 分组内总行数</p>
<p>&ensp;&ensp;&ensp;&ensp;举例：查询小于等于当前人气的比例（或者说某人是前百分之几，生活中很常用）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT</span><br><span class="line">	*,</span><br><span class="line">	CUME_DIST() OVER w AS cdt </span><br><span class="line">FROM</span><br><span class="line">	&#96;民工漫班级&#96; WINDOW w AS ( ORDER BY &#96;人气&#96; DESC );</span><br></pre></td></tr></table></figure>

<p>结果：</p>
<img src="/2021/04/21/%E6%95%B0%E6%8D%AE%E5%BA%93%EF%BC%9AMySql8.0%E7%AA%97%E5%8F%A3%E5%87%BD%E6%95%B0/6.png" alt="image-20201217110444956" style="zoom: 67%;">

<p><strong>前后函数：LAG(expr,n)、LEAD(expr,n)</strong></p>
<p>&ensp;&ensp;&ensp;&ensp;用途：返回位于当前行的前n行（LAG(expr,n)）或后n行（LEAD(expr,n)）的expr的值（以当前行为原点）</p>
<p>&ensp;&ensp;&ensp;&ensp;例：这个生活中应该挺常用</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT</span><br><span class="line">	*,</span><br><span class="line">	&#96;我的前面一名人气&#96; - &#96;人气&#96; AS &#96;我和前面一名的差距&#96;,</span><br><span class="line">	&#96;人气&#96; - &#96;后面一名人气&#96; AS &#96;我甩开后面一名多少差距&#96; </span><br><span class="line">FROM</span><br><span class="line">	(</span><br><span class="line">	SELECT</span><br><span class="line">		*,</span><br><span class="line">		LAG( &#96;人气&#96;, 1 ) OVER w AS &#96;我的前面一名人气&#96;,# 取前面第一行的人气值</span><br><span class="line">		LEAD( &#96;人气&#96;, 1 ) OVER w AS &#96;后面一名人气&#96; # 取后面第一行的人气值</span><br><span class="line">		</span><br><span class="line">	FROM</span><br><span class="line">		&#96;民工漫班级&#96; WINDOW w AS ( ORDER BY &#96;人气&#96; DESC ) </span><br><span class="line">	) t;</span><br></pre></td></tr></table></figure>

<p>结果：</p>
<img src="/2021/04/21/%E6%95%B0%E6%8D%AE%E5%BA%93%EF%BC%9AMySql8.0%E7%AA%97%E5%8F%A3%E5%87%BD%E6%95%B0/7.png" alt="image-20201217113619889" style="zoom: 67%;">

<p>&ensp;&ensp;&ensp;&ensp;蓝染的前1行是路飞，其人气为90，差距为2；后一行是佐助，甩开他1人气。</p>
<p><strong>头尾函数：FIRST_VALUE(expr),LAST_VALUE(expr)</strong></p>
<p>&ensp;&ensp;&ensp;&ensp;用途：返回第一个（FIRST_VALUE(expr)）或最后一个（LAST_VALUE(expr)）expr的值</p>
<p>&ensp;&ensp;&ensp;&ensp;例：截止到当前人气，按人气排名，第一名和最后一名是多少（降序排，最后一名肯定是自己）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT</span><br><span class="line">	*,</span><br><span class="line">	FIRST_VALUE( &#96;人气&#96; ) OVER w AS &#96;当前第一人气值&#96;,</span><br><span class="line">	LAST_VALUE( &#96;人气&#96; ) OVER w AS &#96;当前倒数第一人气值&#96; </span><br><span class="line">FROM</span><br><span class="line">	&#96;民工漫班级&#96; WINDOW w AS ( ORDER BY &#96;人气&#96; DESC );</span><br></pre></td></tr></table></figure>

<p>结果：</p>
<img src="/2021/04/21/%E6%95%B0%E6%8D%AE%E5%BA%93%EF%BC%9AMySql8.0%E7%AA%97%E5%8F%A3%E5%87%BD%E6%95%B0/8.png" alt="image-20201217114336947" style="zoom: 67%;">

<p><strong>其它函数：NTH_VALUE(expr, n)、NTILE(n)</strong></p>
<p><strong>NTH_VALUE(expr, n)</strong></p>
<p>&ensp;&ensp;&ensp;&ensp;用途：返回窗口中第N个expr的值，expr可以是表达式，也可以是列名。</p>
<p>&ensp;&ensp;&ensp;&ensp;例：截至当前人气，显示每个人物的人气中排名第2、第4、第6的人气值</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT</span><br><span class="line">	*,</span><br><span class="line">	NTH_VALUE( &#96;人气&#96;, 2 ) OVER w AS &#96;第二人气值&#96;,</span><br><span class="line">	NTH_VALUE( &#96;人气&#96;, 4 ) OVER w AS &#96;第四人气值&#96;,</span><br><span class="line">	NTH_VALUE( &#96;人气&#96;, 6 ) OVER w AS &#96;第六人气值&#96; </span><br><span class="line">FROM</span><br><span class="line">	&#96;民工漫班级&#96; WINDOW w AS ( ORDER BY &#96;人气&#96; DESC );</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>结果：</p>
<img src="/2021/04/21/%E6%95%B0%E6%8D%AE%E5%BA%93%EF%BC%9AMySql8.0%E7%AA%97%E5%8F%A3%E5%87%BD%E6%95%B0/9.png" alt="image-20201217135748608" style="zoom: 67%;">

<p><strong>NTILE(n)</strong></p>
<p>&ensp;&ensp;&ensp;&ensp;用途：将分区中的有序数据分为n个等级，记录等级数</p>
<p>例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT</span><br><span class="line">	*,</span><br><span class="line">	ROW_NUMBER() OVER w AS &#39;row_number&#39;,</span><br><span class="line">	NTILE( 2 ) OVER w AS &#39;ntile2&#39;,</span><br><span class="line">	NTILE( 4 ) OVER w AS &#39;ntile4&#39; </span><br><span class="line">FROM</span><br><span class="line">	&#96;民工漫班级&#96; WINDOW w AS ( ORDER BY &#96;人气&#96; );</span><br></pre></td></tr></table></figure>

<p>结果：</p>
<img src="/2021/04/21/%E6%95%B0%E6%8D%AE%E5%BA%93%EF%BC%9AMySql8.0%E7%AA%97%E5%8F%A3%E5%87%BD%E6%95%B0/10.png" alt="image-20201217170421940" style="zoom:67%;">

<h3 id="四、用聚合函数作为窗口函数"><a href="#四、用聚合函数作为窗口函数" class="headerlink" title="四、用聚合函数作为窗口函数"></a>四、用聚合函数作为窗口函数</h3><p>&ensp;&ensp;&ensp;&ensp;用途：在窗口中每条记录动态地应用聚合函数（SUM()、AVG()、MAX()、MIN()、COUNT()），可以动态计算在指定的窗口内的各种聚合函数值</p>
<p>例：普通使用：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT</span><br><span class="line">	*,</span><br><span class="line">	sum( &#96;人气&#96; )  AS current_sum,</span><br><span class="line">	avg( &#96;人气&#96; )  AS current_avg,</span><br><span class="line">	count( &#96;人气&#96; )  AS current_count,</span><br><span class="line">	max( &#96;人气&#96; )  AS current_max,</span><br><span class="line">	min( &#96;人气&#96; ) AS current_min </span><br><span class="line">FROM</span><br><span class="line">	&#96;民工漫班级&#96;;</span><br></pre></td></tr></table></figure>

<p>结果：</p>
<img src="/2021/04/21/%E6%95%B0%E6%8D%AE%E5%BA%93%EF%BC%9AMySql8.0%E7%AA%97%E5%8F%A3%E5%87%BD%E6%95%B0/11.png" alt="image-20201217172447565" style="zoom: 67%;">

<p>&ensp;&ensp;&ensp;&ensp;按学号排序，作为窗口函数：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT</span><br><span class="line">	*,</span><br><span class="line">	sum( &#96;人气&#96; ) over w AS current_sum,</span><br><span class="line">	avg( &#96;人气&#96; ) over w AS current_avg,</span><br><span class="line">	count( &#96;人气&#96; ) over w AS current_count,</span><br><span class="line">	max( &#96;人气&#96; ) over w AS current_max,</span><br><span class="line">	min( &#96;人气&#96; ) over w AS current_min </span><br><span class="line">FROM</span><br><span class="line">	&#96;民工漫班级&#96; WINDOW w AS ( ORDER BY &#96;学号&#96; );</span><br></pre></td></tr></table></figure>

<p>结果：</p>
<img src="/2021/04/21/%E6%95%B0%E6%8D%AE%E5%BA%93%EF%BC%9AMySql8.0%E7%AA%97%E5%8F%A3%E5%87%BD%E6%95%B0/12.png" alt="image-20201217172207911" style="zoom:67%;">

<p>&ensp;&ensp;&ensp;&ensp;以current_sum为例，每一行current_sum的值为上面所有行的<code>人气</code>值之和。</p>
<p>本文主要参考：</p>
<p><a href="https://dev.mysql.com/doc/refman/8.0/en/">《MySql8.0参考手册》</a></p>
]]></content>
      <categories>
        <category>数据库</category>
        <category>MySql</category>
      </categories>
      <tags>
        <tag>数据库</tag>
        <tag>窗口函数</tag>
        <tag>MySql</tag>
      </tags>
  </entry>
</search>
