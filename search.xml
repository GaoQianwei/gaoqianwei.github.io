<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>函数模板</title>
    <url>/2021/05/07/C++%E6%B3%9B%E5%9E%8B%EF%BC%9A%E5%87%BD%E6%95%B0%E6%A8%A1%E6%9D%BF/</url>
    <content><![CDATA[<h3 id="一、简介"><a href="#一、简介" class="headerlink" title="一、简介"></a>一、简介</h3><p>    在C++中，数据的类型也可以通过参数来传递，在函数定义时可以不指明具体的数据类型，当发生函数调用时，编译器可以根据传入的实参自动推断数据类型。这就是类型的参数化。</p>
<span id="more"></span>

<p>    函数模板是一种特殊的函数，可以使用不同的类型进行调用，对于功能相同的函数，不需要重复编写代码，并且函数模板与普通函数看起来很类似，区别就是类型可以被参数化。</p>
<h3 id="二、语法"><a href="#二、语法" class="headerlink" title="二、语法"></a>二、语法</h3><p>    函数模板的语法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">template &lt;typename 类型参数1 , typename 类型参数2 , ...&gt; 返回值类型  函数名(形参列表)&#123;</span><br><span class="line">  &#x2F;&#x2F;在函数体中可以使用类型参数</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>    类型参数可以有多个，它们之间以逗号<code>,</code>分隔。类型参数列表以<code>&lt; &gt;</code>包围，形式参数列表以<code>( )</code>包围。</p>
<p>    <code>typename</code>关键字也可以使用<code>class</code>关键字替代，它们没有任何区别。C++ 早期对模板的支持并不严谨，没有引入新的关键字，而是用 class 来指明类型参数，但是 class 关键字本来已经用在类的定义中了，这样做显得不太友好，所以后来 C++ 又引入了一个新的关键字 typename，专门用来定义类型参数。不过至今仍然有很多代码在使用 class 关键字，包括 C++ 标准库、一些开源程序等。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _CRT_SECURE_NO_WARNINGS</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> 0 </span></span><br><span class="line"><span class="comment">//int类型数据交换</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MySwap</span><span class="params">(<span class="keyword">int</span>&amp; a, <span class="keyword">int</span>&amp; b)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> temp = a;</span><br><span class="line">	a = b;</span><br><span class="line">	b = temp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//double类型</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MySwap</span><span class="params">(<span class="keyword">double</span>&amp; a, <span class="keyword">double</span>&amp; b)</span></span>&#123;</span><br><span class="line">	<span class="keyword">double</span> temp = a;</span><br><span class="line">	a = b;</span><br><span class="line">	b = temp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//模板技术 类型参数化 编写代码可以忽略类型</span></span><br><span class="line"><span class="comment">//为了让编译器区分是普通函数  模板函数</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T1</span>,<span class="keyword">class</span> <span class="title">T2</span>&gt;</span> <span class="comment">//template&lt;typename T&gt;告诉编译器 ，下面写模板函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MySwap</span><span class="params">(T&amp; a, T&amp; b)</span></span>&#123;</span><br><span class="line">	T temp = a;</span><br><span class="line">	a = b;</span><br><span class="line">	b = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> a = <span class="number">30</span>;</span><br><span class="line">	<span class="keyword">int</span> b = <span class="number">20</span>;</span><br><span class="line">	<span class="comment">//1 自动类型推导,编译器根据你传的值 进行类型自动推导</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;a:&quot;</span> &lt;&lt; a &lt;&lt; <span class="string">&quot; b:&quot;</span> &lt;&lt; b &lt;&lt; endl;</span><br><span class="line">	<span class="built_in">MySwap</span>(a, b); </span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;a:&quot;</span> &lt;&lt; a &lt;&lt; <span class="string">&quot; b:&quot;</span> &lt;&lt; b &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">double</span> da = <span class="number">12.3</span>;</span><br><span class="line">	<span class="keyword">double</span> db = <span class="number">21.1</span>;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;da:&quot;</span> &lt;&lt; da &lt;&lt; <span class="string">&quot; db:&quot;</span> &lt;&lt; db &lt;&lt; endl;</span><br><span class="line">	<span class="built_in">MySwap</span>(da, db);</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;da:&quot;</span> &lt;&lt; da &lt;&lt; <span class="string">&quot; db:&quot;</span> &lt;&lt; db &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//2. 显式的指定类型</span></span><br><span class="line">	MySwap&lt;<span class="keyword">int</span>&gt;(a, b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;	</span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="三、函数模板跟普通函数"><a href="#三、函数模板跟普通函数" class="headerlink" title="三、函数模板跟普通函数"></a>三、函数模板跟普通函数</h3><p>    函数模板跟普通函数一样，也可以被重载</p>
<ul>
<li>C++编译器优先考虑普通函数</li>
<li>如果函数模板可以产生一个更好的匹配，那么就选择函数模板</li>
<li>也可以通过空模板实参列表&lt;&gt;限定编译器只匹配函数模板</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _CRT_SECURE_NO_WARNINGS</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">MyAdd</span><span class="params">(T a,T b)</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//普通函数可以进行自动类型转换</span></span><br><span class="line"><span class="comment">//函数模板必须严格类型匹配</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">MyAdd</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> c)</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> a + c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span>&#123;	</span><br><span class="line">	<span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">	<span class="keyword">int</span> b = <span class="number">20</span>;</span><br><span class="line">	<span class="keyword">char</span> c1 = <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">	<span class="keyword">char</span> c2 = <span class="string">&#x27;b&#x27;</span>;</span><br><span class="line"></span><br><span class="line">	MyAdd&lt;&gt;(a,b);<span class="comment">//限定只使用函数模板</span></span><br><span class="line"> </span><br><span class="line">	<span class="built_in">MyAdd</span>(a,c1);<span class="comment">//这个调用，函数模板有更好的匹配，于是调用函数模板</span></span><br><span class="line">	<span class="built_in">MyAdd</span>(a, b);<span class="comment">//普通函数int MyAdd(int a,int c)已经能完美匹配，于是调用普通函数</span></span><br><span class="line">	<span class="built_in">MyAdd</span>(c1,b);<span class="comment">//这个调用，函数模板有更好的匹配，于是调用函数模板</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//函数模板被重载</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Print</span><span class="params">(T a)</span></span>&#123;	</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Print</span><span class="params">(T a , T b)</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">test01</span>();	</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="四、函数模板机制："><a href="#四、函数模板机制：" class="headerlink" title="四、函数模板机制："></a>四、函数模板机制：</h3><ul>
<li>编译器并不是把函数模板处理成能够处理任何类型的函数</li>
<li>函数模板通过具体类型产生不同的函数</li>
<li>编译器会对函数模板进行再次编译，在声明的地方对模板代码本身进行编译，在调用的地方对参数替换后的代码进行编译。</li>
</ul>
]]></content>
      <categories>
        <category>C++</category>
        <category>泛型</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>泛型</tag>
      </tags>
  </entry>
  <entry>
    <title>类模板</title>
    <url>/2021/05/07/C++%E6%B3%9B%E5%9E%8B%EF%BC%9A%E7%B1%BB%E6%A8%A1%E6%9D%BF/</url>
    <content><![CDATA[<h3 id="一、简介"><a href="#一、简介" class="headerlink" title="一、简介"></a>一、简介</h3><p>    类模板和函数模板的定义及使用类似。有时，有两个或多个类，其功能是相同的，仅仅是数据类型不同。</p>
<span id="more"></span>

<ul>
<li>类模板用于实现类所需数据的类型参数化</li>
<li>类模板在表示如数组、表、图等数据结构显得特别重要，这些数据结构的表示和算法不受所包含的数据类型的影响。</li>
</ul>
<h3 id="二、语法"><a href="#二、语法" class="headerlink" title="二、语法"></a>二、语法</h3><p>    C++ 中类模板的写法如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;类型参数表&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> 类模板名&#123;</span></span><br><span class="line">  成员函数和成员变量</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>    类型参数表的写法如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span>类塑参数1, <span class="keyword">class</span>类型参数2, ...</span></span><br></pre></td></tr></table></figure>

<p>    类模板中的成员函数放到类模板定义外面写时的语法如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;类型参数表&gt;</span><br><span class="line">返回值类型 类模板名&lt;类型参数名列表&gt;::成员函数名(参数表)</span><br><span class="line">&#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>    用类模板定义对象的写法如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">类模板名&lt;真实类型参数表&gt; 对象名(构造函数实际参数表);</span><br></pre></td></tr></table></figure>

<p>    如果类模板有无参构造函数，那么也可以使用如下写法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">类模板名 &lt;真实类型参数表&gt; 对象名;</span><br></pre></td></tr></table></figure>

<p>    例：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Person</span>(T id,T age)&#123;</span><br><span class="line">		<span class="keyword">this</span>-&gt;mAge = age;</span><br><span class="line">		<span class="keyword">this</span>-&gt;mId = id;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">Show</span><span class="params">()</span></span>&#123;	</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;ID:&quot;</span> &lt;&lt; mId &lt;&lt; <span class="string">&quot; Age:&quot;</span> &lt;&lt; mAge &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	T mId;</span><br><span class="line">	T mAge;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span>&#123;	</span><br><span class="line">	<span class="comment">//函数模板在调用的时候，可以自动类型推导</span></span><br><span class="line">	<span class="comment">//类模板必须显式指定类型</span></span><br><span class="line">	<span class="function">Person&lt;<span class="keyword">int</span>&gt; <span class="title">p</span><span class="params">(<span class="number">15</span>,<span class="number">22</span>)</span></span>;</span><br><span class="line">	p.<span class="built_in">Show</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="三、类模板的派生"><a href="#三、类模板的派生" class="headerlink" title="三、类模板的派生"></a>三、类模板的派生</h3><ol>
<li>普通类派生类模板</li>
<li>类模板也可以派生类模板，这时，派生类模板的参数表中应包含基类模板的参数。</li>
<li>模板类与普通类一样也具有多继承，即模板类之间允许有多继承。</li>
</ol>
<p>     可以从类模板派生出新的类，既可以派生类模板，也可以派生非模板类。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//类模板派生普通类</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Person</span>()&#123;</span><br><span class="line">		mAge = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	T mAge;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//类区定义对象，这个对象需要编译分配内存,要指定类型</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SubPerson</span> :</span> <span class="keyword">public</span> Person&lt;<span class="keyword">int</span>&gt;&#123;&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//类模板派生类模板</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">J</span><span class="params">()</span></span>&#123;</span><br><span class="line">		cout &lt;&lt; mAge &lt;&lt; <span class="string">&quot;动物在叫!&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	T mAge;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cat</span> :</span> <span class="keyword">public</span> Animal&lt;T&gt;&#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;	</span><br><span class="line">	Cat&lt;<span class="keyword">int</span>&gt; cat;<span class="comment">//指定类型</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="四、类模板外部实现成员函数"><a href="#四、类模板外部实现成员函数" class="headerlink" title="四、类模板外部实现成员函数"></a>四、类模板外部实现成员函数</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Person</span>(T age, T id);</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">Show</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	T mAge;</span><br><span class="line">	T mID;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//外部实现函数</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line">Person&lt;T&gt;::<span class="built_in">Person</span>(T age, T id)&#123;</span><br><span class="line">	<span class="keyword">this</span>-&gt;mID = id;</span><br><span class="line">	<span class="keyword">this</span>-&gt;mAge = age;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="keyword">void</span> Person&lt;T&gt;::<span class="built_in">Show</span>()&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;Age:&quot;</span> &lt;&lt; mAge &lt;&lt; <span class="string">&quot; ID:&quot;</span> &lt;&lt; mID &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="五、类模板的编译"><a href="#五、类模板的编译" class="headerlink" title="五、类模板的编译"></a>五、类模板的编译</h3><p>    首先，一个<em>编译单元</em>（<em>translation unit</em>）是指一个*.cpp<em>文件以及它所</em>#include<em>的所有</em>.h<em>文件，</em>.h<em>文件里的代码将会被扩展到包含它的</em>.cpp<em>文件里，然后编译器编译该</em>.cpp<em>文件为一个</em>.obj<em>文件（假定我们的平台是win32），后者拥有</em>PE<em>（</em>Portable Executable<em>，即</em>windows<em>可执行文件）文件格式，并且本身包含的就已经是二进制码，但是不一定能够执行，因为并不保证其中一定有</em>main<em>函数。当编译器将一个工程里的所有</em>.cpp<em>文件以分离的方式编译完毕后，再由连接器（</em>linker<em>）进行连接成为一个</em>.exe*文件。</p>
<p>    就像类一样，类模板是可以将其实现与声明放在一起的，或者也可以将接口与实现分离。但是呢，编译器由于历史原因对于分离式编译的支持非常弱，并且因平台的不同支持力度有所不同。</p>
<p>    STL 的类模板都是接口与实现放在一起的，随着主流走就可以。（文件保存为<em><strong>类模板.hpp</strong></em>,其实质就是将.cpp的实现代码混入.h头文件当中，定义与实现都包含在同一文件，则该类的调用者只需要include该hpp文件即可，无需再 将cpp加入到project中进行编译。）</p>
<h3 id="六、类模板中的static关键字"><a href="#六、类模板中的static关键字" class="headerlink" title="六、类模板中的static关键字"></a>六、类模板中的<strong>static</strong>关键字</h3><p>    不同的类型参数的类的静态成员变量是相互独立的，这是由类模板的实现机制决定的。</p>
<figure class="highlight hpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _CRT_SECURE_NO_WARNINGS</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">int</span> a;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span> <span class="keyword">int</span> Person&lt;T&gt;::a = <span class="number">0</span>;<span class="comment">//类外初始化</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Person&lt;<span class="keyword">int</span>&gt; p1, p2, p3;</span><br><span class="line">	Person&lt;<span class="keyword">char</span>&gt; pp1, pp2, pp3;</span><br><span class="line">	p1.a = <span class="number">10</span>;</span><br><span class="line">	pp1.a = <span class="number">100</span>;</span><br><span class="line">	cout &lt;&lt; p1.a &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; p2.a &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; p3.a &lt;&lt; endl;<span class="comment">//输出10 10 10</span></span><br><span class="line">	cout &lt;&lt; pp1.a &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; pp2.a &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; pp3.a &lt;&lt; endl;<span class="comment">//输出100 100 100</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>    可以看到相同类型如int对应的类模板的对象之间的static成员是共享的，不同类型之间如int,float,char对应的类模板的对象之间的static是不共享的。</p>
]]></content>
      <categories>
        <category>C++</category>
        <category>泛型</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>泛型</tag>
      </tags>
  </entry>
  <entry>
    <title>成员模板</title>
    <url>/2021/05/07/C++%E6%B3%9B%E5%9E%8B%EF%BC%9A%E6%88%90%E5%91%98%E6%A8%A1%E6%9D%BF/</url>
    <content><![CDATA[<h3 id="一、简介"><a href="#一、简介" class="headerlink" title="一、简介"></a>一、简介</h3><p>    任意类（模板或非模板）可以拥有本身为类模板或函数模板的成员，这种成员称为成员函数模板。STL中为什么要运用这种技术呢？考虑 vector 容器的 assign 成员函数，它可以接受两个迭代器为容器赋值，而这两个迭代器可以是 list 的迭代器、deque的迭代器、甚至是两个原生指针。也就是说成员函数 assign 的形参是不确定的。解决的方法是使用模板形参来表示迭代器形参的类型。</p>
<span id="more"></span>

<h3 id="二、语法"><a href="#二、语法" class="headerlink" title="二、语法"></a>二、语法</h3><p>    C++ 中成员模板的写法如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//在类内部</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">I</span>&gt;</span></span><br><span class="line">返回类型 函数名(模板参数表)</span><br><span class="line">&#123;  &#125;</span><br></pre></td></tr></table></figure>

<p>    在外面定义成员模板，必须包含两个模板形参表，类模板形参和自己的模板形参。首先是类模板形参表，然后是自己的模板形参表。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;类模板形参表&gt; <span class="keyword">template</span> &lt;模板形参表&gt;</span><br><span class="line">返回类型 类名&lt;类参数表&gt;::函数名(函数参数表)</span><br><span class="line">&#123; &#125;</span><br></pre></td></tr></table></figure>

<p>    例：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//自定义</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyAlloc</span>&#123;</span></span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="keyword">class</span> <span class="title">Alloc</span> =</span> MyAlloc&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyVector</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">typedef</span> T value_type;</span><br><span class="line">	<span class="keyword">typedef</span> value_type* iterator;</span><br><span class="line">	<span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">I</span>&gt;</span></span><br><span class="line">	<span class="built_in">MyVector</span>(I first, I last);</span><br><span class="line">	<span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">I</span>&gt;</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">assign</span><span class="params">(I first, I last)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="keyword">class</span> <span class="title">Alloc</span>&gt;</span> <span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">I</span>&gt;</span></span><br><span class="line">MyVector&lt;T, Alloc&gt;::<span class="built_in">MyVector</span>(I first, I last)</span><br><span class="line">&#123; </span><br><span class="line">	cout&lt;&lt;<span class="string">&quot;MyVector&quot;</span>&lt;&lt;endl; </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="keyword">class</span> <span class="title">Alloc</span>&gt;</span> <span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">I</span>&gt;</span></span><br><span class="line"><span class="keyword">void</span> MyVector&lt;T, Alloc&gt;::<span class="built_in">assign</span>(I first, I last)</span><br><span class="line">&#123; </span><br><span class="line">	cout&lt;&lt;<span class="string">&quot;assign&quot;</span>&lt;&lt;endl; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>C++</category>
        <category>泛型</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>泛型</tag>
      </tags>
  </entry>
  <entry>
    <title>STL_deque容器</title>
    <url>/2021/05/07/STL%EF%BC%9Adeque%E5%AE%B9%E5%99%A8/</url>
    <content><![CDATA[<h3 id="一、deque简介"><a href="#一、deque简介" class="headerlink" title="一、deque简介"></a>一、deque简介</h3><p>&ensp;&ensp;&ensp;&ensp;deque是“double-ended queue”的缩写，和vector一样都是STL的容器，deque是双端数组，而vector是单端的。</p>
<p>&ensp;&ensp;&ensp;&ensp;deque在接口上和vector非常相似，在许多操作的地方可以直接替换。</p>
<span id="more"></span>

<p>&ensp;&ensp;&ensp;&ensp;deque可以随机存取元素（支持索引值直接存取， 用[]操作符或at()方法）。</p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>deque头部和尾部添加或移除元素都非常快速。</strong>但是在中部安插元素或移除元素比较费时。</p>
<p>&ensp;&ensp;&ensp;&ensp;#include &lt;deque&gt; </p>
<img src="/2021/05/07/STL%EF%BC%9Adeque%E5%AE%B9%E5%99%A8/1.png" alt="image-20210124101431485" style="zoom: 50%;">

<p>&ensp;&ensp;&ensp;&ensp;<strong>原理：</strong></p>
<img src="/2021/05/07/STL%EF%BC%9Adeque%E5%AE%B9%E5%99%A8/2.png" alt="image-20210124101954916" style="zoom:50%;">

<p>&ensp;&ensp;&ensp;&ensp;Deque容器是连续的空间，至少逻辑上看来如此，连续现行空间总是令我们联想到array和vector,array无法成长，vector虽可成长，却只能向尾端成长，而且其成长其实是一个假象，事实上(1) 申请更大空间 (2)原数据复制新空间 (3)释放原空间 三步骤，如果不是vector每次配置新的空间时都留有余裕，其成长假象所带来的代价是非常昂贵的。</p>
<p>&ensp;&ensp;&ensp;&ensp;Deque是由一段一段的定量的连续空间构成。一旦有必要在deque前端或者尾端增加新的空间，便配置一段连续定量的空间，串接在deque的头端或者尾端。Deque最大的工作就是维护这些分段连续的内存空间的整体性的假象，并提供随机存取的接口，避开了重新配置空间，复制，释放的轮回，代价就是复杂的迭代器架构。</p>
<p>&ensp;&ensp;&ensp;&ensp;既然deque是分段连续内存空间，那么就必须有中央控制，维持整体连续的假象，数据结构的设计及迭代器的前进后退操作颇为繁琐。<strong>Deque代码的实现远比vector或list都多得多</strong>。</p>
<p>&ensp;&ensp;&ensp;&ensp;Deque采取一块所谓的map(注意，不是STL的map容器)作为主控，这里所谓的map是一小块连续的内存空间，其中每一个元素(此处成为一个结点)都是一个指针，指向另一段连续性内存空间，称作缓冲区。缓冲区才是deque的存储空间的主体。</p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>与vector的差异：</strong></p>
<p>&ensp;&ensp;&ensp;&ensp;Deque容器和vector容器最大的差异，一在于deque允许使用常数项时间对头端进行元素的插入和删除操作。二在于deque没有容量的概念，因为它是动态的以分段连续空间组合而成，随时可以增加一段新的空间并链接起来，换句话说，像vector那样，”旧空间不足而重新配置一块更大空间，然后复制元素，再释放旧空间”这样的事情在deque身上是不会发生的。也因此，deque没有必须要提供所谓的空间保留(reserve)功能。</p>
<p>&ensp;&ensp;&ensp;&ensp;虽然deque容器也提供了Random Access Iterator，但是它的迭代器并不是普通的指针，其复杂度和vector不是一个量级，这当然影响各个运算的层面。因此，除非有必要，<strong>我们应该尽可能的使用vector，而不是deque</strong>。<strong>对deque进行的排序操作，为了最高效率，可将deque先完整的复制到一个vector中，对vector容器进行排序，再复制回deque</strong>。</p>
<h3 id="二、deque对象的构造"><a href="#二、deque对象的构造" class="headerlink" title="二、deque对象的构造"></a>二、deque对象的构造</h3><p>&ensp;&ensp;&ensp;&ensp;deque采用模板类实现，deque对象的默认构造形式：deque&lt;T&gt; deqT; </p>
<ul>
<li><p>deque &lt;int&gt; deqInt;       //一个存放int的deque容器。</p>
</li>
<li><p>deque &lt;float&gt; deqFloat;   //一个存放float的deque容器。</p>
</li>
<li><p>deque&lt;string&gt; deqString;   //一个存放string的deque容器。           </p>
</li>
<li><p> //尖括号内还可以设置指针类型或自定义类型。 </p>
</li>
</ul>
<p>&ensp;&ensp;&ensp;&ensp;deque(beg, end);//构造函数将[beg, end)区间中的元素拷贝给本身。</p>
<p>&ensp;&ensp;&ensp;&ensp;deque(n, elem);//构造函数将n个elem拷贝给本身。</p>
<p>&ensp;&ensp;&ensp;&ensp;deque(const deque &amp;deq);//拷贝构造函数。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">deque&lt;<span class="keyword">int</span>&gt; d1;</span><br><span class="line"><span class="function">deque&lt;<span class="keyword">int</span>&gt; <span class="title">d2</span><span class="params">(<span class="number">10</span>, <span class="number">5</span>)</span></span>;</span><br><span class="line"><span class="function">deque&lt;<span class="keyword">int</span>&gt; <span class="title">d3</span><span class="params">(d2.begin(), d2.end())</span></span>;</span><br><span class="line"><span class="function">deque&lt;<span class="keyword">int</span>&gt; <span class="title">d4</span><span class="params">(d3)</span></span>;</span><br></pre></td></tr></table></figure>



<h3 id="三、deque末尾的添加移除操作"><a href="#三、deque末尾的添加移除操作" class="headerlink" title="三、deque末尾的添加移除操作"></a>三、deque末尾的添加移除操作</h3><p>&ensp;&ensp;&ensp;&ensp;deque.push_back(elem);  //在容器尾部添加一个数据</p>
<p>&ensp;&ensp;&ensp;&ensp;deque.push_front(elem); //在容器头部插入一个数据</p>
<p>&ensp;&ensp;&ensp;&ensp;deque.pop_back();        //删除容器最后一个数据</p>
<p>&ensp;&ensp;&ensp;&ensp;deque.pop_front();      //删除容器第一个数据</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">deque&lt;<span class="keyword">int</span>&gt; deqInt;</span><br><span class="line"></span><br><span class="line">deqInt.<span class="built_in">push_back</span>(<span class="number">1</span>);</span><br><span class="line">deqInt.<span class="built_in">push_back</span>(<span class="number">3</span>);</span><br><span class="line">deqInt.<span class="built_in">push_back</span>(<span class="number">5</span>);</span><br><span class="line">deqInt.<span class="built_in">push_back</span>(<span class="number">7</span>);</span><br><span class="line"></span><br><span class="line">deqInt.<span class="built_in">pop_front</span>();</span><br><span class="line">deqInt.<span class="built_in">pop_front</span>();</span><br><span class="line"></span><br><span class="line">deqInt.<span class="built_in">push_front</span>(<span class="number">11</span>);</span><br><span class="line">deqInt.<span class="built_in">push_front</span>(<span class="number">13</span>);</span><br><span class="line"></span><br><span class="line">deqInt.<span class="built_in">pop_back</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">//deqInt &#123; 13,11,5&#125;</span></span><br></pre></td></tr></table></figure>



<h3 id="四、deque的数据存取"><a href="#四、deque的数据存取" class="headerlink" title="四、deque的数据存取"></a>四、deque的数据存取</h3><p>&ensp;&ensp;&ensp;&ensp;deque.at(idx); //返回索引idx所指的数据，如果idx越界，抛出out_of_range。</p>
<p>&ensp;&ensp;&ensp;&ensp;deque[idx]; //返回索引idx所指的数据，如果idx越界，不抛出异常，直接出错。</p>
<p>&ensp;&ensp;&ensp;&ensp;deque.front();  //返回第一个数据。</p>
<p>&ensp;&ensp;&ensp;&ensp;deque.back();  //返回最后一个数据     </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">deque&lt;<span class="keyword">int</span>&gt; deqInt;</span><br><span class="line"></span><br><span class="line">deqInt.<span class="built_in">push_back</span>(<span class="number">1</span>);</span><br><span class="line">deqInt.<span class="built_in">push_back</span>(<span class="number">3</span>);</span><br><span class="line">deqInt.<span class="built_in">push_back</span>(<span class="number">5</span>);</span><br><span class="line">deqInt.<span class="built_in">push_back</span>(<span class="number">7</span>);</span><br><span class="line">deqInt.<span class="built_in">push_back</span>(<span class="number">9</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> iA = deqInt.<span class="built_in">at</span>(<span class="number">0</span>);        <span class="comment">//1</span></span><br><span class="line"><span class="keyword">int</span> iB = deqInt[<span class="number">1</span>];           <span class="comment">//3</span></span><br><span class="line">deqInt.<span class="built_in">at</span>(<span class="number">0</span>) = <span class="number">99</span>;           <span class="comment">//99</span></span><br><span class="line">deqInt[<span class="number">1</span>] = <span class="number">88</span>;         <span class="comment">//88</span></span><br><span class="line"><span class="keyword">int</span> iFront = deqInt.<span class="built_in">front</span>();    <span class="comment">//99</span></span><br><span class="line"><span class="keyword">int</span> iBack = deqInt.<span class="built_in">back</span>();    <span class="comment">//9</span></span><br><span class="line">deqInt.<span class="built_in">front</span>() = <span class="number">77</span>;         <span class="comment">//77</span></span><br><span class="line">deqInt.<span class="built_in">back</span>() = <span class="number">66</span>;         <span class="comment">//66</span></span><br></pre></td></tr></table></figure>



<h3 id="五、deque与迭代器"><a href="#五、deque与迭代器" class="headerlink" title="五、deque与迭代器"></a>五、deque与迭代器</h3><p>&ensp;&ensp;&ensp;&ensp;deque.begin(); //返回容器中第一个元素的迭代器。</p>
<p>&ensp;&ensp;&ensp;&ensp;deque.end(); //返回容器中最后一个元素之后的迭代器。</p>
<p>&ensp;&ensp;&ensp;&ensp;deque.rbegin(); //返回容器中倒数第一个元素的迭代器。</p>
<p>&ensp;&ensp;&ensp;&ensp;deque.rend();  //返回容器中倒数最后一个元素之后的迭代器。 </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">deque&lt;<span class="keyword">int</span>&gt; deqInt;</span><br><span class="line"></span><br><span class="line">deqInt.<span class="built_in">push_back</span>(<span class="number">1</span>);</span><br><span class="line">deqInt.<span class="built_in">push_back</span>(<span class="number">3</span>);</span><br><span class="line">deqInt.<span class="built_in">push_back</span>(<span class="number">5</span>);</span><br><span class="line">deqInt.<span class="built_in">push_back</span>(<span class="number">7</span>);</span><br><span class="line">deqInt.<span class="built_in">push_back</span>(<span class="number">9</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (deque&lt;<span class="keyword">int</span>&gt;::iterator it=deqInt.<span class="built_in">begin</span>(); it!=deqInt.<span class="built_in">end</span>(); ++it)</span><br><span class="line">&#123;</span><br><span class="line">    cout &lt;&lt; *it;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 1 3 5 7 9</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (deque&lt;<span class="keyword">int</span>&gt;::reverse_iterator rit=deqInt.<span class="built_in">rbegin</span>(); rit!=deqInt.<span class="built_in">rend</span>(); ++rit)</span><br><span class="line">&#123;</span><br><span class="line">    cout &lt;&lt; *rit;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//9 7 5 3 1</span></span><br></pre></td></tr></table></figure>



<h3 id="六、deque的赋值"><a href="#六、deque的赋值" class="headerlink" title="六、deque的赋值"></a>六、deque的赋值</h3><p>&ensp;&ensp;&ensp;&ensp;deque.assign(beg,end);  //将[beg, end)区间中的数据拷贝赋值给本身。注意该区间是左闭右开的区间。</p>
<p>&ensp;&ensp;&ensp;&ensp;deque.assign(n,elem); //将n个elem拷贝赋值给本身。</p>
<p>&ensp;&ensp;&ensp;&ensp;deque&amp; operator=(const deque &amp;deq);  //重载等号操作符</p>
<p>&ensp;&ensp;&ensp;&ensp;deque.swap(deq); // 将vec与本身的元素互换 </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">deque&lt;<span class="keyword">int</span>&gt; deqIntA,deqIntB,deqIntC,deqIntD;</span><br><span class="line"></span><br><span class="line">deqIntA.<span class="built_in">push_back</span>(<span class="number">1</span>);</span><br><span class="line">deqIntA.<span class="built_in">push_back</span>(<span class="number">3</span>);</span><br><span class="line">deqIntA.<span class="built_in">push_back</span>(<span class="number">5</span>);</span><br><span class="line">deqIntA.<span class="built_in">push_back</span>(<span class="number">7</span>);</span><br><span class="line">deqIntA.<span class="built_in">push_back</span>(<span class="number">9</span>);</span><br><span class="line"></span><br><span class="line">deqIntB.<span class="built_in">assign</span>(deqIntA.<span class="built_in">begin</span>(),deqIntA.<span class="built_in">end</span>());   <span class="comment">// 1 3 5 7 9</span></span><br><span class="line"></span><br><span class="line">deqIntC.<span class="built_in">assign</span>(<span class="number">5</span>,<span class="number">8</span>);                         <span class="comment">//8 8 8 8 8</span></span><br><span class="line"></span><br><span class="line">deqIntD = deqIntA;                          <span class="comment">//1 3 5 7 9</span></span><br><span class="line"></span><br><span class="line">deqIntC.<span class="built_in">swap</span>(deqIntD);                      <span class="comment">//互换</span></span><br></pre></td></tr></table></figure>



<h3 id="七、deque的大小"><a href="#七、deque的大小" class="headerlink" title="七、deque的大小"></a>七、deque的大小</h3><p>&ensp;&ensp;&ensp;&ensp;deque.size();     //返回容器中元素的个数</p>
<p>&ensp;&ensp;&ensp;&ensp;deque.empty();   //判断容器是否为空</p>
<p>&ensp;&ensp;&ensp;&ensp;deque.resize(num);  //重新指定容器的长度为num，若容器变长，则以默认值填充新位置。如果容器变短，则末尾超出容器长度的元素被删除。</p>
<p>&ensp;&ensp;&ensp;&ensp;deque.resize(num, elem); //重新指定容器的长度为num，若容器变长，则以elem值填充新位置。如果容器变短，则末尾超出容器长度的元素被删除。      </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">deque&lt;<span class="keyword">int</span>&gt; deqIntA;</span><br><span class="line"></span><br><span class="line">deqIntA.<span class="built_in">push_back</span>(<span class="number">1</span>);</span><br><span class="line">deqIntA.<span class="built_in">push_back</span>(<span class="number">3</span>);</span><br><span class="line">deqIntA.<span class="built_in">push_back</span>(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> iSize = deqIntA.<span class="built_in">size</span>(); <span class="comment">//3</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!deqIntA.<span class="built_in">empty</span>())</span><br><span class="line">&#123;</span><br><span class="line">    deqIntA.<span class="built_in">resize</span>(<span class="number">5</span>);      <span class="comment">//1 3 5 0 0</span></span><br><span class="line">    deqIntA.<span class="built_in">resize</span>(<span class="number">7</span>,<span class="number">1</span>); 	<span class="comment">//1 3 5 0 0 1 1</span></span><br><span class="line">    deqIntA.<span class="built_in">resize</span>(<span class="number">2</span>);      <span class="comment">//1 3</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="八、deque的插入"><a href="#八、deque的插入" class="headerlink" title="八、deque的插入"></a>八、deque的插入</h3><p>&ensp;&ensp;&ensp;&ensp;deque.insert(pos,elem);  //在pos位置插入一个elem元素的拷贝，返回新数据的位置。</p>
<p>&ensp;&ensp;&ensp;&ensp;deque.insert(pos,n,elem);  //在pos位置插入n个elem数据，无返回值。</p>
<p>&ensp;&ensp;&ensp;&ensp;deque.insert(pos,beg,end);  //在pos位置插入[beg,end)区间的数据，无返回值。 </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">deque&lt;<span class="keyword">int</span>&gt; deqA;</span><br><span class="line">deque&lt;<span class="keyword">int</span>&gt; deqB;</span><br><span class="line"></span><br><span class="line">deqA.<span class="built_in">push_back</span>(<span class="number">1</span>);</span><br><span class="line">deqA.<span class="built_in">push_back</span>(<span class="number">3</span>);</span><br><span class="line">deqA.<span class="built_in">push_back</span>(<span class="number">5</span>);</span><br><span class="line">deqA.<span class="built_in">push_back</span>(<span class="number">7</span>);</span><br><span class="line">deqA.<span class="built_in">push_back</span>(<span class="number">9</span>);</span><br><span class="line"></span><br><span class="line">deqB.<span class="built_in">push_back</span>(<span class="number">2</span>);</span><br><span class="line">deqB.<span class="built_in">push_back</span>(<span class="number">4</span>);</span><br><span class="line">deqB.<span class="built_in">push_back</span>(<span class="number">6</span>);</span><br><span class="line">deqB.<span class="built_in">push_back</span>(<span class="number">8</span>);</span><br><span class="line"></span><br><span class="line">deqA.<span class="built_in">insert</span>(deqA.<span class="built_in">begin</span>(), <span class="number">11</span>);        <span class="comment">//&#123;11, 1, 3, 5, 7, 9&#125;</span></span><br><span class="line">deqA.<span class="built_in">insert</span>(deqA.<span class="built_in">begin</span>()+<span class="number">1</span>,<span class="number">2</span>,<span class="number">33</span>);     <span class="comment">//&#123;11,33,33,1,3,5,7,9&#125;</span></span><br><span class="line">deqA.<span class="built_in">insert</span>(deqA.<span class="built_in">begin</span>() , deqB.<span class="built_in">begin</span>() , deqB.<span class="built_in">end</span>() ); <span class="comment">//&#123;2,4,6,8,11,33,33,1,3,5,7,9&#125;</span></span><br></pre></td></tr></table></figure>



<h3 id="九、deque的删除"><a href="#九、deque的删除" class="headerlink" title="九、deque的删除"></a>九、deque的删除</h3><p>&ensp;&ensp;&ensp;&ensp;deque.clear();  //移除容器的所有数据</p>
<p>&ensp;&ensp;&ensp;&ensp;deque.erase(beg,end); //删除[beg,end)区间的数据，返回下一个数据的位置。</p>
<p>&ensp;&ensp;&ensp;&ensp;deque.erase(pos);  //删除pos位置的数据，返回下一个数据的位置。 </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//删除区间内的元素</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//deqInt是用deque&lt;int&gt;声明的容器，现已包含按顺序的1,3,5,6,9元素。</span></span><br><span class="line">deque&lt;<span class="keyword">int</span>&gt;::iterator itBegin=deqInt.<span class="built_in">begin</span>()+<span class="number">1</span>;</span><br><span class="line">deque&lt;<span class="keyword">int</span>&gt;::iterator itEnd=deqInt.<span class="built_in">begin</span>()+<span class="number">3</span>;</span><br><span class="line">deqInt.<span class="built_in">erase</span>(itBegin,itEnd);</span><br><span class="line"><span class="comment">//此时容器deqInt包含按顺序的1,6,9三个元素。 </span></span><br><span class="line"></span><br><span class="line"><span class="comment">//假设 deqInt 包含1,3,2,3,3,3,4,3,5,3，删除容器中等于3的元素</span></span><br><span class="line"><span class="keyword">for</span>(deque&lt;<span class="keyword">int</span>&gt;::iterator it=deqInt.<span class="built_in">being</span>(); it!=deqInt.<span class="built_in">end</span>(); )  &#123;</span><br><span class="line">    <span class="comment">//小括号里不需写 ++it	</span></span><br><span class="line">    <span class="keyword">if</span>(*it == <span class="number">3</span>)&#123;</span><br><span class="line">        it = deqInt.<span class="built_in">erase</span>(it);    </span><br><span class="line">        <span class="comment">//以迭代器为参数，删除元素3，并把数据删除后的下一个元素位置返回给迭代器。</span></span><br><span class="line">        <span class="comment">//此时，不执行 ++it； </span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        ++it;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//删除deqInt的所有元素</span></span><br><span class="line">deqInt.<span class="built_in">clear</span>();         <span class="comment">//容器为空</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>C++</category>
        <category>STL</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>STL</tag>
        <tag>STL容器</tag>
      </tags>
  </entry>
  <entry>
    <title>STL_list容器</title>
    <url>/2021/05/07/STL%EF%BC%9Alist%E5%AE%B9%E5%99%A8/</url>
    <content><![CDATA[<h3 id="一、List简介"><a href="#一、List简介" class="headerlink" title="一、List简介"></a>一、List简介</h3><p>    链表是一种物理存储单元上非连续、非顺序的存储结构，数据元素的逻辑顺序是通过链表中的指针链接次序实现的。</p>
<span id="more"></span>

<p>    链表由一系列结点（链表中每一个元素称为结点）组成，结点可以在运行时动态生成。每个结点包括两个部分：一个是存储数据元素的数据域，另一个是存储下一个结点地址的指针域。</p>
<p>    相较于vector的连续线性空间，list的好处是每次插入或者删除一个元素，就是配置或者释放一个元素的空间。因此，list对于空间的运用有绝对的精准，一点也不浪费。而且，对于任何位置的元素插入或元素的移除，list永远是常数时间。</p>
<p>    List和vector是两个最常被使用的容器。</p>
<p>    list容器是一个<strong>双向链表容器</strong>，可高效地进行插入删除元素。</p>
<p>    list不可以随机存取元素，所以不支持at.(pos)函数与[]操作符。</p>
<p>    #include &lt;list&gt; </p>
 <img src="/2021/05/07/STL%EF%BC%9Alist%E5%AE%B9%E5%99%A8/1.png" alt="image-20210125101251344" style="zoom:50%;">

<h3 id="二、list对象的默认构造"><a href="#二、list对象的默认构造" class="headerlink" title="二、list对象的默认构造"></a>二、list对象的默认构造</h3><p>    list采用采用模板类实现,对象的默认构造形式：list&lt;T&gt; LIST; 如：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">list&lt;<span class="keyword">int</span>&gt; lstInt;      <span class="comment">//定义一个存放int的list容器。</span></span><br><span class="line">list&lt;<span class="keyword">float</span>&gt; lstFloat;   <span class="comment">//定义一个存放float的list容器。</span></span><br><span class="line">list&lt;string&gt; lstString;   <span class="comment">//定义一个存放string的list容器。              </span></span><br><span class="line"><span class="comment">//尖括号内还可以设置指针类型或自定义类型。</span></span><br></pre></td></tr></table></figure>



<h3 id="三、list头尾的添加移除操作"><a href="#三、list头尾的添加移除操作" class="headerlink" title="三、list头尾的添加移除操作"></a>三、list头尾的添加移除操作</h3><p>    list.push_back(elem);      //在容器尾部加入一个元素</p>
<p>    list.pop_back();       //删除容器中最后一个元素</p>
<p>    list.push_front(elem);   //在容器开头插入一个元素</p>
<p>    list.pop_front();       //从容器开头移除第一个元素</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">list&lt;<span class="keyword">int</span>&gt; lstInt;</span><br><span class="line">lstInt.<span class="built_in">push_back</span>(<span class="number">1</span>);</span><br><span class="line">lstInt.<span class="built_in">push_back</span>(<span class="number">3</span>);</span><br><span class="line">lstInt.<span class="built_in">push_back</span>(<span class="number">5</span>);</span><br><span class="line">lstInt.<span class="built_in">push_back</span>(<span class="number">7</span>);</span><br><span class="line">lstInt.<span class="built_in">push_back</span>(<span class="number">9</span>);</span><br><span class="line">lstInt.<span class="built_in">pop_front</span>();</span><br><span class="line">lstInt.<span class="built_in">pop_front</span>();</span><br><span class="line">lstInt.<span class="built_in">push_front</span>(<span class="number">11</span>);</span><br><span class="line">lstInt.<span class="built_in">push_front</span>(<span class="number">13</span>);</span><br><span class="line">lstInt.<span class="built_in">pop_back</span>();</span><br><span class="line">lstInt.<span class="built_in">pop_back</span>();</span><br><span class="line"><span class="comment">// lstInt    &#123;13,11,5&#125;</span></span><br></pre></td></tr></table></figure>



<h3 id="四、list的数据存取"><a href="#四、list的数据存取" class="headerlink" title="四、list的数据存取"></a>四、list的数据存取</h3><p>    list.front();  //返回第一个元素。</p>
<p>    list.back(); //返回最后一个元素。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">list&lt;<span class="keyword">int</span>&gt; lstInt;</span><br><span class="line">lstInt.<span class="built_in">push_back</span>(<span class="number">1</span>);</span><br><span class="line">lstInt.<span class="built_in">push_back</span>(<span class="number">5</span>);</span><br><span class="line">lstInt.<span class="built_in">push_back</span>(<span class="number">9</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> iFront = lstInt.<span class="built_in">front</span>();	<span class="comment">//1</span></span><br><span class="line"><span class="keyword">int</span> iBack = lstInt.<span class="built_in">back</span>();		<span class="comment">//9</span></span><br></pre></td></tr></table></figure>



<h3 id="五、list与迭代器"><a href="#五、list与迭代器" class="headerlink" title="五、list与迭代器"></a>五、list与迭代器</h3><p>    list.begin();           //返回容器中第一个元素的迭代器。</p>
<p>    list.end();            //返回容器中最后一个元素之后的迭代器。</p>
<p>    list.rbegin();     //返回容器中倒数第一个元素的迭代器。</p>
<p>    list.rend();     //返回容器中倒数最后一个元素的后面的迭代器。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (list&lt;<span class="keyword">int</span>&gt;::iterator it=lstInt.<span class="built_in">begin</span>(); it!=lstInt.<span class="built_in">end</span>(); ++it)	&#123;</span><br><span class="line">		cout &lt;&lt; *it&lt;&lt;cout &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>



<h3 id="六、list对象的带参数构造"><a href="#六、list对象的带参数构造" class="headerlink" title="六、list对象的带参数构造"></a>六、list对象的带参数构造</h3><p>    list(beg,end);  //构造函数将[beg, end)区间中的元素拷贝给本身。注意该区间是左闭右开的区间。</p>
<p>    list(n,elem);  //构造函数将n个elem拷贝给本身。</p>
<p>    list(const list &amp;lst); //拷贝构造函数。 </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">list&lt;<span class="keyword">int</span>&gt; mlist1;</span><br><span class="line"><span class="function">list&lt;<span class="keyword">int</span>&gt; <span class="title">mlist2</span><span class="params">(<span class="number">10</span>, <span class="number">10</span>)</span></span>; <span class="comment">//有参构造</span></span><br><span class="line"><span class="function">list&lt;<span class="keyword">int</span>&gt; <span class="title">mlist3</span><span class="params">(mlist2)</span></span>;<span class="comment">//拷贝构造</span></span><br><span class="line"><span class="function">list&lt;<span class="keyword">int</span>&gt; <span class="title">mlist4</span><span class="params">(mlist2.begin(), mlist2.end())</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (list&lt;<span class="keyword">int</span>&gt;::iterator it = mlist4.<span class="built_in">begin</span>(); it != mlist4.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">    cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">结果：</span></span><br><span class="line"><span class="comment">10 10 10 10 10 10 10 10 10 10</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>



<h3 id="七、list的赋值"><a href="#七、list的赋值" class="headerlink" title="七、list的赋值"></a>七、list的赋值</h3><p>    list.assign(beg,end);  //将[beg, end)区间中的数据拷贝赋值给本身。注意该区间是左闭右开的区间。</p>
<p>    list.assign(n,elem); //将n个elem拷贝赋值给本身。</p>
<p>    list&amp; operator=(const list &amp;lst); //重载等号操作符</p>
<p>    list.swap(lst); // 将lst与本身的元素互换。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">list&lt;<span class="keyword">int</span>&gt; lstIntA,lstIntB,lstIntC,lstIntD;</span><br><span class="line">lstIntA.<span class="built_in">push_back</span>(<span class="number">1</span>);</span><br><span class="line">lstIntA.<span class="built_in">push_back</span>(<span class="number">5</span>);</span><br><span class="line">lstIntA.<span class="built_in">push_back</span>(<span class="number">9</span>);</span><br><span class="line"></span><br><span class="line">lstIntB.<span class="built_in">assign</span>(lstIntA.<span class="built_in">begin</span>(),lstIntA.<span class="built_in">end</span>());		<span class="comment">//1 5 9</span></span><br><span class="line">lstIntC.<span class="built_in">assign</span>(<span class="number">5</span>,<span class="number">8</span>);							<span class="comment">//8 8 8 8 8</span></span><br><span class="line">lstIntD = lstIntA;							<span class="comment">//1 5 9</span></span><br><span class="line">lstIntC.<span class="built_in">swap</span>(lstIntD);						<span class="comment">//互换</span></span><br></pre></td></tr></table></figure>

<h3 id="八、list的大小"><a href="#八、list的大小" class="headerlink" title="八、list的大小"></a>八、list的大小</h3><p>    list.size();    //返回容器中元素的个数</p>
<p>    list.empty();      //判断容器是否为空</p>
<p>    list.resize(num);  //重新指定容器的长度为num，若容器变长，则以默认值填充新位置。如果容器变短，则末尾超出容器长度的元素被删除。</p>
<p>    list.resize(num, elem); //重新指定容器的长度为num，若容器变长，则以elem值填充新位置。如果容器变短，则末尾超出容器长度的元素被删除。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">list&lt;<span class="keyword">int</span>&gt; lstIntA;</span><br><span class="line">lstIntA.<span class="built_in">push_back</span>(<span class="number">11</span>);</span><br><span class="line">lstIntA.<span class="built_in">push_back</span>(<span class="number">33</span>);</span><br><span class="line">lstIntA.<span class="built_in">push_back</span>(<span class="number">55</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!lstIntA.<span class="built_in">empty</span>())</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> iSize = lstIntA.<span class="built_in">size</span>();		<span class="comment">//3</span></span><br><span class="line">    lstIntA.<span class="built_in">resize</span>(<span class="number">5</span>);			<span class="comment">//11 33 55 0 0</span></span><br><span class="line">    lstIntA.<span class="built_in">resize</span>(<span class="number">7</span>,<span class="number">1</span>);			<span class="comment">//11 33 55 0 0 1 1</span></span><br><span class="line">    lstIntA.<span class="built_in">resize</span>(<span class="number">2</span>);			<span class="comment">//11 33</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="九、list的插入"><a href="#九、list的插入" class="headerlink" title="九、list的插入"></a>九、list的插入</h3><p>    list.insert(pos,elem);  //在pos位置插入一个elem元素的拷贝，返回新数据的位置。</p>
<p>    list.insert(pos,n,elem);  //在pos位置插入n个elem数据，无返回值。</p>
<p>    list.insert(pos,beg,end);  //在pos位置插入[beg,end)区间的数据，无返回值。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">list&lt;<span class="keyword">int</span>&gt; lstA;</span><br><span class="line">list&lt;<span class="keyword">int</span>&gt; lstB;</span><br><span class="line"></span><br><span class="line">lstA.<span class="built_in">push_back</span>(<span class="number">1</span>);</span><br><span class="line">lstA.<span class="built_in">push_back</span>(<span class="number">5</span>);</span><br><span class="line">lstA.<span class="built_in">push_back</span>(<span class="number">9</span>);</span><br><span class="line"></span><br><span class="line">lstB.<span class="built_in">push_back</span>(<span class="number">2</span>);</span><br><span class="line">lstB.<span class="built_in">push_back</span>(<span class="number">6</span>);</span><br><span class="line"></span><br><span class="line">lstA.<span class="built_in">insert</span>(lstA.<span class="built_in">begin</span>(), <span class="number">11</span>);		<span class="comment">//&#123;11, 1, 5, 9&#125;</span></span><br><span class="line">lstA.<span class="built_in">insert</span>(++lstA.<span class="built_in">begin</span>(),<span class="number">2</span>,<span class="number">33</span>);		<span class="comment">//&#123;11,33,33,1,5,9&#125;</span></span><br><span class="line">lstA.<span class="built_in">insert</span>(lstA.<span class="built_in">begin</span>() , lstB.<span class="built_in">begin</span>() , lstB.<span class="built_in">end</span>() );	<span class="comment">//&#123;2,6,11,33,33,1,5,9&#125;</span></span><br></pre></td></tr></table></figure>



<h3 id="十、list的删除"><a href="#十、list的删除" class="headerlink" title="十、list的删除"></a>十、list的删除</h3><p>    list.clear();     //移除容器的所有数据</p>
<p>    list.erase(beg,end); //**删除[beg,end)**区间的数据，返回下一个数据的位置。</p>
<p>    list.erase(pos);  //删除pos位置的数据，返回下一个数据的位置。</p>
<p>    lst.remove(elem);  //删除容器中所有与elem值匹配的元素。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//删除区间内的元素</span></span><br><span class="line"><span class="comment">//lstInt是用list&lt;int&gt;声明的容器，现已包含按顺序的1,3,5,6,9元素。</span></span><br><span class="line">list&lt;<span class="keyword">int</span>&gt;::iterator itBegin=lstInt.<span class="built_in">begin</span>();</span><br><span class="line">++ itBegin;</span><br><span class="line">list&lt;<span class="keyword">int</span>&gt;::iterator itEnd=lstInt.<span class="built_in">begin</span>();</span><br><span class="line">++ itEnd;</span><br><span class="line">++ itEnd;</span><br><span class="line">++ itEnd;</span><br><span class="line">lstInt.<span class="built_in">erase</span>(itBegin,itEnd);</span><br><span class="line"><span class="comment">//此时容器lstInt包含按顺序的1,6,9三个元素。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//假设 lstInt 包含1,3,2,3,3,3,4,3,5,3，删除容器中等于3的元素的方法一</span></span><br><span class="line"><span class="keyword">for</span>(list&lt;<span class="keyword">int</span>&gt;::iterator it=lstInt.<span class="built_in">being</span>(); it!=lstInt.<span class="built_in">end</span>(); )    <span class="comment">//小括号里不需写  ++it</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="keyword">if</span>(*it == <span class="number">3</span>)&#123;</span><br><span class="line">        it  =  lstInt.<span class="built_in">erase</span>(it);       <span class="comment">//以迭代器为参数，删除元素3，并把数据删除后的下一个元素位置返回给迭代器。</span></span><br><span class="line">         <span class="comment">//此时，不执行  ++it；  </span></span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">else</span>&#123;</span><br><span class="line">       ++it;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//删除容器中等于3的元素的方法二</span></span><br><span class="line">lstInt.<span class="built_in">remove</span>(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//删除lstInt的所有元素</span></span><br><span class="line">lstInt.<span class="built_in">clear</span>();			<span class="comment">//容器为空</span></span><br></pre></td></tr></table></figure>



<h3 id="十一、list的反序排列"><a href="#十一、list的反序排列" class="headerlink" title="十一、list的反序排列"></a>十一、list的反序排列</h3><p>    lst.reverse();   //反转链表  </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">list&lt;<span class="keyword">int</span>&gt; lstA;</span><br><span class="line"></span><br><span class="line">lstA.<span class="built_in">push_back</span>(<span class="number">1</span>);</span><br><span class="line">lstA.<span class="built_in">push_back</span>(<span class="number">3</span>);</span><br><span class="line">lstA.<span class="built_in">push_back</span>(<span class="number">5</span>);</span><br><span class="line">lstA.<span class="built_in">push_back</span>(<span class="number">7</span>);</span><br><span class="line">lstA.<span class="built_in">push_back</span>(<span class="number">9</span>);</span><br><span class="line"></span><br><span class="line">lstA.<span class="built_in">reverse</span>();			<span class="comment">//9 7 5 3 1</span></span><br></pre></td></tr></table></figure>

<h3 id="十二、拼接"><a href="#十二、拼接" class="headerlink" title="十二、拼接"></a>十二、拼接</h3><p>    list::splice实现list拼接的功能。将源list的内容部分或全部元素删除，拼插入到目的list。</p>
<p>    函数有以下三种声明：</p>
<ol>
<li><p> void splice ( iterator position, list&lt;T,Allocator&gt;&amp; x );  </p>
</li>
<li><p> void splice ( iterator position, list&lt;T,Allocator&gt;&amp; x, iterator it );</p>
</li>
<li><p> void splice ( iterator position, list&lt;T,Allocator&gt;&amp; x, iterator first, iterator last );</p>
</li>
</ol>
<p>解释：</p>
<p>    position 是要操作的list对象的迭代器；ist&lt;T Allocator&gt;&amp;x 被剪的对象</p>
<p>    对于一：会在position后把list&lt;T Allocator&gt;&amp;x所有的元素到剪接到要操作的list对象</p>
<p>    对于二：只会把it的值剪接到要操作的list对象中</p>
<p>    对于三：把first 到 last 剪接到要操作的list对象中 </p>
<p>样例：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	list&lt;<span class="keyword">int</span>&gt;li1,li2;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">4</span>;i++) li1.<span class="built_in">push_back</span>(i),li2.<span class="built_in">push_back</span>(i+<span class="number">10</span>);</span><br><span class="line">	<span class="comment">// li1 1 2 3 4</span></span><br><span class="line">	<span class="comment">// li2 11 12 13 14</span></span><br><span class="line">	list&lt;<span class="keyword">int</span>&gt;::iterator it=li1.<span class="built_in">begin</span>();</span><br><span class="line">	it++;</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	li1.<span class="built_in">splice</span>(it,li2);<span class="comment">//1 11 12 13 14 2 3 4</span></span><br><span class="line">	<span class="keyword">if</span>(li2.<span class="built_in">empty</span>()) cout&lt;&lt;<span class="string">&quot;li2 is empty&quot;</span>&lt;&lt;endl;</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	li2.<span class="built_in">splice</span>(li2.<span class="built_in">begin</span>(),li1,it);</span><br><span class="line">	cout&lt;&lt;*it&lt;&lt;<span class="string">&quot;   chen&quot;</span>&lt;&lt;endl;</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	li1 1 11 12 13 14 3 4</span></span><br><span class="line"><span class="comment">	li2 2</span></span><br><span class="line"><span class="comment">	这里的it的值还是2  但是指向的已经是li2中的了 </span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">	</span><br><span class="line">	it=li1.<span class="built_in">begin</span>();</span><br><span class="line">	<span class="built_in">advance</span>(it,<span class="number">3</span>);<span class="comment">//advance 的意思是增加的意思，就是相当于 it=it+3;这里指向13</span></span><br><span class="line">	li1.<span class="built_in">splice</span>(li1.<span class="built_in">begin</span>(),li1,it,li1.<span class="built_in">end</span>()); <span class="comment">//13 14 3 4 1 11 12 可以发现it到li1.end()被剪贴到li1.begin()前面了 </span></span><br><span class="line">	<span class="keyword">for</span>(list&lt;<span class="keyword">int</span>&gt;::iterator it=li1.<span class="built_in">begin</span>();it!=li1.<span class="built_in">end</span>();++it) cout&lt;&lt;*it&lt;&lt;<span class="string">&quot;  &quot;</span>;</span><br><span class="line">	cout&lt;&lt;endl;</span><br><span class="line">	<span class="keyword">for</span>(list&lt;<span class="keyword">int</span>&gt;::iterator it=li2.<span class="built_in">begin</span>();it!=li2.<span class="built_in">end</span>();++it) cout&lt;&lt;*it&lt;&lt;<span class="string">&quot;  &quot;</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>C++</category>
        <category>STL</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>STL</tag>
        <tag>STL容器</tag>
      </tags>
  </entry>
  <entry>
    <title>STL_优先队列</title>
    <url>/2021/05/07/STL%EF%BC%9Apriority_queue/</url>
    <content><![CDATA[<h3 id="一、简介"><a href="#一、简介" class="headerlink" title="一、简介"></a>一、简介</h3><p>    优先队列容器与队列一样，只能从队尾插入元素，从队首删除元素。但是它有一个特性，就是队列中最大的元素总是位于队首，所以出队时，并非按照先进先出的原则进行，而是将当前队列中最大的元素出队。</p>
<span id="more"></span>

<p>    元素的比较规则默认按元素值由大到小排序，可以重载“&lt;”操作符来重新定义比较规则。</p>
<p>    优先级队列可以用向量(vector)或双向队列(deque)来实现</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">priority_queue&lt;int, vector&lt;int&gt;, less&lt;int&gt; &gt; pq1; 　　　 &#x2F;&#x2F; 使用递增less&lt;int&gt;函数对象排序</span><br><span class="line">priority_queue&lt;int, deque&lt;int&gt;, greater&lt;int&gt; &gt; pq2; 　　&#x2F;&#x2F; 使用递减greater&lt;int&gt;函数对象排序</span><br></pre></td></tr></table></figure>

<h3 id="二、基本操作"><a href="#二、基本操作" class="headerlink" title="二、基本操作"></a>二、基本操作</h3><p>    #include &lt;queue&gt;</p>
<table>
<thead>
<tr>
<th>函数接口</th>
<th align="center">功能</th>
</tr>
</thead>
<tbody><tr>
<td>empty()</td>
<td align="center">如果队列为空，则返回真</td>
</tr>
<tr>
<td>pop()</td>
<td align="center">删除对顶元素，删除第一个元素</td>
</tr>
<tr>
<td>push(elem)</td>
<td align="center">加入一个元素</td>
</tr>
<tr>
<td>size()</td>
<td align="center">返回优先队列中拥有的元素个数</td>
</tr>
<tr>
<td>top()</td>
<td align="center">返回优先队列对顶元素，返回优先队列中有最高优先级的元素</td>
</tr>
</tbody></table>
<h3 id="三、代码示例"><a href="#三、代码示例" class="headerlink" title="三、代码示例"></a>三、代码示例</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span> </span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    priority_queue&lt;<span class="keyword">int</span>&gt; p1; <span class="comment">//默认是 最大值优先级队列 </span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//priority_queue&lt;int, vector&lt;int&gt;, less&lt;int&gt; &gt; p1**; //相当于这样写</span></span><br><span class="line"></span><br><span class="line">    priority_queue&lt;<span class="keyword">int</span>, vector&lt;<span class="keyword">int</span>&gt;, greater&lt;<span class="keyword">int</span>&gt;&gt; p2; <span class="comment">//最小值优先级队列</span></span><br><span class="line"></span><br><span class="line">    p1.<span class="built_in">push</span>(<span class="number">33</span>);</span><br><span class="line">    p1.<span class="built_in">push</span>(<span class="number">11</span>);</span><br><span class="line">    p1.<span class="built_in">push</span>(<span class="number">55</span>);</span><br><span class="line">    p1.<span class="built_in">push</span>(<span class="number">22</span>);</span><br><span class="line">    cout &lt;&lt;<span class="string">&quot;队列大小&quot;</span> &lt;&lt; p1.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt;<span class="string">&quot;队头&quot;</span> &lt;&lt; p1.<span class="built_in">top</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (p1.<span class="built_in">size</span>() &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">         cout &lt;&lt; p1.<span class="built_in">top</span>() &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">         p1.<span class="built_in">pop</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;测试 最小值优先级队列&quot;</span> &lt;&lt; endl;</span><br><span class="line">    p2.<span class="built_in">push</span>(<span class="number">33</span>);</span><br><span class="line">    p2.<span class="built_in">push</span>(<span class="number">11</span>);</span><br><span class="line">    p2.<span class="built_in">push</span>(<span class="number">55</span>);</span><br><span class="line">    p2.<span class="built_in">push</span>(<span class="number">22</span>);</span><br><span class="line">    <span class="keyword">while</span> (p2.<span class="built_in">size</span>() &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">         cout &lt;&lt; p2.<span class="built_in">top</span>() &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">         p2.<span class="built_in">pop</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">队列大小4</span></span><br><span class="line"><span class="comment">队头55</span></span><br><span class="line"><span class="comment">55 33 22 11</span></span><br><span class="line"><span class="comment">测试 最小值优先级队列</span></span><br><span class="line"><span class="comment">11 22 33 55</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h3 id="四、优先队列与堆"><a href="#四、优先队列与堆" class="headerlink" title="四、优先队列与堆"></a>四、优先队列与堆</h3><p>    这里面说的堆默认我们最常使用的二叉堆，而二叉堆只是优先队列的一种是实现方式而已。</p>
<p>    优先队列还有哪些实现方式：二项堆 平衡树 线段树 甚至用二进制分组的vector来实现一个优先对列。</p>
<p><a href="https://mp.weixin.qq.com/s?__biz=MzAxODQxMDM0Mw==&mid=2247484495&idx=1&sn=bbfeba9bb5cfd50598e2a4d08c839ee9&chksm=9bd7fa47aca073512e094110a7fe7d9bac052be114d1db72fe07b7efa6beb915f51b3f19291e&scene=21#wechat_redirect">图文详解二叉堆，实现优先级队列</a></p>
]]></content>
      <categories>
        <category>C++</category>
        <category>STL</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>STL</tag>
        <tag>STL容器</tag>
      </tags>
  </entry>
  <entry>
    <title>STL_map和multimap容器</title>
    <url>/2021/05/07/STL%EF%BC%9Amap%E5%92%8Cmultimap%E5%AE%B9%E5%99%A8/</url>
    <content><![CDATA[<h3 id="一、map-multimap的简介"><a href="#一、map-multimap的简介" class="headerlink" title="一、map/multimap的简介"></a>一、map/multimap的简介</h3><p>    map是标准的<strong>关联式</strong>容器，一个map是一个键值对序列，即(key,value)对。它提供基于key的快速检索能力。</p>
<span id="more"></span>

<p>    map中<strong>key</strong>值是唯一的<strong>。集合中的元素按一定的顺序</strong>排列。元素插入过程是按排序规则插入，所以不能指定插入位置。</p>
<p>    map的具体实现采用红黑树变体的平衡二叉树的数据结构，在插入操作和删除操作上比vector快。</p>
<p>    map可以直接存取key所对应的value，支持[]操作符，如map[key]=value。</p>
<p>    multimap与map的区别：map支持唯一键值，每个键只能出现一次；而multimap中相同键可以出现多次。multimap不支持[]操作符。</p>
<p>    #include &lt;map&gt; </p>
<p>​                         </p>
<h3 id="二、map-multimap对象的默认构造"><a href="#二、map-multimap对象的默认构造" class="headerlink" title="二、map/multimap对象的默认构造"></a>二、map/multimap对象的默认构造</h3><p>    map/multimap采用模板类实现，对象的默认构造形式：</p>
<ul>
<li>map&lt;T1,T2&gt; mapTT; </li>
<li>multimap&lt;T1,T2&gt; multimapTT; </li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">map&lt;<span class="keyword">int</span>, <span class="keyword">char</span>&gt; mapA;</span><br><span class="line">map&lt;string,<span class="keyword">float</span>&gt; mapB;</span><br><span class="line"><span class="comment">//其中T1,T2还可以用各种指针类型或自定义类型</span></span><br></pre></td></tr></table></figure>



<h3 id="三、map的插入与迭代器"><a href="#三、map的插入与迭代器" class="headerlink" title="三、map的插入与迭代器"></a>三、map的插入与迭代器</h3><p>    map.insert(…);  //往容器插入元素，返回pair&lt;iterator,bool&gt;</p>
<p>    假设map&lt;int, int&gt; mymap，在map中插入元素的方式：</p>
<ol>
<li><p>通过pair的方式插入对象：mymap.insert(pair&lt;int, int&gt;(10, 10));</p>
</li>
<li><p>通过pair的方式插入对象：mymap.insert(make_pair(20, 20));</p>
</li>
<li><p>通过value_type的方式插入对象：mymap.insert(map&lt;int, int&gt;::value_type(30, 30));</p>
</li>
<li><p>通过数组的方式插入值：mymap[40] = 40。</p>
</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//map容器模板参数，第一个参数key的类型，第二参数value类型</span></span><br><span class="line">map&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; mymap;</span><br><span class="line"></span><br><span class="line"><span class="comment">//插入数据  pair.first key值 piar.second value值</span></span><br><span class="line"><span class="comment">//第一种</span></span><br><span class="line">pair&lt;map&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;::iterator, <span class="keyword">bool</span>&gt; ret = mymap.<span class="built_in">insert</span>(pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;(<span class="number">10</span>, <span class="number">10</span>));</span><br><span class="line"><span class="comment">//第二种</span></span><br><span class="line">mymap.<span class="built_in">insert</span>(<span class="built_in">make_pair</span>(<span class="number">20</span>, <span class="number">20</span>));</span><br><span class="line"><span class="comment">//第三种</span></span><br><span class="line">mymap.<span class="built_in">insert</span>(map&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;::<span class="built_in">value_type</span>(<span class="number">30</span>, <span class="number">30</span>));</span><br><span class="line"><span class="comment">//第四种，发现如果key不存在，创建pair插入到map容器中；如果发现key存在，那么会修改key对应的value。</span></span><br><span class="line">mymap[<span class="number">40</span>] = <span class="number">40</span>;</span><br><span class="line">mymap[<span class="number">10</span>] = <span class="number">20</span>;</span><br><span class="line">mymap[<span class="number">50</span>] = <span class="number">50</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (map&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;::iterator it = mymap.<span class="built_in">begin</span>(); it != mymap.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;key:&quot;</span> &lt;&lt; (*it).first &lt;&lt; <span class="string">&quot; value:&quot;</span> &lt;&lt; it-&gt;second &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">结果：</span></span><br><span class="line"><span class="comment">key:10 value:20</span></span><br><span class="line"><span class="comment">key:20 value:20</span></span><br><span class="line"><span class="comment">key:30 value:30</span></span><br><span class="line"><span class="comment">key:40 value:40</span></span><br><span class="line"><span class="comment">key:50 value:50</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>    前三种方法，采用的是insert()方法，该方法返回值为pair&lt;iterator,bool&gt;</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">	pair&lt;map&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;::iterator, <span class="keyword">bool</span>&gt; ret = mymap.<span class="built_in">insert</span>(pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;(<span class="number">10</span>, <span class="number">10</span>));</span><br><span class="line">	<span class="keyword">if</span> (ret.second) &#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;第一次插入成功!&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;插入失败!&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">结果：</span></span><br><span class="line"><span class="comment">第一次插入成功!</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>    第四种方法非常直观，但存在一个性能的问题。插入3时，先在mapStu中查找主键为3的项，若没发现，则将一个键为3，值为初始化值的对组插入到mapStu中，然后再将值<strong>修改</strong>。若发现已存在3这个键，则修改这个键对应的value。  </p>
<p>    map&lt;T1,T2,less&lt;T1&gt; &gt; mapA; //该容器是按键的升序方式排列元素。未指定函数对象，默认采用less&lt;T1&gt;函数对象。</p>
<p>    map&lt;T1,T2,greater&lt;T1&gt;&gt; mapB;  //该容器是按键的降序方式排列元素。</p>
<p>    less&lt;T1&gt;与greater&lt;T1&gt; 可以替换成其它的函数对象functor。</p>
<p>    可编写自定义函数对象以进行自定义类型的比较，使用方法与set构造时所用的函数对象一样。</p>
<h3 id="四、map对象的拷贝构造与赋值"><a href="#四、map对象的拷贝构造与赋值" class="headerlink" title="四、map对象的拷贝构造与赋值"></a>四、map对象的拷贝构造与赋值</h3><p>    map(const map &amp;mp);         //拷贝构造函数</p>
<p>    map&amp; operator=(const map &amp;mp);    //重载等号操作符</p>
<p>    map.swap(mp);                //交换两个集合容器       </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">map&lt;<span class="keyword">int</span>, string&gt; mapA;</span><br><span class="line">mapA.<span class="built_in">insert</span>(pair&lt;<span class="keyword">int</span>,string&gt;(<span class="number">3</span>,<span class="string">&quot;小张&quot;</span>));</span><br><span class="line">mapA.<span class="built_in">insert</span>(pair&lt;<span class="keyword">int</span>,string&gt;(<span class="number">1</span>,<span class="string">&quot;小杨&quot;</span>));    </span><br><span class="line">mapA.<span class="built_in">insert</span>(pair&lt;<span class="keyword">int</span>,string&gt;(<span class="number">7</span>,<span class="string">&quot;小赵&quot;</span>));    </span><br><span class="line">mapA.<span class="built_in">insert</span>(pair&lt;<span class="keyword">int</span>,string&gt;(<span class="number">5</span>,<span class="string">&quot;小王&quot;</span>));    </span><br><span class="line">map&lt;int ,string&gt; mapB(mapA);            //拷贝构造</span><br><span class="line">map&lt;<span class="keyword">int</span>, string&gt; mapC;</span><br><span class="line">mapC = mapA;                              <span class="comment">//赋值</span></span><br><span class="line">mapC[<span class="number">3</span>] = <span class="string">&quot;老张&quot;</span>;</span><br><span class="line">mapC.<span class="built_in">swap</span>(mapA);         <span class="comment">//交换</span></span><br></pre></td></tr></table></figure>



<h3 id="五、map的大小"><a href="#五、map的大小" class="headerlink" title="五、map的大小"></a>五、map的大小</h3><p>    map.size(); //返回容器中元素的数目</p>
<p>    map.empty();//判断容器是否为空         </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">map&lt;<span class="keyword">int</span>, string&gt; mapA;</span><br><span class="line">mapA.<span class="built_in">insert</span>(pair&lt;<span class="keyword">int</span>,string&gt;(<span class="number">3</span>,<span class="string">&quot;小张&quot;</span>));    </span><br><span class="line">mapA.<span class="built_in">insert</span>(pair&lt;<span class="keyword">int</span>,string&gt;(<span class="number">1</span>,<span class="string">&quot;小杨&quot;</span>));    </span><br><span class="line"><span class="keyword">if</span> (mapA.<span class="built_in">empty</span>())</span><br><span class="line">&#123;</span><br><span class="line">   <span class="keyword">int</span> iSize = mapA.<span class="built_in">size</span>();       <span class="comment">//iSize == 4</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="六、map的删除"><a href="#六、map的删除" class="headerlink" title="六、map的删除"></a>六、map的删除</h3><p>    map.clear();        //删除所有元素</p>
<p>    map.erase(pos); //删除pos迭代器所指的元素，返回下一个元素的迭代器。</p>
<p>    map.erase(beg,end);   //删除区间[beg,end)的所有元素 ，返回下一个元素的迭代器。</p>
<p>    map.erase(keyElem);   //删除容器中key为keyElem的对组。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">map&lt;<span class="keyword">int</span>, string&gt; mapA;</span><br><span class="line">mapA.<span class="built_in">insert</span>(pair&lt;<span class="keyword">int</span>,string&gt;(<span class="number">3</span>,<span class="string">&quot;小张&quot;</span>));   </span><br><span class="line">mapA.<span class="built_in">insert</span>(pair&lt;<span class="keyword">int</span>,string&gt;(<span class="number">1</span>,<span class="string">&quot;小杨&quot;</span>));   </span><br><span class="line">mapA.<span class="built_in">insert</span>(pair&lt;<span class="keyword">int</span>,string&gt;(<span class="number">7</span>,<span class="string">&quot;小赵&quot;</span>));   </span><br><span class="line">mapA.<span class="built_in">insert</span>(pair&lt;<span class="keyword">int</span>,string&gt;(<span class="number">5</span>,<span class="string">&quot;小王&quot;</span>));    </span><br><span class="line"> <span class="comment">//删除区间内的元素</span></span><br><span class="line">map&lt;<span class="keyword">int</span>,string&gt;::iterator itBegin=mapA.<span class="built_in">begin</span>();</span><br><span class="line">++ itBegin;</span><br><span class="line">++ itBegin;</span><br><span class="line"></span><br><span class="line">map&lt;<span class="keyword">int</span>,string&gt;::iterator itEnd=mapA.<span class="built_in">end</span>();</span><br><span class="line">mapA.<span class="built_in">erase</span>(itBegin,itEnd);         <span class="comment">//此时容器mapA包含按顺序的&#123;1,&quot;小杨&quot;&#125;&#123;3,&quot;小张&quot;&#125;两个元素。</span></span><br><span class="line"></span><br><span class="line">mapA.<span class="built_in">insert</span>(pair&lt;<span class="keyword">int</span>,string&gt;(<span class="number">7</span>,<span class="string">&quot;小赵&quot;</span>));    </span><br><span class="line">mapA.<span class="built_in">insert</span>(pair&lt;<span class="keyword">int</span>,string&gt;(<span class="number">5</span>,<span class="string">&quot;小王&quot;</span>));    </span><br><span class="line"></span><br><span class="line"><span class="comment">//删除容器中第一个元素</span></span><br><span class="line">mapA.<span class="built_in">erase</span>(mapA.<span class="built_in">begin</span>());  <span class="comment">//此时容器mapA包含了按顺序的&#123;3,&quot;小张&quot;&#125;&#123;5,&quot;小王&quot;&#125;&#123;7,&quot;小赵&quot;&#125;三个元素</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//删除容器中key为5的元素</span></span><br><span class="line">mapA.<span class="built_in">erase</span>(<span class="number">5</span>);  </span><br><span class="line"></span><br><span class="line"><span class="comment">//删除mapA的所有元素</span></span><br><span class="line">mapA.<span class="built_in">clear</span>();          <span class="comment">//容器为空</span></span><br></pre></td></tr></table></figure>



<h3 id="七、map的查找"><a href="#七、map的查找" class="headerlink" title="七、map的查找"></a>七、map的查找</h3><p>    map.find(key);  //查找键key是否存在，若存在，返回该键的元素的迭代器；若不存在，返回map.end();</p>
<p>    map.count(keyElem);  //返回容器中key为keyElem的对组个数。对map来说，要么是0，要么是1。对multimap来说，值可能大于1。</p>
<p>    map.begin(); //返回容器中第一个数据的迭代器。</p>
<p>    map.end(); //返回容器中最后一个数据之后的迭代器。</p>
<p>    map.rbegin(); //返回容器中倒数第一个元素的迭代器。</p>
<p>    map.rend();  //返回容器中倒数最后一个元素的后面的迭代器。</p>
<p>    map.lower_bound(keyElem); //返回第一个key&gt;=keyElem元素的迭代器。</p>
<p>    map.upper_bound(keyElem);   // 返回第一个key&gt;keyElem元素的迭代器      </p>
<p>    map.equal_range(keyElem);       //返回容器中key与keyElem相等的上下限的两个迭代器。上限是闭区间，下限是开区间，如[beg,end)。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">	map&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; mymap;</span><br><span class="line">	mymap.<span class="built_in">insert</span>(<span class="built_in">make_pair</span>(<span class="number">1</span>, <span class="number">4</span>));</span><br><span class="line">	mymap.<span class="built_in">insert</span>(<span class="built_in">make_pair</span>(<span class="number">2</span>, <span class="number">5</span>));</span><br><span class="line">	mymap.<span class="built_in">insert</span>(<span class="built_in">make_pair</span>(<span class="number">3</span>, <span class="number">6</span>));</span><br><span class="line"></span><br><span class="line">	pair&lt;map&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;::iterator, map&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;::iterator&gt; ret = mymap.<span class="built_in">equal_range</span>(<span class="number">2</span>);</span><br><span class="line">	<span class="keyword">if</span> (ret.first != mymap.<span class="built_in">end</span>()) &#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;找到lower_bound！&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;没有找到&quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (ret.second != mymap.<span class="built_in">end</span>()) &#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;找到upper_bound！&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;没有找到&quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">结果：</span></span><br><span class="line"><span class="comment">找到lower_bound！</span></span><br><span class="line"><span class="comment">找到upper_bound！</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>C++</category>
        <category>STL</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>STL</tag>
        <tag>STL容器</tag>
      </tags>
  </entry>
  <entry>
    <title>STL_queue容器</title>
    <url>/2021/05/07/STL%EF%BC%9Aqueue%E5%AE%B9%E5%99%A8/</url>
    <content><![CDATA[<h3 id="一、queue简介"><a href="#一、queue简介" class="headerlink" title="一、queue简介"></a>一、queue简介</h3><p>    queue所有元素的进出都必须符合”先进先出”的条件，只有queue的顶端元素，才有机会被外界取用。queue不提供遍历功能，也不提供迭代器。</p>
<span id="more"></span>

<p>    queue是简单地装饰deque容器而成为另外的一种容器。</p>
<p>    #include &lt;queue&gt; </p>
<h3 id="二、queue对象的默认构造"><a href="#二、queue对象的默认构造" class="headerlink" title="二、queue对象的默认构造"></a>二、queue对象的默认构造</h3><p>    queue采用模板类实现，queue对象的默认构造形式：queue&lt;T&gt; queT; </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">queue&lt;<span class="keyword">int</span>&gt; queInt;      <span class="comment">//一个存放int的queue容器。</span></span><br><span class="line">queue&lt;<span class="keyword">float</span>&gt; queFloat;   <span class="comment">//一个存放float的queue容器。</span></span><br><span class="line">queue&lt;string&gt; queString;   <span class="comment">//一个存放string的queue容器。</span></span><br><span class="line"><span class="comment">//尖括号内还可以设置指针类型或自定义类型。          </span></span><br></pre></td></tr></table></figure>

<h3 id="三、queue的push-与pop-方法"><a href="#三、queue的push-与pop-方法" class="headerlink" title="三、queue的push()与pop()方法"></a>三、queue的push()与pop()方法</h3><p>    queue.push(elem);  //往队尾添加元素</p>
<p>    queue.pop();  //从队头移除第一个元素 </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">queue&lt;<span class="keyword">int</span>&gt; queInt;</span><br><span class="line"></span><br><span class="line">queInt.<span class="built_in">push</span>(<span class="number">1</span>);</span><br><span class="line">queInt.<span class="built_in">push</span>(<span class="number">3</span>);</span><br><span class="line">queInt.<span class="built_in">push</span>(<span class="number">5</span>);</span><br><span class="line">queInt.<span class="built_in">push</span>(<span class="number">7</span>);</span><br><span class="line">queInt.<span class="built_in">push</span>(<span class="number">9</span>);</span><br><span class="line">queInt.<span class="built_in">pop</span>();</span><br><span class="line">queInt.<span class="built_in">pop</span>();</span><br><span class="line"><span class="comment">//此时queInt存放的元素是5,7,9</span></span><br></pre></td></tr></table></figure>



<h3 id="四、queue对象的拷贝构造与赋值"><a href="#四、queue对象的拷贝构造与赋值" class="headerlink" title="四、queue对象的拷贝构造与赋值"></a>四、queue对象的拷贝构造与赋值</h3><p>    queue(const queue &amp;que);          //拷贝构造函数</p>
<p>    queue&amp; operator=(const queue &amp;que); //重载等号操作符        </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">queue&lt;<span class="keyword">int</span>&gt; queIntA;</span><br><span class="line">queIntA.<span class="built_in">push</span>(<span class="number">1</span>);</span><br><span class="line">queIntA.<span class="built_in">push</span>(<span class="number">3</span>); </span><br><span class="line"><span class="function">queue&lt;<span class="keyword">int</span>&gt; <span class="title">queIntB</span><span class="params">(queIntA)</span></span>;    <span class="comment">//拷贝构造</span></span><br><span class="line">queue&lt;<span class="keyword">int</span>&gt; queIntC;</span><br><span class="line">queIntC = queIntA;              <span class="comment">//赋值</span></span><br></pre></td></tr></table></figure>



<h3 id="五、queue的数据存取"><a href="#五、queue的数据存取" class="headerlink" title="五、queue的数据存取"></a>五、queue的数据存取</h3><p>    queue.back();  //返回最后一个元素</p>
<p>    queue.front();  //返回第一个元素        </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">queue&lt;<span class="keyword">int</span>&gt; queIntA;</span><br><span class="line">queIntA.<span class="built_in">push</span>(<span class="number">1</span>);</span><br><span class="line">queIntA.<span class="built_in">push</span>(<span class="number">3</span>);</span><br><span class="line">queIntA.<span class="built_in">push</span>(<span class="number">5</span>);</span><br><span class="line">queIntA.<span class="built_in">push</span>(<span class="number">7</span>);</span><br><span class="line">queIntA.<span class="built_in">push</span>(<span class="number">9</span>);</span><br><span class="line"><span class="keyword">int</span> iFront = queIntA.<span class="built_in">front</span>();       <span class="comment">//1</span></span><br><span class="line"><span class="keyword">int</span> iBack = queIntA.<span class="built_in">back</span>();       <span class="comment">//9</span></span><br></pre></td></tr></table></figure>

<h3 id="六、queue的大小"><a href="#六、queue的大小" class="headerlink" title="六、queue的大小"></a>六、queue的大小</h3><p>    queue.empty();  //判断队列是否为空</p>
<p>    queue.size();      //返回队列的大小         </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">queue&lt;<span class="keyword">int</span>&gt; queIntA;    </span><br><span class="line">queIntA.<span class="built_in">push</span>(<span class="number">1</span>);      </span><br><span class="line">queIntA.<span class="built_in">push</span>(<span class="number">3</span>);      </span><br><span class="line">queIntA.<span class="built_in">push</span>(<span class="number">5</span>);       </span><br><span class="line">queIntA.<span class="built_in">push</span>(<span class="number">7</span>);       </span><br><span class="line">queIntA.<span class="built_in">push</span>(<span class="number">9</span>);       </span><br><span class="line"><span class="keyword">if</span> (!queIntA.<span class="built_in">empty</span>())&#123;</span><br><span class="line">   <span class="keyword">int</span> iSize = queIntA.<span class="built_in">size</span>();     <span class="comment">//5</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>C++</category>
        <category>STL</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>STL</tag>
        <tag>STL容器</tag>
      </tags>
  </entry>
  <entry>
    <title>STL_set和multiset容器</title>
    <url>/2021/05/07/STL%EF%BC%9Aset%E5%92%8Cmultiset%E5%AE%B9%E5%99%A8/</url>
    <content><![CDATA[<h3 id="一、set-multiset的简介"><a href="#一、set-multiset的简介" class="headerlink" title="一、set/multiset的简介"></a>一、set/multiset的简介</h3><p>    set是一个<strong>集合</strong>容器，其中所包含的元素是<strong>唯一</strong>的，<strong>集合中的元素按一定的顺序排列</strong>。<strong>元素插入过程是按排序规则插入</strong>，所以不能指定插入位置。</p>
<span id="more"></span>

<p>    set采用<strong>红黑树</strong>变体的数据结构实现，红黑树属于平衡二叉树。<strong>在插入操作和删除操作上比vector快</strong>。</p>
<p>    set不可以直接存取元素。（不可以使用at.(pos)与[]操作符）。</p>
<p>    multiset与set的区别：</p>
<ul>
<li>set支持唯一键值，<strong>每个元素值只能出现一次</strong>；</li>
<li>multiset中<strong>同一值可以出现多次</strong>。</li>
</ul>
<p>    不可以直接修改set或multiset容器中的元素值，因为该类容器是自动排序的。如果希望修改一个元素值，必须先删除原有的元素，再插入新的元素。</p>
<p>    #include &lt;set&gt; </p>
<p>​                               </p>
<h3 id="二、set-multiset构造函数"><a href="#二、set-multiset构造函数" class="headerlink" title="二、set/multiset构造函数"></a>二、set/multiset构造函数</h3><p>    set&lt;T&gt; st;//set默认构造函数：</p>
<p>    mulitset&lt;T&gt; mst; //multiset默认构造函数</p>
<p>    set(const set &amp;st);         //拷贝构造函数</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">set&lt;<span class="keyword">int</span>&gt; setInt;      <span class="comment">//一个存放int的set容器。</span></span><br><span class="line">multiset&lt;<span class="keyword">int</span>&gt; mulsetInt;      <span class="comment">//一个存放int的multiset容器。</span></span><br><span class="line"><span class="function">set&lt;<span class="keyword">int</span>&gt; <span class="title">setIntB</span><span class="params">(setIntA)</span></span>; <span class="comment">//1 3 5 7 9</span></span><br></pre></td></tr></table></figure>



<h3 id="三、set的插入与迭代器"><a href="#三、set的插入与迭代器" class="headerlink" title="三、set的插入与迭代器"></a>三、set的插入与迭代器</h3><p>    set.insert(elem);   //在容器中插入元素。</p>
<p>    set.begin(); //返回容器中第一个数据的迭代器。</p>
<p>    set.end(); //返回容器中最后一个数据之后的迭代器。</p>
<p>    set.rbegin(); //返回容器中倒数第一个元素的迭代器。</p>
<p>    set.rend();  //返回容器中倒数最后一个元素的后面的迭代器。 </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">set&lt;<span class="keyword">int</span>&gt; setInt;</span><br><span class="line">setInt.<span class="built_in">insert</span>(<span class="number">3</span>); </span><br><span class="line">setInt.<span class="built_in">insert</span>(<span class="number">1</span>);</span><br><span class="line">setInt.<span class="built_in">insert</span>(<span class="number">5</span>);</span><br><span class="line">setInt.<span class="built_in">insert</span>(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(set&lt;<span class="keyword">int</span>&gt;::iterator it=setInt.<span class="built_in">begin</span>(); it!=setInt.<span class="built_in">end</span>(); ++it)&#123;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">int</span> iItem = *it;</span><br><span class="line">   cout &lt;&lt; iItem;  <span class="comment">//或直接使用cout &lt;&lt; *it</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//这样子便顺序输出 1 2 3 5(默认排序，从小到大)</span></span><br></pre></td></tr></table></figure>

<h3 id="四、set集合的元素排序"><a href="#四、set集合的元素排序" class="headerlink" title="四、set集合的元素排序"></a>四、set集合的元素排序</h3><p>    set&lt;int,less&lt;int&gt; &gt; setIntA; //该容器是按升序方式排列元素。</p>
<p>    set&lt;int,greater&lt;int&gt;&gt; setIntB;  //该容器是按降序方式排列元素。</p>
<p>    set&lt;int&gt; 相当于 set&lt;int,less&lt;int&gt;&gt;。</p>
<p>    less&lt;int&gt;与greater&lt;int&gt;中的int可以改成其它类型，该类型主要要跟set容纳的数据类型一致。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">set&lt;<span class="keyword">int</span>,greater&lt;<span class="keyword">int</span>&gt;&gt; setIntB;</span><br><span class="line">setIntB.<span class="built_in">insert</span>(<span class="number">3</span>);</span><br><span class="line">setIntB.<span class="built_in">insert</span>(<span class="number">1</span>);</span><br><span class="line">setIntB.<span class="built_in">insert</span>(<span class="number">5</span>);</span><br><span class="line">setIntB.<span class="built_in">insert</span>(<span class="number">2</span>);</span><br><span class="line"><span class="comment">//此时容器setIntB就包含了按顺序的5,3,2,1元素</span></span><br></pre></td></tr></table></figure>



<h3 id="五、函数对象functor的用法"><a href="#五、函数对象functor的用法" class="headerlink" title="五、函数对象functor的用法"></a>五、函数对象functor的用法</h3><p>    尽管函数指针被广泛用于实现函数回调，但C++还提供了一个重要的实现回调函数的方法，那就是函数对象。</p>
<p>    functor，翻译成函数对象，伪函数，算符，是重载了“()”操作符的普通类对象。从语法上讲，它与普通函数行为类似。</p>
<p>    greater&lt;&gt;与less&lt;&gt;就是函数对象。 </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//下面举出greater&lt;int&gt;的简易实现原理。</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">greater</span>&#123;</span></span><br><span class="line">	<span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span> <span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>&amp; iLeft, <span class="keyword">const</span> <span class="keyword">int</span>&amp; iRight)</span></span>&#123;</span><br><span class="line">   		<span class="keyword">return</span> (iLeft&gt;iRight);  <span class="comment">//如果是实现less&lt;int&gt;的话，这边是写return (iLeft&lt;iRight);</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//容器就是调用函数对象的operator()方法去比较两个值的大小。</span></span><br></pre></td></tr></table></figure>

<h3 id="六、set对象赋值"><a href="#六、set对象赋值" class="headerlink" title="六、set对象赋值"></a>六、set对象赋值</h3><p>    set&amp; operator=(const set &amp;st);    //重载等号操作符</p>
<p>    set.swap(st);               //交换两个集合容器</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">set&lt;<span class="keyword">int</span>&gt; setIntA;</span><br><span class="line">set&lt;<span class="keyword">int</span>&gt; setIntC;</span><br><span class="line"></span><br><span class="line">setIntA.<span class="built_in">insert</span>(<span class="number">3</span>);</span><br><span class="line">setIntA.<span class="built_in">insert</span>(<span class="number">1</span>);</span><br><span class="line">setIntA.<span class="built_in">insert</span>(<span class="number">7</span>);</span><br><span class="line">setIntA.<span class="built_in">insert</span>(<span class="number">5</span>);</span><br><span class="line">setIntA.<span class="built_in">insert</span>(<span class="number">9</span>);    </span><br><span class="line"></span><br><span class="line">setIntC = setIntA;       <span class="comment">//1 3 5 7 9 </span></span><br><span class="line">setIntC.<span class="built_in">insert</span>(<span class="number">6</span>);</span><br><span class="line">setIntC.<span class="built_in">swap</span>(setIntA);    <span class="comment">//交换</span></span><br></pre></td></tr></table></figure>



<h3 id="七、set的大小"><a href="#七、set的大小" class="headerlink" title="七、set的大小"></a>七、set的大小</h3><p>    set.size();  //返回容器中元素的数目</p>
<p>    set.empty();//判断容器是否为空 </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">set&lt;<span class="keyword">int</span>&gt; setIntA;</span><br><span class="line">setIntA.<span class="built_in">insert</span>(<span class="number">3</span>);</span><br><span class="line">setIntA.<span class="built_in">insert</span>(<span class="number">1</span>);</span><br><span class="line">setIntA.<span class="built_in">insert</span>(<span class="number">7</span>);</span><br><span class="line"><span class="keyword">if</span> (!setIntA.<span class="built_in">empty</span>())&#123;</span><br><span class="line">   <span class="keyword">int</span> iSize = setIntA.<span class="built_in">size</span>();      <span class="comment">//3</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="八、set的删除"><a href="#八、set的删除" class="headerlink" title="八、set的删除"></a>八、set的删除</h3><p>    set.clear();     //清除所有元素</p>
<p>    set.erase(pos);  //删除pos迭代器所指的元素，返回下一个元素的迭代器。</p>
<p>    set.erase(beg,end);    //删除区间[beg,end)的所有元素 ，返回下一个元素的迭代器。</p>
<p>    set.erase(elem);   //删除容器中值为elem的元素。 </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//删除区间内的元素</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//setInt是用set&lt;int&gt;声明的容器，现已包含按顺序的1,3,5,6,9,11元素。</span></span><br><span class="line">set&lt;<span class="keyword">int</span>&gt;::iterator itBegin=setInt.<span class="built_in">begin</span>();</span><br><span class="line">++ itBegin;</span><br><span class="line">set&lt;<span class="keyword">int</span>&gt;::iterator itEnd=setInt.<span class="built_in">begin</span>();</span><br><span class="line">++ itEnd;</span><br><span class="line">++ itEnd;</span><br><span class="line">++ itEnd;</span><br><span class="line">setInt.<span class="built_in">erase</span>(itBegin,itEnd);</span><br><span class="line"><span class="comment">//此时容器setInt包含按顺序的1,6,9,11四个元素。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//删除容器中第一个元素</span></span><br><span class="line">setInt.<span class="built_in">erase</span>(setInt.<span class="built_in">begin</span>());       <span class="comment">//6,9,11</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//删除容器中值为9的元素</span></span><br><span class="line">set.<span class="built_in">erase</span>(<span class="number">9</span>);   </span><br><span class="line"></span><br><span class="line"><span class="comment">//删除setInt的所有元素</span></span><br><span class="line">setInt.<span class="built_in">clear</span>();          <span class="comment">//容器为空</span></span><br></pre></td></tr></table></figure>

<h3 id="九、set的查找"><a href="#九、set的查找" class="headerlink" title="九、set的查找"></a>九、set的查找</h3><p>    set.find(elem);  //查找elem元素，返回指向elem元素的迭代器；若不存在，返回set.end()</p>
<p>    set.count(elem);  //返回容器中值为elem的元素个数。对set来说，要么是0，要么是1。对multiset来说，值可能大于1。</p>
<p>    set.lower_bound(elem); //返回第一个&gt;=elem元素的迭代器。</p>
<p>    set.upper_bound(elem);    // 返回第一个&gt;elem元素的迭代器。</p>
<p>    set.equal_range(elem);       //返回容器中与elem相等的上下限的两个迭代器。上限是闭区间，下限是开区间，如[beg,end)。返回两个迭代器，而这两个迭代器被封装在pair中。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">set&lt;<span class="keyword">int</span>&gt; s1;</span><br><span class="line">s1.<span class="built_in">insert</span>(<span class="number">7</span>);</span><br><span class="line">s1.<span class="built_in">insert</span>(<span class="number">2</span>);</span><br><span class="line">s1.<span class="built_in">insert</span>(<span class="number">4</span>);</span><br><span class="line">s1.<span class="built_in">insert</span>(<span class="number">5</span>);</span><br><span class="line">s1.<span class="built_in">insert</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">set&lt;<span class="keyword">int</span>&gt;::iterator ret = s1.<span class="built_in">find</span>(<span class="number">14</span>);</span><br><span class="line"><span class="keyword">if</span> (ret == s1.<span class="built_in">end</span>()) &#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;没有找到!&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;ret:&quot;</span> &lt;&lt; *ret &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//找第一个大于等于key的元素</span></span><br><span class="line">ret = s1.<span class="built_in">lower_bound</span>(<span class="number">2</span>);</span><br><span class="line"><span class="keyword">if</span> (ret == s1.<span class="built_in">end</span>()) &#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;没有找到!&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;ret:&quot;</span> &lt;&lt; *ret &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//找第一个大于key的值</span></span><br><span class="line">ret = s1.<span class="built_in">upper_bound</span>(<span class="number">2</span>);</span><br><span class="line"><span class="keyword">if</span> (ret == s1.<span class="built_in">end</span>()) &#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;没有找到!&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;ret:&quot;</span> &lt;&lt; *ret &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//equal_range 返回Lower_bound 和 upper_bound值</span></span><br><span class="line">pair&lt;set&lt;<span class="keyword">int</span>&gt;::iterator, set&lt;<span class="keyword">int</span>&gt;::iterator&gt; myret = s1.<span class="built_in">equal_range</span>(<span class="number">2</span>);</span><br><span class="line"><span class="keyword">if</span> (myret.first == s1.<span class="built_in">end</span>()) &#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;没有找到！&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;myret:&quot;</span> &lt;&lt; *(myret.first) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (myret.second == s1.<span class="built_in">end</span>()) &#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;没有找到！&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;myret:&quot;</span> &lt;&lt; *(myret.second) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">结果：</span></span><br><span class="line"><span class="comment">没有找到!</span></span><br><span class="line"><span class="comment">ret:2</span></span><br><span class="line"><span class="comment">ret:4</span></span><br><span class="line"><span class="comment">myret:2</span></span><br><span class="line"><span class="comment">myret:4</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>C++</category>
        <category>STL</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>STL</tag>
        <tag>STL容器</tag>
      </tags>
  </entry>
  <entry>
    <title>STL_stack容器</title>
    <url>/2021/05/07/STL%EF%BC%9Astack%E5%AE%B9%E5%99%A8/</url>
    <content><![CDATA[<h3 id="一、stack简介"><a href="#一、stack简介" class="headerlink" title="一、stack简介"></a>一、stack简介</h3><p>    stack是一种先进后出(First In Last Out,FILO)的数据结构，它只有一个出口。stack容器允许新增元素，移除元素，取得栈顶元素，但是除了最顶端外，没有任何其他方法可以存取stack的其他元素。换言之，stack不允许有遍历行为。</p>
<span id="more"></span>

<ul>
<li>有元素推入栈的操作称为:push</li>
<li>将元素推出stack的操作称为pop</li>
</ul>
<p>    stack是简单地装饰deque容器而成为另外的一种容器。</p>
<p>    #include&lt;stack&gt; </p>
<h3 id="二、stack对象的默认构造"><a href="#二、stack对象的默认构造" class="headerlink" title="二、stack对象的默认构造"></a>二、stack对象的默认构造</h3><p>    stack采用模板类实现， stack对象的默认构造形式： stack <T> stkT; </T></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">stack &lt;<span class="keyword">int</span>&gt; stkInt;      <span class="comment">//一个存放int的stack容器。</span></span><br><span class="line">stack &lt;<span class="keyword">float</span>&gt; stkFloat;   <span class="comment">//一个存放float的stack容器。</span></span><br><span class="line">stack &lt;string&gt; stkString;   <span class="comment">//一个存放string的stack容器。</span></span><br><span class="line"><span class="comment">//尖括号内还可以设置指针类型或自定义类型。</span></span><br></pre></td></tr></table></figure>



<h3 id="三、stack的push-与pop-方法"><a href="#三、stack的push-与pop-方法" class="headerlink" title="三、stack的push()与pop()方法"></a>三、stack的push()与pop()方法</h3><p>    stack.push(elem);  //往栈头添加元素</p>
<p>    stack.pop();  //从栈头移除第一个元素 </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">stack&lt;<span class="keyword">int</span>&gt; stkInt;  </span><br><span class="line"></span><br><span class="line">stkInt.<span class="built_in">push</span>(<span class="number">1</span>);</span><br><span class="line">stkInt.<span class="built_in">push</span>(<span class="number">3</span>);</span><br><span class="line">stkInt.<span class="built_in">pop</span>();  </span><br><span class="line"><span class="comment">//此时stkInt存放的元素是1</span></span><br></pre></td></tr></table></figure>



<h3 id="四、stack对象的拷贝构造与赋值"><a href="#四、stack对象的拷贝构造与赋值" class="headerlink" title="四、stack对象的拷贝构造与赋值"></a>四、stack对象的拷贝构造与赋值</h3><p>    stack(const stack &amp;stk);         //拷贝构造函数</p>
<p>    stack&amp; operator=(const stack &amp;stk);    //重载等号操作符         </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">stack&lt;<span class="keyword">int</span>&gt; stkIntA;</span><br><span class="line">stkIntA.<span class="built_in">push</span>(<span class="number">9</span>);</span><br><span class="line"><span class="function">stack&lt;<span class="keyword">int</span>&gt; <span class="title">stkIntB</span><span class="params">(stkIntA)</span></span>;       <span class="comment">//拷贝构造</span></span><br><span class="line">stack&lt;<span class="keyword">int</span>&gt; stkIntC;</span><br><span class="line">stkIntC = stkIntA;               <span class="comment">//赋值</span></span><br></pre></td></tr></table></figure>



<h3 id="五、stack的数据存取"><a href="#五、stack的数据存取" class="headerlink" title="五、stack的数据存取"></a>五、stack的数据存取</h3><p>    stack.top();  //返回最后一个压入栈元素，即栈顶元素        </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">stack&lt;<span class="keyword">int</span>&gt; stkIntA;</span><br><span class="line">stkIntA.<span class="built_in">push</span>(<span class="number">1</span>);</span><br><span class="line">stkIntA.<span class="built_in">push</span>(<span class="number">7</span>);</span><br><span class="line">stkIntA.<span class="built_in">push</span>(<span class="number">9</span>); </span><br><span class="line"><span class="keyword">int</span> iTop = stkIntA.<span class="built_in">top</span>();      <span class="comment">//9</span></span><br></pre></td></tr></table></figure>

<h3 id="六、stack的大小"><a href="#六、stack的大小" class="headerlink" title="六、stack的大小"></a>六、stack的大小</h3><p>    stack.empty();  //判断堆栈是否为空</p>
<p>    stack.size();       //返回堆栈的大小         </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">stack&lt;<span class="keyword">int</span>&gt; stkIntA;</span><br><span class="line">stkIntA.<span class="built_in">push</span>(<span class="number">1</span>);</span><br><span class="line">stkIntA.<span class="built_in">push</span>(<span class="number">3</span>);</span><br><span class="line"><span class="keyword">if</span> (!stkIntA.<span class="built_in">empty</span>())&#123;</span><br><span class="line">	<span class="keyword">int</span> iSize = stkIntA.<span class="built_in">size</span>();      <span class="comment">//2</span></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>C++</category>
        <category>STL</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>STL</tag>
        <tag>STL容器</tag>
      </tags>
  </entry>
  <entry>
    <title>STL_string容器</title>
    <url>/2021/05/07/STL%EF%BC%9Astring%E5%AE%B9%E5%99%A8/</url>
    <content><![CDATA[<h3 id="一、string概念"><a href="#一、string概念" class="headerlink" title="一、string概念"></a>一、string概念</h3><p>    string是STL的字符串类型，通常用来表示字符串。而在使用string之前，字符串通常是用char*表示的。string与char*都可以用来表示字符串，那么二者有什么区别。</p>
<span id="more"></span>

<p>    string和char*的比较:</p>
<ul>
<li><p>string是一个类, char*是一个指向字符的指针。</p>
<p>​     string封装了char*，管理这个字符串，是一个char*型的容器。</p>
</li>
<li><p>string不用考虑内存释放和越界。</p>
<p>​     string管理char*所分配的内存。每一次string的复制，取值都由string类负责维护，不用担心复制越界和取值越界等。</p>
</li>
<li><p>string提供了一系列的字符串操作函数</p>
<p>​     查找find，拷贝copy，删除erase，替换replace，插入insert</p>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//string 转 char*</span></span><br><span class="line">string str_1=<span class="string">&quot;string&quot;</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>* cstr_1=str.<span class="built_in">c_str</span>();</span><br><span class="line"><span class="comment">//char* 转 string</span></span><br><span class="line"><span class="keyword">char</span>* cstr_2=<span class="string">&quot;char&quot;</span>;</span><br><span class="line"><span class="function">string <span class="title">str_2</span><span class="params">(cstr)</span></span>;</span><br></pre></td></tr></table></figure>



<h3 id="二、string的构造函数"><a href="#二、string的构造函数" class="headerlink" title="二、string的构造函数"></a>二、string的构造函数</h3><ol>
<li><p>默认构造函数：string();    //构造一个空的字符串string s1。</p>
</li>
<li><p>构造函数：string(const string &amp;str); //构造一个与str一样的string。如string s1(s2)。</p>
</li>
<li><p>带参数的构造函数：</p>
<p>string(const char *s);  //用字符串s初始化</p>
<p>string(int n,char c);  //用n个字符c初始化</p>
</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">string s1; <span class="comment">//调用无参构造</span></span><br><span class="line"><span class="function">string <span class="title">s2</span><span class="params">(<span class="number">10</span>, <span class="string">&#x27;a&#x27;</span>)</span></span>;</span><br><span class="line"><span class="function">string <span class="title">s3</span><span class="params">(<span class="string">&quot;abcdefg&quot;</span>)</span></span>;</span><br><span class="line"><span class="function">string <span class="title">s4</span><span class="params">(s3)</span></span>; <span class="comment">//拷贝构造</span></span><br><span class="line"></span><br><span class="line">cout &lt;&lt; s1 &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; s2 &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; s3 &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; s4 &lt;&lt; endl;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">结果：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">aaaaaaaaaa</span></span><br><span class="line"><span class="comment">abcdefg</span></span><br><span class="line"><span class="comment">abcdefg</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>



<h3 id="三、string的存取字符操作"><a href="#三、string的存取字符操作" class="headerlink" title="三、string的存取字符操作"></a>三、string的存取字符操作</h3><p>string类的字符操作：</p>
<ul>
<li>const char &amp;operator[] (int n) const;    //通过[]方式取字符</li>
<li>const char &amp;at(int n) const;     //通过at方法获取字符</li>
<li>char &amp;operator[] (int n);</li>
<li>char &amp;at(int n);</li>
</ul>
<p>    operator[]和at()均返回当前字符串中第n个字符，但二者是有区别的。</p>
<p>    主要区别在于at()在越界时会抛出异常，[]在刚好越界时会返回(char)0，再继续越界时，编译器直接出错。如果你的程序希望可以通过try,catch捕获异常，建议采用at()。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">string s1 = <span class="string">&quot;abcdefg&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//重载[]操作符</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s1.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">    cout &lt;&lt; s1[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">//at成员函数</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s1.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">    cout &lt;&lt; s1.<span class="built_in">at</span>(i) &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">//区别：[]方式 如果访问越界，直接挂了</span></span><br><span class="line"><span class="comment">//at方式 访问越界 抛异常out_of_range</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">//cout &lt;&lt; s1[100] &lt;&lt; endl;</span></span><br><span class="line">    cout &lt;&lt; s1.<span class="built_in">at</span>(<span class="number">100</span>) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in"><span class="keyword">catch</span></span> (...) &#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;越界!&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">结果：</span></span><br><span class="line"><span class="comment">a b c d e f g</span></span><br><span class="line"><span class="comment">a b c d e f g</span></span><br><span class="line"><span class="comment">越界!</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>



<h3 id="四、从string取得const-char-的操作"><a href="#四、从string取得const-char-的操作" class="headerlink" title="四、从string取得const char*的操作"></a>四、从string取得const char*的操作</h3><p>    const char *c_str() const;  //返回一个以’\0’结尾的字符串的首地址</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//string 转 char*</span></span><br><span class="line">string str_1=<span class="string">&quot;string&quot;</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *cstr_1=str.<span class="built_in">c_str</span>();</span><br></pre></td></tr></table></figure>



<h3 id="五、把string拷贝到char-指向的内存空间的操作"><a href="#五、把string拷贝到char-指向的内存空间的操作" class="headerlink" title="五、把string拷贝到char*指向的内存空间的操作"></a>五、把string拷贝到char*指向的内存空间的操作</h3><p>    int copy(char *s, int n, int pos=0) const; </p>
<p>    把当前串中以pos开始的n个字符拷贝到以s为起始位置的字符数组中，返回实际拷贝的数目。注意要保证s所指向的空间足够大以容纳当前字符串，不然会越界。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">string s1 = <span class="string">&quot;abcdefg&quot;</span>;</span><br><span class="line"><span class="keyword">int</span> n = <span class="number">5</span>;pose</span><br><span class="line">    <span class="keyword">int</span> pose = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span>* s2 = (<span class="keyword">char</span>*)<span class="built_in">malloc</span>(n*<span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">char</span>));</span><br><span class="line"><span class="keyword">if</span>(s1.<span class="built_in">copy</span>(s2, n, pose))</span><br><span class="line">    cout &lt;&lt; s2 ;</span><br><span class="line"><span class="keyword">else</span> cout&lt;&lt;<span class="string">&quot;error&quot;</span>&lt;&lt;endl;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">结果：</span></span><br><span class="line"><span class="comment">def</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>



<h3 id="六、string的长度"><a href="#六、string的长度" class="headerlink" title="六、string的长度"></a>六、string的长度</h3><p>    int length() const;  //返回当前字符串的长度。长度不包括字符串结尾的’\0’。</p>
<p>    bool empty() const;   //当前字符串是否为空</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">string s1 = <span class="string">&quot;abcdefg&quot;</span>;</span><br><span class="line">string s2 = <span class="string">&quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> s1_length=s1.<span class="built_in">length</span>();  </span><br><span class="line"><span class="keyword">bool</span> s1_empty = s1.<span class="built_in">empty</span>();</span><br><span class="line"><span class="keyword">int</span> s2_length = s2.<span class="built_in">length</span>();  </span><br><span class="line"><span class="keyword">bool</span> s2_empty = s2.<span class="built_in">empty</span>();</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; s1_length &lt;&lt; <span class="string">&quot;     &quot;</span> &lt;&lt; s1_empty &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; s2_length &lt;&lt; <span class="string">&quot;     &quot;</span> &lt;&lt; s2_empty &lt;&lt; endl;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">结果：</span></span><br><span class="line"><span class="comment">7     0</span></span><br><span class="line"><span class="comment">0     1</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>



<h3 id="七、string的赋值"><a href="#七、string的赋值" class="headerlink" title="七、string的赋值"></a>七、string的赋值</h3><ul>
<li><p>  string &amp;operator=(const string &amp;s);//把字符串s赋给当前的字符串</p>
</li>
<li><p>  string &amp;assign(const char *s); //把字符串s赋给当前的字符串</p>
</li>
<li><p>  string &amp;assign(const char *s, int n); //把字符串s的前n个字符赋给当前的字符串</p>
</li>
<li><p>  string &amp;assign(const string &amp;s); //把字符串s赋给当前字符串</p>
</li>
<li><p>  string &amp;assign(int n,char c); //用n个字符c赋给当前字符串</p>
</li>
<li><p>  string &amp;assign(const string &amp;s,int start, int n); //把字符串s中从start开始的n个字符赋给当前字符串</p>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">string s1;</span><br><span class="line"><span class="function">string <span class="title">s2</span><span class="params">(<span class="string">&quot;appp&quot;</span>)</span></span>;</span><br><span class="line">s1 = <span class="string">&quot;abcdef&quot;</span>;</span><br><span class="line">cout &lt;&lt; s1 &lt;&lt; endl;</span><br><span class="line">s1 = s2;</span><br><span class="line">cout &lt;&lt; s1 &lt;&lt; endl;</span><br><span class="line">s1 = <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">cout &lt;&lt; s1 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">//成员方法assign</span></span><br><span class="line">s1.<span class="built_in">assign</span>(<span class="string">&quot;jkl&quot;</span>);</span><br><span class="line">cout &lt;&lt; s1 &lt;&lt; endl;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">结果：</span></span><br><span class="line"><span class="comment">abcdef</span></span><br><span class="line"><span class="comment">appp</span></span><br><span class="line"><span class="comment">a</span></span><br><span class="line"><span class="comment">jkl</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>



<h3 id="八、string字符串连接"><a href="#八、string字符串连接" class="headerlink" title="八、string字符串连接"></a>八、string字符串连接</h3><ul>
<li><p>  string &amp;operator+=(const string &amp;s); //把字符串s连接到当前字符串结尾</p>
</li>
<li><p>  string &amp;operator+=(const char *s);//把字符串s连接到当前字符串结尾</p>
</li>
<li><p>  string &amp;append(const char *s);  //把字符串s连接到当前字符串结尾</p>
</li>
<li><p>  string &amp;append(const char *s,int n); //把字符串s的前n个字符连接到当前字符串结尾</p>
</li>
<li><p>  string &amp;append(const string &amp;s);  //同operator+=()</p>
</li>
<li><p>  string &amp;append(const string &amp;s,int pos, int n);//把字符串s中从pos开始的n个字符连接到当前字符串结尾</p>
</li>
<li><p>  string &amp;append(int n, char c);  //在当前字符串结尾添加n个字符c</p>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">string s = <span class="string">&quot;abcd&quot;</span>;</span><br><span class="line">string s2 = <span class="string">&quot;1111&quot;</span>;</span><br><span class="line">s += <span class="string">&quot;abcd&quot;</span>;</span><br><span class="line">s += s2;</span><br><span class="line">cout &lt;&lt; s &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">string s3 = <span class="string">&quot;2222&quot;</span>;</span><br><span class="line">s2.<span class="built_in">append</span>(s3);</span><br><span class="line">cout &lt;&lt; s2 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">string s4 = s2 + s3;</span><br><span class="line">cout &lt;&lt; s4 &lt;&lt; endl;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">结果：</span></span><br><span class="line"><span class="comment">abcdabcd1111</span></span><br><span class="line"><span class="comment">11112222</span></span><br><span class="line"><span class="comment">111122222222</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>



<h3 id="九、string的比较"><a href="#九、string的比较" class="headerlink" title="九、string的比较"></a>九、string的比较</h3><ul>
<li><p>  int compare(const string &amp;s) const; //与字符串s比较</p>
</li>
<li><p>  int compare(const char *s) const;  //与字符串s比较</p>
</li>
<li><p>  compare函数在&gt;时返回 1，&lt;时返回 -1，==时返回 0。比较区分大小写，比较时参考字典顺序，排越前面的越小。大写的A比小写的a小。</p>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">string s1 = <span class="string">&quot;abcd&quot;</span>;</span><br><span class="line">string s2 = <span class="string">&quot;abce&quot;</span>;</span><br><span class="line"><span class="keyword">if</span> (s1.<span class="built_in">compare</span>(s2)==<span class="number">0</span>) &#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;字符串相等!&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;字符串不相等!&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="十、string的子串"><a href="#十、string的子串" class="headerlink" title="十、string的子串"></a>十、string的子串</h3><p>    string substr(int pos=0, int n=npos) const;  //返回由pos开始的n个字符组成的子字符串</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">string s = <span class="string">&quot;abcdefg&quot;</span>;</span><br><span class="line">string mysubstr = s.<span class="built_in">substr</span>(<span class="number">1</span>, <span class="number">3</span>);</span><br><span class="line">cout &lt;&lt; mysubstr &lt;&lt; endl;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">结果：</span></span><br><span class="line"><span class="comment">bcd</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>



<h3 id="十一、string的查找和替换"><a href="#十一、string的查找和替换" class="headerlink" title="十一、string的查找和替换"></a>十一、string的查找和替换</h3><h5 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h5><ul>
<li><p>  int find(char c,int pos=0) const; //从pos开始查找字符c在当前字符串的位置 </p>
</li>
<li><p>  int find(const char *s, int pos=0) const; //从pos开始查找字符串s在当前字符串的位置</p>
</li>
<li><p>int find(const string &amp;s, int pos=0) const; //从pos开始查找字符串s在当前字符串中的位置</p>
<p>  //find函数如果查找不到，就返回-1</p>
</li>
<li><p>  int rfind(char c, int pos=npos) const;  //从pos开始从后向前查找字符c在当前字符串中的位置 </p>
</li>
<li><p>  int rfind(const char *s, int pos=npos) const;</p>
</li>
<li><p>int rfind(const string &amp;s, int pos=npos) const;</p>
<p>  //rfind是反向查找的意思，如果查找不到， 返回-1 </p>
</li>
</ul>
<h5 id="替换"><a href="#替换" class="headerlink" title="替换"></a>替换</h5><ul>
<li><p>  string &amp;replace(int pos, int n, const char *s);//删除从pos开始的n个字符，然后在pos处插入串s</p>
</li>
<li><p>  string &amp;replace(int pos, int n, const string &amp;s); //删除从pos开始的n个字符，然后在pos处插入串s</p>
</li>
<li><p>  void swap(string &amp;s2);  //交换当前字符串与s2的值 </p>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 字符串的查找和替换</span></span><br><span class="line">string s1 = <span class="string">&quot;wbm hello wbm 111 wbm 222 wbm 333&quot;</span>;</span><br><span class="line"><span class="keyword">size_t</span> index = s1.<span class="built_in">find</span>(<span class="string">&quot;wbm&quot;</span>, <span class="number">0</span>);</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;index: &quot;</span> &lt;&lt; index;  </span><br><span class="line"></span><br><span class="line"><span class="comment">//求itcast出现的次数</span></span><br><span class="line"><span class="keyword">size_t</span> offindex = s1.<span class="built_in">find</span>(<span class="string">&quot;wbm&quot;</span>, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">while</span> (offindex != string::npos)&#123;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;在下标index: &quot;</span> &lt;&lt; offindex &lt;&lt; <span class="string">&quot;找到wbm\n&quot;</span>;</span><br><span class="line">    offindex = offindex + <span class="number">1</span>;</span><br><span class="line">    offindex = s1.<span class="built_in">find</span>(<span class="string">&quot;wbm&quot;</span>, offindex);</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">//替换 </span></span><br><span class="line">string s2 = <span class="string">&quot;wbm hello wbm 111 wbm 222 wbm 333&quot;</span>;</span><br><span class="line">s2.<span class="built_in">replace</span>(<span class="number">0</span>, <span class="number">3</span>, <span class="string">&quot;wbm&quot;</span>);</span><br><span class="line">cout &lt;&lt; s2 &lt;&lt; endl; </span><br><span class="line"></span><br><span class="line"><span class="comment">//求itcast出现的次数</span></span><br><span class="line">offindex = s2.<span class="built_in">find</span>(<span class="string">&quot;wbm&quot;</span>, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">while</span> (offindex != string::npos)&#123;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;在下标index: &quot;</span> &lt;&lt; offindex &lt;&lt; <span class="string">&quot;找到wbm\n&quot;</span>;</span><br><span class="line">    s2.<span class="built_in">replace</span>(offindex, <span class="number">3</span>, <span class="string">&quot;WBM&quot;</span>);</span><br><span class="line">    offindex = offindex + <span class="number">1</span>;</span><br><span class="line">    offindex = s1.<span class="built_in">find</span>(<span class="string">&quot;wbm&quot;</span>, offindex);</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;替换以后的s2：&quot;</span> &lt;&lt; s2 &lt;&lt; endl; </span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">结果：</span></span><br><span class="line"><span class="comment">index: 0在下标index: 0找到wbm</span></span><br><span class="line"><span class="comment">在下标index: 10找到wbm</span></span><br><span class="line"><span class="comment">在下标index: 18找到wbm</span></span><br><span class="line"><span class="comment">在下标index: 26找到wbm</span></span><br><span class="line"><span class="comment">wbm hello wbm 111 wbm 222 wbm 333</span></span><br><span class="line"><span class="comment">在下标index: 0找到wbm</span></span><br><span class="line"><span class="comment">在下标index: 10找到wbm</span></span><br><span class="line"><span class="comment">在下标index: 18找到wbm</span></span><br><span class="line"><span class="comment">在下标index: 26找到wbm</span></span><br><span class="line"><span class="comment">替换以后的s2：WBM hello WBM 111 WBM 222 WBM 333</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>



<h3 id="十二、String的区间删除和插入"><a href="#十二、String的区间删除和插入" class="headerlink" title="十二、String的区间删除和插入"></a>十二、String的区间删除和插入</h3><ul>
<li><p>  string &amp;insert(int pos, const char *s);</p>
</li>
<li><p>  string &amp;insert(int pos, const string &amp;s);//在pos位置插入字符串s</p>
</li>
<li><p>  string &amp;insert(int pos, int n, char c); //在pos位置 插入n个字符c </p>
</li>
<li><p>  string &amp;erase(int pos=0, int n=npos); //删除pos开始的n个字符，返回修改后的字符串</p>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">string s = <span class="string">&quot;abcdefg&quot;</span>;</span><br><span class="line">s.<span class="built_in">insert</span>(<span class="number">3</span>, <span class="string">&quot;111&quot;</span>);</span><br><span class="line">cout &lt;&lt; s &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">s.<span class="built_in">erase</span>(<span class="number">0</span>, <span class="number">2</span>);</span><br><span class="line">cout &lt;&lt; s &lt;&lt; endl;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">结果：</span></span><br><span class="line"><span class="comment">abc111defg</span></span><br><span class="line"><span class="comment">c111defg</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>C++</category>
        <category>STL</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>STL</tag>
        <tag>STL容器</tag>
      </tags>
  </entry>
  <entry>
    <title>STL_tuple容器</title>
    <url>/2021/05/07/STL%EF%BC%9Atuple%E5%AE%B9%E5%99%A8/</url>
    <content><![CDATA[<h3 id="一、元组简介"><a href="#一、元组简介" class="headerlink" title="一、元组简介"></a>一、元组简介</h3><p>    tuple是一个固定大小的不同类型值的集合，是泛化的std::pair。我们也可以把他当做一个通用的结构体来用，不需要创建结构体又获取结构体的特征，在某些情况下可以取代结构体使程序更简洁，直观。std::tuple理论上可以有无数个任意类型的成员变量，而std::pair只能是2个成员，因此在需要保存3个及以上的数据时就需要使用tuple元组了。</p>
<span id="more"></span>

<p>    tuple（元组）在c++11中开始引用的。tuple看似简单，其实它是简约而不简单，可以说它是c++11中一个既简单又复杂的东东，关于它简单的一面是它很容易使用，复杂的一面是它内部隐藏了太多细节，要揭开它神秘的面纱时又比较困难。</p>
<p>    #include &lt;tuple&gt;   </p>
<h3 id="二、tuple的创建和初始化"><a href="#二、tuple的创建和初始化" class="headerlink" title="二、tuple的创建和初始化"></a>二、tuple的创建和初始化</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">std::tuple&lt;T1, T2, TN&gt; t1;            </span><br><span class="line"><span class="comment">//创建一个空的tuple对象（使用默认构造），它对应的元素分别是T1和T2...Tn类型，采用值初始化。</span></span><br><span class="line">std::tuple&lt;T1, T2, TN&gt; t2(v1, v2, ... TN);    </span><br><span class="line"><span class="comment">//创建一个tuple对象，它的两个元素分别是T1和T2 ...Tn类型; 要获取元素的值需要通过tuple的成员get&lt;Ith&gt;(obj)进行获取(Ith是指获取在tuple中的第几个元素，请看后面具体实例)。</span></span><br><span class="line"><span class="function">std::tuple&lt;T1&amp;&gt; <span class="title">t3</span><span class="params">(ref&amp;)</span></span>; <span class="comment">// tuple的元素类型可以是一个引用</span></span><br><span class="line">std::<span class="built_in">make_tuple</span>(v1, v2); <span class="comment">// 像pair一样也可以通过make_tuple进行创建一个tuple对象</span></span><br></pre></td></tr></table></figure>


<p>     tuple的元素类型为引用：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">std::string name;</span><br><span class="line">std::tuple&lt;string &amp;, int&gt; tpRef(name, 30);</span><br><span class="line"><span class="comment">// 对tpRef第一个元素赋值，同时name也被赋值 - 引用</span></span><br><span class="line">std::get&lt;<span class="number">0</span>&gt;(tpRef) = <span class="string">&quot;Sven&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// name输出也是Sven</span></span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;name: &quot;</span> &lt;&lt; name &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br></pre></td></tr></table></figure>

<h3 id="三、有关tuple元素的操作"><a href="#三、有关tuple元素的操作" class="headerlink" title="三、有关tuple元素的操作"></a>三、有关tuple元素的操作</h3><h5 id="1-等价结构体"><a href="#1-等价结构体" class="headerlink" title="1.等价结构体"></a>1.等价结构体</h5><p>    开篇讲过在某些时候tuple可以等同于结构体一样使用，这样既方便又快捷。如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">struct person &#123;</span><br><span class="line">    char *m_name;</span><br><span class="line">    char *m_addr;</span><br><span class="line">    int  *m_ages;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;可以用tuple来表示这样的一个结构类型，作用是一样的。</span><br><span class="line">std::tuple&lt;const char *, const char *, int&gt;</span><br></pre></td></tr></table></figure>



<h5 id="2-如何获取tuple元素个数"><a href="#2-如何获取tuple元素个数" class="headerlink" title="2.如何获取tuple元素个数"></a>2.如何获取tuple元素个数</h5><p>    当有一个tuple对象但不知道有多少元素可以通过如下查询：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">std::tuple&lt;int, char, double&gt; mytuple (10, &#x27;a&#x27;, 3.14);</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;mytuple has &quot;</span>;</span><br><span class="line">std::cout &lt;&lt; std::tuple_size&lt;<span class="keyword">decltype</span>(mytuple)&gt;::value;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot; elements.&quot;</span> &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line"><span class="comment">//输出结果：</span></span><br><span class="line"><span class="comment">//mytuple has 3 elements</span></span><br></pre></td></tr></table></figure>



<h5 id="3-获取元素的值"><a href="#3-获取元素的值" class="headerlink" title="3. 获取元素的值"></a>3. 获取元素的值</h5><p>    获取tuple对象元素的值可以通过get&lt;Ith&gt;(obj)方法进行获取；</p>
<p>    Ith - 是想获取的元素在tuple对象中的位置。</p>
<p>    obj - 是想获取tuple的对象</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">std::tuple&lt;int, char, double&gt; mytuple (10, &#x27;a&#x27;, 3.14);</span><br><span class="line"><span class="comment">//获取元素</span></span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;the elements is: &quot;</span>;</span><br><span class="line">std::cout &lt;&lt; std::get&lt;<span class="number">0</span>&gt;(mytuple) &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">std::cout &lt;&lt; std::get&lt;<span class="number">1</span>&gt;(mytuple) &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">std::cout &lt;&lt; std::get&lt;<span class="number">2</span>&gt;(mytuple) &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line"><span class="comment">//输出结果：</span></span><br><span class="line"><span class="comment">//the elements is: 10 a 3.14 </span></span><br></pre></td></tr></table></figure>


<p>   tuple不支持迭代，只能通过元素索引(或tie解包)进行获取元素的值。但是<strong>给定的索引必须是在编译器就已经给定，不能在运行期进行动态传递，否则将发生编译错误</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">3</span>; i++)</span><br><span class="line">std::cout &lt;&lt; std::get&lt;i&gt;(mytuple) &lt;&lt; <span class="string">&quot; &quot;</span>; <span class="comment">//将引发编译错误</span></span><br></pre></td></tr></table></figure>



<h5 id="4-获取元素的类型"><a href="#4-获取元素的类型" class="headerlink" title="4.获取元素的类型"></a>4.获取元素的类型</h5><p>     要想得到元素类型可以通过tuple_element方法获取，如有以下元组对象：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">std::tuple&lt;std::string, int&gt; tp(&quot;Sven&quot;, 20);</span><br><span class="line"><span class="comment">// 得到第二个元素类型</span></span><br><span class="line">std::tuple_element&lt;<span class="number">1</span>, <span class="keyword">decltype</span>(tp)&gt;::type ages;  <span class="comment">// ages就为int类型</span></span><br><span class="line">ages = std::get&lt;<span class="number">1</span>&gt;(tp);</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;ages: &quot;</span> &lt;&lt; ages &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line"><span class="comment">//输出结果： </span></span><br><span class="line">ages: <span class="number">20</span></span><br></pre></td></tr></table></figure>



<h5 id="5-利用tie进行解包元素的值"><a href="#5-利用tie进行解包元素的值" class="headerlink" title="5.利用tie进行解包元素的值"></a>5.利用tie进行解包元素的值</h5><p>     如同pair一样也是可以通过tie进行解包tuple的各个元素的值。如下tuple对象有4个元素，通过tie解包将会把这4个元素的值分别赋值给tie提供的4个变量中。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;tuple&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;utility&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span> </span>&#123;</span><br><span class="line">    std::tuple&lt;std::string, <span class="keyword">int</span>, std::string, <span class="keyword">int</span>&gt; tp;</span><br><span class="line">    tp = std::<span class="built_in">make_tuple</span>(<span class="string">&quot;Sven&quot;</span>, <span class="number">25</span>, <span class="string">&quot;Shanghai&quot;</span>, <span class="number">21</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义接收变量</span></span><br><span class="line">    std::string name;</span><br><span class="line">    std::string addr;</span><br><span class="line">    <span class="keyword">int</span> ages;</span><br><span class="line">    <span class="keyword">int</span> areaCode;</span><br><span class="line">     </span><br><span class="line">    std::<span class="built_in">tie</span>(name, ages, addr, areaCode) = tp;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Output: &quot;</span> &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;name: &quot;</span> &lt;&lt; name &lt;&lt;<span class="string">&quot;, &quot;</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;addr: &quot;</span> &lt;&lt; addr &lt;&lt; <span class="string">&quot;, &quot;</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;ages: &quot;</span> &lt;&lt; ages &lt;&lt; <span class="string">&quot;, &quot;</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;areaCode: &quot;</span> &lt;&lt; areaCode &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;     </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*输出结果：</span></span><br><span class="line"><span class="comment">Output: </span></span><br><span class="line"><span class="comment">name: Sven, addr: Shanghai, ages: 25, areaCode: 21</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>


<p>    但有时候tuple包含的多个元素时只需要其中的一个或两个元素，如此可以通过std::ignore进行变量占位，这样将会忽略提取对应的元素。可以修改上述例程：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;tuple&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;utility&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span> </span>&#123;</span><br><span class="line">    std::tuple&lt;std::string, <span class="keyword">int</span>, std::string, <span class="keyword">int</span>&gt; tp;</span><br><span class="line">    tp = std::<span class="built_in">make_tuple</span>(<span class="string">&quot;Sven&quot;</span>, <span class="number">25</span>, <span class="string">&quot;Shanghai&quot;</span>, <span class="number">21</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义接收变量</span></span><br><span class="line">    std::string name;</span><br><span class="line">    std::string addr;</span><br><span class="line">    <span class="keyword">int</span> ages;</span><br><span class="line">    <span class="keyword">int</span> areaCode = <span class="number">110</span>;</span><br><span class="line">     </span><br><span class="line">    std::<span class="built_in">tie</span>(name, ages, std::ignore, std::ignore) = tp;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Output: &quot;</span> &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;name: &quot;</span> &lt;&lt; name &lt;&lt;<span class="string">&quot;, &quot;</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;addr: &quot;</span> &lt;&lt; addr &lt;&lt; <span class="string">&quot;, &quot;</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;ages: &quot;</span> &lt;&lt; ages &lt;&lt; <span class="string">&quot;, &quot;</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;areaCode: &quot;</span> &lt;&lt; areaCode &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">     </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">输出结果：</span></span><br><span class="line"><span class="comment">Output: </span></span><br><span class="line"><span class="comment">name: Sven, addr: , ages: 25, areaCode: 110</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>


<h5 id="6-tuple元素的引用"><a href="#6-tuple元素的引用" class="headerlink" title="6.tuple元素的引用"></a>6.tuple元素的引用</h5><p>    前面已经列举了将引用作为tuple的元素类型。下面通过引用搭配make_tuple()可以提取tuple的元素值，将某些变量值设给它们，并通过改变这些变量来改变tuple元素的值：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;tuple&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;functional&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **agrv)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    std::tuple&lt;std::string, int, float&gt; tp1(&quot;Sven Cheng&quot;, 77, 66.1);</span><br><span class="line">     </span><br><span class="line">    std::string name;</span><br><span class="line">    <span class="keyword">int</span> weight;</span><br><span class="line">    <span class="keyword">float</span> f;</span><br><span class="line">     </span><br><span class="line">    <span class="keyword">auto</span> tp2 = std::<span class="built_in">make_tuple</span>(std::<span class="built_in">ref</span>(name), std::<span class="built_in">ref</span>(weight), std::<span class="built_in">ref</span>(f)) = tp1;</span><br><span class="line">     </span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Before change: &quot;</span> &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;name: &quot;</span> &lt;&lt; name &lt;&lt; <span class="string">&quot;, &quot;</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;weight: &quot;</span> &lt;&lt; weight &lt;&lt; <span class="string">&quot;, &quot;</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;f: &quot;</span> &lt;&lt; f &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">     </span><br><span class="line">    name = <span class="string">&quot;Sven&quot;</span>;</span><br><span class="line">    weight = <span class="number">80</span>;</span><br><span class="line">    f = <span class="number">3.14</span>;</span><br><span class="line">     </span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;After change: &quot;</span> &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;element 1st: &quot;</span> &lt;&lt; std::get&lt;<span class="number">0</span>&gt;(tp2) &lt;&lt; <span class="string">&quot;, &quot;</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;element 2nd: &quot;</span> &lt;&lt; std::get&lt;<span class="number">1</span>&gt;(tp2) &lt;&lt; <span class="string">&quot;, &quot;</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;element 3rd: &quot;</span> &lt;&lt; std::get&lt;<span class="number">2</span>&gt;(tp2) &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">     </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">输出结果：</span></span><br><span class="line"><span class="comment">Before change: </span></span><br><span class="line"><span class="comment">name: Sven Cheng, weight: 77, f: 66.1</span></span><br><span class="line"><span class="comment">After change: </span></span><br><span class="line"><span class="comment">element 1st: Sven, element 2nd: 80, element 3rd: 3.14</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>C++</category>
        <category>STL</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>STL</tag>
        <tag>STL容器</tag>
      </tags>
  </entry>
  <entry>
    <title>STL_ map和unordered_map的差别</title>
    <url>/2021/05/07/STL%EF%BC%9Aunordered_%E7%AD%89%E5%AE%B9%E5%99%A8/</url>
    <content><![CDATA[<h3 id="需要引入的头文件不同"><a href="#需要引入的头文件不同" class="headerlink" title="需要引入的头文件不同"></a>需要引入的头文件不同</h3><span id="more"></span>

<ul>
<li>  map:     #include &lt; map &gt;</li>
<li>  unordered_map:     #include &lt; unordered_map &gt;</li>
</ul>
<h3 id="内部实现机理不同"><a href="#内部实现机理不同" class="headerlink" title="内部实现机理不同"></a>内部实现机理不同</h3><p>    map： map内部实现了一个红黑树（红黑树是非严格平衡二叉搜索树，而AVL是严格平衡二叉搜索树），红黑树具有自动排序的功能，因此map内部的所有元素都是有序的，红黑树的每一个节点都代表着map的一个元素。因此，对于map进行的查找，删除，添加等一系列的操作都相当于是对红黑树进行的操作。map中的元素是按照二叉搜索树（又名二叉查找树、二叉排序树，特点就是左子树上所有节点的键值都小于根节点的键值，右子树所有节点的键值都大于根节点的键值）存储的，使用中序遍历可将键值按照从小到大遍历出来。</p>
<p>    unordered_map: unordered_map内部实现了一个哈希表（也叫散列表，通过把关键码值映射到Hash表中一个位置来访问记录，查找的时间复杂度可达到O(1)，其在海量数据处理中有着广泛应用）。因此，其元素的排列顺序是无序的。哈希表详细介绍</p>
<h3 id="优缺点以及适用处"><a href="#优缺点以及适用处" class="headerlink" title="优缺点以及适用处"></a>优缺点以及适用处</h3><h5 id="map："><a href="#map：" class="headerlink" title="map："></a>map：</h5><p>    优点：有序性，这是map结构最大的优点，其元素的有序性在很多应用中都会简化很多的操作红黑树，内部实现一个红黑书使得map的很多操作在lgn的时间复杂度下就可以实现，因此效率非常的高。</p>
<p>    缺点： 空间占用率高，因为map内部实现了红黑树，虽然提高了运行效率，但是因为每一个节点都需要额外保存父节点、孩子节点和红/黑性质，使得每一个节点都占用大量的空间。</p>
<p>    适用处：对于那些有顺序要求的问题，用map会更高效一些</p>
<h5 id="unordered-map："><a href="#unordered-map：" class="headerlink" title="unordered_map："></a>unordered_map：</h5><p>    优点： 因为内部实现了哈希表，因此其查找速度非常的快</p>
<p>    缺点： 哈希表的建立比较耗费时间</p>
<p>    适用处：对于查找问题，unordered_map会更加高效一些，因此遇到查找问题，常会考虑一下用unordered_map</p>
<h5 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h5><ol>
<li> 内存占有率的问题就转化成红黑树 VS hash表 , 还是unorder_map占用的内存要高。</li>
<li> 但是unordered_map执行效率要比map高很多</li>
<li> 对于unordered_map或unordered_set容器，其遍历顺序与创建该容器时输入的顺序不一定相同，因为遍历是按照哈希表从前往后依次遍历的</li>
</ol>
<p>map和unordered_map的使用</p>
<p>    unordered_map的用法和map是一样的，提供了 insert，size，count等操作，并且里面的元素也是以pair类型来存贮的。其底层实现是完全不同的，上方已经解释了，但是就外部使用来说却是一致的。</p>
<p>    set与unordered_set、multiset与unordered_multiset、multimap与unordered_map之间类似。</p>
]]></content>
      <categories>
        <category>C++</category>
        <category>STL</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>STL</tag>
        <tag>STL容器</tag>
      </tags>
  </entry>
  <entry>
    <title>STL_vector容器</title>
    <url>/2021/05/07/STL%EF%BC%9Avector%E5%AE%B9%E5%99%A8/</url>
    <content><![CDATA[<h3 id="一、Vector容器简介"><a href="#一、Vector容器简介" class="headerlink" title="一、Vector容器简介"></a>一、Vector容器简介</h3><p>    vector是将元素置于一个动态数组中加以管理的容器。</p>
<p>    vector可以随机存取元素（支持索引值直接存取， 用[]操作符或at()方法）。</p>
<p>    vector尾部添加或移除元素非常快速，但是在中部或头部插入元素或移除元素比较费时。</p>
<span id="more"></span>

<h3 id="二、vector对象的默认构造"><a href="#二、vector对象的默认构造" class="headerlink" title="二、vector对象的默认构造"></a>二、vector对象的默认构造</h3><p>    vector采用模板类实现，vector对象的默认构造形式：<strong>vector&lt;T&gt; vecT;</strong>  </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">vector&lt;<span class="keyword">int</span>&gt; vecInt;     <span class="comment">//一个存放int的vector容器。</span></span><br><span class="line"></span><br><span class="line">vector&lt;<span class="keyword">float</span>&gt; vecFloat;    <span class="comment">//一个存放float的vector容器。</span></span><br><span class="line"></span><br><span class="line">vector&lt;string&gt; vecString;   <span class="comment">//一个存放string的vector容器。</span></span><br><span class="line"></span><br><span class="line">...                  <span class="comment">//尖括号内还可以设置指针类型或自定义类型。</span></span><br><span class="line"></span><br><span class="line">Class CA&#123;&#125;;</span><br><span class="line"></span><br><span class="line">vector&lt;CA*&gt; vecpCA;      <span class="comment">//用于存放CA对象的指针的vector容器。</span></span><br><span class="line"></span><br><span class="line">vector&lt;CA&gt; vecCA;       <span class="comment">//用于存放CA对象的vector容器。由于容器元素的存放是按值复制的方式进行的，所以此时CA必须提供CA的拷贝构造函数，以保证CA对象间拷贝正常。</span></span><br></pre></td></tr></table></figure>



<h3 id="三、vector对象的带参数构造"><a href="#三、vector对象的带参数构造" class="headerlink" title="三、vector对象的带参数构造"></a>三、vector对象的带参数构造</h3><ul>
<li><p>  vector(beg,end);  //构造函数将[beg, end)区间中的元素拷贝给本身。注意该区间是左闭右开的区间。</p>
</li>
<li><p>  vector(n,elem);  //构造函数将n个elem拷贝给本身。</p>
</li>
<li><p>  vector(const vector &amp;vec); //拷贝构造函数</p>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printVector</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; v)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (vector&lt;<span class="keyword">int</span>&gt;::iterator it = v.<span class="built_in">begin</span>(); it != v.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">		cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">vector&lt;<span class="keyword">int</span>&gt; vl;<span class="comment">//默认构造</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> arr[] = &#123; <span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span> &#125;;</span><br><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">v2</span><span class="params">(arr, arr + <span class="keyword">sizeof</span>(arr) / <span class="keyword">sizeof</span>(<span class="keyword">int</span>))</span></span>;</span><br><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">v3</span><span class="params">(v2.begin(), v2.begin()+<span class="number">3</span>)</span></span>;</span><br><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">v4</span><span class="params">(v3)</span></span>;</span><br><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">v5</span><span class="params">(<span class="number">4</span>,<span class="number">5</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printVector</span>(v2);</span><br><span class="line"><span class="built_in">printVector</span>(v3);</span><br><span class="line"><span class="built_in">printVector</span>(v4);</span><br><span class="line"><span class="built_in">printVector</span>(v5);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">结果：</span></span><br><span class="line"><span class="comment">10 20 30 40</span></span><br><span class="line"><span class="comment">10 20 30</span></span><br><span class="line"><span class="comment">10 20 30</span></span><br><span class="line"><span class="comment">5 5 5 5</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h3 id="四、vector的赋值"><a href="#四、vector的赋值" class="headerlink" title="四、vector的赋值"></a>四、vector的赋值</h3><ul>
<li><p>  vector.assign(beg,end);  //将[beg, end)区间中的数据拷贝赋值给本身。注意该区间是左闭右开的区间。</p>
</li>
<li><p>  vector.assign(n,elem); //将n个elem拷贝赋值给本身。</p>
</li>
<li><p>  vector&amp; operator=(const vector &amp;vec); //重载等号操作符</p>
</li>
<li><p>  vector.swap(vec); // 将vec与本身的元素互换。 </p>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> arr[] = &#123; <span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span> &#125;;</span><br><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">v1</span><span class="params">(arr, arr + <span class="keyword">sizeof</span>(arr) / <span class="keyword">sizeof</span>(<span class="keyword">int</span>))</span></span>;<span class="comment">//默认构造</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//成员方法</span></span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; v2;</span><br><span class="line">v2.<span class="built_in">assign</span>(v1.<span class="built_in">begin</span>(), v1.<span class="built_in">end</span>());</span><br><span class="line"></span><br><span class="line"><span class="comment">//重载=</span></span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; v3;</span><br><span class="line">v3 = v2;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> arr1[] = &#123; <span class="number">100</span>, <span class="number">200</span>, <span class="number">300</span>, <span class="number">400</span> &#125;;</span><br><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">v4</span><span class="params">(arr1, arr1 + <span class="keyword">sizeof</span>(arr) / <span class="keyword">sizeof</span>(<span class="keyword">int</span>))</span></span>;<span class="comment">//默认构造</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">printVector</span>(v1);</span><br><span class="line"><span class="built_in">printVector</span>(v2);</span><br><span class="line"><span class="built_in">printVector</span>(v3);</span><br><span class="line"><span class="built_in">printVector</span>(v4);</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;------------------&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">v4.<span class="built_in">swap</span>(v1);</span><br><span class="line"><span class="built_in">printVector</span>(v1);</span><br><span class="line"><span class="built_in">printVector</span>(v2);</span><br><span class="line"><span class="built_in">printVector</span>(v3);</span><br><span class="line"><span class="built_in">printVector</span>(v4);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">结果：</span></span><br><span class="line"><span class="comment">10 20 30 40</span></span><br><span class="line"><span class="comment">10 20 30 40</span></span><br><span class="line"><span class="comment">10 20 30 40</span></span><br><span class="line"><span class="comment">100 200 300 400</span></span><br><span class="line"><span class="comment">------------------</span></span><br><span class="line"><span class="comment">100 200 300 400</span></span><br><span class="line"><span class="comment">10 20 30 40</span></span><br><span class="line"><span class="comment">10 20 30 40</span></span><br><span class="line"><span class="comment">10 20 30 40</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>



<h3 id="五、vector的大小"><a href="#五、vector的大小" class="headerlink" title="五、vector的大小"></a>五、vector的大小</h3><ul>
<li><p>  vector.size();      //返回容器中元素的个数</p>
</li>
<li><p>  vector.empty();   //判断容器是否为空</p>
</li>
<li><p>  vector.resize(num);  //重新指定容器的长度为num，若容器变长，则以默认值填充新位置。如果容器变短，则末尾超出容器长度的元素被删除。</p>
</li>
<li><p>  vector.resize(num, elem); //重新指定容器的长度为num，若容器变长，则以elem值填充新位置。如果容器变短，则末尾超出容器长度的元素被删除。</p>
</li>
<li><p>  capacity();<em>//容器的容量</em> </p>
</li>
<li><p>  reserve(int len);//容器预留len个元素长度，预留位置不初始化，元素不可访问。 </p>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> arr1[] = &#123; <span class="number">100</span>, <span class="number">200</span>, <span class="number">300</span>, <span class="number">400</span> &#125;;</span><br><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">v4</span><span class="params">(arr1, arr1 + <span class="keyword">sizeof</span>(arr1) / <span class="keyword">sizeof</span>(<span class="keyword">int</span>))</span></span>;<span class="comment">//默认构造</span></span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;size：&quot;</span> &lt;&lt; v4.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line"><span class="keyword">if</span> (v4.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;空！&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;不空！&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printVector</span>(v4);</span><br><span class="line">v4.<span class="built_in">resize</span>(<span class="number">2</span>);</span><br><span class="line"><span class="built_in">printVector</span>(v4);</span><br><span class="line">v4.<span class="built_in">resize</span>(<span class="number">6</span>);</span><br><span class="line"><span class="built_in">printVector</span>(v4);</span><br><span class="line">v4.<span class="built_in">resize</span>(<span class="number">8</span>, <span class="number">1</span>);</span><br><span class="line"><span class="built_in">printVector</span>(v4);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++) &#123;</span><br><span class="line">    v4.<span class="built_in">push_back</span>(i);</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;size：&quot;</span> &lt;&lt; v4.<span class="built_in">size</span>() &lt;&lt; endl;  </span><br><span class="line">cout &lt;&lt; <span class="string">&quot;容量:&quot;</span> &lt;&lt; v4.<span class="built_in">capacity</span>() &lt;&lt; endl;<span class="comment">//容量不一定等于size</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">结果：</span></span><br><span class="line"><span class="comment">size：4</span></span><br><span class="line"><span class="comment">不空！</span></span><br><span class="line"><span class="comment">100 200 300 400</span></span><br><span class="line"><span class="comment">100 200</span></span><br><span class="line"><span class="comment">100 200 0 0 0 0</span></span><br><span class="line"><span class="comment">100 200 0 0 0 0 1 1</span></span><br><span class="line"><span class="comment">size：10008</span></span><br><span class="line"><span class="comment">容量:12138</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>



<h3 id="六、vector末尾的添加移除操作"><a href="#六、vector末尾的添加移除操作" class="headerlink" title="六、vector末尾的添加移除操作"></a>六、vector末尾的添加移除操作</h3><ul>
<li><p>  vector.push_back(); //在容器尾部加入一个元素</p>
</li>
<li><p>  vector.pop_back();; //移除容器中最后一个元素</p>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> arr1[] = &#123; <span class="number">100</span>, <span class="number">200</span>, <span class="number">300</span>, <span class="number">400</span> &#125;;</span><br><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">v1</span><span class="params">(arr1, arr1 + <span class="keyword">sizeof</span>(arr1) / <span class="keyword">sizeof</span>(<span class="keyword">int</span>))</span></span>;<span class="comment">//默认构造</span></span><br><span class="line"></span><br><span class="line">v1.<span class="built_in">push_back</span>(<span class="number">500</span>);</span><br><span class="line">v1.<span class="built_in">push_back</span>(<span class="number">600</span>);</span><br><span class="line">v1.<span class="built_in">push_back</span>(<span class="number">700</span>);</span><br><span class="line">v1.<span class="built_in">pop_back</span>();</span><br><span class="line"><span class="built_in">printVector</span>(v1);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">结果：</span></span><br><span class="line"><span class="comment">100 200 300 400 500 600100 200 300 400 500 600</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>



<h3 id="七、vector的数据存取"><a href="#七、vector的数据存取" class="headerlink" title="七、vector的数据存取"></a>七、vector的数据存取</h3><ul>
<li><p>  vector.at(int idx); //返回索引idx所指的数据，如果idx越界，抛出out_of_range异常。</p>
</li>
<li><p>  vector[int idx];//返回索引idx所指的数据，越界时，运行直接报错</p>
</li>
<li><p>  vector.front();//返回容器中第一个数据元素</p>
</li>
<li><p>  vector.back();//返回容器中最后一个数据元素</p>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> arr1[] = &#123; <span class="number">100</span>, <span class="number">200</span>, <span class="number">300</span>, <span class="number">400</span> &#125;;</span><br><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">v4</span><span class="params">(arr1, arr1 + <span class="keyword">sizeof</span>(arr1) / <span class="keyword">sizeof</span>(<span class="keyword">int</span>))</span></span>;<span class="comment">//默认构造</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//区别: at抛异常 []不抛异常</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; v4.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">    cout &lt;&lt; v4[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; v4.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">    cout &lt;&lt; v4.<span class="built_in">at</span>(i) &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;front:&quot;</span> &lt;&lt; v4.<span class="built_in">front</span>() &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;back:&quot;</span> &lt;&lt; v4.<span class="built_in">back</span>() &lt;&lt; endl;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">结果：</span></span><br><span class="line"><span class="comment">100 200 300 400</span></span><br><span class="line"><span class="comment">100 200 300 400</span></span><br><span class="line"><span class="comment">front:100</span></span><br><span class="line"><span class="comment">back:400</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>



<h3 id="八、vector的插入和删除"><a href="#八、vector的插入和删除" class="headerlink" title="八、vector的插入和删除"></a>八、vector的插入和删除</h3><ul>
<li><p>  vector.insert(pos,elem);  //在pos位置插入一个elem元素的拷贝，返回新数据的位置。</p>
</li>
<li><p>  vector.insert(pos,n,elem);  //在pos位置插入n个elem数据，无返回值。</p>
</li>
<li><p>  vector.insert(pos,beg,end);  //在pos位置插入[beg,end)区间的数据，无返回值</p>
</li>
<li><p>  vector.clear();   //移除容器的所有数据</p>
</li>
<li><p>  vector.erase(beg,end); //删除[beg,end)区间的数据，返回下一个数据的位置。</p>
</li>
<li><p>  vector.erase(pos);  //删除pos位置的数据，返回下一个数据的位置。</p>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">vector&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line">v.<span class="built_in">push_back</span>(<span class="number">10</span>);</span><br><span class="line">v.<span class="built_in">push_back</span>(<span class="number">20</span>);</span><br><span class="line"><span class="comment">//头插法</span></span><br><span class="line">v.<span class="built_in">insert</span>(v.<span class="built_in">begin</span>(), <span class="number">30</span>);</span><br><span class="line">v.<span class="built_in">insert</span>(v.<span class="built_in">end</span>(), <span class="number">40</span>);</span><br><span class="line"></span><br><span class="line">v.<span class="built_in">insert</span>(v.<span class="built_in">begin</span>() + <span class="number">2</span>, <span class="number">100</span>); <span class="comment">//vector支持随机访问</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//支持数组下标，一般都支持随机访问</span></span><br><span class="line"><span class="comment">//迭代器可以直接+2 +3 -2 -5操作</span></span><br><span class="line"><span class="built_in">printVector</span>(v);</span><br><span class="line"></span><br><span class="line"><span class="comment">//删除</span></span><br><span class="line">v.<span class="built_in">erase</span>(v.<span class="built_in">begin</span>());</span><br><span class="line"><span class="built_in">printVector</span>(v);</span><br><span class="line">v.<span class="built_in">erase</span>(v.<span class="built_in">begin</span>() + <span class="number">1</span>, v.<span class="built_in">end</span>());</span><br><span class="line"><span class="built_in">printVector</span>(v);</span><br><span class="line">v.<span class="built_in">clear</span>();</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;size:&quot;</span> &lt;&lt; v.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">结果：</span></span><br><span class="line"><span class="comment">30 10 100 20 40</span></span><br><span class="line"><span class="comment">10 100 20 40</span></span><br><span class="line"><span class="comment">10</span></span><br><span class="line"><span class="comment">size:0</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h3 id="九、巧用swap，收缩内存空间"><a href="#九、巧用swap，收缩内存空间" class="headerlink" title="九、巧用swap，收缩内存空间"></a>九、巧用swap，收缩内存空间</h3><p>    vector&lt;T&gt;(x).swap(x);    //其中，x 指当前要操作的容器，T 为该容器存储元素的类型。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//vector添加元素 他会自动增长 你删除元素时候，不会自动减少</span></span><br><span class="line"></span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100000</span>; i++) &#123;</span><br><span class="line">    v.<span class="built_in">push_back</span>(i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;size:&quot;</span> &lt;&lt; v.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;capacity:&quot;</span> &lt;&lt; v.<span class="built_in">capacity</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">v.<span class="built_in">resize</span>(<span class="number">10</span>);</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;--------------&quot;</span> &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;size:&quot;</span> &lt;&lt; v.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;capacity:&quot;</span> &lt;&lt; v.<span class="built_in">capacity</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">//收缩空间</span></span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt;(v).<span class="built_in">swap</span>(v);</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;--------------&quot;</span> &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;size:&quot;</span> &lt;&lt; v.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;capacity:&quot;</span> &lt;&lt; v.<span class="built_in">capacity</span>() &lt;&lt; endl;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">结果：</span></span><br><span class="line"><span class="comment">size:100000</span></span><br><span class="line"><span class="comment">capacity:138255</span></span><br><span class="line"><span class="comment">--------------</span></span><br><span class="line"><span class="comment">size:10</span></span><br><span class="line"><span class="comment">capacity:138255</span></span><br><span class="line"><span class="comment">--------------</span></span><br><span class="line"><span class="comment">size:10</span></span><br><span class="line"><span class="comment">capacity:10</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h3 id="十、reserve-预留空间"><a href="#十、reserve-预留空间" class="headerlink" title="十、reserve 预留空间"></a>十、reserve 预留空间</h3><p>    vector的reserve增加了vector的capacity，但是它的size没有改变！而resize改变了vector的capacity同时也增加了它的size！</p>
<p>原因如下：</p>
<ul>
<li>reserve是容器预留空间，但在空间内不真正创建元素对象，所以在没有添加新的对象之前，不能引用容器内的元素。加入新的元素时，要调用push_back()/insert()函数。</li>
<li> resize是改变容器的大小，且在创建对象，因此，调用这个函数之后，就可以引用容器内的对象了，因此当加入新的元素时，用operator[]操作符，或者用迭代器来引用元素对象。此时再调用push_back()函数，是加在这个新的空间后面的。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span>* address = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line">v.<span class="built_in">reserve</span>(<span class="number">100000</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100000</span>; i++) &#123;</span><br><span class="line">    v.<span class="built_in">push_back</span>(i);</span><br><span class="line">    <span class="keyword">if</span> (address != &amp;(v[<span class="number">0</span>])) &#123;</span><br><span class="line">        address = &amp;(v[<span class="number">0</span>]);</span><br><span class="line">        num++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;num:&quot;</span> &lt;&lt; num &lt;&lt; endl;<span class="comment">//申请num次空间</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">结果：</span></span><br><span class="line"><span class="comment">num:1</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>    如果一个vector使用默认的capacity，那么在push_back操作的时候，会根据添加元素的数量，动态的自动分配空间，2^n递增；<strong>如果声明vector的时候，显式的使用capacity(size_type n)来指定vector的容量，那么在push_back的过程中（元素数量不超过n），vector不会自动分配空间，提高程序效率。</strong></p>
]]></content>
      <categories>
        <category>C++</category>
        <category>STL</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>STL</tag>
        <tag>STL容器</tag>
      </tags>
  </entry>
  <entry>
    <title>STL_函数对象、谓词、预定义函数对象、函数适配器</title>
    <url>/2021/05/07/STL%EF%BC%9A%E5%87%BD%E6%95%B0%E5%AF%B9%E8%B1%A1%E3%80%81%E8%B0%93%E8%AF%8D%E3%80%81%E9%A2%84%E5%AE%9A%E4%B9%89%E5%87%BD%E6%95%B0%E5%AF%B9%E8%B1%A1%E3%80%81%E5%87%BD%E6%95%B0%E9%80%82%E9%85%8D%E5%99%A8/</url>
    <content><![CDATA[<h3 id="一、函数对象（仿函数）"><a href="#一、函数对象（仿函数）" class="headerlink" title="一、函数对象（仿函数）"></a>一、函数对象（仿函数）</h3><p>重载函数调用操作符的类，其对象常称为函数对象（function object），即它们是行为类似函数的对象，也叫仿函数(functor),其实就是重载“()”操作符，使得类对象可以像函数那样调用。</p>
<span id="more"></span>

<p>注意: </p>
<ol>
<li>函数对象(仿函数)是一个类，不是一个函数。</li>
<li>函数对象(仿函数)重载了”() ”操作符使得它可以像函数一样调用。</li>
</ol>
<p>分类:假定某个类有一个重载的operator()，而且重载的operator()要求获取一个参数，我们就将这个类称为“一元仿函数”（unary functor）；相反，如果重载的operator()要求获取两个参数，就将这个类称为“二元仿函数”（binary functor）。</p>
<p>函数对象的作用:</p>
<p>STL提供的算法往往都有两个版本，其中一个版本表现出最常用的某种运算，另一版本则允许用户通过template参数的形式来指定所要采取的策略。</p>
<p>“在标准库中，函数对象被广泛地使用以获得弹性”，标准库中的很多算法都可以使用函数对象或者函数来作为自定的回调行为。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _CRT_SECURE_NO_WARNINGS</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">MyPrint</span> &#123;</span></span><br><span class="line">	<span class="built_in">MyPrint</span>() &#123;</span><br><span class="line">		mNum = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">		mNum++;</span><br><span class="line">		cout &lt;&lt; val &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">int</span> mNum;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> num = <span class="number">0</span>; <span class="comment">//真正开发中，尽量避免去使用全局变量，加锁解锁繁琐</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MyPrint02</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">	num++;</span><br><span class="line">	cout &lt;&lt; val &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	MyPrint print;</span><br><span class="line">	<span class="built_in">print</span>(<span class="number">10</span>);</span><br><span class="line">	<span class="comment">//函数对象可以像普通函数一样调用</span></span><br><span class="line">	<span class="comment">//函数对象可以像普通函数那样接收参数</span></span><br><span class="line">	<span class="comment">//函数对象超出了函数的概念，函数对象可以保存函数调用的状态，避免使用全局变量</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test02</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	vector&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="number">10</span>);</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="number">20</span>);</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="number">30</span>);</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="number">40</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//计算函数调用次数</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> 0</span></span><br><span class="line">	<span class="built_in">MyPrint02</span>(<span class="number">10</span>);</span><br><span class="line">	<span class="built_in">MyPrint02</span>(<span class="number">20</span>);</span><br><span class="line">	cout &lt;&lt; num &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	MyPrint print;</span><br><span class="line">	<span class="built_in">print</span>(<span class="number">10</span>);</span><br><span class="line">	<span class="built_in">print</span>(<span class="number">20</span>);</span><br><span class="line">	cout &lt;&lt; print.mNum &lt;&lt; endl;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">	MyPrint print;</span><br><span class="line">	MyPrint print02=for_each(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), print);</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;print调用次数:&quot;</span> &lt;&lt; print.mNum &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;print调用次数:&quot;</span> &lt;&lt; print02.mNum &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">	<span class="built_in">test02</span>();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">结果：</span></span><br><span class="line"><span class="comment">10</span></span><br><span class="line"><span class="comment">20</span></span><br><span class="line"><span class="comment">30</span></span><br><span class="line"><span class="comment">40</span></span><br><span class="line"><span class="comment">print调用次数:0</span></span><br><span class="line"><span class="comment">print调用次数:4</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h3 id="二、谓词"><a href="#二、谓词" class="headerlink" title="二、谓词"></a>二、谓词</h3><p>谓词是指普通函数或重载的operator()返回值是bool类型的函数对象(仿函数)。如果operator接受一个参数，那么叫做一元谓词,如果接受两个参数，那么叫做二元谓词，谓词可作为一个判断式。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//一元谓词函数举例如下</span></span><br><span class="line"><span class="comment">//1，判断给出的string对象的长度是否小于6</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">GT6</span><span class="params">(<span class="keyword">const</span> string &amp;s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> s.<span class="built_in">size</span>() &gt;= <span class="number">6</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//2,判断给出的int是否在3到8之间</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Compare</span><span class="params">( <span class="keyword">int</span> i )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> ( i &gt;= <span class="number">3</span> &amp;&amp; i &lt;= <span class="number">8</span> );</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//二元谓词举例如下</span></span><br><span class="line"><span class="comment">//1，比较两个string对象，返回一个bool值，指出第一个string是否比第二个短</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isShorter</span><span class="params">(<span class="keyword">const</span> string &amp;s1, <span class="keyword">const</span> string &amp;s2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> s1.<span class="built_in">size</span>() &lt; s2.<span class="built_in">size</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="三、预定义函数对象"><a href="#三、预定义函数对象" class="headerlink" title="三、预定义函数对象"></a>三、预定义函数对象</h3><h5 id="1）预定义函数对象基本概念："><a href="#1）预定义函数对象基本概念：" class="headerlink" title="1）预定义函数对象基本概念："></a>1）预定义函数对象基本概念：</h5><p>标准模板库STL提前定义了很多预定义函数对象，#include &lt;functional&gt; 必须包含。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//使用预定义函数对象：</span></span><br><span class="line"><span class="comment">//类模板plus&lt;&gt; 的实现了： 不同类型的数据进行加法运算</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main41</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    plus&lt;<span class="keyword">int</span>&gt; intAdd;</span><br><span class="line">    <span class="keyword">int</span> x = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">int</span> y = <span class="number">20</span>;</span><br><span class="line">    <span class="keyword">int</span> z = <span class="built_in">intAdd</span>(x, y); <span class="comment">//等价于 x + y </span></span><br><span class="line">    cout &lt;&lt; z &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    plus&lt;string&gt; stringAdd;</span><br><span class="line">    string myc = <span class="built_in">stringAdd</span>(<span class="string">&quot;aaa&quot;</span>, <span class="string">&quot;bbb&quot;</span>);</span><br><span class="line">    cout &lt;&lt; myc &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    vector&lt;string&gt; v1;</span><br><span class="line">    v1.<span class="built_in">push_back</span>(<span class="string">&quot;bbb&quot;</span>);</span><br><span class="line">    v1.<span class="built_in">push_back</span>(<span class="string">&quot;aaa&quot;</span>);</span><br><span class="line">    v1.<span class="built_in">push_back</span>(<span class="string">&quot;ccc&quot;</span>);</span><br><span class="line">    v1.<span class="built_in">push_back</span>(<span class="string">&quot;zzzz&quot;</span>);</span><br><span class="line"> </span><br><span class="line">   <span class="comment">//缺省情况下，sort()用底层元素类型的小于操作符以升序排列容器的元素。</span></span><br><span class="line">   <span class="comment">//为了降序，可以传递预定义的类模板greater,它调用底层元素类型的大于操作符：</span></span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;sort()函数排序&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">sort</span>(v1.<span class="built_in">begin</span>(), v1.<span class="built_in">end</span>(), greater&lt;string&gt;() ); <span class="comment">//从大到小</span></span><br><span class="line">    <span class="keyword">for</span> (vector&lt;string&gt;::iterator it=v1.<span class="built_in">begin</span>(); it!=v1.<span class="built_in">end</span>(); it++ )</span><br><span class="line">    &#123;</span><br><span class="line">         cout &lt;&lt; *it &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="2）算术函数对象"><a href="#2）算术函数对象" class="headerlink" title="2）算术函数对象"></a>2）算术函数对象</h5><p>预定义的函数对象支持加、减、乘、除、求余和取反。调用的操作符是与type相关联的实例</p>
<p>加法：plus&lt;Types&gt;</p>
<p>plus&lt;string&gt; stringAdd;</p>
<p>sres = stringAdd(sva1,sva2);</p>
<p>减法：minus&lt;Types&gt;</p>
<p>乘法：multiplies&lt;Types&gt;</p>
<p>除法divides&lt;Tpye&gt;</p>
<p>求余：modulus&lt;Tpye&gt;</p>
<p>取反：negate&lt;Type&gt;</p>
<p>negate&lt;int&gt; intNegate;</p>
<p>ires = intNegate(ires);</p>
<p>Ires= UnaryFunc(negate&lt;int&gt;(),Ival1);</p>
<h5 id="3）关系函数对象"><a href="#3）关系函数对象" class="headerlink" title="3）关系函数对象"></a>3）关系函数对象</h5><p>等于equal_to&lt;Tpye&gt;</p>
<p>equal_to&lt;string&gt; stringEqual;</p>
<p>sres = stringEqual(sval1,sval2);</p>
<p>不等于not_equal_to&lt;Type&gt;</p>
<p>大于 greater&lt;Type&gt;</p>
<p>大于等于greater_equal&lt;Type&gt;</p>
<p>小于 less&lt;Type&gt;</p>
<p>小于等于less_equal&lt;Type&gt;</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main42</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;string&gt; v1;</span><br><span class="line">    v1.<span class="built_in">push_back</span>(<span class="string">&quot;bbb&quot;</span>);</span><br><span class="line">    v1.<span class="built_in">push_back</span>(<span class="string">&quot;aaa&quot;</span>);</span><br><span class="line">    v1.<span class="built_in">push_back</span>(<span class="string">&quot;ccc&quot;</span>);</span><br><span class="line">    v1.<span class="built_in">push_back</span>(<span class="string">&quot;zzzz&quot;</span>);</span><br><span class="line">    v1.<span class="built_in">push_back</span>(<span class="string">&quot;ccc&quot;</span>);</span><br><span class="line">    string s1 = <span class="string">&quot;ccc&quot;</span>;</span><br><span class="line">    <span class="comment">//int num = count_if(v1.begin(),v1.end(), equal_to&lt;string&gt;(),s1);</span></span><br><span class="line">    <span class="keyword">int</span> num = <span class="built_in">count_if</span>(v1.<span class="built_in">begin</span>(),v1.<span class="built_in">end</span>(),<span class="built_in">bind2nd</span>(equal_to&lt;string&gt;(), s1));</span><br><span class="line">    cout &lt;&lt; num &lt;&lt; endl;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<h5 id="4）逻辑函数对象"><a href="#4）逻辑函数对象" class="headerlink" title="4）逻辑函数对象"></a>4）逻辑函数对象</h5><p>逻辑与 logical_and&lt;Type&gt;</p>
<p>logical_and&lt;int&gt; indAnd;</p>
<p>ires = intAnd(ival1,ival2);</p>
<p>dres=BinaryFunc( logical_and&lt;double&gt;(),dval1,dval2);</p>
<p>逻辑或logical_or&lt;Type&gt;</p>
<p>逻辑非logical_not&lt;Type&gt;</p>
<p>logical_not&lt;int&gt; IntNot;</p>
<p>Ires = IntNot(ival1);</p>
<p>Dres=UnaryFunc( logical_not&lt;double&gt;,dval1);</p>
<h3 id="四、函数适配器"><a href="#四、函数适配器" class="headerlink" title="四、函数适配器"></a>四、函数适配器</h3><p>标准库提供一组函数适配器，用来特殊化或者扩展一元和二元函数对象。常用适配器是：</p>
<ul>
<li>绑定器（binder）: binder通过把二元函数对象的一个实参绑定到一个特殊的值上，将其转换成一元函数对象。C＋＋标准库提供两种预定义的binder适配器：bind1st和bind2nd，前者把值绑定到二元函数对象的第一个实参上，后者绑定在第二个实参上。</li>
<li>取反器(negator) : negator是一个将函数对象的值翻转的函数适配器。标准库提供两个预定义的ngeator适配器：not1翻转一元预定义函数对象的真值，而not2翻转二元谓词函数的真值。</li>
</ul>
<p>常用函数适配器列表如下：</p>
<ul>
<li>bind1st(op, value)</li>
<li>bind2nd(op, value)</li>
<li>not1(op)</li>
<li>not2(op)</li>
<li>mem_fun_ref(op)</li>
<li>mem_fun(op)</li>
<li>ptr_fun(op)</li>
</ul>
<h5 id="绑定器（binder）"><a href="#绑定器（binder）" class="headerlink" title="绑定器（binder）"></a>绑定器（binder）</h5><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">MyPrint</span> :</span> <span class="keyword">public</span> binary_function&lt;<span class="keyword">int</span>, <span class="keyword">int</span>, <span class="keyword">void</span>&gt; &#123;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">int</span> v, <span class="keyword">int</span> val)</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;v:&quot;</span> &lt;&lt; v &lt;&lt; <span class="string">&quot;   val:&quot;</span>&lt;&lt; val&lt;&lt; <span class="string">&quot;   v+val:&quot;</span> &lt;&lt; v + val &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; endl;</span><br><span class="line">		&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	vector&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">		v.<span class="built_in">push_back</span>(i);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> addNum = <span class="number">200</span>;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;bind1st结果:&quot;</span> &lt;&lt; endl;</span><br><span class="line">	for_each(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="built_in">bind1st</span>(<span class="built_in">MyPrint</span>(), addNum));<span class="comment">//绑定适配器  将一个二元函数对象转变成一元函数对象</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;bind2nd结果:&quot;</span> &lt;&lt; endl;</span><br><span class="line">	for_each(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="built_in">bind2nd</span>(<span class="built_in">MyPrint</span>(), addNum));</span><br><span class="line">	<span class="comment">//bind1st bind2nd区别？</span></span><br><span class="line">	<span class="comment">//bind1st，将addNum绑定为函数对象的第一个参数</span></span><br><span class="line">	<span class="comment">//bind2nd，将addNum绑定为函数对象的第二个参数</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">bind1st结果:</span></span><br><span class="line"><span class="comment">v:200   val:0   v+val:200</span></span><br><span class="line"><span class="comment">v:200   val:1   v+val:201</span></span><br><span class="line"><span class="comment">v:200   val:2   v+val:202</span></span><br><span class="line"><span class="comment">bind2nd结果:</span></span><br><span class="line"><span class="comment">v:0   val:200   v+val:200</span></span><br><span class="line"><span class="comment">v:1   val:200   v+val:201</span></span><br><span class="line"><span class="comment">v:2   val:200   v+val:202</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h5 id="取反器-negator"><a href="#取反器-negator" class="headerlink" title="取反器(negator)"></a>取反器(negator)</h5><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">MyPrint02</span> &#123;</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">		cout &lt;&lt; v &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">MyCompare</span> :</span> <span class="keyword">public</span> binary_function&lt;<span class="keyword">int</span>, <span class="keyword">int</span>, <span class="keyword">bool</span>&gt; &#123;</span><br><span class="line">	<span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">int</span> v1, <span class="keyword">int</span> v2)</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> v1 &gt; v2;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">MyGreater5</span> :</span> <span class="keyword">public</span> binary_function&lt;<span class="keyword">int</span>, <span class="keyword">int</span>, <span class="keyword">bool</span>&gt; &#123;</span><br><span class="line">	<span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">int</span> v, <span class="keyword">int</span> val)</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;v:&quot;</span> &lt;&lt; v &lt;&lt; <span class="string">&quot; val:&quot;</span> &lt;&lt; val &lt;&lt; endl;</span><br><span class="line">		<span class="keyword">return</span> v &gt; val;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//仿函数适配器 not1 not2 取反适配器</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test02</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	vector&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">		v.<span class="built_in">push_back</span>(<span class="built_in">rand</span>()%<span class="number">100</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	for_each(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="built_in">MyPrint02</span>()); </span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">	<span class="built_in">sort</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="built_in">MyCompare</span>());</span><br><span class="line">	for_each(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="built_in">MyPrint02</span>());</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">	<span class="built_in">sort</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="built_in">not2</span>(<span class="built_in">MyCompare</span>()));</span><br><span class="line">	for_each(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="built_in">MyPrint02</span>());</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//not1 not2 </span></span><br><span class="line">	<span class="comment">//如果对二元谓词取反，用not2</span></span><br><span class="line">	<span class="comment">//如果对一元谓词取反，用not1</span></span><br><span class="line">	vector&lt;<span class="keyword">int</span>&gt;::iterator it = <span class="built_in">find_if</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="built_in">not1</span>(<span class="built_in">bind2nd</span>(<span class="built_in">MyGreater5</span>(), <span class="number">10</span>)));</span><br><span class="line">	<span class="keyword">if</span> (it == v.<span class="built_in">end</span>()) &#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;没有找到&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		cout &lt;&lt; *it &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="ptr-fun-op"><a href="#ptr-fun-op" class="headerlink" title="ptr_fun(op)"></a>ptr_fun(op)</h5><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MyPrint03</span><span class="params">(<span class="keyword">int</span> val, <span class="keyword">int</span> val2)</span> </span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;val1:&quot;</span> &lt;&lt; val &lt;&lt; <span class="string">&quot;   val2:&quot;</span> &lt;&lt; val2 &lt;&lt; <span class="string">&quot;   val + val2:&quot;</span>&lt;&lt;val + val2 &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test03</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	vector&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">		v.<span class="built_in">push_back</span>(i);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//ptr_func把普通函数转成函数对象</span></span><br><span class="line">	for_each(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="built_in">bind2nd</span>(<span class="built_in">ptr_fun</span>(MyPrint03), <span class="number">10</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">结果：</span></span><br><span class="line"><span class="comment">val1:0   val2:10   val + val2:10</span></span><br><span class="line"><span class="comment">val1:1   val2:10   val + val2:11</span></span><br><span class="line"><span class="comment">val1:2   val2:10   val + val2:12</span></span><br><span class="line"><span class="comment">val1:3   val2:10   val + val2:13</span></span><br><span class="line"><span class="comment">val1:4   val2:10   val + val2:14</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h5 id="成员函数适配器："><a href="#成员函数适配器：" class="headerlink" title="成员函数适配器："></a>成员函数适配器：</h5><p>mem_fun_ref、mem_fun</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Person</span>(<span class="keyword">int</span> age, <span class="keyword">int</span> id) :<span class="built_in">age</span>(age), <span class="built_in">id</span>(id) &#123;&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;age:&quot;</span> &lt;&lt; age &lt;&lt; <span class="string">&quot; id:&quot;</span> &lt;&lt; id &lt;&lt; <span class="string">&quot; aaa&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">int</span> age;</span><br><span class="line">	<span class="keyword">int</span> id;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test04</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//如果容器中存放的对象或者对象指针，我们for_each算法打印的时候，调用类自己提供的打印函数</span></span><br><span class="line"></span><br><span class="line">	vector&lt;Person&gt; v;</span><br><span class="line">	Person p1(10, 20), p2(30, 40), p3(50, 60);</span><br><span class="line">	v.<span class="built_in">push_back</span>(p1);</span><br><span class="line">	v.<span class="built_in">push_back</span>(p2);</span><br><span class="line">	v.<span class="built_in">push_back</span>(p3);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//格式: &amp;类名::函数名</span></span><br><span class="line">	for_each(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="built_in">mem_fun_ref</span>(&amp;Person::show));</span><br><span class="line"></span><br><span class="line">	vector&lt;Person*&gt; v1;</span><br><span class="line">	v1.<span class="built_in">push_back</span>(&amp;p1);</span><br><span class="line">	v1.<span class="built_in">push_back</span>(&amp;p2);</span><br><span class="line">	v1.<span class="built_in">push_back</span>(&amp;p3);</span><br><span class="line"></span><br><span class="line">	for_each(v1.<span class="built_in">begin</span>(), v1.<span class="built_in">end</span>(), <span class="built_in">mem_fun</span>(&amp;Person::show));</span><br><span class="line">	<span class="comment">//mem_fun_ref mem_fun区别?</span></span><br><span class="line">	<span class="comment">//如果存放的是对象指针 使用mem_fun</span></span><br><span class="line">	<span class="comment">//如果使用的是对象 使用mem_fun_ref</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">结果：</span></span><br><span class="line"><span class="comment">age:10 id:20 aaa</span></span><br><span class="line"><span class="comment">age:30 id:40 aaa</span></span><br><span class="line"><span class="comment">age:50 id:60 aaa</span></span><br><span class="line"><span class="comment">age:10 id:20 aaa</span></span><br><span class="line"><span class="comment">age:30 id:40 aaa</span></span><br><span class="line"><span class="comment">age:50 id:60 aaa</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>C++</category>
        <category>STL</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>STL</tag>
      </tags>
  </entry>
  <entry>
    <title>STL_容器共性机制与使用时机</title>
    <url>/2021/05/07/STL%EF%BC%9A%E5%AE%B9%E5%99%A8%E5%85%B1%E6%80%A7%E6%9C%BA%E5%88%B6%E4%B8%8E%E4%BD%BF%E7%94%A8%E6%97%B6%E6%9C%BA/</url>
    <content><![CDATA[<h3 id="一、容器的共通能力"><a href="#一、容器的共通能力" class="headerlink" title="一、容器的共通能力"></a>一、容器的共通能力</h3><p>    C++模板是容器的概念。                            </p>
<p>    理论提高：所有容器提供的都是值（value）语意，而非引用（reference）语意。<strong>容器执行插入元素的操作时，内部实施拷贝动作。</strong>所以STL容器内存储的元素必须<strong>能够被拷贝</strong>（必须提供拷贝构造函数）。</p>
<span id="more"></span>

<p>     除了queue与stack外，每个容器都提供可返回迭代器的函数，运用返回的迭代器就可以访问元素。</p>
<p>    通常STL不会丢出异常，要求使用者确保传入正确的参数。</p>
<p>    每个容器都提供了一个默认构造函数跟一个默认拷贝构造函数。</p>
<p>    如已有容器vecIntA。 </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">vecIntB</span><span class="params">(vecIntA)</span></span>; <span class="comment">//调用拷贝构造函数，复制vecIntA到vecIntB中。</span></span><br></pre></td></tr></table></figure>

<p>    与大小相关的操作方法(c代表容器)：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">c.<span class="built_in">size</span>();  <span class="comment">//返回容器中元素的个数</span></span><br><span class="line">c.<span class="built_in">empty</span>();  <span class="comment">//判断容器是否为空</span></span><br></pre></td></tr></table></figure>

<p>    比较操作(c1,c2代表容器)：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">c1 == c2   <span class="comment">//判断c1是否等于c2</span></span><br><span class="line">c1 != c2   <span class="comment">//判断c1是否不等于c2</span></span><br><span class="line">c1 = c2    <span class="comment">//把c2的所有元素指派给c1 </span></span><br></pre></td></tr></table></figure>



<h3 id="二、STL容器使用时机"><a href="#二、STL容器使用时机" class="headerlink" title="二、STL容器使用时机"></a>二、STL容器使用时机</h3><table>
<thead>
<tr>
<th>.</th>
<th>vector</th>
<th>deque</th>
<th>list</th>
<th>set</th>
<th>multiset</th>
<th>map</th>
<th>multimap</th>
</tr>
</thead>
<tbody><tr>
<td>典型内存结构</td>
<td>单端数组</td>
<td>双端数组</td>
<td>双向链表</td>
<td>二叉树</td>
<td>二叉树</td>
<td>二叉树</td>
<td>二叉树</td>
</tr>
<tr>
<td>可随机存取</td>
<td>是</td>
<td>是</td>
<td>否</td>
<td>否</td>
<td>否</td>
<td>对key而言：是</td>
<td>否</td>
</tr>
<tr>
<td>元素搜寻速度</td>
<td>慢</td>
<td>慢</td>
<td>非常慢</td>
<td>快</td>
<td>快</td>
<td>对key而言：快</td>
<td>对key而言：快</td>
</tr>
<tr>
<td>元素安插移除</td>
<td>尾端</td>
<td>头尾两端</td>
<td>任何位置</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
</tr>
</tbody></table>
<p>    vector的使用场景：比如软件历史操作记录的存储，我们经常要查看历史记录，比如上一次的记录，上上次的记录，但却不会去删除记录，因为记录是事实的描述。</p>
<p>    deque的使用场景：比如排队购票系统，对排队者的存储可以采用deque，支持头端的快速移除，尾端的快速添加。如果采用vector，则头端移除时，会移动大量的数据，速度慢。</p>
<p>    vector与deque的比较：</p>
<ul>
<li>一：vector.at()比deque.at()效率高，比如vector.at(0)是固定的，deque的开始位置 却是不固定的。</li>
<li>二：如果有大量释放操作的话，vector花的时间更少，这跟二者的内部实现有关。</li>
<li>三：deque支持头部的快速插入与快速移除，这是deque的优点。</li>
</ul>
<p>    list的使用场景：比如公交车乘客的存储，随时可能有乘客下车，支持频繁的不确实位置元素的移除插入。</p>
<p>    set的使用场景：比如对手机游戏的个人得分记录的存储，存储要求从高分到低分的顺序排列。</p>
<p>    map的使用场景：比如按ID号存储十万个用户，想要快速要通过ID查找对应的用户。二叉树的查找效率，这时就体现出来了。如果是vector容器，最坏的情况下可能要遍历完整个容器才能找到该用户。</p>
]]></content>
      <categories>
        <category>C++</category>
        <category>STL</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>STL</tag>
        <tag>STL容器</tag>
      </tags>
  </entry>
  <entry>
    <title>STL_员工分组案例</title>
    <url>/2021/05/07/STL%EF%BC%9A%E5%91%98%E5%B7%A5%E5%88%86%E7%BB%84%E6%A1%88%E4%BE%8B/</url>
    <content><![CDATA[<p>公司今天招聘了 5 个员工， 5 名员工进入公司之后，需要指派员工在那个部门工作</p>
<ul>
<li>人员信息有: 姓名 年龄 电话 工资等组成</li>
<li>通过 Multimap 进行信息的插入 保存 显示</li>
<li>分部门显示员工信息 显示全部员工信息</li>
</ul>
<span id="more"></span>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//main.cpp文件</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;worker.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;manager.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	manager m;</span><br><span class="line">	m.<span class="built_in">show</span>();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//work.h文件</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">worker</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function">string <span class="title">getName</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">setName</span><span class="params">(string name)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="function">string <span class="title">getTelephone</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">setTelephone</span><span class="params">(string telephone)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">float</span> <span class="title">getSalary</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">setSalary</span><span class="params">(<span class="keyword">float</span> salary)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	string name;</span><br><span class="line">	<span class="keyword">int</span> age;</span><br><span class="line">	string telephone;</span><br><span class="line">	<span class="keyword">float</span> salary;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//work.cpp文件</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;worker.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function">string <span class="title">worker::getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">this</span>-&gt;name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">worker::setName</span><span class="params">(string name)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">this</span>-&gt;name = name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">string <span class="title">worker::getTelephone</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">this</span>-&gt;telephone;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">worker::setTelephone</span><span class="params">(string telephone)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">this</span>-&gt;telephone = telephone;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">worker::getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">this</span>-&gt;age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">worker::setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">this</span>-&gt;age = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">float</span> <span class="title">worker::getSalary</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">this</span>-&gt;salary;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">worker::setSalary</span><span class="params">(<span class="keyword">float</span> salary)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">this</span>-&gt;salary = salary;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//manager.h文件</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> WORKER_NUMBER 5</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SALE_DEPATMENT 1 <span class="comment">//销售部门</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DEVELOP_DEPATMENT 2 <span class="comment">//研发部门</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FINACIAL_DEPATMENT 3 <span class="comment">//财务部门</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;worker.h&quot;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">manager</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">create_worker</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">divide_worker</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">print_worker</span><span class="params">(<span class="keyword">int</span> departID)</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">print_worker_by_group</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	vector&lt;worker&gt; worker_vector;</span><br><span class="line">	multimap&lt;<span class="keyword">int</span>, worker&gt; worker_group;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//manager.cpp文件</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;worker.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;manager.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">manager::create_worker</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	string name_seed = <span class="string">&quot;ABCDE&quot;</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; WORKER_NUMBER; i++) &#123;</span><br><span class="line"></span><br><span class="line">		worker worker;</span><br><span class="line">		string tmp = name_seed.<span class="built_in">substr</span>(i, <span class="number">1</span>);</span><br><span class="line">		worker.<span class="built_in">setName</span>(<span class="string">&quot;选手&quot;</span> + tmp);</span><br><span class="line">		worker.<span class="built_in">setAge</span>(<span class="built_in">rand</span>() % <span class="number">15</span> + <span class="number">20</span>);</span><br><span class="line">		worker.<span class="built_in">setTelephone</span>(<span class="string">&quot;010-88888888&quot;</span>);</span><br><span class="line">		worker.<span class="built_in">setSalary</span>(<span class="built_in">rand</span>()%<span class="number">10000</span>+<span class="number">1000.00</span>);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">this</span>-&gt;worker_vector.<span class="built_in">push_back</span>(worker);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">manager::divide_worker</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">srand</span>(<span class="built_in">time</span>(<span class="literal">NULL</span>));</span><br><span class="line">	<span class="keyword">for</span> (vector&lt;worker&gt;::iterator it = <span class="keyword">this</span>-&gt;worker_vector.<span class="built_in">begin</span>() ; it !=<span class="keyword">this</span>-&gt;worker_vector.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">int</span> departID = <span class="built_in">rand</span>() % <span class="number">3</span> + <span class="number">1</span>;</span><br><span class="line">		<span class="built_in"><span class="keyword">switch</span></span> (departID) &#123;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">case</span> SALE_DEPATMENT:</span><br><span class="line">				<span class="keyword">this</span>-&gt;worker_group.<span class="built_in">insert</span>(<span class="built_in">make_pair</span>(SALE_DEPATMENT, *it));</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> DEVELOP_DEPATMENT:</span><br><span class="line">				<span class="keyword">this</span>-&gt;worker_group.<span class="built_in">insert</span>(<span class="built_in">make_pair</span>(DEVELOP_DEPATMENT, *it));</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> FINACIAL_DEPATMENT:</span><br><span class="line">				<span class="keyword">this</span>-&gt;worker_group.<span class="built_in">insert</span>(<span class="built_in">make_pair</span>(FINACIAL_DEPATMENT, *it));</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">default</span>:</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">manager::print_worker</span><span class="params">(<span class="keyword">int</span> departID)</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">	multimap&lt;<span class="keyword">int</span>, worker&gt;::iterator it = <span class="keyword">this</span>-&gt;worker_group.<span class="built_in">find</span>(departID);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">int</span> DepartCount = <span class="keyword">this</span>-&gt;worker_group.<span class="built_in">count</span>(departID);</span><br><span class="line">	<span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (multimap&lt;<span class="keyword">int</span>, worker&gt;::iterator pos = it; it != <span class="keyword">this</span>-&gt;worker_group.<span class="built_in">end</span>() &amp;&amp; num &lt; DepartCount; pos++, num++) &#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;姓名:&quot;</span> &lt;&lt; pos-&gt;second.<span class="built_in">getName</span>()&lt;&lt; <span class="string">&quot; 年龄:&quot;</span> &lt;&lt; pos-&gt;second.<span class="built_in">getAge</span>() &lt;&lt; <span class="string">&quot; 电话:&quot;</span> &lt;&lt; pos-&gt;second.<span class="built_in">getTelephone</span>() &lt;&lt; <span class="string">&quot; 工资:&quot;</span> &lt;&lt; pos-&gt;second.<span class="built_in">getSalary</span>() &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//打印每一部分员工信息</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">manager::print_worker_by_group</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//显示销售部门</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;销售部门:&quot;</span> &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">this</span>-&gt;<span class="built_in">print_worker</span>(SALE_DEPATMENT);</span><br><span class="line">	<span class="comment">//显示开发部门</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;研发部门:&quot;</span> &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">this</span>-&gt;<span class="built_in">print_worker</span>(DEVELOP_DEPATMENT);</span><br><span class="line">	<span class="comment">//显示财务部门</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;财务部门:&quot;</span> &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">this</span>-&gt;<span class="built_in">print_worker</span>(FINACIAL_DEPATMENT);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">manager::show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">this</span>-&gt;<span class="built_in">create_worker</span>();</span><br><span class="line">	<span class="keyword">this</span>-&gt;<span class="built_in">divide_worker</span>();</span><br><span class="line">	<span class="keyword">this</span>-&gt;<span class="built_in">print_worker_by_group</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>C++</category>
        <category>STL</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>STL</tag>
        <tag>STL案例</tag>
      </tags>
  </entry>
  <entry>
    <title>STL_常用的算法</title>
    <url>/2021/05/07/STL%EF%BC%9A%E5%B8%B8%E7%94%A8%E7%9A%84%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<p>&ensp;&ensp;&ensp;&ensp;总结了常用的算法并举例。</p>
<span id="more"></span>

<h3 id="一、常用的查找算法"><a href="#一、常用的查找算法" class="headerlink" title="一、常用的查找算法"></a>一、常用的查找算法</h3><h4 id="adjacent-find"><a href="#adjacent-find" class="headerlink" title="adjacent_find()"></a>adjacent_find()</h4><p>&ensp;&ensp;&ensp;&ensp;adjacent_find(iterator beg, iterator end, _callback);</p>
<p>&ensp;&ensp;&ensp;&ensp;在iterator对标识元素范围内，查找一对相邻重复元素，找到则返回指向这对元素的第一个元素的迭代器。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">vector&lt;<span class="keyword">int</span>&gt; vecInt;</span><br><span class="line">vecInt.<span class="built_in">push_back</span>(<span class="number">1</span>);</span><br><span class="line">vecInt.<span class="built_in">push_back</span>(<span class="number">2</span>);</span><br><span class="line">   vecInt.<span class="built_in">push_back</span>(<span class="number">2</span>);</span><br><span class="line">   vecInt.<span class="built_in">push_back</span>(<span class="number">4</span>);</span><br><span class="line">   vecInt.<span class="built_in">push_back</span>(<span class="number">5</span>);</span><br><span class="line">vecInt.<span class="built_in">push_back</span>(<span class="number">5</span>);</span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt;::iterator it = <span class="built_in">adjacent_find</span>(vecInt.<span class="built_in">begin</span>(), vecInt.<span class="built_in">end</span>()); </span><br><span class="line">   <span class="comment">//*it = 2</span></span><br></pre></td></tr></table></figure>



<h4 id="binary-search（）"><a href="#binary-search（）" class="headerlink" title="binary_search（）"></a>binary_search（）</h4><p>&ensp;&ensp;&ensp;&ensp;bool binary_search(iterator beg, iterator end, value);</p>
<p>&ensp;&ensp;&ensp;&ensp;在有序序列中查找value,找到则返回true。注意：在无序序列中，不可使用。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">set&lt;<span class="keyword">int</span>&gt; setInt;</span><br><span class="line">setInt.<span class="built_in">insert</span>(<span class="number">3</span>);</span><br><span class="line">   setInt.<span class="built_in">insert</span>(<span class="number">1</span>);</span><br><span class="line">setInt.<span class="built_in">insert</span>(<span class="number">7</span>);</span><br><span class="line">setInt.<span class="built_in">insert</span>(<span class="number">5</span>);</span><br><span class="line">setInt.<span class="built_in">insert</span>(<span class="number">9</span>);</span><br><span class="line"><span class="keyword">bool</span> bFind = <span class="built_in">binary_search</span>(setInt.<span class="built_in">begin</span>(), setInt.<span class="built_in">end</span>(), <span class="number">5</span>);<span class="comment">//nFind=true</span></span><br></pre></td></tr></table></figure>



<h4 id="count"><a href="#count" class="headerlink" title="count()"></a>count()</h4><p>&ensp;&ensp;&ensp;&ensp;count(iterator beg, iterator end, value);</p>
<p>&ensp;&ensp;&ensp;&ensp;利用等于操作符，把标志范围内的元素与输入值比较，返回相等的个数。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">vector&lt;<span class="keyword">int</span>&gt; vecInt;</span><br><span class="line">vecInt.<span class="built_in">push_back</span>(<span class="number">1</span>);</span><br><span class="line">vecInt.<span class="built_in">push_back</span>(<span class="number">2</span>);</span><br><span class="line">vecInt.<span class="built_in">push_back</span>(<span class="number">2</span>);</span><br><span class="line">vecInt.<span class="built_in">push_back</span>(<span class="number">4</span>);</span><br><span class="line">vecInt.<span class="built_in">push_back</span>(<span class="number">2</span>);</span><br><span class="line">vecInt.<span class="built_in">push_back</span>(<span class="number">5</span>);</span><br><span class="line"><span class="keyword">int</span> iCount = <span class="built_in">count</span>(vecInt.<span class="built_in">begin</span>(),vecInt.<span class="built_in">end</span>(),<span class="number">2</span>);  <span class="comment">//iCount==3</span></span><br></pre></td></tr></table></figure>

<p>​    </p>
<h4 id="count-if"><a href="#count-if" class="headerlink" title="count_if()"></a>count_if()</h4><p>&ensp;&ensp;&ensp;&ensp;count_if(首迭代器，未迭代器，搜索值（要比较的值的结果）)(条件计数)</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//假设vector&lt;int&gt; vecIntA，vecIntA包含1,3,5,7,9元素</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//先定义比较函数</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">GreaterThree</span><span class="params">(<span class="keyword">int</span> iNum)</span></span>&#123;</span><br><span class="line">     <span class="keyword">if</span>(iNum&gt;=<span class="number">3</span>)&#123;</span><br><span class="line">     	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">else</span>&#123;</span><br><span class="line">	    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">     &#125;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> iCount = <span class="built_in">count_if</span>(vecIntA.<span class="built_in">begin</span>(), vecIntA.<span class="built_in">end</span>(), GreaterThree);</span><br><span class="line"><span class="comment">//此时iCount == 4</span></span><br></pre></td></tr></table></figure>



<h4 id="find"><a href="#find" class="headerlink" title="find()"></a>find()</h4><p>&ensp;&ensp;&ensp;&ensp;find(iterator beg, iterator end, value)</p>
<p>&ensp;&ensp;&ensp;&ensp;find: 利用底层元素的等于操作符，对指定范围内的元素与输入值进行比较。当匹配时，结束搜索，返回该元素的迭代器。 </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">vector&lt;<span class="keyword">int</span>&gt; vecInt;</span><br><span class="line">vecInt.<span class="built_in">push_back</span>(<span class="number">1</span>);</span><br><span class="line">vecInt.<span class="built_in">push_back</span>(<span class="number">3</span>);</span><br><span class="line">vecInt.<span class="built_in">push_back</span>(<span class="number">5</span>);</span><br><span class="line">vecInt.<span class="built_in">push_back</span>(<span class="number">7</span>);</span><br><span class="line">vecInt.<span class="built_in">push_back</span>(<span class="number">9</span>);</span><br><span class="line"></span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt;::iterator it = <span class="built_in">find</span>(vecInt.<span class="built_in">begin</span>(), vecInt.<span class="built_in">end</span>(), <span class="number">5</span>);        <span class="comment">//*it == 5</span></span><br></pre></td></tr></table></figure>



<h4 id="find-if"><a href="#find-if" class="headerlink" title="find_if()"></a>find_if()</h4><p>&ensp;&ensp;&ensp;&ensp;find_if(iterator beg, iterator end, _callback);（条件查找）</p>
<p>&ensp;&ensp;&ensp;&ensp;find_if:  使用输入的函数代替等于操作符执行find。返回被找到的元素的迭代器。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//假设vector&lt;int&gt; vecIntA，vecIntA包含1,3,5,3,9元素 </span></span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt;::it = <span class="built_in">find_if</span>(vecInt.<span class="built_in">begin</span>(),vecInt.<span class="built_in">end</span>(),GreaterThree);</span><br><span class="line"><span class="comment">//此时 *it==3, *(it+1)==5, *(it+2)==3, *(it+3)==9 </span></span><br></pre></td></tr></table></figure>



<h3 id="二、常用的排序算法"><a href="#二、常用的排序算法" class="headerlink" title="二、常用的排序算法"></a>二、常用的排序算法</h3><h4 id="merge"><a href="#merge" class="headerlink" title="merge()"></a>merge()</h4><p>&ensp;&ensp;&ensp;&ensp;以下是排序和通用算法：提供元素排序策略</p>
<p>&ensp;&ensp;&ensp;&ensp;merge:  合并两个有序序列，存放到另一个序列。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//例如：vecIntA,vecIntB,vecIntC是用vector\&lt;int&gt;声明的容器，vecIntA已包含1,3,5,7,9元素，vecIntB已包含2,4,6,8元素</span></span><br><span class="line">vecIntC.<span class="built_in">resize</span>(<span class="number">9</span>); <span class="comment">//扩大容量</span></span><br><span class="line"><span class="built_in">merge</span>(vecIntA.<span class="built_in">begin</span>(),vecIntA.<span class="built_in">end</span>(),vecIntB.<span class="built_in">begin</span>(),vecIntB.<span class="built_in">end</span>(),vecIntC.<span class="built_in">begin</span>());</span><br><span class="line"><span class="comment">//此时vecIntC就存放了按顺序的1,2,3,4,5,6,7,8,9九个元素</span></span><br></pre></td></tr></table></figure>



<h4 id="sort"><a href="#sort" class="headerlink" title="sort()"></a>sort()</h4><p>&ensp;&ensp;&ensp;&ensp;sort: 以默认升序的方式重新排列指定范围内的元素。若要改排序规则，可以输入比较函数。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//学生类</span></span><br><span class="line">Class CStudent:</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">CStudent</span>(<span class="keyword">int</span> iID, string strName)</span><br><span class="line">    &#123;</span><br><span class="line">		m_iID=iID; </span><br><span class="line">		m_strName=strName; </span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">public</span>:      </span><br><span class="line">    <span class="keyword">int</span> m_iID;</span><br><span class="line">    string m_strName;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//学号比较函数</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Compare</span><span class="params">(<span class="keyword">const</span> CStudent &amp;stuA,<span class="keyword">const</span> CStudent &amp;stuB)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> (stuA.m_iID&lt;strB.m_iID);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;CStudent&gt; vecStu;</span><br><span class="line">    vecStu.<span class="built_in">push_back</span>(<span class="built_in">CStudent</span>(<span class="number">2</span>,<span class="string">&quot;老二&quot;</span>));</span><br><span class="line">	vecStu.<span class="built_in">push_back</span>(<span class="built_in">CStudent</span>(<span class="number">1</span>,<span class="string">&quot;老大&quot;</span>));</span><br><span class="line">	vecStu.<span class="built_in">push_back</span>(<span class="built_in">CStudent</span>(<span class="number">3</span>,<span class="string">&quot;老三&quot;</span>));</span><br><span class="line">	vecStu.<span class="built_in">push_back</span>(<span class="built_in">CStudent</span>(<span class="number">4</span>,<span class="string">&quot;老四&quot;</span>));</span><br><span class="line">	<span class="built_in">sort</span>(vecStu.<span class="built_in">begin</span>(),vecStu.<span class="built_in">end</span>(),Compare);</span><br><span class="line">	<span class="comment">// 此时，vecStu容器包含了按顺序的&quot;老大对象&quot;,&quot;老二对象&quot;,&quot;老三对象&quot;,&quot;老四对象&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="random-shuffle"><a href="#random-shuffle" class="headerlink" title="random_shuffle()"></a>random_shuffle()</h4><p>&ensp;&ensp;&ensp;&ensp;random_shuffle:   对指定范围内的元素随机调整次序。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">srand</span>(<span class="built_in">time</span>(<span class="number">0</span>));             <span class="comment">//设置随机种子</span></span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; vecInt;</span><br><span class="line">vecInt.<span class="built_in">push_back</span>(<span class="number">1</span>);</span><br><span class="line">vecInt.<span class="built_in">push_back</span>(<span class="number">3</span>);</span><br><span class="line">vecInt.<span class="built_in">push_back</span>(<span class="number">5</span>);</span><br><span class="line">vecInt.<span class="built_in">push_back</span>(<span class="number">7</span>);</span><br><span class="line">vecInt.<span class="built_in">push_back</span>(<span class="number">9</span>);</span><br><span class="line"><span class="function">string <span class="title">str</span><span class="params">(<span class="string">&quot;itcastitcast &quot;</span>)</span></span>;</span><br><span class="line"><span class="built_in">random_shuffle</span>(vecInt.<span class="built_in">begin</span>(), vecInt.<span class="built_in">end</span>());  <span class="comment">//随机排序，结果比如：9,7,1,5,3</span></span><br><span class="line"><span class="built_in">random_shuffle</span>(str.<span class="built_in">begin</span>(), str.<span class="built_in">end</span>());        <span class="comment">//随机排序，结果比如：&quot; itstcasticat &quot;</span></span><br></pre></td></tr></table></figure>



<h4 id="reverse"><a href="#reverse" class="headerlink" title="reverse()"></a>reverse()</h4><p>&ensp;&ensp;&ensp;&ensp;reverse：反转指定范围的元素</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">vector&lt;<span class="keyword">int</span>&gt; vecInt;</span><br><span class="line">vecInt.<span class="built_in">push_back</span>(<span class="number">1</span>);</span><br><span class="line">vecInt.<span class="built_in">push_back</span>(<span class="number">3</span>);</span><br><span class="line">vecInt.<span class="built_in">push_back</span>(<span class="number">5</span>);</span><br><span class="line">vecInt.<span class="built_in">push_back</span>(<span class="number">7</span>);</span><br><span class="line">vecInt.<span class="built_in">push_back</span>(<span class="number">9</span>);</span><br><span class="line"><span class="built_in">reverse</span>(vecInt.<span class="built_in">begin</span>(), vecInt.<span class="built_in">end</span>());       <span class="comment">//&#123;9,7,5,3,1&#125;</span></span><br></pre></td></tr></table></figure>



<h3 id="三、常用的拷贝和替换算法"><a href="#三、常用的拷贝和替换算法" class="headerlink" title="三、常用的拷贝和替换算法"></a>三、常用的拷贝和替换算法</h3><h4 id="copy"><a href="#copy" class="headerlink" title="copy()"></a>copy()</h4><p>&ensp;&ensp;&ensp;&ensp;copy算法 将容器内指定范围的元素拷贝到另一容器中</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">vector&lt;<span class="keyword">int</span>&gt; vecIntA;</span><br><span class="line">vecIntA.<span class="built_in">push_back</span>(<span class="number">1</span>);</span><br><span class="line">vecIntA.<span class="built_in">push_back</span>(<span class="number">3</span>);</span><br><span class="line">vecIntA.<span class="built_in">push_back</span>(<span class="number">5</span>);</span><br><span class="line">vecIntA.<span class="built_in">push_back</span>(<span class="number">7</span>);</span><br><span class="line">vecIntA.<span class="built_in">push_back</span>(<span class="number">9</span>);</span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; vecIntB;</span><br><span class="line">vecIntB.<span class="built_in">resize</span>(<span class="number">5</span>);           <span class="comment">//扩大空间</span></span><br><span class="line"><span class="built_in">copy</span>(vecIntA.<span class="built_in">begin</span>(), vecIntA.<span class="built_in">end</span>(), vecIntB.<span class="built_in">begin</span>());  <span class="comment">//vecIntB: &#123;1,3,5,7,9&#125;</span></span><br></pre></td></tr></table></figure>



<h4 id="replace"><a href="#replace" class="headerlink" title="replace()"></a>replace()</h4><p>&ensp;&ensp;&ensp;&ensp;replace(beg,end,oldValue,newValue):  将指定范围内的所有等于oldValue的元素替换成newValue。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">vector&lt;<span class="keyword">int</span>&gt; vecIntA;</span><br><span class="line">vecIntA.<span class="built_in">push_back</span>(<span class="number">1</span>);</span><br><span class="line">vecIntA.<span class="built_in">push_back</span>(<span class="number">3</span>);</span><br><span class="line">vecIntA.<span class="built_in">push_back</span>(<span class="number">5</span>);</span><br><span class="line">vecIntA.<span class="built_in">push_back</span>(<span class="number">3</span>);</span><br><span class="line">vecIntA.<span class="built_in">push_back</span>(<span class="number">9</span>);</span><br><span class="line"><span class="built_in">replace</span>(vecIntA.<span class="built_in">begin</span>(), vecIntA.<span class="built_in">end</span>(), <span class="number">3</span>, <span class="number">8</span>);     <span class="comment">//&#123;1,8,5,8,9&#125;</span></span><br></pre></td></tr></table></figure>



<h4 id="replace-if"><a href="#replace-if" class="headerlink" title="replace_if()"></a>replace_if()</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	replace_if算法 将容器内指定范围满足条件的元素替换为新元素</span></span><br><span class="line"><span class="comment">	@param beg 容器开始迭代器</span></span><br><span class="line"><span class="comment">	@param end 容器结束迭代器</span></span><br><span class="line"><span class="comment">	@param callback函数回调或者谓词(返回Bool类型的函数对象)</span></span><br><span class="line"><span class="comment">	@param oldvalue 新元素</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="built_in">replace_if</span>(iterator beg, iterator end, _callback, newvalue)</span><br></pre></td></tr></table></figure>

<p>&ensp;&ensp;&ensp;&ensp;replace_if : 将指定范围内所有操作结果为true的元素用新值替换。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//把大于等于3的元素替换成8</span></span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; vecIntA;</span><br><span class="line">vecIntA.<span class="built_in">push_back</span>(<span class="number">1</span>);</span><br><span class="line">vecIntA.<span class="built_in">push_back</span>(<span class="number">3</span>);</span><br><span class="line">vecIntA.<span class="built_in">push_back</span>(<span class="number">5</span>);</span><br><span class="line">vecIntA.<span class="built_in">push_back</span>(<span class="number">3</span>);</span><br><span class="line">vecIntA.<span class="built_in">push_back</span>(<span class="number">9</span>);</span><br><span class="line"><span class="built_in">replace_if</span>(vecIntA.<span class="built_in">begin</span>(), vecIntA.<span class="built_in">end</span>(), GreaterThree, <span class="number">8</span>);     <span class="comment">// GreaterThree的定义在上面。</span></span><br></pre></td></tr></table></figure>



<h4 id="swap"><a href="#swap" class="headerlink" title="swap()"></a>swap()</h4><p>&ensp;&ensp;&ensp;&ensp;swap:  交换两个容器的元素</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">vector&lt;<span class="keyword">int</span>&gt; vecIntA;</span><br><span class="line">vecIntA.<span class="built_in">push_back</span>(<span class="number">1</span>);</span><br><span class="line">vecIntA.<span class="built_in">push_back</span>(<span class="number">3</span>);</span><br><span class="line">vecIntA.<span class="built_in">push_back</span>(<span class="number">5</span>);</span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; vecIntB;</span><br><span class="line">vecIntB.<span class="built_in">push_back</span>(<span class="number">2</span>);</span><br><span class="line">vecIntB.<span class="built_in">push_back</span>(<span class="number">4</span>);</span><br><span class="line"><span class="built_in">swap</span>(vecIntA, vecIntB); <span class="comment">//交换</span></span><br></pre></td></tr></table></figure>



<h3 id="四、常用的算术和生成算法"><a href="#四、常用的算术和生成算法" class="headerlink" title="四、常用的算术和生成算法"></a>四、常用的算术和生成算法</h3><h4 id="accumulate"><a href="#accumulate" class="headerlink" title="accumulate()"></a>accumulate()</h4><p>&ensp;&ensp;&ensp;&ensp;accumulate: 对指定范围内的元素求和，然后结果再加上一个由val指定的初始值。</p>
<p>    #include&lt;numeric&gt;</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">vector&lt;<span class="keyword">int</span>&gt; vecIntA;</span><br><span class="line">vecIntA.<span class="built_in">push_back</span>(<span class="number">1</span>);</span><br><span class="line">vecIntA.<span class="built_in">push_back</span>(<span class="number">3</span>);</span><br><span class="line">vecIntA.<span class="built_in">push_back</span>(<span class="number">5</span>);</span><br><span class="line">vecIntA.<span class="built_in">push_back</span>(<span class="number">7</span>);</span><br><span class="line">vecIntA.<span class="built_in">push_back</span>(<span class="number">9</span>);</span><br><span class="line"><span class="keyword">int</span> iSum = <span class="built_in">accumulate</span>(vecIntA.<span class="built_in">begin</span>(), vecIntA.<span class="built_in">end</span>(), <span class="number">100</span>);     <span class="comment">//iSum==125</span></span><br></pre></td></tr></table></figure>



<h4 id="fill"><a href="#fill" class="headerlink" title="fill()"></a>fill()</h4><p>    fill:  将输入值赋给标志范围内的所有元素。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">vector&lt;<span class="keyword">int</span>&gt; vecIntA;</span><br><span class="line">vecIntA.<span class="built_in">push_back</span>(<span class="number">1</span>);</span><br><span class="line">vecIntA.<span class="built_in">push_back</span>(<span class="number">3</span>);</span><br><span class="line">vecIntA.<span class="built_in">push_back</span>(<span class="number">5</span>);</span><br><span class="line">vecIntA.<span class="built_in">push_back</span>(<span class="number">7</span>);</span><br><span class="line">vecIntA.<span class="built_in">push_back</span>(<span class="number">9</span>);</span><br><span class="line"><span class="built_in">fill</span>(vecIntA.<span class="built_in">begin</span>(), vecIntA.<span class="built_in">end</span>(), <span class="number">8</span>);       <span class="comment">//8, 8, 8, 8, 8</span></span><br></pre></td></tr></table></figure>



<h3 id="五、常用的集合算法"><a href="#五、常用的集合算法" class="headerlink" title="五、常用的集合算法"></a>五、常用的集合算法</h3><h4 id="set-union-set-intersection-set-difference"><a href="#set-union-set-intersection-set-difference" class="headerlink" title="set_union(),set_intersection(),set_difference()"></a>set_union(),set_intersection(),set_difference()</h4><p>    set_union: 构造一个有序序列，包含两个有序序列的并集。</p>
<p>    set_intersection: 构造一个有序序列，包含两个有序序列的交集。</p>
<p>    set_difference: 构造一个有序序列，该序列保留第一个有序序列中存在而第二个有序序列中不存在的元素。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">vector&lt;<span class="keyword">int</span>&gt; vecIntA;</span><br><span class="line">vecIntA.<span class="built_in">push_back</span>(<span class="number">1</span>);</span><br><span class="line">vecIntA.<span class="built_in">push_back</span>(<span class="number">3</span>);</span><br><span class="line">vecIntA.<span class="built_in">push_back</span>(<span class="number">5</span>);</span><br><span class="line">vecIntA.<span class="built_in">push_back</span>(<span class="number">7</span>);</span><br><span class="line">vecIntA.<span class="built_in">push_back</span>(<span class="number">9</span>);</span><br><span class="line"> </span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; vecIntB;</span><br><span class="line">vecIntB.<span class="built_in">push_back</span>(<span class="number">1</span>);</span><br><span class="line">vecIntB.<span class="built_in">push_back</span>(<span class="number">3</span>);</span><br><span class="line">vecIntB.<span class="built_in">push_back</span>(<span class="number">5</span>);</span><br><span class="line">vecIntB.<span class="built_in">push_back</span>(<span class="number">6</span>);</span><br><span class="line">vecIntB.<span class="built_in">push_back</span>(<span class="number">8</span>);</span><br><span class="line"></span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; vecIntC;</span><br><span class="line">vecIntC.<span class="built_in">resize</span>(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//并集</span></span><br><span class="line"><span class="built_in">set_union</span>(vecIntA.<span class="built_in">begin</span>(), vecIntA.<span class="built_in">end</span>(), vecIntB.<span class="built_in">begin</span>(), vecIntB.<span class="built_in">end</span>(), vecIntC.<span class="built_in">begin</span>());       </span><br><span class="line"><span class="comment">//vecIntC : &#123;1,3,5,6,7,8,9,0,0,0&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//交集</span></span><br><span class="line"><span class="built_in">fill</span>(vecIntC.<span class="built_in">begin</span>(),vecIntC.<span class="built_in">end</span>(),<span class="number">0</span>);</span><br><span class="line"><span class="built_in">set_intersection</span>(vecIntA.<span class="built_in">begin</span>(), vecIntA.<span class="built_in">end</span>(), vecIntB.<span class="built_in">begin</span>(), vecIntB.<span class="built_in">end</span>(), vecIntC.<span class="built_in">begin</span>());   </span><br><span class="line"><span class="comment">//vecIntC: &#123;1,3,5,0,0,0,0,0,0,0&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//差集</span></span><br><span class="line"><span class="built_in">fill</span>(vecIntC.<span class="built_in">begin</span>(),vecIntC.<span class="built_in">end</span>(),<span class="number">0</span>);</span><br><span class="line"><span class="built_in">set_difference</span>(vecIntA.<span class="built_in">begin</span>(), vecIntA.<span class="built_in">end</span>(), vecIntB.<span class="built_in">begin</span>(), vecIntB.<span class="built_in">end</span>(), vecIntC.<span class="built_in">begin</span>());     </span><br><span class="line"><span class="comment">//vecIntC: &#123;7,9,0,0,0,0,0,0,0,0&#125;</span></span><br></pre></td></tr></table></figure>



<h3 id="六、常用的遍历算法"><a href="#六、常用的遍历算法" class="headerlink" title="六、常用的遍历算法"></a>六、常用的遍历算法</h3><h4 id="for-each"><a href="#for-each" class="headerlink" title="for_each()"></a>for_each()</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    遍历算法 遍历容器元素</span></span><br><span class="line"><span class="comment">	@param beg 开始迭代器</span></span><br><span class="line"><span class="comment">	@param end 结束迭代器</span></span><br><span class="line"><span class="comment">	@param _callback  函数回调或者函数对象</span></span><br><span class="line"><span class="comment">	@return 函数对象</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">for_each(iterator beg, iterator end, _callback);</span><br></pre></td></tr></table></figure>

<p>for_each: 用指定函数依次对指定范围内所有元素进行迭代访问。该函数不得修改序列中的元素。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> &amp;iItem)</span></span>&#123;</span><br><span class="line">    cout &lt;&lt; iItem;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">main</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> iArray[] = &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;;</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">vecInt</span><span class="params">(iArray,iArray+<span class="keyword">sizeof</span>(iArray)/<span class="keyword">sizeof</span>(iArray[<span class="number">0</span>]))</span></span>;</span><br><span class="line">	for_each(vecInt.<span class="built_in">begin</span>(), vecInt.<span class="built_in">end</span>(), show);</span><br><span class="line"><span class="comment">//结果打印出0 1 2 3 4</span></span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>



<h4 id="transform"><a href="#transform" class="headerlink" title="transform()"></a>transform()</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	transform算法 将指定容器区间元素搬运到另一容器中</span></span><br><span class="line"><span class="comment">	注意 : transform 不会给目标容器分配内存，所以需要我们提前分配好内存</span></span><br><span class="line"><span class="comment">	@param beg1 源容器开始迭代器</span></span><br><span class="line"><span class="comment">	@param end1 源容器结束迭代器</span></span><br><span class="line"><span class="comment">	@param beg2 目标容器开始迭代器</span></span><br><span class="line"><span class="comment">	@param _cakkback 回调函数或者函数对象</span></span><br><span class="line"><span class="comment">	@return 返回目标容器迭代器</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="built_in">transform</span>(iterator beg1, iterator end1, iterator beg2, _callbakc)</span><br></pre></td></tr></table></figure>

<p>    transform:  与for_each类似，遍历所有元素，但可对容器的元素进行修改</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">increase</span> <span class="params">(<span class="keyword">int</span> i)</span></span>&#123; </span><br><span class="line">    <span class="keyword">return</span> i+<span class="number">1</span>;  </span><br><span class="line">&#125; </span><br><span class="line"><span class="built_in">main</span>()</span><br><span class="line">&#123;</span><br><span class="line">	vector&lt;<span class="keyword">int</span>&gt; vecIntA;</span><br><span class="line">    vecIntA.<span class="built_in">push_back</span>(<span class="number">1</span>)；</span><br><span class="line">    vecIntA.<span class="built_in">push_back</span>(<span class="number">3</span>);</span><br><span class="line">	vecIntA.<span class="built_in">push_back</span>(<span class="number">5</span>);</span><br><span class="line">    vecIntA.<span class="built_in">push_back</span>(<span class="number">7</span>);</span><br><span class="line">    vecIntA.<span class="built_in">push_back</span>(<span class="number">9</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">transform</span>(vecIntA.<span class="built_in">begin</span>(),vecIntA.<span class="built_in">end</span>(),vecIntA.<span class="built_in">begin</span>(),increase);   </span><br><span class="line">    <span class="comment">//vecIntA : &#123;2,4,6,8,10&#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>C++</category>
        <category>STL</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>STL</tag>
        <tag>STL算法</tag>
      </tags>
  </entry>
  <entry>
    <title>STL_打分案例</title>
    <url>/2021/05/07/STL%EF%BC%9A%E6%89%93%E5%88%86%E6%A1%88%E4%BE%8B/</url>
    <content><![CDATA[<p>评委打分案例(sort 算法排序)</p>
<ul>
<li>创建 5 个选手(姓名，得分) ， 10 个评委对 5 个选手进行打分</li>
<li>得分规则：去除最高分，去除最低分，取出平均分</li>
<li>按得分对 5 名选手进行排名</li>
</ul>
<span id="more"></span>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _CRT_SECURE_NO_WARNINGS</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PLAYER_NUMBER 5</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;deque&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//选手类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Player</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Player</span>() &#123;&#125;;</span><br><span class="line">	<span class="built_in">Player</span>(string name, <span class="keyword">int</span> score)&#123;</span><br><span class="line">		<span class="keyword">this</span>-&gt;name = name;</span><br><span class="line">		<span class="keyword">this</span>-&gt;score = score;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function">string <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">this</span>-&gt;name;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">setName</span><span class="params">(string name)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>-&gt;name = name;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">getScore</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">this</span>-&gt;score;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">setScore</span><span class="params">(<span class="keyword">int</span> score)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>-&gt;score = score;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	string name;</span><br><span class="line">	<span class="keyword">int</span> score;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">creat_player</span><span class="params">(vector&lt;Player&gt; &amp;player_vector,<span class="keyword">int</span> number)</span> </span>&#123;</span><br><span class="line">	string name_seed = <span class="string">&quot;ABCDE&quot;</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; number; i++) &#123;</span><br><span class="line">		Player player;</span><br><span class="line">		string tmp = name_seed.<span class="built_in">substr</span>(i,<span class="number">1</span>);</span><br><span class="line">		player.<span class="built_in">setName</span>(<span class="string">&quot;选手&quot;</span>+tmp);</span><br><span class="line">		player.<span class="built_in">setScore</span>(<span class="number">0</span>);</span><br><span class="line">		player_vector.<span class="built_in">push_back</span>(player);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">set_score</span><span class="params">(vector&lt;Player&gt;&amp; player_vector)</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">srand</span>(<span class="built_in">time</span>(<span class="literal">nullptr</span>));</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (vector&lt;Player&gt;::iterator it=player_vector.<span class="built_in">begin</span>();it!=player_vector.<span class="built_in">end</span>();it++) &#123;</span><br><span class="line">		</span><br><span class="line">		deque&lt;<span class="keyword">int</span>&gt; player_score_list;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;<span class="number">10</span>;i++) &#123;</span><br><span class="line">			<span class="keyword">int</span> score = <span class="built_in">rand</span>() % <span class="number">41</span> + <span class="number">60</span>;</span><br><span class="line">			player_score_list.<span class="built_in">push_back</span>(score);</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="built_in">sort</span>(player_score_list.<span class="built_in">begin</span>(),player_score_list.<span class="built_in">end</span>());</span><br><span class="line">		</span><br><span class="line">		player_score_list.<span class="built_in">pop_back</span>();</span><br><span class="line">		player_score_list.<span class="built_in">pop_front</span>();</span><br><span class="line"></span><br><span class="line">		<span class="keyword">int</span> total_score = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (deque&lt;<span class="keyword">int</span>&gt;::iterator dit = player_score_list.<span class="built_in">begin</span>(); dit != player_score_list.<span class="built_in">end</span>(); dit++) &#123;</span><br><span class="line">			total_score += (*dit);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">int</span> avg_score = total_score / player_score_list.<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line">		(*it).<span class="built_in">setScore</span>(avg_score);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">mycompare</span><span class="params">(Player&amp; p1, Player&amp; p2)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> p1.<span class="built_in">getScore</span>() &gt; p2.<span class="built_in">getScore</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print_rank</span><span class="params">(vector&lt;Player&gt;&amp; player_vector)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">sort</span>(player_vector.<span class="built_in">begin</span>(),player_vector.<span class="built_in">end</span>(),mycompare);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (vector&lt;Player&gt;::iterator it = player_vector.<span class="built_in">begin</span>(); it != player_vector.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line"></span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;姓名：&quot;</span>&lt;&lt;(*it).<span class="built_in">getName</span>()&lt;&lt;<span class="string">&quot;  得分：&quot;</span>&lt;&lt;(*it).<span class="built_in">getScore</span>()&lt;&lt;endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	vector&lt;Player&gt; player_vector;</span><br><span class="line">	<span class="built_in">creat_player</span>(player_vector,PLAYER_NUMBER);</span><br><span class="line">	<span class="built_in">set_score</span>(player_vector);</span><br><span class="line">	<span class="built_in">print_rank</span>(player_vector);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>C++</category>
        <category>STL</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>STL</tag>
        <tag>STL案例</tag>
      </tags>
  </entry>
  <entry>
    <title>STL_简介</title>
    <url>/2021/05/07/STL%EF%BC%9A%E7%AE%80%E4%BB%8B/</url>
    <content><![CDATA[<h3 id="一、基本概念"><a href="#一、基本概念" class="headerlink" title="一、基本概念"></a>一、基本概念</h3><p>    STL（Standard Template Library，标准模板库)是惠普实验室开发的一系列软件的统称。现然主要出现在C++中，但在被引入C++之前该技术就已经存在了很长的一段时间。</p>
<span id="more"></span>

<p>    STL的从广义上讲分为三类：<strong>algorithm（算法）、container（容器）和iterator（迭代器）</strong>，容器和算法通过迭代器可以进行无缝地连接。几乎所有的代码都采 用了模板类和模板函数的方式，这相比于传统的由函数和类组成的库来说提供了更好的代码重用机会。</p>
<p>    在C++标准中，STL 就位于各个 C++ 的头文件中，即它并非以二进制代码的形式提供，而是以源代码的形式提供。STL被组织为下面的13个头文 件：&lt;algorithm&gt;、&lt;deque&gt;、&lt;functional&gt;、&lt;iterator&gt;、&lt;vector&gt;、&lt;list&gt;、&lt;map&gt;、&lt;memory&gt;、&lt;numeric&gt;、&lt;queue&gt;、&lt;set&gt;、&lt;stack&gt; 和&lt;utility&gt;。</p>
<p>STL详细的说六大组件：</p>
<ol>
<li><strong>容器</strong>：各种数据结构，如vector、list、deque、set、map等,用来存放数据，从实现角度来看，STL容器是一种class template。</li>
<li><strong>算法</strong>：各种常用的算法，如sort、find、copy、for_each。从实现的角度来看，STL算法是一种function tempalte.</li>
<li><strong>迭代器</strong>：扮演了容器与算法之间的胶合剂，共有五种类型，从实现角度来看，迭代器是一种将operator* , operator-&gt; , operator++,operator–等指针相关操作予以重载的class template. 所有STL容器都附带有自己专属的迭代器，只有容器的设计者才知道如何遍历自己的元素。原生指针(native pointer)也是一种迭代器。</li>
<li><strong>仿函数</strong>：行为类似函数，可作为算法的某种策略。从实现角度来看，仿函数是一种重载了operator()的class 或者class template</li>
<li><strong>适配器</strong>：一种用来修饰容器或者仿函数或迭代器接口的东西。</li>
<li><strong>空间配置器</strong>：负责空间的配置与管理。从实现角度看，配置器是一个实现了动态空间配置、空间管理、空间释放的class tempalte.</li>
</ol>
<p>    STL六大组件的交互关系，容器通过空间配置器取得数据存储空间，算法通过迭代器存储容器中的内容，仿函数可以协助算法完成不同的策略的变化，适配器可以修饰仿函数</p>
<h3 id="二、STL优点"><a href="#二、STL优点" class="headerlink" title="二、STL优点"></a>二、STL优点</h3><p>    1）STL是C++的一部分，因此不用额外安装什么，它被内建在你的编译器之内。</p>
<p>    2）STL的一个重要特点是数据结构和算法的分离。尽管这是个简单的概念，但是这种分离确实使得STL变得非常通用。</p>
<p>    例如，在STL的vector容器中，可以放入元素、基础数据类型变量、元素的地址；</p>
<p>    STL的sort()函数可以用来操作vector,list等容器。</p>
<p>    3） 程序员可以不用思考STL具体的实现过程，只要能够熟练使用STL就OK了。这样他们就可以把精力放在程序开发的别的方面。</p>
<p>    4） STL具有高可重用性，高性能，高移植性，跨平台的优点。</p>
<ul>
<li>高可重用性：STL中几乎所有的代码都采用了模板类和模版函数的方式实现，这相比于传统的由函数和类组成的库来说提供了更好的代码重用机会。关于模板的知识，已经给大家介绍了。</li>
<li>高性能：如map可以高效地从十万条记录里面查找出指定的记录，因为map是采用红黑树的变体实现的。(红黑树是平横二叉树的一种)</li>
<li>高移植性：如在项目A上用STL编写的模块，可以直接移植到项目B上。</li>
<li>跨平台：如用windows的Visual Studio编写的代码可以在Mac OS的XCode上直接编译。</li>
</ul>
<p>    5） 程序员可以不用思考STL具体的实现过程，只要能够熟练使用STL就OK了。这样他们就可以把精力放在程序开发的别的方面。</p>
<p>    6） 了解到STL的这些好处，我们知道STL无疑是最值得C++程序员骄傲的一部分。每一个C++程序员都应该好好学习STL。只有能够熟练使用STL的程序员，才是好的C++程序员。</p>
<p>    7）  总之：招聘工作中，经常遇到C++程序员对STL不是非常了解。大多是有一个大致的映像，而对于在什么情况下应该使用哪个容器和算法都感到比较茫然。<strong>STL是C++程序员的一项不可或缺的基本技能</strong>，掌握它对提升C++编程大有裨益。</p>
<h3 id="三、三大组件介绍"><a href="#三、三大组件介绍" class="headerlink" title="三、三大组件介绍"></a>三、三大组件介绍</h3><h4 id="容器"><a href="#容器" class="headerlink" title="容器"></a>容器</h4><p>    几乎可以说，任何特定的数据结构都是为了实现某种特定的算法。STL容器就是将运用最广泛的一些数据结构实现出来。</p>
<p>    常用的数据结构：<strong>数组</strong>(array) , <strong>链表</strong>(list), tree(<strong>树</strong>)，<strong>栈</strong>(stack), <strong>队列</strong>(queue), <strong>集合</strong>(set),<strong>映射表</strong>(map), 根据数据在容器中的排列特性，这些数据分为序列式容器和关联式容器两种。</p>
<ul>
<li><p>序列式容器（Sequence containers）</p>
<p>每个元素都有固定位置－－取决于插入时机和地点，和元素值无关。如：Array数组、Vector容器、Deque容器、List容器等。</p>
</li>
<li><p>关联式容器（Associated containers）</p>
<p>元素位置取决于特定的排序准则，和插入顺序无关。关联式容器是非线性的树结构，更准确的说是二叉树结构。各元素之间没有严格的物理上的顺序关系，也就是说元素在容器中并没有保存元素置入容器时的逻辑顺序。关联式容器另一个显著特点是：在值中选择一个值作为关键字key，这个关键字对值起到索引的作用，方便查找。Set/multiset容器 Map/multimap容器 </p>
</li>
</ul>
<table>
<thead>
<tr>
<th>数据结构</th>
<th>描述</th>
<th>实现头文件</th>
</tr>
</thead>
<tbody><tr>
<td>向量(vector)</td>
<td>连续存储的元素</td>
<td>&lt;vector&gt;</td>
</tr>
<tr>
<td>列表(list)</td>
<td>由节点组成的双向链表，每个结点包含着一个元素</td>
<td>&lt;list&gt;</td>
</tr>
<tr>
<td>双队列(deque)</td>
<td>连续存储的指向不同元素的指针所组成的数组</td>
<td>&lt;deque&gt;</td>
</tr>
<tr>
<td>集合(set)</td>
<td>由节点组成的红黑树，每个节点都包含着一个元素，节点之间以某种作用于元素对的谓词排列，没有两个不同的元素能够拥有相同的次序</td>
<td>&lt;set&gt;</td>
</tr>
<tr>
<td>多重集合(multiset)</td>
<td>允许存在两个次序相等的元素的集合</td>
<td>&lt;set&gt;</td>
</tr>
<tr>
<td>栈(stack)</td>
<td>后进先出的值的排列</td>
<td>&lt;stack&gt;</td>
</tr>
<tr>
<td>队列(queue)</td>
<td>先进先出的执的排列</td>
<td>&lt;queue&gt;</td>
</tr>
<tr>
<td>优先队列(priority_queue)</td>
<td>元素的次序是由作用于所存储的值对上的某种谓词决定的的一种队列</td>
<td>&lt;queue&gt;</td>
</tr>
<tr>
<td>映射(map)</td>
<td>由{键，值}对组成的集合，以某种作用于键对上的谓词排列</td>
<td>&lt;map&gt;</td>
</tr>
<tr>
<td>多重映射(multimap)</td>
<td>允许键对有相等的次序的映射</td>
<td>&lt;map&gt;</td>
</tr>
</tbody></table>
<h4 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h4><p>    迭代器从作用上来说是最基本的部分，可是理解起来比前两者都要费力一些。软件设计有一个基本原则，所有的问题都可以通过引进一个间接层来简化， 这种简化在STL中就是用迭代器来完成的。概括来说，迭代器在STL中用来将算法和容器联系起来，起着一种黏和剂的作用。几乎STL提供的所有算法都是通 过迭代器存取元素序列进行工作的，每一个容器都定义了其本身所专有的迭代器，用以存取容器中的元素。</p>
<p>    迭代器部分主要由头文件&lt;utility&gt;,&lt;iterator&gt;和&lt;memory&gt;组 成。&lt;utility&gt;是一个很小的头文件，它包括了贯穿使用在STL中的几个模板的声明，&lt;iterator&gt;中提供了迭代器 使用的许多方法，而对于&lt;memory&gt;的描述则十分的困难，它以不同寻常的方式为容器中的元素分配存储空间，同时也为某些算法执行期间产生 的临时对象提供机制,&lt;memory&gt;中的主要部分是模板类allocator，它负责产生所有容器中的默认分配器。</p>
<p>    迭代器的种类:</p>
<table>
<thead>
<tr>
<th>迭代器</th>
<th>功能</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>输入迭代器</td>
<td>提供对数据的只读访问</td>
<td>只读，支持++、==、！=</td>
</tr>
<tr>
<td>输出迭代器</td>
<td>提供对数据的只写访问</td>
<td>只写，支持++</td>
</tr>
<tr>
<td>前向迭代器</td>
<td>提供读写操作，并能向前推进迭代器</td>
<td>读写，支持++、==、！=</td>
</tr>
<tr>
<td>双向迭代器</td>
<td>提供读写操作，并能向前和向后操作</td>
<td>读写，支持++、–，</td>
</tr>
<tr>
<td>随机访问迭代器</td>
<td>提供读写操作，并能以跳跃的方式访问容器的任意数据，是功能最强的迭代器</td>
<td>读写，支持++、–、[n]、-n、&lt;、&lt;=、&gt;、&gt;=</td>
</tr>
</tbody></table>
<h4 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h4><p>    函数库对数据类型的选择对其可重用性起着至关重要的作用。举例来说，一个求方根的函数，在使用浮点数作为其参数类型的情况下的可重用性肯定比使 用整型作为它的参数类性要高。而C++通过模板的机制允许推迟对某些类型的选择，直到真正想使用模板或者说对模板进行特化的时候，STL就利用了这一点提 供了相当多的有用算法。它是在一个有效的框架中完成这些算法的——可以将所有的类型划分为少数的几类，然后就可以在模版的参数中使用一种类型替换掉同一种 类中的其他类型。</p>
<p>    STL提供了大约100个实现算法的模版函数，比如算法for_each将为指定序列中的每一个元素调用指定的函数，stable_sort以你所指定的规则对序列进行稳定性排序等等。这样一来，只要熟悉了STL之后，许多代码可以被大大的化简，只需要通过调用一两个算法模板，就可以完成所需要 的功能并大大地提升效率。</p>
<p>    算法部分主要由头文件&lt;algorithm&gt;，&lt;numeric&gt;和&lt;functional&gt;组 成。&lt;algorithm&gt;是所有STL头文件中最大的一个（尽管它很好理解），它是由一大堆模版函数组成的，可以认为每个函数在很大程度上 都是独立的，其中常用到的功能范围涉及到比较、交换、查找、遍历操作、复制、修改、移除、反转、排序、合并等等。&lt;numeric&gt;体积很 小，只包括几个在序列上面进行简单数学运算的模板函数，包括加法和乘法在序列上的一些操作。&lt;functional&gt;中则定义了一些模板类， 用以声明函数对象。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _CRT_SECURE_NO_WARNINGS</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//STL 中的容器 算法 迭代器</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span>&#123;</span><br><span class="line">	vector&lt;<span class="keyword">int</span>&gt; v; <span class="comment">//STL 中的标准容器之一 ：动态数组</span></span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="number">1</span>); <span class="comment">//vector 容器提供的插入数据的方法</span></span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="number">5</span>);</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="number">3</span>);</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="number">7</span>);</span><br><span class="line">	<span class="comment">//迭代器</span></span><br><span class="line">	vector&lt;<span class="keyword">int</span>&gt;::iterator pStart = v.<span class="built_in">begin</span>(); <span class="comment">//vector 容器提供了 begin()方法 返回指向第一个元素的迭代器</span></span><br><span class="line">	vector&lt;<span class="keyword">int</span>&gt;::iterator pEnd = v.<span class="built_in">end</span>(); <span class="comment">//vector 容器提供了 end()方法 返回指向最后一个元素下一个位置的迭代器</span></span><br><span class="line">	<span class="comment">//通过迭代器遍历</span></span><br><span class="line">	<span class="keyword">while</span> (pStart != pEnd)&#123;</span><br><span class="line">		cout &lt;&lt; *pStart &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">		pStart++;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">	<span class="comment">//算法 count 算法 用于统计元素的个数</span></span><br><span class="line">	<span class="keyword">int</span> n = <span class="built_in">count</span>(pStart, pEnd, <span class="number">5</span>);</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;n:&quot;</span> &lt;&lt; n &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//STL 容器不单单可以存储基础数据类型，也可以存储类对象</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Teacher</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Teacher</span>(<span class="keyword">int</span> age) :<span class="built_in">age</span>(age)&#123;&#125;;</span><br><span class="line">	~<span class="built_in">Teacher</span>()&#123;&#125;;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">int</span> age;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test02</span><span class="params">()</span></span>&#123;</span><br><span class="line">	vector&lt;Teacher&gt; v; <span class="comment">//存储 Teacher 类型数据的容器</span></span><br><span class="line">	Teacher t1(10), t2(20), t3(30);</span><br><span class="line">	v.<span class="built_in">push_back</span>(t1);</span><br><span class="line">	v.<span class="built_in">push_back</span>(t2);</span><br><span class="line">	v.<span class="built_in">push_back</span>(t3);</span><br><span class="line">	vector&lt;Teacher&gt;::iterator pStart = v.<span class="built_in">begin</span>();</span><br><span class="line">	vector&lt;Teacher&gt;::iterator pEnd = v.<span class="built_in">end</span>();</span><br><span class="line">	<span class="comment">//通过迭代器遍历</span></span><br><span class="line">	<span class="keyword">while</span> (pStart != pEnd)&#123;</span><br><span class="line">		cout &lt;&lt; pStart-&gt;age &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">		pStart++;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//存储 Teacher 类型指针</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test03</span><span class="params">()</span></span>&#123;</span><br><span class="line">	vector&lt;Teacher*&gt; v; <span class="comment">//存储 Teacher 类型指针</span></span><br><span class="line">	Teacher* t1 = <span class="keyword">new</span> <span class="built_in">Teacher</span>(<span class="number">10</span>);</span><br><span class="line">	Teacher* t2 = <span class="keyword">new</span> <span class="built_in">Teacher</span>(<span class="number">20</span>);</span><br><span class="line">	Teacher* t3 = <span class="keyword">new</span> <span class="built_in">Teacher</span>(<span class="number">30</span>);</span><br><span class="line">	v.<span class="built_in">push_back</span>(t1);</span><br><span class="line">	v.<span class="built_in">push_back</span>(t2);</span><br><span class="line">	v.<span class="built_in">push_back</span>(t3);</span><br><span class="line">	<span class="comment">//拿到容器迭代器</span></span><br><span class="line">	vector&lt;Teacher*&gt;::iterator pStart = v.<span class="built_in">begin</span>();</span><br><span class="line">	vector&lt;Teacher*&gt;::iterator pEnd = v.<span class="built_in">end</span>();</span><br><span class="line">	<span class="comment">//通过迭代器遍历</span></span><br><span class="line">	<span class="keyword">while</span> (pStart != pEnd)&#123;</span><br><span class="line">		cout &lt;&lt; (*pStart)-&gt;age &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">		pStart++;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//容器嵌套容器 难点</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test04</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	vector&lt; vector&lt;<span class="keyword">int</span>&gt; &gt; v;</span><br><span class="line">	vector&lt;<span class="keyword">int</span>&gt;v1;</span><br><span class="line">	vector&lt;<span class="keyword">int</span>&gt;v2;</span><br><span class="line">	vector&lt;<span class="keyword">int</span>&gt;v3;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		v1.<span class="built_in">push_back</span>(i);</span><br><span class="line">		v2.<span class="built_in">push_back</span>(i * <span class="number">10</span>);</span><br><span class="line">		v3.<span class="built_in">push_back</span>(i * <span class="number">100</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	v.<span class="built_in">push_back</span>(v1);</span><br><span class="line">	v.<span class="built_in">push_back</span>(v2);</span><br><span class="line">	v.<span class="built_in">push_back</span>(v3);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (vector&lt; vector&lt;<span class="keyword">int</span>&gt; &gt;::iterator it = v.<span class="built_in">begin</span>(); it != v.<span class="built_in">end</span>();it++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span> (vector&lt;<span class="keyword">int</span>&gt;::iterator subIt = (*it).<span class="built_in">begin</span>(); subIt != (*it).<span class="built_in">end</span>(); subIt ++)</span><br><span class="line">		&#123;</span><br><span class="line">			cout &lt;&lt; *subIt &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		cout &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="comment">//test01();</span></span><br><span class="line">	<span class="comment">//test02();</span></span><br><span class="line">	<span class="comment">//test03();</span></span><br><span class="line">	<span class="built_in">test04</span>();</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>部分内容来自：</p>
<p><a href="https://blog.csdn.net/qq_42322103/article/details/99685797">STL详解</a></p>
]]></content>
      <categories>
        <category>C++</category>
        <category>STL</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>STL</tag>
      </tags>
  </entry>
  <entry>
    <title>STL_算法基础</title>
    <url>/2021/05/07/STL%EF%BC%9A%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<h3 id="一、算法概述"><a href="#一、算法概述" class="headerlink" title="一、算法概述"></a>一、算法概述</h3><p>    算法部分主要由头文件&lt;algorithm&gt;，&lt;numeric&gt;和&lt;functional&gt;组成。</p>
<span id="more"></span>

<p>    &lt;algorithm&gt;是所有STL头文件中最大的一个，其中常用到的功能范围涉及到比较、交换、查找、遍历操作、复制、修改、反转、排序、合并等等。</p>
<p>    &lt;numeric&gt;体积很小，只包括几个在序列上面进行简单数学运算的模板函数，包括加法和乘法在序列上的一些操作。</p>
<p>    &lt;functional&gt;中则定义了一些模板类，用以声明函数对象。</p>
<p>    STL提供了大量实现算法的模版函数，只要我们熟悉了STL之后，许多代码可以被大大的化简，只需要通过调用一两个算法模板，就可以完成所需要的功能，从而大大地提升效率。</p>
<p>    #include &lt;algorithm&gt;</p>
<p>    #include &lt;numeric&gt;</p>
<p>    #include &lt;functional&gt;</p>
<h3 id="二、STL中算法分类"><a href="#二、STL中算法分类" class="headerlink" title="二、STL中算法分类"></a>二、STL中算法分类</h3><ul>
<li><p>操作对象 </p>
</li>
<li><ul>
<li>直接改变容器的内容</li>
<li>将原容器的内容复制一份,修改其副本,然后传回该副本</li>
</ul>
</li>
<li><p>功能: </p>
</li>
<li><ul>
<li><p>非可变序列算法 指不直接修改其所操作的容器内容的算法</p>
</li>
<li><ul>
<li>计数算法     count、count_if</li>
<li>搜索算法     search、find、find_if、find_first_of、…</li>
<li>比较算法     equal、mismatch、lexicographical_compare</li>
</ul>
</li>
<li><p>可变序列算法 指可以修改它们所操作的容器内容的算法</p>
</li>
<li><ul>
<li>删除算法     remove、remove_if、remove_copy、…</li>
<li>修改算法     for_each、transform</li>
<li>排序算法     sort、stable_sort、partial_sort、</li>
</ul>
</li>
<li><p>排序算法 包括对序列进行排序和合并的算法、搜索算法以及有序序列上的集合操作</p>
</li>
<li><p>数值算法 对容器内容进行数值计算</p>
</li>
</ul>
</li>
</ul>
<h3 id="三、常用算法汇总"><a href="#三、常用算法汇总" class="headerlink" title="三、常用算法汇总"></a>三、常用算法汇总</h3><p>    常用的<strong>查找</strong>算法：adjacent_find()（ adjacent 是邻近的意思）,binary_search(),count(),count_if(),equal_range(),find(),find_if()。</p>
<p>    常用的<strong>排序</strong>算法：merge(),sort(),random_shuffle()（shuffle是洗牌的意思） ,reverse()。</p>
<p>    常用的<strong>拷贝和替换</strong>算法：copy(), replace(),replace_if(),swap()</p>
<p>    常用的<strong>算术和生成</strong>算法：accumulate()（ accumulate 是求和的意思）,fill(),。</p>
<p>    常用的<strong>集合</strong>算法：set_union(),set_intersection(),set_difference()。</p>
<p>    常用的<strong>遍历</strong>算法：for_each(), transform()（ transform 是变换的意思）。</p>
]]></content>
      <categories>
        <category>C++</category>
        <category>STL</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>STL</tag>
        <tag>STL算法</tag>
      </tags>
  </entry>
  <entry>
    <title>STL_综合案例</title>
    <url>/2021/05/07/STL%EF%BC%9A%E7%BB%BC%E5%90%88%E6%A1%88%E4%BE%8B/</url>
    <content><![CDATA[<h3 id="学校演讲比赛"><a href="#学校演讲比赛" class="headerlink" title="学校演讲比赛"></a>学校演讲比赛</h3><p>&ensp;&ensp;&ensp;&ensp;1）某市举行一场演讲比赛，共有24个人参加，按参加顺序设置参赛号。比赛共三轮，前两轮为淘汰赛，第三轮为决赛。</p>
<span id="more"></span>

<p>&ensp;&ensp;&ensp;&ensp;2）比赛方式：分组比赛<br>&ensp;&ensp;&ensp;&ensp;    第一轮分为4个小组，根据参赛号顺序依次划分，比如100-105为一组，106-111为第二组，依次类推，每组6个人，每人分别按参赛号顺序演讲。<br>当小组演讲完后，淘汰组内排名最后的三个选手，然后继续下一个小组的比赛。<br>    &ensp;&ensp;&ensp;&ensp;第二轮分为2个小组，每组6人，每个人分别按参赛号顺序演讲。当小组完后，淘汰组内排名最后的三个选手，然后继续下一个小组的比赛。<br>    &ensp;&ensp;&ensp;&ensp;第三轮只剩下6个人，本轮为赛决，选出前三名。<br>    &ensp;&ensp;&ensp;&ensp;选手每次要随机分组，进行比赛。<br>&ensp;&ensp;&ensp;&ensp;3）比赛评分：10个评委打分，去除最低、最高分，求平均分<br>    &ensp;&ensp;&ensp;&ensp;每个选手演讲完由10个评委分别打分。该选手的最终得分是去掉一个最高分和一个最低分，求得剩下的8个成绩的平均分。选手的名次按得分降序排列，<br>若得分一样，按参赛号升序排名。</p>
<p>&ensp;&ensp;&ensp;&ensp;用STL编程，求解一下问题</p>
<ol>
<li>请打印出所有选手的名字与参赛号，并以参赛号的升序排列。</li>
<li>打印每一轮比赛前，分组情况</li>
<li>打印每一轮比赛后，小组晋级名单</li>
<li>打印决赛前三名，选手名称、成绩。</li>
</ol>
<h3 id="main-cpp文件"><a href="#main-cpp文件" class="headerlink" title="main.cpp文件"></a>main.cpp文件</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;manager.h&quot;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Manager m;</span><br><span class="line">	m.<span class="built_in">show</span>();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Speaker-h文件"><a href="#Speaker-h文件" class="headerlink" title="Speaker.h文件"></a>Speaker.h文件</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Speaker</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">setName</span><span class="params">(string s)</span></span>;</span><br><span class="line">	<span class="function">string <span class="title">getName</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">setScore</span><span class="params">(<span class="keyword">int</span> n)</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">getScore</span><span class="params">(<span class="keyword">int</span> n)</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">setNumber</span><span class="params">(<span class="keyword">int</span> n)</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">getNumber</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	string name;</span><br><span class="line">	<span class="keyword">int</span> number;</span><br><span class="line">	vector&lt;<span class="keyword">int</span>&gt;scores;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h3 id="Speaker-cpp文件"><a href="#Speaker-cpp文件" class="headerlink" title="Speaker.cpp文件"></a>Speaker.cpp文件</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;Speaker.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Speaker::setName</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">this</span>-&gt;name = s;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">string <span class="title">Speaker::getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">this</span>-&gt;name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Speaker::setScore</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;<span class="comment">//n是第n+1次成绩</span></span><br><span class="line">	<span class="keyword">this</span>-&gt;scores.<span class="built_in">push_back</span>(n);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Speaker::getScore</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (n &lt; <span class="number">0</span> || n&gt;<span class="number">2</span>)</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;error&quot;</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">this</span>-&gt;scores[n];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Speaker::setNumber</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">this</span>-&gt;number = n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Speaker::getNumber</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">this</span>-&gt;number;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="Manager-h文件"><a href="#Manager-h文件" class="headerlink" title="Manager.h文件"></a>Manager.h文件</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SPEAKER_NUMBER 24</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deque&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;Speaker.h&quot;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Manager</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">create_speaker</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">divid_speaker</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">first_game</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">second_game</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">final_game</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	vector&lt;Speaker&gt; first_vector;</span><br><span class="line">	vector&lt;Speaker&gt; second_vector;</span><br><span class="line">	vector&lt;Speaker&gt; third_vector;</span><br><span class="line">	multimap&lt;<span class="keyword">int</span>,Speaker&gt; first_groups;</span><br><span class="line">	multimap&lt;<span class="keyword">int</span>, Speaker&gt; second_groups;</span><br><span class="line">	multimap&lt;<span class="keyword">int</span>, Speaker&gt; third_groups;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="Manager-cpp文件"><a href="#Manager-cpp文件" class="headerlink" title="Manager.cpp文件"></a>Manager.cpp文件</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;Manager.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get_avg_score</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	deque&lt;<span class="keyword">int</span>&gt;score_list;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">		<span class="keyword">int</span> score = <span class="built_in">rand</span>() % <span class="number">61</span> + <span class="number">40</span>;</span><br><span class="line">		score_list.<span class="built_in">push_back</span>(score);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">sort</span>(score_list.<span class="built_in">begin</span>(), score_list.<span class="built_in">end</span>());</span><br><span class="line">	score_list.<span class="built_in">pop_back</span>();</span><br><span class="line">	score_list.<span class="built_in">pop_front</span>();</span><br><span class="line">	<span class="keyword">int</span> total_score = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (deque&lt;<span class="keyword">int</span>&gt;::iterator it = score_list.<span class="built_in">begin</span>(); it != score_list.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">		total_score += (*it);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> total_score / score_list.<span class="built_in">size</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print_info_after_game</span><span class="params">(multimap&lt;<span class="keyword">int</span>, Speaker&gt;::iterator p,<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;姓名:&quot;</span> &lt;&lt; (*p).second.<span class="built_in">getName</span>()</span><br><span class="line">		&lt;&lt; <span class="string">&quot;   编号：&quot;</span> &lt;&lt; (*p).second.<span class="built_in">getNumber</span>()</span><br><span class="line">		&lt;&lt; <span class="string">&quot;   组号：&quot;</span> &lt;&lt; (*p).first</span><br><span class="line">		&lt;&lt; <span class="string">&quot;   分数：&quot;</span> &lt;&lt; (*p).second.<span class="built_in">getScore</span>(n)</span><br><span class="line">		&lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">divide_and_print</span><span class="params">(vector&lt;Speaker&gt; &amp;v, multimap&lt;<span class="keyword">int</span>, Speaker&gt; &amp;m)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> flag = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span> (vector&lt;Speaker&gt;::iterator it = v.<span class="built_in">begin</span>(); it != v.<span class="built_in">end</span>(); ) &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">6</span>; j++, it++) &#123;</span><br><span class="line">			m.<span class="built_in">insert</span>(<span class="built_in">make_pair</span>(flag, *it));</span><br><span class="line">		&#125;</span><br><span class="line">		flag++;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;第二次分组：&quot;</span> &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">for</span> (multimap&lt;<span class="keyword">int</span>, Speaker&gt;::iterator p = m.<span class="built_in">begin</span>(); p != m.<span class="built_in">end</span>(); p++) &#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;姓名:&quot;</span> &lt;&lt; (*p).second.<span class="built_in">getName</span>() &lt;&lt; <span class="string">&quot;   编号：&quot;</span> &lt;&lt; (*p).second.<span class="built_in">getNumber</span>() &lt;&lt; <span class="string">&quot;   组号：&quot;</span> &lt;&lt; (*p).first &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print_info_after_game</span><span class="params">(multimap&lt;<span class="keyword">int</span>, Speaker&gt; &amp;m,vector&lt;Speaker&gt; &amp;v)</span> </span>&#123;	</span><br><span class="line">	<span class="keyword">for</span> (multimap&lt;<span class="keyword">int</span>, Speaker&gt;::iterator p = m.<span class="built_in">begin</span>(); p != m.<span class="built_in">end</span>(); p++) &#123;</span><br><span class="line">		<span class="built_in">print_info_after_game</span>(p, <span class="number">0</span>);</span><br><span class="line">		v.<span class="built_in">push_back</span>((*p).second);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Manager::create_speaker</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	string name_seed = <span class="string">&quot;ABCDEFGHIJKLMNOPQRSTUVWXYZ&quot;</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; SPEAKER_NUMBER; i++) &#123;</span><br><span class="line"></span><br><span class="line">		Speaker speaker;</span><br><span class="line">		string tmp = name_seed.<span class="built_in">substr</span>(i, <span class="number">1</span>);</span><br><span class="line">		speaker.<span class="built_in">setName</span>(<span class="string">&quot;选手&quot;</span> + tmp);</span><br><span class="line">		<span class="keyword">this</span>-&gt;first_vector.<span class="built_in">push_back</span>(speaker);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">compare</span><span class="params">(Speaker &amp;s1,Speaker &amp;s2)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> s1.<span class="built_in">getNumber</span>() &lt; s2.<span class="built_in">getNumber</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Manager::divid_speaker</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">//随机分配编号</span></span><br><span class="line">	<span class="built_in">random_shuffle</span>(<span class="keyword">this</span>-&gt;first_vector.<span class="built_in">begin</span>(), <span class="keyword">this</span>-&gt;first_vector.<span class="built_in">end</span>()); </span><br><span class="line">	<span class="keyword">int</span> ij = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (vector&lt;Speaker&gt;::iterator it = <span class="keyword">this</span>-&gt;first_vector.<span class="built_in">begin</span>(); it != <span class="keyword">this</span>-&gt;first_vector.<span class="built_in">end</span>(); ij++,it++) &#123;</span><br><span class="line">		<span class="keyword">this</span>-&gt;first_vector[ij].<span class="built_in">setNumber</span>(ij+<span class="number">100</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">sort</span>(<span class="keyword">this</span>-&gt;first_vector.<span class="built_in">begin</span>(),<span class="keyword">this</span>-&gt;first_vector.<span class="built_in">end</span>(),compare);</span><br><span class="line">	<span class="built_in">divide_and_print</span>(<span class="keyword">this</span>-&gt;first_vector, <span class="keyword">this</span>-&gt;first_groups);	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">compare_score</span><span class="params">(Speaker&amp; s1, Speaker&amp; s2)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> s1.<span class="built_in">getScore</span>(<span class="number">0</span>) &gt; s2.<span class="built_in">getScore</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Manager::first_game</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">srand</span>(<span class="built_in">time</span>(<span class="literal">nullptr</span>));</span><br><span class="line">	<span class="keyword">for</span> (multimap&lt;<span class="keyword">int</span>, Speaker&gt;::iterator p = <span class="keyword">this</span>-&gt;first_groups.<span class="built_in">begin</span>(); p != <span class="keyword">this</span>-&gt;first_groups.<span class="built_in">end</span>(); p++) &#123;</span><br><span class="line">		<span class="comment">//cout &lt;&lt; &quot;姓名:&quot; &lt;&lt; (*p).second.getName() &lt;&lt; &quot;   编号：&quot; &lt;&lt; (*p).second.getNumber() &lt;&lt; &quot;   组号：&quot; &lt;&lt; (*p).first &lt;&lt; endl;</span></span><br><span class="line">		<span class="keyword">int</span> avg_score = <span class="built_in">get_avg_score</span>();</span><br><span class="line">		(*p).second.<span class="built_in">setScore</span>(avg_score);</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;第一次比赛后：&quot;</span> &lt;&lt; endl;</span><br><span class="line">	<span class="built_in">print_info_after_game</span>(<span class="keyword">this</span>-&gt;first_groups, <span class="keyword">this</span>-&gt;second_vector);</span><br><span class="line">		</span><br><span class="line">	<span class="comment">//先按分数排序，再去掉后一半，再按编号排序</span></span><br><span class="line">	<span class="built_in">sort</span>(<span class="keyword">this</span>-&gt;second_vector.<span class="built_in">begin</span>(),<span class="keyword">this</span>-&gt;second_vector.<span class="built_in">end</span>(),compare_score);</span><br><span class="line">	<span class="keyword">this</span>-&gt;second_vector.<span class="built_in">erase</span>(<span class="keyword">this</span>-&gt;second_vector.<span class="built_in">begin</span>()+<span class="number">12</span>,<span class="keyword">this</span>-&gt;second_vector.<span class="built_in">end</span>());</span><br><span class="line">	<span class="built_in">sort</span>(<span class="keyword">this</span>-&gt;second_vector.<span class="built_in">begin</span>(), <span class="keyword">this</span>-&gt;second_vector.<span class="built_in">end</span>(), compare);</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;第一次比赛后晋级名单:&quot;</span> &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">for</span> (vector&lt;Speaker&gt;::iterator it = <span class="keyword">this</span>-&gt;second_vector.<span class="built_in">begin</span>(); it != <span class="keyword">this</span>-&gt;second_vector.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">		cout &lt;&lt; (*it).<span class="built_in">getName</span>() &lt;&lt; <span class="string">&quot;  &quot;</span>&lt;&lt;(*it).<span class="built_in">getNumber</span>()&lt;&lt;endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">divide_and_print</span>(<span class="keyword">this</span>-&gt;second_vector, <span class="keyword">this</span>-&gt;second_groups);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">compare_score_second</span><span class="params">(Speaker&amp; s1, Speaker&amp; s2)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> s1.<span class="built_in">getScore</span>(<span class="number">1</span>) &gt; s2.<span class="built_in">getScore</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Manager::second_game</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">srand</span>(<span class="built_in">time</span>(<span class="literal">nullptr</span>));</span><br><span class="line">	<span class="keyword">for</span> (multimap&lt;<span class="keyword">int</span>, Speaker&gt;::iterator p = <span class="keyword">this</span>-&gt;second_groups.<span class="built_in">begin</span>(); p != <span class="keyword">this</span>-&gt;second_groups.<span class="built_in">end</span>(); p++) &#123;</span><br><span class="line">		<span class="comment">//cout &lt;&lt; &quot;姓名:&quot; &lt;&lt; (*p).second.getName() &lt;&lt; &quot;   编号：&quot; &lt;&lt; (*p).second.getNumber() &lt;&lt; &quot;   组号：&quot; &lt;&lt; (*p).first &lt;&lt; endl;</span></span><br><span class="line">		<span class="keyword">int</span> avg_score = <span class="built_in">get_avg_score</span>();</span><br><span class="line">		(*p).second.<span class="built_in">setScore</span>(avg_score);</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;第二次比赛后：&quot;</span> &lt;&lt; endl;</span><br><span class="line">	<span class="built_in">print_info_after_game</span>(<span class="keyword">this</span>-&gt;second_groups, <span class="keyword">this</span>-&gt;third_vector);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//先按分数排序，再去掉后一半，再按编号排序</span></span><br><span class="line">	<span class="built_in">sort</span>(<span class="keyword">this</span>-&gt;third_vector.<span class="built_in">begin</span>(), <span class="keyword">this</span>-&gt;third_vector.<span class="built_in">end</span>(), compare_score_second);</span><br><span class="line">	<span class="keyword">this</span>-&gt;third_vector.<span class="built_in">erase</span>(<span class="keyword">this</span>-&gt;third_vector.<span class="built_in">begin</span>() + <span class="number">6</span>, <span class="keyword">this</span>-&gt;third_vector.<span class="built_in">end</span>());</span><br><span class="line">	<span class="built_in">sort</span>(<span class="keyword">this</span>-&gt;third_vector.<span class="built_in">begin</span>(), <span class="keyword">this</span>-&gt;third_vector.<span class="built_in">end</span>(), compare);</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;第二次比赛后晋级名单:&quot;</span> &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">for</span> (vector&lt;Speaker&gt;::iterator it = <span class="keyword">this</span>-&gt;third_vector.<span class="built_in">begin</span>(); it != <span class="keyword">this</span>-&gt;third_vector.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">		cout &lt;&lt; (*it).<span class="built_in">getName</span>() &lt;&lt; <span class="string">&quot;  &quot;</span> &lt;&lt; (*it).<span class="built_in">getNumber</span>() &lt;&lt; endl;</span><br><span class="line">	&#125;	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">compare_score_third</span><span class="params">(Speaker&amp; s1, Speaker&amp; s2)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> s1.<span class="built_in">getScore</span>(<span class="number">2</span>) &gt; s2.<span class="built_in">getScore</span>(<span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Manager::final_game</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">srand</span>(<span class="built_in">time</span>(<span class="literal">nullptr</span>));</span><br><span class="line">	<span class="keyword">for</span> (vector&lt;Speaker&gt;::iterator p = <span class="keyword">this</span>-&gt;third_vector.<span class="built_in">begin</span>(); p != <span class="keyword">this</span>-&gt;third_vector.<span class="built_in">end</span>(); p++) &#123;</span><br><span class="line">		<span class="keyword">int</span> avg_score = <span class="built_in">get_avg_score</span>();</span><br><span class="line">		(*p).<span class="built_in">setScore</span>(avg_score);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;第三次比赛后：&quot;</span> &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">for</span> (vector&lt;Speaker&gt;::iterator p = <span class="keyword">this</span>-&gt;third_vector.<span class="built_in">begin</span>(); p != <span class="keyword">this</span>-&gt;third_vector.<span class="built_in">end</span>(); p++) &#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;姓名:&quot;</span> &lt;&lt; (*p).<span class="built_in">getName</span>()&lt;&lt; <span class="string">&quot;   编号：&quot;</span> &lt;&lt; (*p).<span class="built_in">getNumber</span>()&lt;&lt; <span class="string">&quot;   分数：&quot;</span> &lt;&lt; (*p).<span class="built_in">getScore</span>(<span class="number">2</span>)	&lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//先按分数排序，再去掉后一半，再按编号排序</span></span><br><span class="line">	<span class="built_in">sort</span>(<span class="keyword">this</span>-&gt;third_vector.<span class="built_in">begin</span>(), <span class="keyword">this</span>-&gt;third_vector.<span class="built_in">end</span>(), compare_score_third);</span><br><span class="line">	<span class="keyword">this</span>-&gt;third_vector.<span class="built_in">erase</span>(<span class="keyword">this</span>-&gt;third_vector.<span class="built_in">begin</span>() + <span class="number">3</span>, <span class="keyword">this</span>-&gt;third_vector.<span class="built_in">end</span>());</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;前三名名单:&quot;</span> &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">for</span> (vector&lt;Speaker&gt;::iterator it = <span class="keyword">this</span>-&gt;third_vector.<span class="built_in">begin</span>(); it != <span class="keyword">this</span>-&gt;third_vector.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;姓名:&quot;</span> &lt;&lt; (*it).<span class="built_in">getName</span>() &lt;&lt; <span class="string">&quot;   编号：&quot;</span>&lt;&lt; (*it).<span class="built_in">getNumber</span>() &lt;&lt; <span class="string">&quot;   分数：&quot;</span> &lt;&lt;(*it).<span class="built_in">getScore</span>(<span class="number">2</span>)&lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Manager::show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">this</span>-&gt;<span class="built_in">create_speaker</span>();</span><br><span class="line">	<span class="keyword">this</span>-&gt;<span class="built_in">divid_speaker</span>();</span><br><span class="line">	<span class="keyword">this</span>-&gt;<span class="built_in">first_game</span>();</span><br><span class="line">	<span class="keyword">this</span>-&gt;<span class="built_in">second_game</span>();</span><br><span class="line">	<span class="keyword">this</span>-&gt;<span class="built_in">final_game</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>C++</category>
        <category>STL</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>STL</tag>
        <tag>STL案例</tag>
      </tags>
  </entry>
  <entry>
    <title>STL_迭代器</title>
    <url>/2021/05/07/STL%EF%BC%9A%E8%BF%AD%E4%BB%A3%E5%99%A8/</url>
    <content><![CDATA[<h3 id="一、迭代器基本原理"><a href="#一、迭代器基本原理" class="headerlink" title="一、迭代器基本原理"></a>一、迭代器基本原理</h3><p>&ensp;&ensp;&ensp;&ensp;迭代器是一个“可遍历STL容器内全部或部分元素”的对象。</p>
<span id="more"></span>

<p>&ensp;&ensp;&ensp;&ensp;迭代器指出容器中的一个特定位置。</p>
<p>&ensp;&ensp;&ensp;&ensp;迭代器就如同一个指针。</p>
<p>&ensp;&ensp;&ensp;&ensp;迭代器提供对一个容器中的对象的访问方法，并且可以定义了容器中对象的范围。</p>
<p><strong>迭代器的类别</strong>：</p>
<ul>
<li><p><strong>输入迭代器</strong>：也有叫法称之为“只读迭代器”，它从容器中读取元素，只能一次读入一个元素向前移动，只支持一遍算法，同一个输入迭代器不能两遍遍历一个序列。</p>
</li>
<li><p><strong>输出迭代器</strong>：也有叫法称之为“只写迭代器”，它往容器中写入元素，只能一次写入一个元素向前移动，只支持一遍算法，同一个输出迭代器不能两遍遍历一个序列。</p>
</li>
<li><p><strong>正向迭代器</strong>：组合输入迭代器和输出迭代器的功能，还可以多次解析一个迭代器指定的位置，可以对一个值进行多次读/写。</p>
</li>
<li><p><strong>双向迭代器</strong>：组合正向迭代器的功能，还可以通过–操作符向后移动位置。</p>
</li>
<li><p><strong>随机访问迭代器</strong>：组合双向迭代器的功能，还可以向前向后跳过任意个位置，可以直接访问容器中任何位置的元素。</p>
</li>
</ul>
<p>目前本系列教程所用到的容器，都支持双向迭代器或随机访问迭代器，下面将会详细介绍这两个类别的迭代器。</p>
<h3 id="二、双向迭代器与随机访问迭代器"><a href="#二、双向迭代器与随机访问迭代器" class="headerlink" title="二、双向迭代器与随机访问迭代器"></a>二、双向迭代器与随机访问迭代器</h3><p>&ensp;&ensp;&ensp;&ensp;双向迭代器支持的操作：it++, ++it,  it–,  –it，*it， itA = itB，itA == itB，itA != itB，其中list,set,multiset,map,multimap支持双向迭代器。</p>
<p>&ensp;&ensp;&ensp;&ensp;随机访问迭代器支持的操作：在双向迭代器的操作基础上添加it+=i， it-=i， it+i(或it=it+i)，it[i],itA&lt;itB,  itA&lt;=itB, itA&gt;itB, itA&gt;=itB 的功能。其中vector，deque支持随机访问迭代器。</p>
<h3 id="三、vector与迭代器的配合使用"><a href="#三、vector与迭代器的配合使用" class="headerlink" title="三、vector与迭代器的配合使用"></a>三、vector与迭代器的配合使用</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">vector&lt;<span class="keyword">int</span>&gt; vecInt; <span class="comment">//假设包含1,3,5,7,9元素</span></span><br><span class="line"></span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt;::iterator it;      <span class="comment">//声明容器vector&lt;int&gt;的迭代器。</span></span><br><span class="line"></span><br><span class="line">it = vecInt.<span class="built_in">begin</span>();  <span class="comment">// *it == 1</span></span><br><span class="line"></span><br><span class="line">++it;             <span class="comment">//或者it++; *it == 3 ，前++的效率比后++的效率高，前++返回引用，后++返回值。</span></span><br><span class="line"></span><br><span class="line">it += <span class="number">2</span>;       <span class="comment">//*it == 7</span></span><br><span class="line"></span><br><span class="line">it = it+<span class="number">1</span>;      <span class="comment">//*it == 9</span></span><br><span class="line"></span><br><span class="line">++it;             <span class="comment">// it == vecInt.end(); 此时不能再执行*it,会出错!</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//正向遍历：</span></span><br><span class="line"><span class="keyword">for</span>(vector&lt;<span class="keyword">int</span>&gt;::iterator it=vecInt.<span class="built_in">begin</span>(); it!=vecInt.<span class="built_in">end</span>(); ++it)&#123;</span><br><span class="line">   	<span class="keyword">int</span> iItem = *it; </span><br><span class="line">	cout &lt;&lt; iItem;  <span class="comment">//或直接使用 cout &lt;&lt; *it;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//这样子便打印出1 3 5 7 9</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//逆向遍历：</span></span><br><span class="line"><span class="keyword">for</span>(vector&lt;<span class="keyword">int</span>&gt;::reverse_iterator rit=vecInt.<span class="built_in">rbegin</span>(); rit!=vecInt.<span class="built_in">rend</span>(); ++rit)  <span class="comment">//注意，小括号内仍是++rit</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="keyword">int</span> iItem = *rit;</span><br><span class="line">   cout &lt;&lt; iItem;   <span class="comment">//或直接使用cout &lt;&lt; *rit;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//此时将打印出9,7,5,3,1</span></span><br></pre></td></tr></table></figure>

<p>&ensp;&ensp;&ensp;&ensp;注意，这里迭代器的声明采用vector&lt;int&gt;::reverse_iterator，而非vector&lt;int&gt;::iterator。 </p>
<p>迭代器还有其它两种声明方法：</p>
<ul>
<li>vector&lt;int&gt;::const_iterator </li>
<li>vector&lt;int&gt;::const_reverse_iterator</li>
</ul>
<p>&ensp;&ensp;&ensp;&ensp; 以上两种分别是vector&lt;int&gt;::iterator 与vector&lt;int&gt;::reverse_iterator 的只读形式，使用这两种迭代器时，不会修改到容器中的值。</p>
<p>&ensp;&ensp;&ensp;&ensp;备注：不过容器中的insert和erase方法仅接受这四种类型中的iterator，其它三种不支持。《Effective STL》建议我们尽量使用iterator取代const_iterator、reverse_iterator和const_reverse_iterator。 </p>
]]></content>
      <categories>
        <category>C++</category>
        <category>STL</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>STL</tag>
        <tag>STL迭代器</tag>
      </tags>
  </entry>
  <entry>
    <title>makedown语法</title>
    <url>/2021/05/01/makedown%EF%BC%9Amakedown%E8%AF%AD%E6%B3%95/</url>
    <content><![CDATA[<p>    介绍一些<code>makedown语法</code>，在<code>Typora</code>可以完美显示，在其它makedown编辑器或网页上可能显示不成功。这篇文章并不是总结性质的，是搜集性质的（需要用到时搜的）。</p>
<span id="more"></span>

<h5 id="空格"><a href="#空格" class="headerlink" title="空格"></a>空格</h5><figure class="highlight tex"><table><tr><td class="code"><pre><span class="line"><span class="built_in">&amp;</span>ensp;<span class="built_in">&amp;</span>ensp;<span class="built_in">&amp;</span>ensp;<span class="built_in">&amp;</span>ensp;          空格</span><br></pre></td></tr></table></figure>

<h5 id="折叠文章"><a href="#折叠文章" class="headerlink" title="折叠文章"></a>折叠文章</h5><figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">&lt;!-- more --&gt;					折叠文章</span><br></pre></td></tr></table></figure>

<h5 id="上标与下标"><a href="#上标与下标" class="headerlink" title="上标与下标"></a>上标与下标</h5><p>x^2^                    x<del>0</del></p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">输入上标，如：x2，则输入 x<span class="built_in">^</span>2<span class="built_in">^</span></span><br><span class="line">输入下标，如：x0，则输入 x~0~</span><br></pre></td></tr></table></figure>

<h5 id="箭头"><a href="#箭头" class="headerlink" title="箭头"></a>箭头</h5><table>
<thead>
<tr>
<th align="center">$\longleftrightarrow$</th>
<th align="center">$\longleftrightarrow$</th>
</tr>
</thead>
<tbody><tr>
<td align="center">$\Longrightarrow$</td>
<td align="center">$\Longrightarrow$</td>
</tr>
<tr>
<td align="center">$\Longleftrightarrow$</td>
<td align="center">$\Longleftrightarrow$</td>
</tr>
<tr>
<td align="center">$\Longleftarrow$</td>
<td align="center">$\Longleftarrow$</td>
</tr>
<tr>
<td align="center">$\Updownarrow$</td>
<td align="center">$\Updownarrow$</td>
</tr>
<tr>
<td align="center">$\circlearrowleft$</td>
<td align="center">$\circlearrowleft$</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>makedown</category>
      </categories>
      <tags>
        <tag>makedown</tag>
      </tags>
  </entry>
  <entry>
    <title>近期说明</title>
    <url>/2021/04/10/top%EF%BC%9A%E8%AF%B4%E6%98%8E/</url>
    <content><![CDATA[<p>&ensp;&ensp;介绍一些博客较大的变化（增删改查）以及其它说明。</p>
<span id="more"></span>

<table>
<thead>
<tr>
<th align="center">时间</th>
<th align="center">网站变化</th>
</tr>
</thead>
<tbody><tr>
<td align="center">2021.6.12</td>
<td align="center">加了些动态规划的算法题，主要是0-1背包问题</td>
</tr>
<tr>
<td align="center">2021.6.6</td>
<td align="center">落后一个周，终于将Hadoop的MapReduce总结好了。</td>
</tr>
<tr>
<td align="center">2021.5.29</td>
<td align="center">将这两个周的优质算法题整理了一下，涉及字符串和数组。Hadoop的MapReduce总结在周末应该也可以整好。</td>
</tr>
<tr>
<td align="center">2021.5.22</td>
<td align="center">把学习数据研发时Hadoop的HDFS相关知识总结了一下，学习视频主要是尚硅谷的Hadoop教程（尚硅谷yyds，每篇文章后都有链接）。</td>
</tr>
<tr>
<td align="center">2021.5.15</td>
<td align="center">本周刷了几道和数组有关的算法题，有子数组相关、数组元素与下标等，趁着周六整理了出来。</td>
</tr>
<tr>
<td align="center">2021.5.9</td>
<td align="center">把以前和数学有关的几道算法题整理了一下，主要是杨辉三角和排列组合子集的相关问题。</td>
</tr>
<tr>
<td align="center">2021.5.7</td>
<td align="center">增加了一些有关二叉树的算法题，不再像链表题那样一个题一篇博客，而是一类题一篇博客；同时由于在学习<code>Shell</code>，所以还增加了两篇和<code>Shell</code>相关的博客。顺道把以前学习C++时的<code>STL</code>笔记整理了上去。</td>
</tr>
<tr>
<td align="center">2021.5.1</td>
<td align="center">为这个小破站添加了友情链接，主要是收藏自己喜欢的学习网站和好友的博客；同时在侧边栏添加了一个粒子时钟，方便查看时间。</td>
</tr>
<tr>
<td align="center">2021.4.29</td>
<td align="center">增添了大量有关链表算法题的文章，都是自己以前写的，今天整理出来了。其它的内容，趁着五一假期，会陆续发布。</td>
</tr>
</tbody></table>
]]></content>
  </entry>
  <entry>
    <title>二叉树的遍历模板</title>
    <url>/2021/05/07/%E4%BA%8C%E5%8F%89%E6%A0%91%EF%BC%9A%E4%BA%8C%E5%8F%89%E6%A0%91%E9%81%8D%E5%8E%86%E6%A8%A1%E6%9D%BF/</url>
    <content><![CDATA[<p>&ensp;&ensp;&ensp;&ensp;总结的二叉树的遍历模板，其中前、中、后序遍历采用递归形式，层序遍历采用迭代。</p>
<span id="more"></span>

<h3 id="前序遍历模板"><a href="#前序遍历模板" class="headerlink" title="前序遍历模板"></a>前序遍历模板</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">traverse</span><span class="params">(TreeNode* root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//to do sth</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">traverse</span>(root-&gt;left)</span><br><span class="line">    <span class="built_in">traverse</span>(root-&gt;right)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="中序遍历模板"><a href="#中序遍历模板" class="headerlink" title="中序遍历模板"></a>中序遍历模板</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">traverse</span><span class="params">(TreeNode* root)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">traverse</span>(root-&gt;left)</span><br><span class="line">         </span><br><span class="line">    <span class="comment">//to do sth</span></span><br><span class="line">        </span><br><span class="line">    <span class="built_in">traverse</span>(root-&gt;right)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="后序遍历模板"><a href="#后序遍历模板" class="headerlink" title="后序遍历模板"></a>后序遍历模板</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">traverse</span><span class="params">(TreeNode* root)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="built_in">traverse</span>(root-&gt;left)</span><br><span class="line">    <span class="built_in">traverse</span>(root-&gt;right)</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//to do sth</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="层序遍历模板"><a href="#层序遍历模板" class="headerlink" title="层序遍历模板"></a>层序遍历模板</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">traverse</span><span class="params">(TreeNode* root)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!root) <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">// 初始化队列，将 root 加入队列</span></span><br><span class="line">    queue&lt;TreeNode*&gt; que;</span><br><span class="line">    que.<span class="built_in">push</span>(root);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!que.<span class="built_in">empty</span>()) </span><br><span class="line">    &#123;</span><br><span class="line">        TreeNode* cur = que.<span class="built_in">front</span>();</span><br><span class="line">        que.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//to do sth</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (cur-&gt;left) </span><br><span class="line">        	que.<span class="built_in">offer</span>(cur-&gt;left);        </span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (cur.right) </span><br><span class="line">            que.<span class="built_in">offer</span>(cur-&gt;right);</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="搜索二叉树的遍历模板"><a href="#搜索二叉树的遍历模板" class="headerlink" title="搜索二叉树的遍历模板"></a>搜索二叉树的遍历模板</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BST</span><span class="params">(TreeNode* root, <span class="keyword">int</span> target)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root-&gt;val == target)</span><br><span class="line">        <span class="comment">// 找到目标，做点什么</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (root-&gt;val &lt; target) </span><br><span class="line">        <span class="built_in">BST</span>(root-&gt;right, target);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (root-&gt;val &gt; target)</span><br><span class="line">        <span class="built_in">BST</span>(root.left, target);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法</category>
        <category>二叉树</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>二叉树</tag>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>二叉树中的序列化和反序列化</title>
    <url>/2021/05/05/%E4%BA%8C%E5%8F%89%E6%A0%91%EF%BC%9A%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%BA%8F%E5%88%97%E5%8C%96%E5%92%8C%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/</url>
    <content><![CDATA[<h3 id="一、题目"><a href="#一、题目" class="headerlink" title="一、题目"></a>一、题目</h3><p>&ensp;&ensp;&ensp;&ensp;序列化是将一个数据结构或者对象转换为连续的比特位的操作，进而可以将转换后的数据存储在一个文件或者内存中，同时也可以通过网络传输到另一个计算机环境，采取相反方式重构得到原数据。</p>
<span id="more"></span>

<p>&ensp;&ensp;&ensp;&ensp;请设计一个算法来实现二叉树的序列化与反序列化。这里不限定你的序列 / 反序列化算法执行逻辑，你只需要保证一个二叉树可以被序列化为一个字符串并且将这个字符串反序列化为原始的树结构。 </p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">     1</span><br><span class="line">   &#x2F;   \</span><br><span class="line">  2     3</span><br><span class="line">       &#x2F; \</span><br><span class="line">      4   5</span><br><span class="line">输入：root &#x3D; [1,2,3,null,null,4,5]</span><br><span class="line">输出：[1,2,3,null,null,4,5]</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：root &#x3D; []</span><br><span class="line">输出：[]</span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：root &#x3D; [1]</span><br><span class="line">输出：[1]</span><br></pre></td></tr></table></figure>

<p><strong>示例 4：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：root &#x3D; [1,2]</span><br><span class="line">输出：[1,2]</span><br></pre></td></tr></table></figure>

<p> <strong>提示：</strong></p>
<ul>
<li>树中结点数在范围 <code>[0, 104]</code> 内</li>
<li><code>-1000 &lt;= Node.val &lt;= 1000</code></li>
</ul>
<h3 id="二、思路与代码"><a href="#二、思路与代码" class="headerlink" title="二、思路与代码"></a>二、思路与代码</h3><p>&ensp;&ensp;&ensp;&ensp;说白了，这不就是先按照一定的规则遍历二叉树，再用与之对应的规则把相应的字符串构建成二叉树。</p>
<p>&ensp;&ensp;&ensp;&ensp;序列化与反序列化主要分为两个流派：dfs和bfs；由于二叉树的特殊性，dfs分为前序、中序、后序遍历，但<strong>只有前序和后序遍历才可以在线性复杂度下进行反序列化</strong>。</p>
<p>&ensp;&ensp;&ensp;&ensp;前序、后序、层序都能够很好的找到根节点，而且不同于一般构造二叉树的问题，为了区分子树，此处将空指针的地方指出，相当于比较完整的给出了树的结构。而且为了区分每个节点的值，不管是空节点还是普通节点，都必须以“,”或其他标记结尾。</p>
<p>&ensp;&ensp;&ensp;&ensp;反序列化时，在确定根节点后，紧接着确定某一子树，对当前子树采用递归，形成了相同的问题，类似于序列化过程中的递归问题。</p>
<p>&ensp;&ensp;&ensp;&ensp;反序列化中值得注意的是，前序是利用序列化结果，依次从前往后构造节点，类似于队列；后序依次从后往前，类似于栈；中序时，由于无法从序列化结果中找到根节点位置，也就无法准确划分左右子树，无法形成递归的结构，这种方式不能反序列化！</p>
<p>&ensp;&ensp;&ensp;&ensp;层序遍历思路类似，相对要麻烦一点，拿新结点一层一层的往后面接，这里可以考虑直接用vector加上索引（也可以用queue，但是vector访问简洁一点）。</p>
<h5 id="先序遍历序列化与反序列化"><a href="#先序遍历序列化与反序列化" class="headerlink" title="先序遍历序列化与反序列化"></a>先序遍历序列化与反序列化</h5><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Codec</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    string treeStr;</span><br><span class="line">    <span class="comment">// Encodes a tree to a single string.</span></span><br><span class="line">    <span class="function">string <span class="title">serialize</span><span class="params">(TreeNode* root)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">preorder</span>(root);</span><br><span class="line">        treeStr.<span class="built_in">pop_back</span>();</span><br><span class="line">        <span class="keyword">return</span> treeStr;</span><br><span class="line">    &#125;  </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">preorder</span><span class="params">(TreeNode* root)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!root)</span><br><span class="line">        &#123;</span><br><span class="line">            treeStr += <span class="string">&quot;#,&quot;</span>;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        treeStr += (<span class="built_in">to_string</span>(root-&gt;val) + <span class="string">&quot;,&quot;</span>);</span><br><span class="line">        <span class="built_in">preorder</span>(root-&gt;left);</span><br><span class="line">        <span class="built_in">preorder</span>(root-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">queue&lt;string&gt; <span class="title">split</span><span class="params">(string&amp; str)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        queue&lt;string&gt; treeNodeQue;</span><br><span class="line">        <span class="keyword">if</span> (str.<span class="built_in">empty</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> treeNodeQue;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> strLength = str.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> pre = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= strLength; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (i == strLength || str[i] == <span class="string">&#x27;,&#x27;</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                treeNodeQue.<span class="built_in">emplace</span>(str.<span class="built_in">substr</span>(pre, i - pre));</span><br><span class="line">                pre = i + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> treeNodeQue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">TreeNode* <span class="title">deserialize</span><span class="params">(queue&lt;string&gt;&amp; treeNodeQue)</span></span></span><br><span class="line"><span class="function">    </span>&#123;        </span><br><span class="line">        <span class="keyword">if</span> (treeNodeQue.<span class="built_in">empty</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        string first = treeNodeQue.<span class="built_in">front</span>();</span><br><span class="line">        treeNodeQue.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">if</span> (first == <span class="string">&quot;#&quot;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        TreeNode* root = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(<span class="built_in">stoi</span>(first));</span><br><span class="line">        root-&gt;left = <span class="built_in">deserialize</span>(treeNodeQue);</span><br><span class="line">        root-&gt;right = <span class="built_in">deserialize</span>(treeNodeQue);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Decodes your encoded data to tree.</span></span><br><span class="line">    <span class="function">TreeNode* <span class="title">deserialize</span><span class="params">(string data)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        queue&lt;string&gt; temp = <span class="built_in">split</span>(data);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">deserialize</span>(temp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="后序遍历序列化与反序列化"><a href="#后序遍历序列化与反序列化" class="headerlink" title="后序遍历序列化与反序列化"></a>后序遍历序列化与反序列化</h5><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Codec</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    string treeStr;</span><br><span class="line">    <span class="comment">// Encodes a tree to a single string.</span></span><br><span class="line">    <span class="function">string <span class="title">serialize</span><span class="params">(TreeNode* root)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">preorder</span>(root);</span><br><span class="line">        treeStr.<span class="built_in">pop_back</span>();</span><br><span class="line">        <span class="keyword">return</span> treeStr;</span><br><span class="line">    &#125;  </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">preorder</span><span class="params">(TreeNode* root)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!root)</span><br><span class="line">        &#123;</span><br><span class="line">            treeStr += <span class="string">&quot;#,&quot;</span>;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">preorder</span>(root-&gt;left);</span><br><span class="line">        <span class="built_in">preorder</span>(root-&gt;right);</span><br><span class="line">        treeStr += (<span class="built_in">to_string</span>(root-&gt;val) + <span class="string">&quot;,&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">stack&lt;string&gt; <span class="title">split</span><span class="params">(string&amp; str)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        stack&lt;string&gt; treeNodeStk;</span><br><span class="line">        <span class="keyword">if</span> (str.<span class="built_in">empty</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> treeNodeStk;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> strLength = str.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> pre = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= strLength; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (i == strLength || str[i] == <span class="string">&#x27;,&#x27;</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                treeNodeStk.<span class="built_in">emplace</span>(str.<span class="built_in">substr</span>(pre, i - pre));</span><br><span class="line">                pre = i + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> treeNodeStk;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">TreeNode* <span class="title">deserialize</span><span class="params">(stack&lt;string&gt;&amp; treeNodeStk)</span></span></span><br><span class="line"><span class="function">    </span>&#123;        </span><br><span class="line">        <span class="keyword">if</span> (treeNodeStk.<span class="built_in">empty</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        string first = treeNodeStk.<span class="built_in">top</span>();</span><br><span class="line">        treeNodeStk.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">if</span> (first == <span class="string">&quot;#&quot;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        TreeNode* root = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(<span class="built_in">stoi</span>(first));</span><br><span class="line">        root-&gt;right = <span class="built_in">deserialize</span>(treeNodeStk);</span><br><span class="line">        root-&gt;left = <span class="built_in">deserialize</span>(treeNodeStk);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Decodes your encoded data to tree.</span></span><br><span class="line">    <span class="function">TreeNode* <span class="title">deserialize</span><span class="params">(string data)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        stack&lt;string&gt; temp = <span class="built_in">split</span>(data);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">deserialize</span>(temp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h5 id="层序遍历序列化与反序列化"><a href="#层序遍历序列化与反序列化" class="headerlink" title="层序遍历序列化与反序列化"></a>层序遍历序列化与反序列化</h5><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Codec</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// Encodes a tree to a single string.</span></span><br><span class="line">    <span class="function">string <span class="title">serialize</span><span class="params">(TreeNode* root)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!root)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        &#125;    </span><br><span class="line">        string str;</span><br><span class="line">        queue&lt;TreeNode*&gt; q;</span><br><span class="line">        q.<span class="built_in">push</span>(root);</span><br><span class="line">        <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) </span><br><span class="line">        &#123;</span><br><span class="line">            TreeNode* node = q.<span class="built_in">front</span>();</span><br><span class="line">            q.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">if</span> (node)</span><br><span class="line">            &#123;</span><br><span class="line">                str += (<span class="built_in">to_string</span>(node-&gt;val) + <span class="string">&quot;,&quot;</span>);</span><br><span class="line">            &#125;                </span><br><span class="line">            <span class="keyword">else</span> </span><br><span class="line">            &#123;</span><br><span class="line">                str += <span class="string">&quot;#,&quot;</span>;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            q.<span class="built_in">push</span>(node-&gt;left);</span><br><span class="line">            q.<span class="built_in">push</span>(node-&gt;right);</span><br><span class="line">        &#125;</span><br><span class="line">        str.<span class="built_in">pop_back</span>();</span><br><span class="line">        <span class="keyword">return</span> str;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">split</span><span class="params">(string&amp; str)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        vector&lt;string&gt; ans;</span><br><span class="line">        <span class="keyword">if</span> (str.<span class="built_in">empty</span>()) <span class="keyword">return</span> ans;</span><br><span class="line">        <span class="keyword">int</span> size = str.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> pre = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= size; ++i) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (i == size || str[i] == <span class="string">&#x27;,&#x27;</span>) </span><br><span class="line">            &#123;</span><br><span class="line">                ans.<span class="built_in">emplace_back</span>(str.<span class="built_in">substr</span>(pre, i - pre));</span><br><span class="line">                pre = i + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">TreeNode* <span class="title">deserialize</span><span class="params">(vector&lt;string&gt;&amp; data)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (data.<span class="built_in">empty</span>())   </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        string node = data[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">        TreeNode* root = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(<span class="built_in">stoi</span>(node));</span><br><span class="line">        queue&lt;TreeNode*&gt; q;</span><br><span class="line">        q.<span class="built_in">push</span>(root);</span><br><span class="line">        <span class="keyword">int</span> i =<span class="number">1</span>; </span><br><span class="line">        <span class="keyword">while</span> (i &lt; data.<span class="built_in">size</span>()) </span><br><span class="line">        &#123;</span><br><span class="line">            TreeNode* node = q.<span class="built_in">front</span>();</span><br><span class="line">            q.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">if</span> (node == <span class="literal">nullptr</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;    </span><br><span class="line">            string s_left = data[i++];</span><br><span class="line">            <span class="keyword">if</span> (s_left == <span class="string">&quot;#&quot;</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                node-&gt;left = <span class="literal">nullptr</span>;</span><br><span class="line">            &#125;                </span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                node-&gt;left = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(<span class="built_in">stoi</span>(s_left));</span><br><span class="line">            &#125;                </span><br><span class="line">            q.<span class="built_in">push</span>(node-&gt;left);</span><br><span class="line">            string s_right = data[i++];</span><br><span class="line">            <span class="keyword">if</span> (s_right == <span class="string">&quot;#&quot;</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                node-&gt;right = <span class="literal">nullptr</span>;</span><br><span class="line">            &#125;                </span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                node-&gt;right = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(<span class="built_in">stoi</span>(s_right));</span><br><span class="line">            &#125;</span><br><span class="line">            q.<span class="built_in">push</span>(node-&gt;right);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Decodes your encoded data to tree.</span></span><br><span class="line">    <span class="function">TreeNode* <span class="title">deserialize</span><span class="params">(string data)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        vector&lt;string&gt; iters = <span class="built_in">split</span>(data);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">deserialize</span>(iters);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><a href="https://leetcode-cn.com/problems/serialize-and-deserialize-binary-tree/solution/ji-chong-bu-tong-bian-li-fang-shi-xia-de-0eap/">参考</a></p>
<p><a href="https://mp.weixin.qq.com/s?__biz=MzAxODQxMDM0Mw==&mid=2247485871&idx=1&sn=bcb24ea8927995b585629a8b9caeed01&chksm=9bd7f7a7aca07eb1b4c330382a4e0b916ef5a82ca48db28908ab16563e28a376b5ca6805bec2&scene=21#wechat_redirect">二叉树的序列化</a></p>
]]></content>
      <categories>
        <category>算法</category>
        <category>二叉树</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>二叉树</tag>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>构建二叉树</title>
    <url>/2021/05/07/%E4%BA%8C%E5%8F%89%E6%A0%91%EF%BC%9A%E6%9E%84%E5%BB%BA%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
    <content><![CDATA[<p>    构建二叉树的方式多种多样，可以从前序与中序遍历序列构造二叉树、从中序与后序遍历序列构造二叉树，还可以从有序数组和链表中构建二叉树。掌握构建的前提是理解遍历二叉树和二叉树的结构。</p>
<span id="more"></span>

<h3 id="105-从前序与中序遍历序列构造二叉树"><a href="#105-从前序与中序遍历序列构造二叉树" class="headerlink" title="105. 从前序与中序遍历序列构造二叉树"></a><a href="https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/">105. 从前序与中序遍历序列构造二叉树</a></h3><p>    根据一棵树的前序遍历与中序遍历构造二叉树。</p>
<p>    **注意:**你可以假设树中没有重复的元素。</p>
<p>    例如，给出</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">前序遍历 preorder &#x3D; [3,9,20,15,7]</span><br><span class="line">中序遍历 inorder &#x3D; [9,3,15,20,7]</span><br></pre></td></tr></table></figure>

<p>    返回如下的二叉树：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">  3</span><br><span class="line"> &#x2F; \</span><br><span class="line">9  20</span><br><span class="line">  &#x2F;  \</span><br><span class="line"> 15   7</span><br></pre></td></tr></table></figure>

<p><strong>思路与代码</strong>：</p>
<p>    首先要知道一个结论，前序/后序+中序序列可以唯一确定一棵二叉树，所以自然而然可以用来建树。</p>
<p>    看一下前序和中序有什么特点，前序<code>1,2,4,7,3,5,6,8</code> ，中序<code>4,7,2,1,5,3,8,6</code>；</p>
<p>    有如下特征：</p>
<ol>
<li> 前序中左起第一位<code>1</code>肯定是根结点，我们可以据此找到中序中根结点的位置<code>rootin</code>；</li>
<li> 中序中根结点左边就是左子树结点，右边就是右子树结点，即<code>[左子树结点，根结点，右子树结点]</code>，我们就可以得出左子树结点个数为<code>int left = rootin - leftin;</code>；</li>
<li> 前序中结点分布应该是：<code>[根结点，左子树结点，右子树结点]</code>；</li>
<li> 根据前一步确定的左子树个数，可以确定前序中左子树结点和右子树结点的范围；</li>
<li>如果我们要前序遍历生成二叉树的话，下一层递归应该是：<ul>
<li>  左子树：<code>root-&gt;left = pre_order(前序序列，前序左子树范围，中序序列，中序左子树范围);</code>；</li>
<li>  右子树：<code>root-&gt;right = pre_order(前序序列，前序右子树范围，中序序列，中序右子树范围);</code>。</li>
</ul>
</li>
<li> 每一层递归都要返回当前根结点<code>root</code>；</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">buildTree</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; preorder, vector&lt;<span class="keyword">int</span>&gt;&amp; inorder)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">help</span>(preorder, <span class="number">0</span>, preorder.<span class="built_in">size</span>() - <span class="number">1</span>, </span><br><span class="line">                    inorder, <span class="number">0</span>, inorder.<span class="built_in">size</span>() - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">TreeNode* <span class="title">help</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; preorder, <span class="keyword">int</span> low1, <span class="keyword">int</span> high1, </span></span></span><br><span class="line"><span class="function"><span class="params">                    vector&lt;<span class="keyword">int</span>&gt;&amp; inorder, <span class="keyword">int</span> low2, <span class="keyword">int</span> high2)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(low1 &gt; high1 || low2 &gt; high2)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> root = preorder.<span class="built_in">at</span>(low1);</span><br><span class="line">        <span class="keyword">int</span> mid = low2;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = low2; i &lt;= high2; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(inorder.<span class="built_in">at</span>(i) == root)</span><br><span class="line">            &#123;</span><br><span class="line">                mid = i;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        TreeNode* rootPtr = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(root);</span><br><span class="line"></span><br><span class="line">        rootPtr-&gt;left = <span class="built_in">help</span>(preorder, low1 + <span class="number">1</span>, low1 + mid - low2,</span><br><span class="line">                            inorder, low2, mid - <span class="number">1</span>);</span><br><span class="line">        rootPtr-&gt;right = <span class="built_in">help</span>(preorder, low1 + mid - low2 +<span class="number">1</span>, high1,</span><br><span class="line">                            inorder, mid + <span class="number">1</span>, high2);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> rootPtr;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h3 id="106-从中序与后序遍历序列构造二叉树"><a href="#106-从中序与后序遍历序列构造二叉树" class="headerlink" title="106. 从中序与后序遍历序列构造二叉树"></a><a href="https://leetcode-cn.com/problems/construct-binary-tree-from-inorder-and-postorder-traversal/">106. 从中序与后序遍历序列构造二叉树</a></h3><p>    根据一棵树的中序遍历与后序遍历构造二叉树。</p>
<p>    **注意:**你可以假设树中没有重复的元素。</p>
<p>    例如，给出</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">中序遍历 inorder &#x3D; [9,3,15,20,7]</span><br><span class="line">后序遍历 postorder &#x3D; [9,15,7,20,3]</span><br></pre></td></tr></table></figure>

<p>    返回如下的二叉树：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">  3</span><br><span class="line"> &#x2F; \</span><br><span class="line">9  20</span><br><span class="line">  &#x2F;  \</span><br><span class="line"> 15   7</span><br></pre></td></tr></table></figure>

<p><strong>思路与代码</strong>：</p>
<p>    首先要知道一个结论，前序/后序+中序序列可以唯一确定一棵二叉树，所以自然而然可以用来建树。</p>
<p>    看一下中序和后序有什么特点，中序<code>[9,3,15,20,7]</code> ，后序<code>[9,15,7,20,3]</code>；</p>
<p>    有如下特征：</p>
<ol>
<li> 后序中右起第一位<code>3</code>肯定是根结点，我们可以据此找到中序中根结点的位置<code>rootin</code>；</li>
<li> 中序中根结点左边就是左子树结点，右边就是右子树结点，即<code>[左子树结点，根结点，右子树结点]</code>，我们就可以得出左子树结点个数为<code>int left = rootin - leftin;</code>；</li>
<li> 后序中结点分布应该是：<code>[左子树结点，右子树结点，根结点]</code>；</li>
<li> 根据前一步确定的左子树个数，可以确定后序中左子树结点和右子树结点的范围；</li>
<li>如果我们要前序遍历生成二叉树的话，下一层递归应该是：<ul>
<li>  左子树：<code>root-&gt;left = pre_order(中序序列，中序左子树范围，后序序列，后序左子树范围);</code>；</li>
<li>  右子树：<code>root-&gt;right = pre_order(中序序列，中序右子树范围，后序序列，后序右子树范围);</code>。</li>
</ul>
</li>
<li> 每一层递归都要返回当前根结点<code>root</code>；</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">buildTree</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; inorder, vector&lt;<span class="keyword">int</span>&gt;&amp; postorder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">help</span>(inorder, <span class="number">0</span>, inorder.<span class="built_in">size</span>() - <span class="number">1</span>,</span><br><span class="line">                    postorder, <span class="number">0</span>, postorder.<span class="built_in">size</span>() - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">TreeNode* <span class="title">help</span><span class="params">(<span class="keyword">const</span> vector&lt;<span class="keyword">int</span>&gt;&amp; inorder, <span class="keyword">int</span> low1, <span class="keyword">int</span> high1,</span></span></span><br><span class="line"><span class="function"><span class="params">                   <span class="keyword">const</span> vector&lt;<span class="keyword">int</span>&gt;&amp; postorder, <span class="keyword">int</span> low2, <span class="keyword">int</span> high2)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(low1 &gt;high1 || low2 &gt; high2)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> rootVal = postorder.<span class="built_in">at</span>(high2);</span><br><span class="line">        <span class="keyword">int</span> mid = low1;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = low1; i &lt;= high1; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(inorder.<span class="built_in">at</span>(i) == rootVal)</span><br><span class="line">            &#123;</span><br><span class="line">                mid = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        TreeNode* root = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(rootVal);</span><br><span class="line"></span><br><span class="line">        root-&gt;left = <span class="built_in">help</span>(inorder, low1, mid - <span class="number">1</span>, </span><br><span class="line">                          postorder, low2, low2 + mid - low1 - <span class="number">1</span>);</span><br><span class="line">        root-&gt;right = <span class="built_in">help</span>(inorder, mid + <span class="number">1</span>, high1,</span><br><span class="line">                           postorder, low2 + mid - low1, high2 - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="108-将有序数组转换为二叉搜索树"><a href="#108-将有序数组转换为二叉搜索树" class="headerlink" title="108. 将有序数组转换为二叉搜索树"></a><a href="https://leetcode-cn.com/problems/convert-sorted-array-to-binary-search-tree/">108. 将有序数组转换为二叉搜索树</a></h3><p>    给你一个整数数组 <code>nums</code> ，其中元素已经按 <strong>升序</strong> 排列，请你将其转换为一棵 <strong>高度平衡</strong> 二叉搜索树。</p>
<p>    <strong>高度平衡</strong> 二叉树是一棵满足「每个节点的左右两个子树的高度差的绝对值不超过 1 」的二叉树。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：nums &#x3D; [-10,-3,0,5,9]</span><br><span class="line">输出：[0,-3,9,-10,null,5]</span><br><span class="line">        0</span><br><span class="line">       &#x2F; \</span><br><span class="line">     -3   9</span><br><span class="line">    &#x2F;    &#x2F;</span><br><span class="line">  10    5</span><br><span class="line">解释：[0,-10,5,null,-3,null,9] 也将被视为正确答案：</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：nums &#x3D; [1,3]</span><br><span class="line">输出：[3,1]</span><br><span class="line">   3   1</span><br><span class="line">  &#x2F;     \</span><br><span class="line"> 1       3</span><br><span class="line">解释：[1,3] 和 [3,1] 都是高度平衡二叉搜索树。</span><br></pre></td></tr></table></figure>

<p> <strong>提示：</strong></p>
<ul>
<li>  <code>1 &lt;= nums.length &lt;= 104</code></li>
<li>  <code>-104 &lt;= nums[i] &lt;= 104</code></li>
<li>  <code>nums</code> 按 <strong>严格递增</strong> 顺序排列</li>
</ul>
<p><strong>思路与代码</strong>：</p>
<p>    数组的中间节点即为当前”root”</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">sortedArrayToBST</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">help</span>(nums, <span class="number">0</span>, nums.<span class="built_in">size</span>() - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">TreeNode* <span class="title">help</span><span class="params">(<span class="keyword">const</span> vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(low &gt; high)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> mid = (low + high + <span class="number">1</span>) / <span class="number">2</span> ;</span><br><span class="line"></span><br><span class="line">        TreeNode* root = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(nums.<span class="built_in">at</span>(mid));</span><br><span class="line"></span><br><span class="line">        root-&gt;left = <span class="built_in">help</span>(nums, low, mid - <span class="number">1</span>);</span><br><span class="line">        root-&gt;right = <span class="built_in">help</span>(nums, mid + <span class="number">1</span>, high);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h3 id="109-有序链表转换二叉搜索树"><a href="#109-有序链表转换二叉搜索树" class="headerlink" title="109. 有序链表转换二叉搜索树"></a><a href="https://leetcode-cn.com/problems/convert-sorted-list-to-binary-search-tree/">109. 有序链表转换二叉搜索树</a></h3><p>    给定一个单链表，其中的元素按升序排序，将其转换为高度平衡的二叉搜索树。</p>
<p>    本题中，一个高度平衡二叉树是指一个二叉树<em>每个节点</em> 的左右两个子树的高度差的绝对值不超过 1。</p>
<p><strong>示例:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">给定的有序链表： [-10, -3, 0, 5, 9],</span><br><span class="line"></span><br><span class="line">一个可能的答案是：[0, -3, 9, -10, null, 5], 它可以表示下面这个高度平衡二叉搜索树：</span><br><span class="line"></span><br><span class="line">      0</span><br><span class="line">     &#x2F; \</span><br><span class="line">   -3   9</span><br><span class="line">   &#x2F;   &#x2F;</span><br><span class="line"> -10  5</span><br></pre></td></tr></table></figure>

<p><strong>思路与代码</strong>：</p>
<p>    还是找中间节点</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">sortedListToBST</span><span class="params">(ListNode* head)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">       </span><br><span class="line">        <span class="keyword">if</span>(!head)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(head-&gt;next == <span class="literal">nullptr</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">TreeNode</span>(head-&gt;val);</span><br><span class="line">    </span><br><span class="line">        <span class="comment">//双指针，找中点</span></span><br><span class="line">        ListNode* pre = head;</span><br><span class="line">        ListNode* p = head-&gt;next;</span><br><span class="line">        ListNode* q = p-&gt;next;        </span><br><span class="line">        <span class="keyword">while</span>(q != <span class="literal">nullptr</span> &amp;&amp; q-&gt;next != <span class="literal">nullptr</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            pre = pre-&gt;next;</span><br><span class="line">            p = pre-&gt;next;</span><br><span class="line">            q = q-&gt;next-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        pre-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">        TreeNode* root = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(p-&gt;val); </span><br><span class="line">        root-&gt;left = <span class="built_in">sortedListToBST</span>(head);</span><br><span class="line">        root-&gt;right = <span class="built_in">sortedListToBST</span>(p-&gt;next);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h3 id="654-最大二叉树"><a href="#654-最大二叉树" class="headerlink" title="654. 最大二叉树"></a><a href="https://leetcode-cn.com/problems/maximum-binary-tree/">654. 最大二叉树</a></h3><p>    给定一个不含重复元素的整数数组 <code>nums</code> 。一个以此数组直接递归构建的 <strong>最大二叉树</strong> 定义如下：</p>
<ol>
<li> 二叉树的根是数组 <code>nums</code> 中的最大元素。</li>
<li> 左子树是通过数组中 <strong>最大值左边部分</strong> 递归构造出的最大二叉树。</li>
<li> 右子树是通过数组中 <strong>最大值右边部分</strong> 递归构造出的最大二叉树。</li>
</ol>
<p>返回有给定数组 <code>nums</code> 构建的 <strong>最大二叉树</strong> 。 </p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：nums &#x3D; [3,2,1,6,0,5]</span><br><span class="line">输出：[6,3,5,null,2,0,null,null,1]</span><br><span class="line">            6</span><br><span class="line">          &#x2F;   \</span><br><span class="line">        3       5</span><br><span class="line">         \    &#x2F;</span><br><span class="line">          2  0</span><br><span class="line">           \</span><br><span class="line">            1</span><br><span class="line">解释：递归调用如下所示：</span><br><span class="line">- [3,2,1,6,0,5] 中的最大值是 6 ，左边部分是 [3,2,1] ，右边部分是 [0,5] 。</span><br><span class="line">    - [3,2,1] 中的最大值是 3 ，左边部分是 [] ，右边部分是 [2,1] 。</span><br><span class="line">        - 空数组，无子节点。</span><br><span class="line">        - [2,1] 中的最大值是 2 ，左边部分是 [] ，右边部分是 [1] 。</span><br><span class="line">            - 空数组，无子节点。</span><br><span class="line">            - 只有一个元素，所以子节点是一个值为 1 的节点。</span><br><span class="line">    - [0,5] 中的最大值是 5 ，左边部分是 [0] ，右边部分是 [] 。</span><br><span class="line">        - 只有一个元素，所以子节点是一个值为 0 的节点。</span><br><span class="line">        - 空数组，无子节点。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：nums &#x3D; [3,2,1]</span><br><span class="line">输出：[3,null,2,null,1]</span><br><span class="line">    3</span><br><span class="line">     \</span><br><span class="line">      2</span><br><span class="line">       \</span><br><span class="line">        1 </span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li>  <code>1 &lt;= nums.length &lt;= 1000</code></li>
<li>  <code>0 &lt;= nums[i] &lt;= 1000</code></li>
<li>  <code>nums</code> 中的所有整数 <strong>互不相同</strong></li>
</ul>
<p>代码</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">constructMaximumBinaryTree</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="built_in">build</span>(nums, <span class="number">0</span>, nums.<span class="built_in">size</span>() - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">TreeNode* <span class="title">build</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(low &gt; high)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">-1</span>, MAX = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = low; i &lt;= high; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(nums.<span class="built_in">at</span>(i) &gt;= MAX)</span><br><span class="line">            &#123;</span><br><span class="line">                MAX = nums.<span class="built_in">at</span>(i);</span><br><span class="line">                index = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        TreeNode* root = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(MAX);</span><br><span class="line">        <span class="comment">//TreeNode* root = &amp;rootNode;</span></span><br><span class="line"></span><br><span class="line">        root-&gt;left = <span class="built_in">build</span>(nums, low, index<span class="number">-1</span>);</span><br><span class="line">        root-&gt;right = <span class="built_in">build</span>(nums, index+<span class="number">1</span>, high);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><a href="https://mp.weixin.qq.com/s?__biz=MzAxODQxMDM0Mw==&mid=2247487270&idx=1&sn=2f7ad74aabc88b53d94012ceccbe51be&chksm=9bd7f12eaca078384733168971147866c140496cb257946f8170f05e46d16099f3eef98d39d9&scene=21#wechat_redirect">东哥手把手帮你刷通二叉树|第二期 (qq.com)</a></p>
]]></content>
      <categories>
        <category>算法</category>
        <category>二叉树</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>二叉树</tag>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode中的Shell习题</title>
    <url>/2021/05/06/Shell%EF%BC%9ALeetcode%E7%9A%84Shell%E4%B9%A0%E9%A2%98/</url>
    <content><![CDATA[<p>&ensp;&ensp;&ensp;&ensp;leetcode中的四道shell题</p>
<span id="more"></span>

<h4 id="192-统计词频"><a href="#192-统计词频" class="headerlink" title="192. 统计词频"></a><a href="https://leetcode-cn.com/problems/word-frequency/">192. 统计词频</a></h4><p>&ensp;&ensp;&ensp;&ensp;写一个 bash 脚本以统计一个文本文件 <code>words.txt</code> 中每个单词出现的频率。</p>
<p>&ensp;&ensp;&ensp;&ensp;为了简单起见，你可以假设：</p>
<ul>
<li><code>words.txt</code>只包括小写字母和 <code>&#39; &#39;</code> 。</li>
<li>每个单词只由小写字母组成。</li>
<li>单词间由一个或多个空格字符分隔。</li>
</ul>
<p><strong>示例:</strong></p>
<p>&ensp;&ensp;&ensp;&ensp;假设 <code>words.txt</code> 内容如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">the day is sunny the the</span><br><span class="line">the sunny is is</span><br></pre></td></tr></table></figure>

<p>&ensp;&ensp;&ensp;&ensp;你的脚本应当输出（以词频降序排列）：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">the 4</span><br><span class="line">is 3</span><br><span class="line">sunny 2</span><br><span class="line">day 1</span><br></pre></td></tr></table></figure>

<p><strong>说明:</strong></p>
<ul>
<li>不要担心词频相同的单词的排序问题，每个单词出现的频率都是唯一的。</li>
<li>你可以使用一行 Unix pipes实现吗？</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> Read from the file words.txt and output the word frequency list to stdout.</span></span><br><span class="line">cat words.txt |tr -s &#x27; &#x27; &#x27;\n&#x27; |sort|uniq -c|sort -r|awk &#x27;&#123;print $2,$1&#125;&#x27;</span><br></pre></td></tr></table></figure>

<p>&ensp;&ensp;&ensp;&ensp;1、首先cat命令查看words.txt<br>&ensp;&ensp;&ensp;&ensp;2、tr -s ‘ ‘ ‘\n’将空格都替换为换行 实现分词<br>&ensp;&ensp;&ensp;&ensp;3、sort排序 将分好的词按照顺序排序<br>&ensp;&ensp;&ensp;&ensp;4、uniq -c 统计重复次数（此步骤与上一步息息相关，-c原理是字符串相同则加一，如果不进行先排序的话将无法统计数目）<br>&ensp;&ensp;&ensp;&ensp;5、sort -r 将数目倒序排列<br>&ensp;&ensp;&ensp;&ensp;6、awk ‘{print $2,$1}’ 将词频和词语调换位置打印出来</p>
<h4 id="193-有效电话号码"><a href="#193-有效电话号码" class="headerlink" title="193. 有效电话号码"></a><a href="https://leetcode-cn.com/problems/valid-phone-numbers/">193. 有效电话号码</a></h4><p>&ensp;&ensp;&ensp;&ensp;给定一个包含电话号码列表（一行一个电话号码）的文本文件 <code>file.txt</code>，写一个单行 bash 脚本输出所有有效的电话号码。</p>
<p>&ensp;&ensp;&ensp;&ensp;你可以假设一个有效的电话号码必须满足以下两种格式： (xxx) xxx-xxxx 或 xxx-xxx-xxxx。（x 表示一个数字）</p>
<p>&ensp;&ensp;&ensp;&ensp;你也可以假设每行前后没有多余的空格字符。 </p>
<p><strong>示例：</strong></p>
<p>&ensp;&ensp;&ensp;&ensp;假设 <code>file.txt</code> 内容如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">987-123-4567</span><br><span class="line">123 456 7890</span><br><span class="line">(123) 456-7890</span><br></pre></td></tr></table></figure>

<p>&ensp;&ensp;&ensp;&ensp;你的脚本应当输出下列有效的电话号码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">987-123-4567</span><br><span class="line">(123) 456-7890</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">三种方法：</span><br><span class="line">grep -P <span class="string">&#x27;^(\d&#123;3&#125;-|\(\d&#123;3&#125;\) )\d&#123;3&#125;-\d&#123;4&#125;$&#x27;</span> file.txt</span><br><span class="line">sed -n -r <span class="string">&#x27;/^([0-9]&#123;3&#125;-|\([0-9]&#123;3&#125;\) )[0-9]&#123;3&#125;-[0-9]&#123;4&#125;$/p&#x27;</span> file.txt</span><br><span class="line">awk <span class="string">&#x27;/^([0-9]&#123;3&#125;-|\([0-9]&#123;3&#125;\) )[0-9]&#123;3&#125;-([0-9]&#123;4&#125;)$/&#x27;</span> file.txt</span><br></pre></td></tr></table></figure>

<h4 id="194-转置文件"><a href="#194-转置文件" class="headerlink" title="194. 转置文件"></a><a href="https://leetcode-cn.com/problems/transpose-file/">194. 转置文件</a></h4><p>&ensp;&ensp;&ensp;&ensp;给定一个文件 <code>file.txt</code>，转置它的内容。</p>
<p>&ensp;&ensp;&ensp;&ensp;你可以假设每行列数相同，并且每个字段由 <code>&#39; &#39;</code> 分隔。</p>
<p> <strong>示例：</strong></p>
<p>&ensp;&ensp;&ensp;&ensp;假设 <code>file.txt</code> 文件内容如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">name age</span><br><span class="line">alice 21</span><br><span class="line">ryan 30</span><br></pre></td></tr></table></figure>

<p>&ensp;&ensp;&ensp;&ensp;应当输出：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">name alice ryan</span><br><span class="line">age 21 30</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">awk <span class="string">&#x27;&#123; #这个大括号里的代码是 对正文的处理</span></span><br><span class="line"><span class="string">    # NF表示列数，NR表示已读的行数</span></span><br><span class="line"><span class="string">    # 注意for中的i从1开始，i前没有类型</span></span><br><span class="line"><span class="string">    for (i=1; i&lt;=NF; i++)&#123;#对每一列</span></span><br><span class="line"><span class="string">        if(NR==1)&#123;       #如果是第一行</span></span><br><span class="line"><span class="string">            #将第i列的值存入res[i],$i表示第i列的值，i为数组的下标，以列序号为下标，</span></span><br><span class="line"><span class="string">            #数组不用定义可以直接使用</span></span><br><span class="line"><span class="string">            res[i]=$i;   </span></span><br><span class="line"><span class="string">        &#125;</span></span><br><span class="line"><span class="string">        else&#123;</span></span><br><span class="line"><span class="string">            #不是第一行时，将该行对应i列的值拼接到res[i]</span></span><br><span class="line"><span class="string">            res[i]=res[i] &quot; &quot; $i</span></span><br><span class="line"><span class="string">        &#125;</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string"># BEGIN&#123;&#125; 文件进行扫描前要执行的操作；END&#123;&#125; 文件扫描结束后要执行的操作。</span></span><br><span class="line"><span class="string">END&#123;</span></span><br><span class="line"><span class="string">    #输出数组</span></span><br><span class="line"><span class="string">	for (i=1; i&lt;=NF; i++)&#123;</span></span><br><span class="line"><span class="string">		print res[i]</span></span><br><span class="line"><span class="string">	&#125;</span></span><br><span class="line"><span class="string">&#125;&#x27;</span> file.txt</span><br></pre></td></tr></table></figure>

<h4 id="195-第十行"><a href="#195-第十行" class="headerlink" title="195. 第十行"></a><a href="https://leetcode-cn.com/problems/tenth-line/">195. 第十行</a></h4><p>&ensp;&ensp;&ensp;&ensp;给定一个文本文件 <code>file.txt</code>，请只打印这个文件中的第十行。</p>
<p><strong>示例:</strong></p>
<p>&ensp;&ensp;&ensp;&ensp;假设 <code>file.txt</code> 有如下内容：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Line 1</span><br><span class="line">Line 2</span><br><span class="line">Line 3</span><br><span class="line">Line 4</span><br><span class="line">Line 5</span><br><span class="line">Line 6</span><br><span class="line">Line 7</span><br><span class="line">Line 8</span><br><span class="line">Line 9</span><br><span class="line">Line 10</span><br></pre></td></tr></table></figure>

<p>&ensp;&ensp;&ensp;&ensp;你的脚本应当显示第十行：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Line 10</span><br></pre></td></tr></table></figure>

<p><strong>说明:</strong></p>
<ol>
<li>如果文件少于十行，你应当输出什么？</li>
<li>至少有三种不同的解法，请尝试尽可能多的方法来解题</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">grep -n <span class="string">&quot;&quot;</span> file.txt | grep -w <span class="string">&#x27;10&#x27;</span> | cut -d: -f2</span><br><span class="line">sed -n <span class="string">&#x27;10p&#x27;</span> file.txt</span><br><span class="line">awk <span class="string">&#x27;&#123;if(NR==10)&#123;print $0&#125;&#125;&#x27;</span> file.txt</span><br></pre></td></tr></table></figure>

<p><a href="https://mp.weixin.qq.com/s/EI63RZZcPzJT4c0zl8XQSA">LeetCode上稀缺的四道shell编程题解析</a></p>
]]></content>
      <categories>
        <category>shell</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>shell</tag>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>二叉树中路径和相关习题</title>
    <url>/2021/05/05/%E4%BA%8C%E5%8F%89%E6%A0%91%EF%BC%9A%E8%B7%AF%E5%BE%84%E5%92%8C%E7%9B%B8%E5%85%B3/</url>
    <content><![CDATA[<p>&ensp;&ensp;&ensp;&ensp;本文有四道二叉树路径和相关的题目，前两道给出了详解。求路径和相关，说到底还是遍历问题，只不过有全局变量或者参数做记录。</p>
<span id="more"></span>

<h2 id="二叉树的最大路径和"><a href="#二叉树的最大路径和" class="headerlink" title="二叉树的最大路径和"></a><strong>二叉树的最大路径和</strong></h2><h3 id="一、题目"><a href="#一、题目" class="headerlink" title="一、题目"></a>一、题目</h3><p>&ensp;&ensp;&ensp;&ensp;<strong>路径</strong>被定义为一条从树中任意节点出发，沿父节点-子节点连接，达到任意节点的序列。同一个节点在一条路径序列中 <strong>至多出现一次</strong> 。该路径 <strong>至少包含一个</strong> 节点，且不一定经过根节点。</p>
<!-- more -->

<p>&ensp;&ensp;&ensp;&ensp;<strong>路径和</strong> 是路径中各节点值的总和。</p>
<p>&ensp;&ensp;&ensp;&ensp;给你一个二叉树的根节点 <code>root</code> ，返回其 <strong>最大路径和</strong> 。 </p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">   1</span><br><span class="line">  &#x2F; \</span><br><span class="line"> 2   3</span><br><span class="line">输入：root &#x3D; [1,2,3]</span><br><span class="line">输出：6</span><br><span class="line">解释：最优路径是 2 -&gt; 1 -&gt; 3 ，路径和为 2 + 1 + 3 &#x3D; 6</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">       -10</span><br><span class="line">      &#x2F;   \</span><br><span class="line">     9     20</span><br><span class="line">          &#x2F;  \</span><br><span class="line">         15   7</span><br><span class="line">输入：root &#x3D; [-10,9,20,null,null,15,7]</span><br><span class="line">输出：42</span><br><span class="line">解释：最优路径是 15 -&gt; 20 -&gt; 7 ，路径和为 15 + 20 + 7 &#x3D; 42</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li>树中节点数目范围是 <code>[1, 3 * 104]</code></li>
<li><code>-1000 &lt;= Node.val &lt;= 1000</code></li>
</ul>
<h3 id="二、思路与代码"><a href="#二、思路与代码" class="headerlink" title="二、思路与代码"></a>二、思路与代码</h3><p>&ensp;&ensp;&ensp;&ensp;对于一个结点，需要向上层节点提供“最大路径和“：即目标最大路径和上的每个节点，它的下层节点是最优的。有三种情况：只有当其那节点值（root-&gt;val）、当前节点值加最大左子树节点和（max(0, help(root-&gt;left))）、当前节点值加最大右子树节点和（max(0, help(root-&gt;right))）。</p>
<p>&ensp;&ensp;&ensp;&ensp;最大左子树节点和不能小于0，可以返回0，最大右子树节点和也是如此。</p>
<p>&ensp;&ensp;&ensp;&ensp;对父节点而言的三种选择，最大收益取最大值：root-&gt;val + max(help(root-&gt;left), help(root-&gt;right))。（获取左右后才判定最大收益，故采用后序遍历）</p>
<p>&ensp;&ensp;&ensp;&ensp;遍历每一个节点过程中，使用全局变量记录最大路径和。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> ans = INT_MIN;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxPathSum</span><span class="params">(TreeNode* root)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">help</span>(root);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">help</span><span class="params">(TreeNode* root)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">//节点为空，返回 0</span></span><br><span class="line">        <span class="keyword">if</span> (!root)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//获取当前节点的最大左子树路径和和最大右子树路径和</span></span><br><span class="line">        <span class="keyword">int</span> left = <span class="built_in">max</span>(<span class="number">0</span>, <span class="built_in">help</span>(root-&gt;left));</span><br><span class="line">        <span class="keyword">int</span> right = <span class="built_in">max</span>(<span class="number">0</span>, <span class="built_in">help</span>(root-&gt;right));</span><br><span class="line">        <span class="comment">//更新全局变量</span></span><br><span class="line">        ans = <span class="built_in">max</span>(ans, left + right + root-&gt;val);</span><br><span class="line">        <span class="comment">//返回当前节点的最优情况</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(left, right) + root-&gt;val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><a href="https://blog.csdn.net/m0_53157173/article/details/116399871">参考</a></p>
<h2 id="路径总和III"><a href="#路径总和III" class="headerlink" title="路径总和III"></a><strong>路径总和III</strong></h2><h3 id="一、题目-1"><a href="#一、题目-1" class="headerlink" title="一、题目"></a>一、题目</h3><p>&ensp;&ensp;&ensp;&ensp;给定一个二叉树，它的每个结点都存放着一个整数值。找出路径和等于给定数值的路径总数。路径不需要从根节点开始，也不需要在叶子节点结束，但是路径方向必须是向下的（只能从父节点到子节点）。</p>
<!-- more -->

<p>&ensp;&ensp;&ensp;&ensp;二叉树不超过1000个节点，且节点数值范围是 [-1000000,1000000] 的整数。</p>
<p><strong>示例：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">root &#x3D; [10,5,-3,3,2,null,11,3,-2,null,1], sum &#x3D; 8</span><br><span class="line"></span><br><span class="line">      10</span><br><span class="line">     &#x2F;  \</span><br><span class="line">    5   -3</span><br><span class="line">   &#x2F; \    \</span><br><span class="line">  3   2   11</span><br><span class="line"> &#x2F; \   \</span><br><span class="line">3  -2   1</span><br><span class="line"></span><br><span class="line">返回 3。和等于 8 的路径有:</span><br><span class="line"></span><br><span class="line">1.  5 -&gt; 3</span><br><span class="line">2.  5 -&gt; 2 -&gt; 1</span><br><span class="line">3.  -3 -&gt; 11</span><br></pre></td></tr></table></figure>

<h3 id="二、思路与代码-1"><a href="#二、思路与代码-1" class="headerlink" title="二、思路与代码"></a>二、思路与代码</h3><p>&ensp;&ensp;&ensp;&ensp;遍历每个节点，对各个节点，获取每个其不同路径和（再进行一次前序遍历），注意初始值为0。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">pathSum</span><span class="params">(TreeNode* root, <span class="keyword">int</span> targetSum)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!root)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">traver</span>(root, targetSum);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">traver</span><span class="params">(TreeNode* root, <span class="keyword">const</span> <span class="keyword">int</span> targetSum)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!root)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">traver</span>(root, targetSum, <span class="number">0</span>);</span><br><span class="line">        <span class="built_in">traver</span>(root-&gt;left, targetSum);</span><br><span class="line">        <span class="built_in">traver</span>(root-&gt;right, targetSum);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">traver</span><span class="params">(TreeNode* root, <span class="keyword">const</span> <span class="keyword">int</span> targetSum, <span class="keyword">int</span> cur)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!root)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (root-&gt;val + cur == targetSum)</span><br><span class="line">        &#123;</span><br><span class="line">            ans++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">traver</span>(root-&gt;left, targetSum, cur + root-&gt;val);</span><br><span class="line">        <span class="built_in">traver</span>(root-&gt;right, targetSum, cur + root-&gt;val);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h2 id="路径总和"><a href="#路径总和" class="headerlink" title="路径总和"></a>路径总和</h2><p>&ensp;&ensp;&ensp;&ensp;给你二叉树的根节点 <code>root</code> 和一个表示目标和的整数 <code>targetSum</code> ，判断该树中是否存在 <strong>根节点到叶子节点</strong> 的路径，这条路径上所有节点值相加等于目标和 <code>targetSum</code> 。</p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>叶子节点</strong> 是指没有子节点的节点。</p>
<p> <strong>示例 1：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">                  5</span><br><span class="line">                &#x2F;   \</span><br><span class="line">               4     8</span><br><span class="line">              &#x2F;     &#x2F; \</span><br><span class="line">            11     13  4</span><br><span class="line">           &#x2F;  \         \</span><br><span class="line">          7    2          1</span><br><span class="line">输入：root &#x3D; [5,4,8,11,null,13,4,7,2,null,null,null,1], targetSum &#x3D; 22</span><br><span class="line">输出：true</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">   1</span><br><span class="line">  &#x2F; \</span><br><span class="line"> 2   3</span><br><span class="line">输入：root &#x3D; [1,2,3], targetSum &#x3D; 5</span><br><span class="line">输出：false</span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：root &#x3D; [1,2], targetSum &#x3D; 0</span><br><span class="line">输出：false</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li>  树中节点的数目在范围 <code>[0, 5000]</code> 内</li>
<li>  <code>-1000 &lt;= Node.val &lt;= 1000</code></li>
<li>  <code>-1000 &lt;= targetSum &lt;= 1000</code></li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">hasPathSum</span><span class="params">(TreeNode* root, <span class="keyword">int</span> targetSum)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!root)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (root-&gt;val == targetSum &amp;&amp; !root-&gt;left &amp;&amp; !root-&gt;right)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">hasPathSum</span>(root-&gt;left, targetSum - root-&gt;val) || <span class="built_in">hasPathSum</span>(root-&gt;right, targetSum - root-&gt;val );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h2 id="路径总和-II"><a href="#路径总和-II" class="headerlink" title="路径总和 II"></a>路径总和 II</h2><p>&ensp;&ensp;&ensp;&ensp;给你二叉树的根节点 <code>root</code> 和一个整数目标和 <code>targetSum</code> ，找出所有 <strong>从根节点到叶子节点</strong> 路径总和等于给定目标和的路径。</p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>叶子节点</strong> 是指没有子节点的节点。</p>
<p> <strong>示例 1：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">                  5</span><br><span class="line">                &#x2F;   \</span><br><span class="line">               4     8</span><br><span class="line">              &#x2F;     &#x2F; \</span><br><span class="line">            11     13  4</span><br><span class="line">           &#x2F;  \         \</span><br><span class="line">          7    2          1</span><br><span class="line">输入：root &#x3D; [5,4,8,11,null,13,4,7,2,null,null,5,1], targetSum &#x3D; 22</span><br><span class="line">输出：[[5,4,11,2],[5,8,4,5]]</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">   1</span><br><span class="line">  &#x2F; \</span><br><span class="line"> 2   3</span><br><span class="line">输入：root &#x3D; [1,2,3], targetSum &#x3D; 5</span><br><span class="line">输出：[]</span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：root &#x3D; [1,2], targetSum &#x3D; 0</span><br><span class="line">输出：[]</span><br></pre></td></tr></table></figure>

<p> <strong>提示：</strong></p>
<ul>
<li>  树中节点总数在范围 <code>[0, 5000]</code> 内</li>
<li>  <code>-1000 &lt;= Node.val &lt;= 1000</code></li>
<li>  <code>-1000 &lt;= targetSum &lt;= 1000</code></li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; ans;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; temp;</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">pathSum</span>(TreeNode* root, <span class="keyword">int</span> targetSum) </span><br><span class="line">    &#123;        </span><br><span class="line">        <span class="built_in">help</span>(root, targetSum);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">help</span> <span class="params">(TreeNode* root, <span class="keyword">int</span> targetSum)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!root)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        temp.<span class="built_in">push_back</span>(root-&gt;val);</span><br><span class="line">        <span class="keyword">if</span> (root-&gt;val == targetSum &amp;&amp; !root-&gt;left &amp;&amp; !root-&gt;right)</span><br><span class="line">        &#123;</span><br><span class="line">            ans.<span class="built_in">push_back</span>(temp);</span><br><span class="line">        &#125;        </span><br><span class="line">        <span class="built_in">help</span>(root-&gt;left, targetSum - root-&gt;val);</span><br><span class="line">        <span class="built_in">help</span>(root-&gt;right, targetSum - root-&gt;val);</span><br><span class="line">        temp.<span class="built_in">pop_back</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法</category>
        <category>二叉树</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>二叉树</tag>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>前缀和数组与差分数组</title>
    <url>/2021/04/23/%E6%95%B0%E7%BB%84%EF%BC%9A%E5%89%8D%E7%BC%80%E5%92%8C%E6%95%B0%E7%BB%84%E4%B8%8E%E5%B7%AE%E5%88%86%E6%95%B0%E7%BB%84/</url>
    <content><![CDATA[<p>&ensp;&ensp;&ensp;&ensp;当我们需要频繁地查询数组某个区间的累加和或频繁地对数组的某个区间的元素进行增减，便需要用到前缀和数组以及差分数组来提高效率</p>
<span id="more"></span>

<h3 id="一、概念简介"><a href="#一、概念简介" class="headerlink" title="一、概念简介"></a>一、概念简介</h3><p>&ensp;&ensp;&ensp;&ensp;<strong>前缀和数组</strong>：对于一个给定的数组 <code>nums</code>，额外开辟一个前缀和数组进行预处理：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">preSum</span><span class="params">(nums.size() + <span class="number">1</span>)</span></span>;</span><br><span class="line">preSum[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i++)</span><br><span class="line">&#123;</span><br><span class="line">    preSum[i + <span class="number">1</span>] = preSum[i] + nums[i];</span><br><span class="line">&#125;    </span><br></pre></td></tr></table></figure>

<p>&ensp;&ensp;&ensp;&ensp;前缀和数组 <code>preSum</code> 的含义很好理解，<code>preSum[i]</code> 就是 <code>nums[0..i-1]</code> 的和。那么如果我们想求 <code>nums[i...j]</code> 的和，只需要一步操作 <code>preSum[j+1] - preSum[i]</code> 即可，而不需要重新去遍历数组了。</p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>前缀和主要适用的场景是原始数组不会被修改的情况下，频繁查询某个区间的累加和</strong>。</p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>差分数组</strong>：对于一个给定的数组<code>nums</code>，额外开辟一个差分数组进行预处理：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">diff</span><span class="params">(nums.size())</span></span>;</span><br><span class="line">diff[<span class="number">0</span>] = diff[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; nums.<span class="built_in">size</span>(); ++i)</span><br><span class="line">&#123;</span><br><span class="line">    diff[i] = nums[i] - nums[i - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&ensp;&ensp;&ensp;&ensp;通过这个<code>diff</code>差分数组是可以反推出原始数组<code>nums</code>的，代码逻辑如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">nums</span><span class="params">(diff.size())</span></span>;</span><br><span class="line"><span class="comment">// 根据差分数组构造结果数组</span></span><br><span class="line">nums[<span class="number">0</span>] = diff[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; diff.<span class="built_in">size</span>(); ++i) </span><br><span class="line">&#123;</span><br><span class="line">    nums[i] = nums[i - <span class="number">1</span>] + diff[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&ensp;&ensp;&ensp;&ensp;这样构造差分数组<code>diff</code>，就可以快速进行区间增减的操作，如果你想对区间<code>nums[i..j]</code>的元素全部加 3，那么只需要让<code>diff[i] += 3</code>，然后再让<code>diff[j+1] -= 3</code>即可。</p>
<p>&ensp;&ensp;&ensp;&ensp;<code>diff[i] += 3</code>意味着给<code>nums[i..]</code>所有的元素都加了 3，然后<code>diff[j+1] -= 3</code>又意味着对于<code>nums[j+1..]</code>所有元素再减 3，那综合起来，就是对<code>nums[i..j]</code>中的所有元素都加 3 了。</p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>差分数组的主要适用场景是频繁对原始数组的某个区间的元素进行增减</strong>。</p>
<h3 id="二、举个例子"><a href="#二、举个例子" class="headerlink" title="二、举个例子"></a>二、举个例子</h3><p><a href="https://leetcode-cn.com/problems/subarray-sum-equals-k/">560. 和为K的子数组</a></p>
<p>&ensp;&ensp;&ensp;&ensp;给定一个整数数组和一个整数 <strong>k，</strong>你需要找到该数组中和为 <strong>k</strong> 的连续的子数组的个数。</p>
<p><strong>示例 1 :</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入:nums &#x3D; [1,1,1], k &#x3D; 2</span><br><span class="line">输出: 2 , [1,1] 与 [1,1] 为两种不同的情况。</span><br></pre></td></tr></table></figure>

<p><strong>说明 :</strong></p>
<ol>
<li> 数组的长度为 [1, 20,000]。</li>
<li> 数组中元素的范围是 [-1000, 1000] ，且整数 <strong>k</strong> 的范围是 [-1e7, 1e7]。</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">subarraySum</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt; nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">  <span class="comment">// 构造前缀和</span></span><br><span class="line">  <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">sum</span><span class="params">(n + <span class="number">1</span>)</span></span>;</span><br><span class="line">  sum[<span class="number">0</span>] = <span class="number">0</span>; </span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    sum[i + <span class="number">1</span>] = sum[i] + nums[i];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">  <span class="comment">// 穷举所有子数组</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">  &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; j++)</span><br><span class="line">      &#123;</span><br><span class="line">          <span class="comment">// sum of nums[j..i-1]</span></span><br><span class="line">          <span class="keyword">if</span> (sum[i] - sum[j] == k)</span><br><span class="line">          &#123;</span><br><span class="line">               ans++;</span><br><span class="line">          &#125;             </span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">    </span><br><span class="line">  <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&ensp;&ensp;&ensp;&ensp;前缀和进阶，与 unordered_map 结合。</p>
<p>&ensp;&ensp;&ensp;&ensp;前面的解法有嵌套的 for 循环：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line"> &#123;</span><br><span class="line">     <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; j++)</span><br><span class="line">     &#123;</span><br><span class="line">         <span class="comment">// sum of nums[j..i-1]</span></span><br><span class="line">         <span class="keyword">if</span> (sum[i] - sum[j] == k)</span><br><span class="line">         &#123;</span><br><span class="line">              ans++;</span><br><span class="line">         &#125;             </span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>&ensp;&ensp;&ensp;&ensp;第二层 for 循环在计算有几个<code>j</code>能够使得<code>sum[i]</code>和<code>sum[j]</code>的差为 k。毎找到一个这样的<code>j</code>，就把结果加一。</p>
<p>&ensp;&ensp;&ensp;&ensp;我们可以把 if 语句里的条件判断移项，这样写：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if (sum[j] &#x3D;&#x3D; sum[i] - k)</span><br><span class="line">    ans++;</span><br></pre></td></tr></table></figure>

<p>&ensp;&ensp;&ensp;&ensp;优化的思路是：<strong>我直接记录下有几个<code>sum[j]</code>和<code>sum[i]-k</code>相等，直接更新结果，就避免了内层的 for 循环</strong>。我们可以用哈希表，在记录前缀和的同时记录该前缀和出现的次数。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">subarraySum</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        unordered_map&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; mp;</span><br><span class="line">        mp[<span class="number">0</span>] = <span class="number">1</span>;			<span class="comment">//前缀和为 0 的子数组个数为 1</span></span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> pre = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; x : nums)</span><br><span class="line">        &#123;</span><br><span class="line">            pre += x;	<span class="comment">//前缀和，直接采用一个变量</span></span><br><span class="line">            <span class="keyword">if</span> (mp.<span class="built_in">find</span>(pre - k) != mp.<span class="built_in">end</span>()) <span class="comment">//pre - k 是目标区间前面数组元素的前缀和</span></span><br><span class="line">            &#123;</span><br><span class="line">                count += mp[pre - k];</span><br><span class="line">            &#125;</span><br><span class="line">            ++mp[pre];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="1109-航班预订统计"><a href="#1109-航班预订统计" class="headerlink" title="1109. 航班预订统计"></a><a href="https://leetcode-cn.com/problems/corporate-flight-bookings/">1109. 航班预订统计</a></h4><p>&ensp;&ensp;&ensp;&ensp;这里有 <code>n</code> 个航班，它们分别从 <code>1</code> 到 <code>n</code> 进行编号。</p>
<p>&ensp;&ensp;&ensp;&ensp;有一份航班预订表 <code>bookings</code> ，表中第 <code>i</code> 条预订记录 <code>bookings[i] = [firsti, lasti, seatsi]</code> 意味着在从 <code>firsti</code> 到 <code>lasti</code> （<strong>包含</strong> <code>firsti</code> 和 <code>lasti</code> ）的 <strong>每个航班</strong> 上预订了 <code>seatsi</code> 个座位。</p>
<p>&ensp;&ensp;&ensp;&ensp;请你返回一个长度为 <code>n</code> 的数组 <code>answer</code>，其中 <code>answer[i]</code> 是航班 <code>i</code> 上预订的座位总数。</p>
<p> <strong>示例 1：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：bookings &#x3D; [[1,2,10],[2,3,20],[2,5,25]], n &#x3D; 5</span><br><span class="line">输出：[10,55,45,25,25]</span><br><span class="line">解释：</span><br><span class="line">航班编号        1   2   3   4   5</span><br><span class="line">预订记录 1 ：   10  10</span><br><span class="line">预订记录 2 ：       20  20</span><br><span class="line">预订记录 3 ：       25  25  25  25</span><br><span class="line">总座位数：      10  55  45  25  25</span><br><span class="line">因此，answer &#x3D; [10,55,45,25,25]</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：bookings &#x3D; [[1,2,10],[2,2,15]], n &#x3D; 2</span><br><span class="line">输出：[10,25]</span><br><span class="line">解释：</span><br><span class="line">航班编号        1   2</span><br><span class="line">预订记录 1 ：   10  10</span><br><span class="line">预订记录 2 ：       15</span><br><span class="line">总座位数：      10  25</span><br><span class="line">因此，answer &#x3D; [10,25]</span><br></pre></td></tr></table></figure>

<p> <strong>提示：</strong></p>
<ul>
<li>  <code>1 &lt;= n &lt;= 2 * 104</code></li>
<li>  <code>1 &lt;= bookings.length &lt;= 2 * 104</code></li>
<li>  <code>bookings[i].length == 3</code></li>
<li>  <code>1 &lt;= firsti &lt;= lasti &lt;= n</code></li>
<li>  <code>1 &lt;= seatsi &lt;= 104</code></li>
</ul>
<p>&ensp;&ensp;&ensp;&ensp;直接上差分数组：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">corpFlightBookings</span><span class="params">(vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; bookings, <span class="keyword">int</span> n)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">res</span><span class="params">(n,<span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">diff</span><span class="params">(n+<span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; bookings.<span class="built_in">size</span>(); ++k)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> i = bookings[k][<span class="number">0</span>] - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">int</span> j = bookings[k][<span class="number">1</span>] - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">int</span> seat = bookings[k][<span class="number">2</span>];</span><br><span class="line">            diff[i] = diff[i] + seat;</span><br><span class="line">            diff[j+<span class="number">1</span>] = diff[j+<span class="number">1</span>] - seat;</span><br><span class="line">        &#125;</span><br><span class="line">        res[<span class="number">0</span>] = diff[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">1</span>; k &lt; n; k++)</span><br><span class="line">        &#123;</span><br><span class="line">            res[k] = res[k<span class="number">-1</span>] + diff[k];</span><br><span class="line">        &#125;          </span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>[参考：论那些小而美的算法技巧：差分数组/前缀和](<a href="https://mp.weixin.qq.com/s?__biz=MzAxODQxMDM0Mw==&mid=2247487011&idx=1&sn=5e2b00c1c736fd7afbf3ed35edc4aeec&chksm=9bd7f02baca0793d569a9633cc14117e708ccc9eb41b7f0add430ea78f22e4f2443f421c6841&scene=21#wechat_redirect">论那些小而美的算法技巧：差分数组/前缀和 (qq.com)</a>)</p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>leetcode</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title>MySql8.0窗口函数</title>
    <url>/2021/04/21/%E6%95%B0%E6%8D%AE%E5%BA%93%EF%BC%9AMySql8.0%E7%AA%97%E5%8F%A3%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<h3 id="一、基本概念"><a href="#一、基本概念" class="headerlink" title="一、基本概念"></a>一、基本概念</h3><p>&ensp;&ensp;&ensp;&ensp;MySQL从<strong>8.0</strong>开始支持窗口函数，这个功能在大多商业数据库和部分开源数据库中早已支持，有的也叫分析函数。</p>
 <span id="more"></span>

<p>概念：</p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>窗口</strong>的概念可以理解为记录集合；<strong>窗口函数</strong>也就是在满足某种条件的记录集合上执行的特殊函数，对于每条记录都要在此窗口内执行函数，有的函数随着记录不同，窗口大小都是固定的，这种是静态窗口；有的函数则是不同的记录对应着不同的窗口，这种动态变化的窗口叫滑动窗口。</p>
<p>窗口函数与聚合函数：</p>
<ol>
<li>聚合函数是将多条记录聚合为一条；</li>
<li>窗口函数是每条记录都会执行，有几条记录执行完还是几条；</li>
<li>聚合函数也可以用于窗口函数。</li>
</ol>
<h3 id="二、基本格式"><a href="#二、基本格式" class="headerlink" title="二、基本格式"></a>二、基本格式</h3><p>基本语法：&lt;窗口函数&gt; over (子句)</p>
<ul>
<li><p>&lt;窗口函数&gt;的位置可以放专用窗口函数（rank()，percent_rank()，dense_rank()等），或者放聚合函数（sum()，avg()，max()等）。</p>
</li>
<li><p>窗口函数是对where或group by子句处理后的结果进行操作，故其原则上只写于SELECT子句中。</p>
</li>
<li><p>over 用来指定函数执行的窗口范围，<strong>若子句为空</strong>，则意味着窗口包含满足WHERE条件的所有行，窗口函数基于所有行进行计算。</p>
</li>
<li><p>若子句非空，则支持以下4中语法来设置窗口：</p>
<p>​        <strong>window_name</strong>：给窗口指定一个别名，如果SQL中涉及的窗口较多，采用别名可以看起来更清晰易读。        </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT</span><br><span class="line">	&#96;姓名&#96;,</span><br><span class="line">	&#96;班级&#96;,</span><br><span class="line">	&#96;人气&#96;,</span><br><span class="line">	rank() over w1 AS rak</span><br><span class="line">FROM</span><br><span class="line">	&#96;民工漫班级&#96; window w1 AS ( PARTITION BY &#96;班级&#96; ORDER BY &#96;人气&#96; DESC );</span><br></pre></td></tr></table></figure>

<p>​        结果：</p>
<img src="/2021/04/21/%E6%95%B0%E6%8D%AE%E5%BA%93%EF%BC%9AMySql8.0%E7%AA%97%E5%8F%A3%E5%87%BD%E6%95%B0/1.png" alt="image-20201217104056497" style="zoom:80%;">

<p>​        <strong>partition子句</strong>：窗口按照那些字段进行分组，窗口函数在不同的分组上分别执行。</p>
<p>​        <strong>order by子句</strong>：按照哪些字段进行排序，窗口函数将按照排序后的记录顺序进行编号。</p>
<p>​        frame子句：frame是当前分区的一个子集，子句用来定义子集的规则，通常用来作为滑动窗口使用。（本文暂不介绍）</p>
<p>​        用于操作示例新建的民工漫班级表：</p>
<img src="/2021/04/21/%E6%95%B0%E6%8D%AE%E5%BA%93%EF%BC%9AMySql8.0%E7%AA%97%E5%8F%A3%E5%87%BD%E6%95%B0/2.png" alt="民工漫班级" style="zoom: 67%;">

<p>​        </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT</span><br><span class="line">	*,</span><br><span class="line">	RANK() over ( PARTITION BY &#96;班级&#96; ORDER BY &#96;人气&#96; DESC ) AS ranking </span><br><span class="line">FROM</span><br><span class="line">	&#96;民工漫班级&#96;;</span><br><span class="line"># PARTITION BY &#96;班级&#96;：按班级分组（使用group by会改变表的行数，一个类别只保留一行；partition by则不会减少表的行数）</span><br><span class="line"># ORDER BY &#96;人气&#96; DESC：对按班级分组后的结果按人气降序排名，名次作为字段 ranking</span><br></pre></td></tr></table></figure>

<p>得到结果：</p>
<img src="/2021/04/21/%E6%95%B0%E6%8D%AE%E5%BA%93%EF%BC%9AMySql8.0%E7%AA%97%E5%8F%A3%E5%87%BD%E6%95%B0/3.png" alt="image-20201217000959621" style="zoom: 50%;"></li>
</ul>
<h3 id="三、mysql窗口函数"><a href="#三、mysql窗口函数" class="headerlink" title="三、mysql窗口函数"></a>三、mysql窗口函数</h3><p><strong>功能划分</strong>：</p>
<p> 按功能划分可将MySQL支持的窗口函数分为如下几类：</p>
<ol>
<li>序号函数：ROW_NUMBER()、RANK()、DENSE_RANK()</li>
<li>分布函数：PERCENT_RANK()、CUME_DIST()，PERCENT_RANK()</li>
<li>前后函数：LAG(expr,n)、LEAD(expr,n)</li>
<li>头尾函数：FIRST_VALUE(expr)、LAST_VALUE(expr)</li>
<li>其它函数：NTH_VALUE(expr, n)、NTILE(n)</li>
</ol>
<p><strong>分别介绍：</strong></p>
<p><strong>序号函数：ROW_NUMBER()、RANK()、DENSE_RANK()</strong></p>
<p>&ensp;&ensp;&ensp;&ensp;举个例子，还用上面的民工漫班级表，用三个函数按人气对其排序：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT</span><br><span class="line">	*,</span><br><span class="line">	RANK() over (  ORDER BY &#96;人气&#96; DESC ) AS &#96;rank&#96; ,</span><br><span class="line">	DENSE_RANK() over (  ORDER BY &#96;人气&#96; DESC ) AS &#96;dense_rank&#96; ,</span><br><span class="line">	ROW_NUMBER() over (  ORDER BY &#96;人气&#96; DESC ) AS &#96;row_number&#96; </span><br><span class="line">FROM</span><br><span class="line">	&#96;民工漫班级&#96;;</span><br></pre></td></tr></table></figure>

<p>&ensp;&ensp;&ensp;&ensp;结果：没有再用partition by对班级分组</p>
<img src="/2021/04/21/%E6%95%B0%E6%8D%AE%E5%BA%93%EF%BC%9AMySql8.0%E7%AA%97%E5%8F%A3%E5%87%BD%E6%95%B0/4.png" alt="image-20201217004449218" style="zoom: 67%;">

<p>由此可知：</p>
<ul>
<li>RANK()：并列排序，跳过重复序号——1、1、3</li>
<li>DENSE_RANK()：并列排序，不跳过重复序号——1、1、2</li>
<li>ROW_NUMBER()：顺序排序——1、2、3；相当于行号。</li>
</ul>
<p><strong>分布函数：PERCENT_RANK()、CUME_DIST()</strong></p>
<p><strong>percent_rank()</strong></p>
<p>&ensp;&ensp;&ensp;&ensp;用途：和之前的RANK()函数相关，每行按照如下公式进行计算：(rank - 1) / (rows - 1)， 其中，rank为RANK()函数产生的序号，rows为当前窗口的记录总行数 该函数可以用来计算分位数。</p>
<p>&ensp;&ensp;&ensp;&ensp;继续举例子（想不到实际生活的应用场景）：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT</span><br><span class="line">	*,</span><br><span class="line">	RANK() OVER w AS rankNo,</span><br><span class="line">	PERCENT_RANK() OVER w AS percent_rankNo </span><br><span class="line">FROM</span><br><span class="line">	&#96;民工漫班级&#96; WINDOW w AS ( ORDER BY &#96;人气&#96; DESC );</span><br></pre></td></tr></table></figure>

<p>结果：</p>
<img src="/2021/04/21/%E6%95%B0%E6%8D%AE%E5%BA%93%EF%BC%9AMySql8.0%E7%AA%97%E5%8F%A3%E5%87%BD%E6%95%B0/5.png" alt="image-20201217105136040" style="zoom: 50%;">

<p>&ensp;&ensp;&ensp;&ensp;对于路飞，percent_rankNo = (rank - 1) / (rows - 1) =(3 - 1) / (10 - 1) =0.22222222……</p>
<p><strong>CUME_DIST()</strong></p>
<p>&ensp;&ensp;&ensp;&ensp;用途：分组内小于、等于当前rank值的行数 / 分组内总行数</p>
<p>&ensp;&ensp;&ensp;&ensp;举例：查询小于等于当前人气的比例（或者说某人是前百分之几，生活中很常用）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT</span><br><span class="line">	*,</span><br><span class="line">	CUME_DIST() OVER w AS cdt </span><br><span class="line">FROM</span><br><span class="line">	&#96;民工漫班级&#96; WINDOW w AS ( ORDER BY &#96;人气&#96; DESC );</span><br></pre></td></tr></table></figure>

<p>结果：</p>
<img src="/2021/04/21/%E6%95%B0%E6%8D%AE%E5%BA%93%EF%BC%9AMySql8.0%E7%AA%97%E5%8F%A3%E5%87%BD%E6%95%B0/6.png" alt="image-20201217110444956" style="zoom: 67%;">

<p><strong>前后函数：LAG(expr,n)、LEAD(expr,n)</strong></p>
<p>&ensp;&ensp;&ensp;&ensp;用途：返回位于当前行的前n行（LAG(expr,n)）或后n行（LEAD(expr,n)）的expr的值（以当前行为原点）</p>
<p>&ensp;&ensp;&ensp;&ensp;例：这个生活中应该挺常用</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT</span><br><span class="line">	*,</span><br><span class="line">	&#96;我的前面一名人气&#96; - &#96;人气&#96; AS &#96;我和前面一名的差距&#96;,</span><br><span class="line">	&#96;人气&#96; - &#96;后面一名人气&#96; AS &#96;我甩开后面一名多少差距&#96; </span><br><span class="line">FROM</span><br><span class="line">	(</span><br><span class="line">	SELECT</span><br><span class="line">		*,</span><br><span class="line">		LAG( &#96;人气&#96;, 1 ) OVER w AS &#96;我的前面一名人气&#96;,# 取前面第一行的人气值</span><br><span class="line">		LEAD( &#96;人气&#96;, 1 ) OVER w AS &#96;后面一名人气&#96; # 取后面第一行的人气值</span><br><span class="line">		</span><br><span class="line">	FROM</span><br><span class="line">		&#96;民工漫班级&#96; WINDOW w AS ( ORDER BY &#96;人气&#96; DESC ) </span><br><span class="line">	) t;</span><br></pre></td></tr></table></figure>

<p>结果：</p>
<img src="/2021/04/21/%E6%95%B0%E6%8D%AE%E5%BA%93%EF%BC%9AMySql8.0%E7%AA%97%E5%8F%A3%E5%87%BD%E6%95%B0/7.png" alt="image-20201217113619889" style="zoom: 67%;">

<p>&ensp;&ensp;&ensp;&ensp;蓝染的前1行是路飞，其人气为90，差距为2；后一行是佐助，甩开他1人气。</p>
<p><strong>头尾函数：FIRST_VALUE(expr),LAST_VALUE(expr)</strong></p>
<p>&ensp;&ensp;&ensp;&ensp;用途：返回第一个（FIRST_VALUE(expr)）或最后一个（LAST_VALUE(expr)）expr的值</p>
<p>&ensp;&ensp;&ensp;&ensp;例：截止到当前人气，按人气排名，第一名和最后一名是多少（降序排，最后一名肯定是自己）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT</span><br><span class="line">	*,</span><br><span class="line">	FIRST_VALUE( &#96;人气&#96; ) OVER w AS &#96;当前第一人气值&#96;,</span><br><span class="line">	LAST_VALUE( &#96;人气&#96; ) OVER w AS &#96;当前倒数第一人气值&#96; </span><br><span class="line">FROM</span><br><span class="line">	&#96;民工漫班级&#96; WINDOW w AS ( ORDER BY &#96;人气&#96; DESC );</span><br></pre></td></tr></table></figure>

<p>结果：</p>
<img src="/2021/04/21/%E6%95%B0%E6%8D%AE%E5%BA%93%EF%BC%9AMySql8.0%E7%AA%97%E5%8F%A3%E5%87%BD%E6%95%B0/8.png" alt="image-20201217114336947" style="zoom: 67%;">

<p><strong>其它函数：NTH_VALUE(expr, n)、NTILE(n)</strong></p>
<p><strong>NTH_VALUE(expr, n)</strong></p>
<p>&ensp;&ensp;&ensp;&ensp;用途：返回窗口中第N个expr的值，expr可以是表达式，也可以是列名。</p>
<p>&ensp;&ensp;&ensp;&ensp;例：截至当前人气，显示每个人物的人气中排名第2、第4、第6的人气值</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT</span><br><span class="line">	*,</span><br><span class="line">	NTH_VALUE( &#96;人气&#96;, 2 ) OVER w AS &#96;第二人气值&#96;,</span><br><span class="line">	NTH_VALUE( &#96;人气&#96;, 4 ) OVER w AS &#96;第四人气值&#96;,</span><br><span class="line">	NTH_VALUE( &#96;人气&#96;, 6 ) OVER w AS &#96;第六人气值&#96; </span><br><span class="line">FROM</span><br><span class="line">	&#96;民工漫班级&#96; WINDOW w AS ( ORDER BY &#96;人气&#96; DESC );</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>结果：</p>
<img src="/2021/04/21/%E6%95%B0%E6%8D%AE%E5%BA%93%EF%BC%9AMySql8.0%E7%AA%97%E5%8F%A3%E5%87%BD%E6%95%B0/9.png" alt="image-20201217135748608" style="zoom: 67%;">

<p><strong>NTILE(n)</strong></p>
<p>&ensp;&ensp;&ensp;&ensp;用途：将分区中的有序数据分为n个等级，记录等级数</p>
<p>例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT</span><br><span class="line">	*,</span><br><span class="line">	ROW_NUMBER() OVER w AS &#39;row_number&#39;,</span><br><span class="line">	NTILE( 2 ) OVER w AS &#39;ntile2&#39;,</span><br><span class="line">	NTILE( 4 ) OVER w AS &#39;ntile4&#39; </span><br><span class="line">FROM</span><br><span class="line">	&#96;民工漫班级&#96; WINDOW w AS ( ORDER BY &#96;人气&#96; );</span><br></pre></td></tr></table></figure>

<p>结果：</p>
<img src="/2021/04/21/%E6%95%B0%E6%8D%AE%E5%BA%93%EF%BC%9AMySql8.0%E7%AA%97%E5%8F%A3%E5%87%BD%E6%95%B0/10.png" alt="image-20201217170421940" style="zoom:67%;">

<h3 id="四、用聚合函数作为窗口函数"><a href="#四、用聚合函数作为窗口函数" class="headerlink" title="四、用聚合函数作为窗口函数"></a>四、用聚合函数作为窗口函数</h3><p>&ensp;&ensp;&ensp;&ensp;用途：在窗口中每条记录动态地应用聚合函数（SUM()、AVG()、MAX()、MIN()、COUNT()），可以动态计算在指定的窗口内的各种聚合函数值</p>
<p>例：普通使用：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT</span><br><span class="line">	*,</span><br><span class="line">	sum( &#96;人气&#96; )  AS current_sum,</span><br><span class="line">	avg( &#96;人气&#96; )  AS current_avg,</span><br><span class="line">	count( &#96;人气&#96; )  AS current_count,</span><br><span class="line">	max( &#96;人气&#96; )  AS current_max,</span><br><span class="line">	min( &#96;人气&#96; ) AS current_min </span><br><span class="line">FROM</span><br><span class="line">	&#96;民工漫班级&#96;;</span><br></pre></td></tr></table></figure>

<p>结果：</p>
<img src="/2021/04/21/%E6%95%B0%E6%8D%AE%E5%BA%93%EF%BC%9AMySql8.0%E7%AA%97%E5%8F%A3%E5%87%BD%E6%95%B0/11.png" alt="image-20201217172447565" style="zoom: 67%;">

<p>&ensp;&ensp;&ensp;&ensp;按学号排序，作为窗口函数：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT</span><br><span class="line">	*,</span><br><span class="line">	sum( &#96;人气&#96; ) over w AS current_sum,</span><br><span class="line">	avg( &#96;人气&#96; ) over w AS current_avg,</span><br><span class="line">	count( &#96;人气&#96; ) over w AS current_count,</span><br><span class="line">	max( &#96;人气&#96; ) over w AS current_max,</span><br><span class="line">	min( &#96;人气&#96; ) over w AS current_min </span><br><span class="line">FROM</span><br><span class="line">	&#96;民工漫班级&#96; WINDOW w AS ( ORDER BY &#96;学号&#96; );</span><br></pre></td></tr></table></figure>

<p>结果：</p>
<img src="/2021/04/21/%E6%95%B0%E6%8D%AE%E5%BA%93%EF%BC%9AMySql8.0%E7%AA%97%E5%8F%A3%E5%87%BD%E6%95%B0/12.png" alt="image-20201217172207911" style="zoom:67%;">

<p>&ensp;&ensp;&ensp;&ensp;以current_sum为例，每一行current_sum的值为上面所有行的<code>人气</code>值之和。</p>
<p>本文主要参考：</p>
<p><a href="https://dev.mysql.com/doc/refman/8.0/en/">《MySql8.0参考手册》</a></p>
]]></content>
      <categories>
        <category>数据库</category>
        <category>MySql</category>
      </categories>
      <tags>
        <tag>数据库</tag>
        <tag>窗口函数</tag>
        <tag>MySql</tag>
      </tags>
  </entry>
  <entry>
    <title>位运算</title>
    <url>/2021/04/26/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E5%AD%A6%EF%BC%9A%E4%BD%8D%E8%BF%90%E7%AE%97/</url>
    <content><![CDATA[<p>&ensp;&ensp;本文介绍一些我在刷题时遇到的有关位运算的算法题。</p>
<span id="more"></span>

<h3 id="位异或："><a href="#位异或：" class="headerlink" title="位异或："></a><strong>位异或</strong>：</h3><p>&ensp;&ensp;&ensp;&ensp;一个数和它本身做异或运算结果为 0，即 <code>a ^ a = 0</code>；一个数和 0 做异或运算的结果为它本身，即 <code>a ^ 0 = a</code>。</p>
<p>&ensp;&ensp;&ensp;&ensp;例：</p>
<p>&ensp;&ensp;&ensp;&ensp;<a href="https://leetcode-cn.com/problems/single-number/">只出现一次的数字</a></p>
<p>&ensp;&ensp;&ensp;&ensp;给定一个<strong>非空</strong>整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。</p>
<p><strong>说明：</strong></p>
<p>&ensp;&ensp;&ensp;&ensp;你的算法应该具有线性时间复杂度。 你可以不使用额外空间来实现吗？</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [2,2,1]</span><br><span class="line">输出: 1</span><br></pre></td></tr></table></figure>

<p><strong>示例 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [4,1,2,1,2]</span><br><span class="line">输出: 4</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">singleNumber</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; nums.<span class="built_in">size</span>(); ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            ans = ans ^ nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h3 id="汉明权重"><a href="#汉明权重" class="headerlink" title="汉明权重"></a>汉明权重</h3><p>&ensp;&ensp;位与<code>&amp;</code>，<code>1 &amp; 1 = 1</code>，<code>1 &amp; 0 = 0 &amp; 1 = 0 &amp; 0 = 0</code></p>
<p>&ensp;&ensp;判断奇偶，n &amp; 1 == 1则为奇数，否则为偶数。</p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>汉明重量</strong>是一串符号中非零符号的个数。因此它等同于同样长度的全零符号串的<a href="https://baike.baidu.com/item/%E6%B1%89%E6%98%8E%E8%B7%9D%E7%A6%BB">汉明距离</a>。在最为常见的<a href="https://baike.baidu.com/item/%E6%95%B0%E6%8D%AE%E4%BD%8D">数据位</a>符号串中，它是1的个数。</p>
<p>&ensp;&ensp;&ensp;&ensp;<code>n&amp;(n-1)</code> 这个操作是算法中常见的，作用是消除数字 <code>n</code> 的二进制表示中的最后一个 1。</p>
<img src="/2021/04/26/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E5%AD%A6%EF%BC%9A%E4%BD%8D%E8%BF%90%E7%AE%97/2021-4-30-bit.png" alt="图片" style="zoom:50%;">

<p>&ensp;&ensp;&ensp;&ensp;其核心逻辑就是，<code>n - 1</code> 一定可以消除最后一个 1，同时把其后的 0 都变成 1，这样再和 <code>n</code> 做一次 <code>&amp;</code> 运算，就可以仅仅把最后一个 1 变成 0 了。</p>
<p>&ensp;&ensp;&ensp;&ensp;核心代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">hammingWeight</span><span class="params">(<span class="keyword">uint32_t</span> n)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (n != <span class="number">0</span>) </span><br><span class="line">    &#123;</span><br><span class="line">        n = n &amp; (n - <span class="number">1</span>);</span><br><span class="line">        res++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="338-比特位计数"><a href="#338-比特位计数" class="headerlink" title="338. 比特位计数"></a><a href="https://leetcode-cn.com/problems/counting-bits/">338. 比特位计数</a></h4><p>&ensp;&ensp;&ensp;&ensp;给定一个非负整数 <strong>num</strong>。对于 <strong>0 ≤ i ≤ num</strong> 范围中的每个数字 <strong>i</strong> ，计算其二进制数中的 1 的数目并将它们作为数组返回。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: 2</span><br><span class="line">输出: [0,1,1]</span><br></pre></td></tr></table></figure>

<p><strong>示例 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: 5</span><br><span class="line">输出: [0,1,1,2,1,2]</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">countBits</span><span class="params">(<span class="keyword">int</span> num)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt; ans;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= num; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            ans.<span class="built_in">push_back</span>(<span class="built_in">hammingWeight</span>(i));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">hammingWeight</span><span class="params">(<span class="keyword">int</span> n)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (n != <span class="number">0</span>) &#123;</span><br><span class="line">            n = n &amp; (n - <span class="number">1</span>);</span><br><span class="line">            res++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>另一解法：</p>
<p>&ensp;&ensp;&ensp;&ensp;对于所有的数字，只有两类：</p>
<p>&ensp;&ensp;&ensp;&ensp;奇数：二进制表示中，奇数一定比前面那个偶数多一个 1，因为多的就是最低位的 1。        </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">举例： </span><br><span class="line">    0 &#x3D; 0       1 &#x3D; 1</span><br><span class="line">    2 &#x3D; 10      3 &#x3D; 11</span><br></pre></td></tr></table></figure>

<p>&ensp;&ensp;&ensp;&ensp;偶数：二进制表示中，偶数中 1 的个数一定和除以 2 之后的那个数一样多。因为最低位是 0，除以 2 就是右移一位，也就是把那个 0 抹掉而已，所以 1 的个数是不变的。         </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">举例：</span><br><span class="line">    2 &#x3D; 10       4 &#x3D; 100       8 &#x3D; 1000</span><br><span class="line">    3 &#x3D; 11       6 &#x3D; 110       12 &#x3D; 1100</span><br></pre></td></tr></table></figure>

<p>&ensp;&ensp;&ensp;&ensp;另外，0 的 1 个数为 0，于是就可以根据奇偶性开始遍历计算了。</p>
<p>&ensp;&ensp;&ensp;&ensp;代码</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">countBits</span><span class="params">(<span class="keyword">int</span> num)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">result</span><span class="params">(num+<span class="number">1</span>)</span></span>;</span><br><span class="line">    result[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= num; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(i % <span class="number">2</span> == <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            result[i] = result[i<span class="number">-1</span>] + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            result[i] = result[i/<span class="number">2</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;        </span><br></pre></td></tr></table></figure>

<h4 id="461-汉明距离"><a href="#461-汉明距离" class="headerlink" title="461. 汉明距离"></a><a href="https://leetcode-cn.com/problems/hamming-distance/">461. 汉明距离</a></h4><p>两个整数之间的<a href="https://baike.baidu.com/item/%E6%B1%89%E6%98%8E%E8%B7%9D%E7%A6%BB">汉明距离</a>指的是这两个数字对应二进制位不同的位置的数目。</p>
<p>给出两个整数 <code>x</code> 和 <code>y</code>，计算它们之间的汉明距离。</p>
<p><strong>注意：</strong><br>0 ≤ <code>x</code>, <code>y</code> &lt; 231.</p>
<p><strong>示例:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: x &#x3D; 1, y &#x3D; 4</span><br><span class="line"></span><br><span class="line">输出: 2</span><br><span class="line"></span><br><span class="line">解释:</span><br><span class="line">1   (0 0 0 1)</span><br><span class="line">4   (0 1 0 0)</span><br><span class="line">       ↑   ↑</span><br><span class="line"></span><br><span class="line">上面的箭头指出了对应二进制位不同的位置。</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">hammingDistance</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = x ^ y;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (n != <span class="number">0</span>) </span><br><span class="line">        &#123;</span><br><span class="line">            n = n &amp; (n - <span class="number">1</span>);</span><br><span class="line">            ++res;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><a href="https://mp.weixin.qq.com/s?__biz=MzAxODQxMDM0Mw==&mid=2247486704&idx=2&sn=59b011722fe722551de8b56f234a4050&chksm=9bd7f2f8aca07bee47852e7bce72325157897ad0a3d5f383d18bca5379d66716518c2b968ae9&scene=21#wechat_redirect">原创 | 东哥教你几招常用的位运算技巧 (qq.com)</a></p>
]]></content>
      <categories>
        <category>算法</category>
        <category>数学</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>leetcode</tag>
        <tag>位运算</tag>
      </tags>
  </entry>
  <entry>
    <title>缺失的第一个整数</title>
    <url>/2021/04/21/%E7%AE%97%E6%B3%95%EF%BC%9A%E7%BC%BA%E5%A4%B1%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E6%AD%A3%E6%95%B0/</url>
    <content><![CDATA[<h3 id="一、简介"><a href="#一、简介" class="headerlink" title="一、简介"></a>一、简介</h3><p>&ensp;&ensp;&ensp;&ensp;2021年拼多多暑期实习技术面一面时碰到了这道题，面试官直接告诉我这是道 hard 级别的题目，还问我要不要换一道，当时头铁，没想换，结果就是代码各种细节漏洞（拼多多面试平台不能运行代码，很痛苦），最后还是换了一道二叉树的 medium 题。</p>
 <span id="more"></span>

<p>&ensp;&ensp;&ensp;&ensp;题目描述：(<a href="https://leetcode-cn.com/problems/first-missing-positive/">leetcode: 41</a>)</p>
<p>&ensp;&ensp;&ensp;&ensp;给你一个未排序的整数数组 <code>nums</code> ，请你找出其中没有出现的最小的正整数要求时间复杂度O(n)，空间复杂度O(1)</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：nums &#x3D; [1,2,0]</span><br><span class="line">输出：3</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：nums &#x3D; [3,4,-1,1]</span><br><span class="line">输出：2</span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：nums &#x3D; [7,8,9,11,12]</span><br><span class="line">输出：1</span><br></pre></td></tr></table></figure>

<p> <strong>提示：</strong></p>
<ul>
<li>  <code>0 &lt;= nums.length &lt;= 300</code></li>
<li>  <code>-231 &lt;= nums[i] &lt;= 231 - 1</code></li>
</ul>
<h3 id="二、题目分析"><a href="#二、题目分析" class="headerlink" title="二、题目分析"></a>二、题目分析</h3><p>&ensp;&ensp;&ensp;&ensp;首先，我们可以确定给定数组的缺失的最小整数的范围：[1, nums.size() + 1]，因此我们可以把数组中的元素<strong>归位</strong>，比如数组中的 1 放在数组第1个位置， 2 放在数组第2个位置……</p>
<p>&ensp;&ensp;&ensp;&ensp;然后从头遍历该数组，当 <code>nums[i] - 1 != i</code>时，返回 <code>i + 1</code>即可；若遍历完仍然没返回值，则返回<code>nums.size() + 1</code>。</p>
<p>&ensp;&ensp;&ensp;&ensp;重点是<strong>归位</strong>元素，使数组中的元素 <code>a</code>，归位到 <code>nums[a - 1]</code>（a的范围有限制），还要考虑<code>a</code>的目标位置上的元素不被覆盖。</p>
<blockquote>
<p>  所以应该交换 a 和 目标位置的元素，这是原来 a 的位置有了新元素，再归位这个新元素。（不要以为只交换一次，新元素可能 ‘’德不配位’‘ ）</p>
</blockquote>
<p>&ensp;&ensp;&ensp;&ensp;例：[3, 4, -1, 1] → [-1, 4, 3, 1] → [-1, 1, 3, 4] → [1, -1, 3, 4]</p>
<ol>
<li> 归位 3， -1 换到 nums[0]，-1 不满足范围限制</li>
<li> 归位 4， 1 换到 nums[1]; 再归位 1，使nums[0] = 1, -1换到nums[1] 处</li>
<li> 再归位后面的元素</li>
</ol>
<p>代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">firstMissingPositive</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> length = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//范围限制</span></span><br><span class="line">            <span class="keyword">while</span> (nums[i] &gt; <span class="number">0</span> &amp;&amp; </span><br><span class="line">                   nums[i] &lt;= nums.<span class="built_in">size</span>() &amp;&amp; </span><br><span class="line">                   nums[nums[i] - <span class="number">1</span>] != nums[i]) </span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">swap</span>(nums[i], nums[nums[i] - <span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); ++i) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] - <span class="number">1</span> != i) </span><br><span class="line">                <span class="keyword">return</span> i + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums.<span class="built_in">size</span>() + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>&ensp;&ensp;&ensp;&ensp;更多博客，敬请期待。</p>
]]></content>
      <categories>
        <category>算法</category>
        <category>遇到的笔试（面试）题</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>leetcode</tag>
        <tag>数组</tag>
        <tag>拼多多实习面试</tag>
      </tags>
  </entry>
  <entry>
    <title>跳跃游戏</title>
    <url>/2021/04/29/%E7%AE%97%E6%B3%95%EF%BC%9A%E8%B7%B3%E8%B7%83%E6%B8%B8%E6%88%8F/</url>
    <content><![CDATA[<h3 id="一、介绍"><a href="#一、介绍" class="headerlink" title="一、介绍"></a>一、介绍</h3><p>&ensp;&ensp;&ensp;&ensp;2021年4月14日华为笔试题第四题，好像是一个有关信号塔传播的题，后来在刷Leetcode的时候碰见了原题，也就是《跳跃游戏2》；跳跃游戏1和2只是问法不一样，核心算法相同。</p>
<span id="more"></span>

<h3 id="二、题目"><a href="#二、题目" class="headerlink" title="二、题目"></a>二、题目</h3><p><a href="https://leetcode-cn.com/problems/jump-game/">跳跃游戏</a></p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">给定一个非负整数数组 nums ，你最初位于数组的第一个下标 。数组中的每个元素代表你在该位置可以跳跃的最大长度。判断你是否能够到达最后一个下标。 </span><br><span class="line"></span><br><span class="line">示例 1：</span><br><span class="line">输入：nums = [2,3,1,1,4]</span><br><span class="line">输出：true</span><br><span class="line">解释：可以先跳 1 步，从下标 0 到达下标 1, 然后再从下标 1 跳 3 步到达最后一个下标。</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line">输入：nums = [3,2,1,0,4]</span><br><span class="line">输出：false</span><br><span class="line">解释：无论怎样，总会到达下标为 3 的位置。但该下标的最大跳跃长度是 0 ， 所以永远不可能到达最后一个下标。</span><br><span class="line">提示：</span><br><span class="line">1 &lt;= nums.length &lt;= 3 * 10<span class="built_in">^</span>4</span><br><span class="line">0 &lt;= nums[i] &lt;= 105</span><br></pre></td></tr></table></figure>

<p><a href="https://leetcode-cn.com/problems/jump-game-ii/">跳跃游戏 II</a></p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">给定一个非负整数数组，你最初位于数组的第一个位置。数组中的每个元素代表你在该位置可以跳跃的最大长度。你的目标是使用最少的跳跃次数到达数组的最后一个位置。假设你总是可以到达数组的最后一个位置。</span><br><span class="line"></span><br><span class="line">示例 1:</span><br><span class="line">输入: [2,3,1,1,4]</span><br><span class="line">输出: 2</span><br><span class="line">解释: 跳到最后一个位置的最小跳跃数是 2。</span><br><span class="line">     从下标为 0 跳到下标为 1 的位置，跳 1 步，然后跳 3 步到达数组的最后一个位置。</span><br><span class="line"></span><br><span class="line">示例 2:</span><br><span class="line">输入: [2,3,0,1,4]</span><br><span class="line">输出: 2</span><br><span class="line"></span><br><span class="line">提示:</span><br><span class="line">1 &lt;= nums.length &lt;= 1000`</span><br><span class="line">0 &lt;= nums[i] &lt;= 105`</span><br></pre></td></tr></table></figure>

<h3 id="三、题解："><a href="#三、题解：" class="headerlink" title="三、题解："></a>三、题解：</h3><p>题一：</p>
<ol>
<li> 如果数组长度为<code>1</code>或数组中没有<code>0</code>，一定可以到达；</li>
<li>对于每一个元素，循环判断它前面的元素是否可以到达<ul>
<li>  如果可以到达，则跳出循环</li>
<li>  如果不可以到达：循环到该元素前面的一个元素，当那个值为<code>0</code></li>
</ul>
</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">canJump</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> numsLength = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span> (numsLength == <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;            </span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt;::iterator it = <span class="built_in">find</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>(), <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (it == nums.<span class="built_in">end</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; numsLength; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; ++j)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums[j] &gt;= i - j)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (nums[j] == <span class="number">0</span> &amp;&amp; i == j + <span class="number">1</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125; </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>题二：</p>
<ol>
<li> 用动态规划的思想，生成一数组<code>dp</code>，<code>dp[i]</code>用来记录<code>nums[0]</code>到达<code>nums[i]</code>的最小跳跃次数</li>
<li> dp[0] = 0</li>
<li> 遍历每个元素，当<code>nums[j]</code>可以到达<code>nums[i]</code>时，另<code>dp[i] = dp[j] + 1;</code>，立即跳出循环</li>
<li> 返回<code>dp[nums.size() - 1]</code></li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">jump</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> numsLength = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">dp</span><span class="params">(nums.size())</span></span>;</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; numsLength; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; ++j)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums[j] &gt;= i - j)</span><br><span class="line">                &#123;</span><br><span class="line">                    dp[i] = dp[j] + <span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125; </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[numsLength - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法</category>
        <category>遇到的笔试（面试）题</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>leetcode</tag>
        <tag>数组</tag>
        <tag>动态规划</tag>
        <tag>华为笔试题</tag>
      </tags>
  </entry>
  <entry>
    <title>模幂运算</title>
    <url>/2021/04/30/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E5%AD%A6%EF%BC%9A%E6%A8%A1%E5%B9%82%E8%BF%90%E7%AE%97/</url>
    <content><![CDATA[<p>&ensp;&ensp;&ensp;&ensp;由于格式原因可能文章显示有问题，a^1234^代表a的1234次幂</p>
<p>&ensp;&ensp;&ensp;&ensp;a^1234^  =  a^4^  *  (a^123^)^10^</p>
<p>&ensp;&ensp;&ensp;&ensp;(a * b) % mod = (a % mod)(b % mod) % mod</p>
<span id="more"></span>

<h4 id="50-Pow-x-n"><a href="#50-Pow-x-n" class="headerlink" title="50. Pow(x, n)"></a><a href="https://leetcode-cn.com/problems/powx-n/">50. Pow(x, n)</a></h4><p>&ensp;&ensp;&ensp;&ensp;实现 pow(<em>x</em>, <em>n</em>) ，即计算 x 的 n 次幂函数（即，x^n^）。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：x &#x3D; 2.00000, n &#x3D; 10</span><br><span class="line">输出：1024.00000</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：x &#x3D; 2.10000, n &#x3D; 3</span><br><span class="line">输出：9.26100</span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：x &#x3D; 2.00000, n &#x3D; -2</span><br><span class="line">输出：0.25000</span><br><span class="line">解释：2^(-2) &#x3D; 1&#x2F;22 &#x3D; 1&#x2F;4 &#x3D; 0.25</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li>  <code>-100.0 &lt; x &lt; 100.0</code></li>
<li>  <code>-231 &lt;= n &lt;= 231-1</code></li>
<li>  <code>-10^4 &lt;= x^n &lt;= 10^4</code></li>
</ul>
<p>&ensp;&ensp;&ensp;&ensp;递归：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">quickMul</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">long</span> <span class="keyword">long</span> N)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (N == <span class="number">0</span>) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1.0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">double</span> y = <span class="built_in">quickMul</span>(x, N / <span class="number">2</span>);</span><br><span class="line">        <span class="keyword">return</span> N % <span class="number">2</span> == <span class="number">0</span> ? y * y : y * y * x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">myPow</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">int</span> n)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> N = n;</span><br><span class="line">        <span class="keyword">return</span> N &gt;= <span class="number">0</span> ? <span class="built_in">quickMul</span>(x, N) : <span class="number">1.0</span> / <span class="built_in">quickMul</span>(x, -N);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>&ensp;&ensp;&ensp;&ensp;迭代：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">quickMul</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">long</span> <span class="keyword">long</span> N)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">double</span> ans = <span class="number">1.0</span>;</span><br><span class="line">        <span class="comment">// 贡献的初始值为 x</span></span><br><span class="line">        <span class="keyword">double</span> x_contribute = x;</span><br><span class="line">        <span class="comment">// 在对 N 进行二进制拆分的同时计算答案</span></span><br><span class="line">        <span class="keyword">while</span> (N &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (N &amp; <span class="number">1</span>) </span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 如果 N 二进制表示的最低位为 1，那么需要计入贡献</span></span><br><span class="line">                ans *= x_contribute;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 将贡献不断地平方</span></span><br><span class="line">            x_contribute *= x_contribute;</span><br><span class="line">            <span class="comment">// 舍弃 N 二进制表示的最低位，这样我们每次只要判断最低位即可</span></span><br><span class="line">            N /= <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">myPow</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">int</span> n)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> N = n;</span><br><span class="line">        <span class="keyword">return</span> N &gt;= <span class="number">0</span> ? <span class="built_in">quickMul</span>(x, N) : <span class="number">1.0</span> / <span class="built_in">quickMul</span>(x, -N);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>&ensp;&ensp;&ensp;&ensp;a^1234^  =  a^4^  *  (a^123^)^10^  $\Longrightarrow$ a^[1,2,3,4]^  =  a^4^  *  (a^[1,2,3]^)^10^ </p>
<h4 id="372-超级次方"><a href="#372-超级次方" class="headerlink" title="372. 超级次方"></a><a href="https://leetcode-cn.com/problems/super-pow/">372. 超级次方</a></h4><p>你的任务是计算  a^b^  对 <code>1337</code> 取模，<code>a</code> 是一个正整数，<code>b</code> 是一个非常大的正整数且会以数组形式给出。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：a &#x3D; 2, b &#x3D; [3]</span><br><span class="line">输出：8</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：a &#x3D; 2, b &#x3D; [1,0]</span><br><span class="line">输出：1024</span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：a &#x3D; 1, b &#x3D; [4,3,3,8,5,2]</span><br><span class="line">输出：1</span><br></pre></td></tr></table></figure>

<p><strong>示例 4：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：a &#x3D; 2147483647, b &#x3D; [2,0,0]</span><br><span class="line">输出：1198</span><br></pre></td></tr></table></figure>

<p> <strong>提示：</strong></p>
<ul>
<li>  <code>1 &lt;= a &lt;= 231 - 1</code></li>
<li>  <code>1 &lt;= b.length &lt;= 2000</code></li>
<li>  <code>0 &lt;= b[i] &lt;= 9</code></li>
<li>  <code>b</code> 不含前导 0</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> mod = <span class="number">1337</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">myPow</span> <span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        x %= mod;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (n) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (n &amp; <span class="number">1</span>) res = res * x % mod;</span><br><span class="line">            x = x * x % mod;</span><br><span class="line">            n &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">superPow</span><span class="params">(<span class="keyword">int</span> a, vector&lt;<span class="keyword">int</span>&gt;&amp; b)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (b.<span class="built_in">empty</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> lastValue = b.<span class="built_in">back</span>();</span><br><span class="line">        b.<span class="built_in">pop_back</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> part1 = <span class="built_in">myPow</span>(a, lastValue);</span><br><span class="line">        <span class="keyword">int</span> part2 = <span class="built_in">myPow</span>(<span class="built_in">superPow</span>(a, b), <span class="number">10</span>);</span><br><span class="line">        <span class="keyword">return</span> part1 * part2 % mod;  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><a href="https://mp.weixin.qq.com/s?__biz=MzAxODQxMDM0Mw==&mid=2247485035&idx=1&sn=c03c9056f412bf590480156e4357b433&chksm=9bd7f863aca07175eca0bd5e638c857969af1936cc2b7b4a01610809ba1d85a3272703e2b3a2&scene=21#wechat_redirect">Super Pow：如何高效进行模幂运算 (qq.com)</a></p>
<p><a href="https://mp.weixin.qq.com/s?__biz=MzA5MTM1NTc2Ng==&mid=2458321758&idx=1&sn=e92e7a72d245831c29acb3d2a29607da&scene=21#wechat_redirect">客户端基本不用的算法系列：快速幂 (qq.com)</a></p>
<p><a href="https://blog.csdn.net/FlushHip/article/details/82495034">右移一位和除二的区别</a></p>
]]></content>
      <categories>
        <category>算法</category>
        <category>数学</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>leetcode</tag>
        <tag>数学</tag>
        <tag>模幂运算</tag>
      </tags>
  </entry>
  <entry>
    <title>删除链表的倒数第n个节点</title>
    <url>/2021/04/30/%E9%93%BE%E8%A1%A8%EF%BC%9A%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E5%80%92%E6%95%B0%E7%AC%ACn%E4%B8%AA%E8%8A%82%E7%82%B9/</url>
    <content><![CDATA[<h3 id="一、题目描述"><a href="#一、题目描述" class="headerlink" title="一、题目描述"></a>一、题目描述</h3><p>&ensp;&ensp;&ensp;&ensp;给定一个链表，删除链表的倒数第 n 个节点，并且返回链表的头结点。</p>
<span id="more"></span>

<p>&ensp;&ensp;&ensp;&ensp;示例：<br>&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;给定一个链表: 1-&gt;2-&gt;3-&gt;4-&gt;5, 和 n = 2.<br>&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;当删除了倒数第二个节点后，链表变为 1-&gt;2-&gt;3-&gt;5.<br>&ensp;&ensp;&ensp;&ensp;说明：给定的 n 保证是有效的。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">removeNthFromEnd</span><span class="params">(ListNode* head, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    	<span class="comment">//to do            </span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="二、解题思路"><a href="#二、解题思路" class="headerlink" title="二、解题思路"></a>二、解题思路</h3><p>&ensp;&ensp;&ensp;&ensp;首先需要知道所给链表的长度</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> length=<span class="number">0</span>;</span><br><span class="line">ListNode *lengthptr=head;</span><br><span class="line">        <span class="keyword">while</span>(lengthptr!=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">            length++;</span><br><span class="line">            lengthptr=length1-&gt;next;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<p>&ensp;&ensp;&ensp;&ensp;然后将中间指针移动到所要删除的节点的前一个节点上，然后执行删除操作。<br>&ensp;&ensp;&ensp;&ensp;根据注释中链表的定义，我们创造了一个新的节点beforhead，它指向head；然后对beforehead后面的链表执行操作，最后返回beforhead-&gt;next，这样便于解决一些特殊情况，比如删除头结点时。</p>
<h3 id="三、我的代码"><a href="#三、我的代码" class="headerlink" title="三、我的代码"></a>三、我的代码</h3><p>&ensp;&ensp;&ensp;&ensp;直接在力扣上写的。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">removeNthFromEnd</span><span class="params">(ListNode* head, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> length=<span class="number">0</span>;</span><br><span class="line">        ListNode *beforhead=<span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">0</span>,head);</span><br><span class="line">        ListNode *begin=beforhead;</span><br><span class="line">        ListNode *lengthptr=head;</span><br><span class="line">        <span class="keyword">while</span>(lengthptr!=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">            length++;</span><br><span class="line">            lengthptr=length1-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;length-n+<span class="number">1</span>;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            begin=begin-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        begin-&gt;next=begin-&gt;next-&gt;next;</span><br><span class="line">        ListNode *ans=beforhead-&gt;next;</span><br><span class="line">        <span class="keyword">return</span> ans;                    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法</category>
        <category>链表</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>leetcode</tag>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title>反转链表</title>
    <url>/2021/04/30/%E9%93%BE%E8%A1%A8%EF%BC%9A%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<h3 id="一、题目描述"><a href="#一、题目描述" class="headerlink" title="一、题目描述"></a>一、题目描述</h3><p>&ensp;&ensp;&ensp;&ensp;反转一个单链表。</p>
<span id="more"></span>

<p>示例:</p>
<pre><code>输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL
输出: 5-&gt;4-&gt;3-&gt;2-&gt;1-&gt;NULL
</code></pre>
<p>进阶:<br>&ensp;&ensp;&ensp;&ensp;你可以迭代或递归地反转链表。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">reverseList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">		<span class="comment">//to do</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="二、解题思路"><a href="#二、解题思路" class="headerlink" title="二、解题思路"></a>二、解题思路</h3><p>&ensp;&ensp;&ensp;&ensp;当链表为空或者只有一个头结点时，直接返回head即可。<br>&ensp;&ensp;&ensp;&ensp;定义三个指针：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">ListNode* p=head;</span><br><span class="line">ListNode* q=head-&gt;next;</span><br><span class="line">ListNode* tmp;</span><br></pre></td></tr></table></figure>
<p>&ensp;&ensp;&ensp;&ensp;p是反转链表的头节点，q是老链表的头节点，tmp作为p，q移动时的中间节点。<br><img src="/2021/04/30/%E9%93%BE%E8%A1%A8%EF%BC%9A%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/1.png" alt="在这里插入图片描述"><br>&ensp;&ensp;&ensp;&ensp;移动一次</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">tmp=q;</span><br><span class="line">q=q-&gt;next;</span><br><span class="line">tmp-&gt;next=p;</span><br><span class="line">p=tmp;</span><br></pre></td></tr></table></figure>

<h3 id="三、我的代码"><a href="#三、我的代码" class="headerlink" title="三、我的代码"></a>三、我的代码</h3><p>&ensp;&ensp;&ensp;&ensp;直接在力扣上写的。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">reverseList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head==<span class="literal">nullptr</span>||head-&gt;next==<span class="literal">nullptr</span>)</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        ListNode* p=head;</span><br><span class="line">        ListNode* q=head-&gt;next;</span><br><span class="line">        ListNode* tmp;</span><br><span class="line">        p-&gt;next=<span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">while</span>(q!=<span class="literal">nullptr</span>)&#123;            </span><br><span class="line">            tmp=q;</span><br><span class="line">            q=q-&gt;next;</span><br><span class="line">            tmp-&gt;next=p;</span><br><span class="line">            p=tmp;          </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> p;          </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="25-K-个一组翻转链表"><a href="#25-K-个一组翻转链表" class="headerlink" title="25. K 个一组翻转链表"></a><a href="https://leetcode-cn.com/problems/reverse-nodes-in-k-group/">25. K 个一组翻转链表</a></h3><p>给你一个链表，每 <em>k</em> 个节点一组进行翻转，请你返回翻转后的链表。</p>
<p><em>k</em> 是一个正整数，它的值小于或等于链表的长度。</p>
<p>如果节点总数不是 <em>k</em> 的整数倍，那么请将最后剩余的节点保持原有顺序。</p>
<p><strong>进阶：</strong></p>
<ul>
<li>  你可以设计一个只使用常数额外空间的算法来解决此问题吗？</li>
<li>  <strong>你不能只是单纯的改变节点内部的值</strong>，而是需要实际进行节点交换。 </li>
</ul>
<p><strong>示例 1：</strong></p>
<p><img src="/2021/04/30/%E9%93%BE%E8%A1%A8%EF%BC%9A%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/2.jpg" alt="img"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：head &#x3D; [1,2,3,4,5], k &#x3D; 2</span><br><span class="line">输出：[2,1,4,3,5]</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<p><img src="/%E5%8F%8D%E8%BD%AC%E9%93%BE%EF%BF%BD.jpg" alt="img"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：head &#x3D; [1,2,3,4,5], k &#x3D; 3</span><br><span class="line">输出：[3,2,1,4,5]</span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：head &#x3D; [1,2,3,4,5], k &#x3D; 1</span><br><span class="line">输出：[1,2,3,4,5]</span><br></pre></td></tr></table></figure>

<p><strong>示例 4：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：head &#x3D; [1], k &#x3D; 1</span><br><span class="line">输出：[1]</span><br></pre></td></tr></table></figure>



<p><strong>提示：</strong></p>
<ul>
<li>  列表中节点的数量在范围 <code>sz</code> 内</li>
<li>  <code>1 &lt;= sz &lt;= 5000</code></li>
<li>  <code>0 &lt;= Node.val &lt;= 1000</code></li>
<li>  <code>1 &lt;= k &lt;= sz</code></li>
</ul>
<p>代码</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">reverse</span><span class="params">(ListNode* a, ListNode* b)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        ListNode* pre = <span class="literal">nullptr</span>;</span><br><span class="line">        ListNode* cur = a;</span><br><span class="line">        ListNode* nxt = a;</span><br><span class="line">        <span class="keyword">while</span>(cur != b)</span><br><span class="line">        &#123;</span><br><span class="line">            nxt = cur-&gt;next;</span><br><span class="line">            cur-&gt;next = pre;</span><br><span class="line">            pre = cur;</span><br><span class="line">            cur = nxt;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pre;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">ListNode* <span class="title">reverseKGroup</span><span class="params">(ListNode* head, <span class="keyword">int</span> k)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!head)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        </span><br><span class="line">        ListNode *a = head, *b = head;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(!b)</span><br><span class="line">                <span class="keyword">return</span> head;</span><br><span class="line">            b = b-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ListNode *newHead = <span class="built_in">reverse</span>(a, b);</span><br><span class="line"></span><br><span class="line">        a-&gt;next = <span class="built_in">reverseKGroup</span>(b, k);</span><br><span class="line">        <span class="keyword">return</span> newHead;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法</category>
        <category>链表</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>leetcode</tag>
        <tag>链表</tag>
        <tag>反转链表</tag>
      </tags>
  </entry>
  <entry>
    <title>反转链表</title>
    <url>/2021/04/30/%E9%93%BE%E8%A1%A8%EF%BC%9A%E5%9B%9E%E6%96%87%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<h3 id="一、题目描述"><a href="#一、题目描述" class="headerlink" title="一、题目描述"></a>一、题目描述</h3><p>&ensp;&ensp;&ensp;&ensp;请判断一个链表是否为回文链表。</p>
<span id="more"></span>

<p>示例 1:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: 1-&gt;2</span><br><span class="line">输出: false</span><br></pre></td></tr></table></figure>
<p>示例 2:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: 1-&gt;2-&gt;2-&gt;1</span><br><span class="line">输出: true</span><br></pre></td></tr></table></figure>
<p>进阶：<br>&ensp;&ensp;&ensp;&ensp;你能否用 O(n) 时间复杂度和 O(1) 空间复杂度解决此题？</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isPalindrome</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="二、解题思路"><a href="#二、解题思路" class="headerlink" title="二、解题思路"></a>二、解题思路</h3><p>&ensp;&ensp;&ensp;&ensp;先判断链表长度</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> length=<span class="number">0</span>;</span><br><span class="line">   ListNode* p=head;</span><br><span class="line">    <span class="keyword">while</span>(p!=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">        length++;</span><br><span class="line">        p=p-&gt;next;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>&ensp;&ensp;&ensp;&ensp;创建一个与链表等长的数组，再把每个节点对应的值放入数组中</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a[length];</span><br><span class="line">   <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;length;i++)&#123;</span><br><span class="line">       a[i]=p-&gt;val;</span><br><span class="line">       p=p-&gt;next;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>&ensp;&ensp;&ensp;&ensp;比较数组中对应的值</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;length/<span class="number">2</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(a[i]!=a[length-i<span class="number">-1</span>])</span><br><span class="line">             <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure>
<h3 id="三、我的代码"><a href="#三、我的代码" class="headerlink" title="三、我的代码"></a>三、我的代码</h3><p>&ensp;&ensp;&ensp;&ensp;直接在力扣上写的。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isPalindrome</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> length=<span class="number">0</span>;</span><br><span class="line">        ListNode* p=head;</span><br><span class="line">        <span class="keyword">while</span>(p!=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">            length++;</span><br><span class="line">            p=p-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(length==<span class="number">0</span>||length==<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        p=head;</span><br><span class="line">        <span class="keyword">int</span> a[length];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;length;i++)&#123;</span><br><span class="line">            a[i]=p-&gt;val;</span><br><span class="line">            p=p-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;length/<span class="number">2</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(a[i]!=a[length-i<span class="number">-1</span>])</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法</category>
        <category>链表</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>leetcode</tag>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title>合并两个有序链表</title>
    <url>/2021/04/30/%E9%93%BE%E8%A1%A8%EF%BC%9A%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<h3 id="一、题目描述"><a href="#一、题目描述" class="headerlink" title="一、题目描述"></a>一、题目描述</h3><p>&ensp;&ensp;&ensp;&ensp;将两个升序链表合并为一个新的 <strong>升序</strong> 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 </p>
<span id="more"></span>

<p><strong>示例：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：1-&gt;2-&gt;4, 1-&gt;3-&gt;4</span><br><span class="line">输出：1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4</span><br></pre></td></tr></table></figure>

<h3 id="二、解题思路"><a href="#二、解题思路" class="headerlink" title="二、解题思路"></a>二、解题思路</h3><ol>
<li><p>先判断有无空链表</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(l1==<span class="literal">nullptr</span>)</span><br><span class="line">	<span class="keyword">return</span> l2;</span><br><span class="line"><span class="keyword">if</span>(l2==<span class="literal">nullptr</span>)</span><br><span class="line">	<span class="keyword">return</span> l1;</span><br></pre></td></tr></table></figure></li>
<li><p>确定合并链表的头结点（整数值小的结点）</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">ListNode* head;</span><br><span class="line">l1-&gt;val&gt;l2-&gt;val ? (head=l2,l2=l2-&gt;next):(head=l1,l1=l1-&gt;next); </span><br></pre></td></tr></table></figure></li>
<li><p>连接后续结点</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(l1!=<span class="literal">nullptr</span>&amp;&amp;l2!=<span class="literal">nullptr</span>)&#123;            </span><br><span class="line">            l1-&gt;val&gt;l2-&gt;val ? (p-&gt;next=l2,l2=l2-&gt;next):(p-&gt;next=l1,l1=l1-&gt;next);            </span><br><span class="line">            p=p-&gt;next;            </span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="三、我的代码"><a href="#三、我的代码" class="headerlink" title="三、我的代码"></a>三、我的代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">mergeTwoLists</span><span class="params">(ListNode* l1, ListNode* l2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(l1==<span class="literal">nullptr</span>)</span><br><span class="line">            <span class="keyword">return</span> l2;</span><br><span class="line">        <span class="keyword">if</span>(l2==<span class="literal">nullptr</span>)</span><br><span class="line">            <span class="keyword">return</span> l1;</span><br><span class="line">        ListNode* head;</span><br><span class="line">        l1-&gt;val&gt;l2-&gt;val ? (head=l2,l2=l2-&gt;next):(head=l1,l1=l1-&gt;next);        </span><br><span class="line">        ListNode* p=head;</span><br><span class="line">        <span class="keyword">while</span>(l1!=<span class="literal">nullptr</span>&amp;&amp;l2!=<span class="literal">nullptr</span>)&#123;            </span><br><span class="line">            l1-&gt;val&gt;l2-&gt;val ? (p-&gt;next=l2,l2=l2-&gt;next):(p-&gt;next=l1,l1=l1-&gt;next);            </span><br><span class="line">            p=p-&gt;next;            </span><br><span class="line">        &#125;</span><br><span class="line">        p-&gt;next=(l1==<span class="literal">nullptr</span>)? l2:l1;        </span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法</category>
        <category>链表</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>leetcode</tag>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title>复制带随机指针的链表</title>
    <url>/2021/04/30/%E9%93%BE%E8%A1%A8%EF%BC%9A%E5%A4%8D%E5%88%B6%E5%B8%A6%E9%9A%8F%E6%9C%BA%E6%8C%87%E9%92%88%E7%9A%84%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<h3 id="一、题目描述"><a href="#一、题目描述" class="headerlink" title="一、题目描述"></a>一、题目描述</h3><p>给定一个链表，每个节点包含一个额外增加的随机指针，该指针可以指向链表中的任何节点或空节点。</p>
<p>要求返回这个链表的深拷贝。 </p>
<span id="more"></span>

<p>我们用一个由 n 个节点组成的链表来表示输入/输出中的链表。每个节点用一个 [val, random_index] 表示：</p>
<ul>
<li>val：一个表示 Node.val 的整数。</li>
<li>random_index：随机指针指向的节点索引（范围从 0 到 n-1）；如果不指向任何节点，则为  null 。</li>
</ul>
<p><strong>示例 1：</strong></p>
<p><img src="/2021/04/30/%E9%93%BE%E8%A1%A8%EF%BC%9A%E5%A4%8D%E5%88%B6%E5%B8%A6%E9%9A%8F%E6%9C%BA%E6%8C%87%E9%92%88%E7%9A%84%E9%93%BE%E8%A1%A8/1.png" alt="image-20201213164012901"></p>
<p>输入：head = [[7,null],[13,0],[11,4],[10,2],[1,0]]</p>
<p>输出：[[7,null],[13,0],[11,4],[10,2],[1,0]]</p>
<p><strong>示例 2：</strong></p>
<p><img src="/2021/04/30/%E9%93%BE%E8%A1%A8%EF%BC%9A%E5%A4%8D%E5%88%B6%E5%B8%A6%E9%9A%8F%E6%9C%BA%E6%8C%87%E9%92%88%E7%9A%84%E9%93%BE%E8%A1%A8/2.png" alt="image-20201213164032257"></p>
<p>输入：head = [[1,1],[2,1]]</p>
<p>输出：[[1,1],[2,1]]</p>
<p><strong>示例 3：</strong></p>
<p><img src="/2021/04/30/%E9%93%BE%E8%A1%A8%EF%BC%9A%E5%A4%8D%E5%88%B6%E5%B8%A6%E9%9A%8F%E6%9C%BA%E6%8C%87%E9%92%88%E7%9A%84%E9%93%BE%E8%A1%A8/3.png" alt="image-20201213164059316"></p>
<p>输入：head = [[3,null],[3,0],[3,null]]</p>
<p>输出：[[3,null],[3,0],[3,null]]</p>
<p><strong>示例 4：</strong></p>
<p>输入：head = []</p>
<p>输出：[]<br>解释：给定的链表为空（空指针），因此返回 null。</p>
<p><strong>提示：</strong></p>
<ul>
<li>-10000 &lt;= Node.val &lt;= 10000</li>
<li>Node.random 为空（null）或指向链表中的节点。</li>
<li>节点数目不超过 1000 。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">// Definition for a Node.</span></span><br><span class="line"><span class="comment">class Node &#123;</span></span><br><span class="line"><span class="comment">public:</span></span><br><span class="line"><span class="comment">    int val;</span></span><br><span class="line"><span class="comment">    Node* next;</span></span><br><span class="line"><span class="comment">    Node* random;</span></span><br><span class="line"><span class="comment">    </span></span><br><span class="line"><span class="comment">    Node(int _val) &#123;</span></span><br><span class="line"><span class="comment">        val = _val;</span></span><br><span class="line"><span class="comment">        next = NULL;</span></span><br><span class="line"><span class="comment">        random = NULL;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Node* <span class="title">copyRandomList</span><span class="params">(Node* head)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//to do</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h3 id="二、解题思路"><a href="#二、解题思路" class="headerlink" title="二、解题思路"></a>二、解题思路</h3><ol>
<li><p>使用哈希图，先生成与原来链表相同个数的节点</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">unordered_map&lt;Node*,Node*&gt;nodemap;</span><br><span class="line">   nodemap[<span class="literal">nullptr</span>]=<span class="literal">nullptr</span>;</span><br><span class="line">   Node* p=head;</span><br><span class="line">   <span class="keyword">while</span>(p)&#123;</span><br><span class="line">       nodemap[p]=<span class="keyword">new</span> <span class="built_in">Node</span>(p-&gt;val);</span><br><span class="line">       p=p-&gt;next;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></li>
<li><p>使哈希图中每个节点等于原节点</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">p=head;</span><br><span class="line">  <span class="keyword">while</span>(p!=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">      nodemap[p]-&gt;next=nodemap[p-&gt;next];</span><br><span class="line">      p=p-&gt;next;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li>
<li><p>再复制random指针</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">p=head;</span><br><span class="line"><span class="keyword">while</span>(p!=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">    nodemap[p]-&gt;random=nodemap[p-&gt;random];</span><br><span class="line">    p=p-&gt;next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="三、我的代码"><a href="#三、我的代码" class="headerlink" title="三、我的代码"></a>三、我的代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">// Definition for a Node.</span></span><br><span class="line"><span class="comment">class Node &#123;</span></span><br><span class="line"><span class="comment">public:</span></span><br><span class="line"><span class="comment">    int val;</span></span><br><span class="line"><span class="comment">    Node* next;</span></span><br><span class="line"><span class="comment">    Node* random;</span></span><br><span class="line"><span class="comment">    </span></span><br><span class="line"><span class="comment">    Node(int _val) &#123;</span></span><br><span class="line"><span class="comment">        val = _val;</span></span><br><span class="line"><span class="comment">        next = NULL;</span></span><br><span class="line"><span class="comment">        random = NULL;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Node* <span class="title">copyRandomList</span><span class="params">(Node* head)</span> </span>&#123;</span><br><span class="line">        unordered_map&lt;Node*,Node*&gt;nodemap;</span><br><span class="line">        nodemap[<span class="literal">nullptr</span>]=<span class="literal">nullptr</span>;</span><br><span class="line">        Node* p=head;</span><br><span class="line">        <span class="keyword">while</span>(p!=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">            nodemap[p]=<span class="keyword">new</span> <span class="built_in">Node</span>(p-&gt;val);</span><br><span class="line">            p=p-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        p=head;</span><br><span class="line">        <span class="keyword">while</span>(p!=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">            nodemap[p]-&gt;next=nodemap[p-&gt;next];</span><br><span class="line">            p=p-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        p=head;</span><br><span class="line">        <span class="keyword">while</span>(p!=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">            nodemap[p]-&gt;random=nodemap[p-&gt;random];</span><br><span class="line">            p=p-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nodemap[head];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法</category>
        <category>链表</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>leetcode</tag>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title>奇偶链表</title>
    <url>/2021/04/30/%E9%93%BE%E8%A1%A8%EF%BC%9A%E5%A5%87%E5%81%B6%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<h1 id="LeetCode328：奇偶链表"><a href="#LeetCode328：奇偶链表" class="headerlink" title="LeetCode328：奇偶链表"></a>LeetCode328：奇偶链表</h1><h3 id="一、题目描述"><a href="#一、题目描述" class="headerlink" title="一、题目描述"></a>一、题目描述</h3><p>&ensp;&ensp;&ensp;&ensp;给定一个单链表，把所有的奇数节点和偶数节点分别排在一起。请注意，这里的奇数节点和偶数节点指的是节点编号的奇偶性，而不是节点的值的奇偶性。</p>
<span id="more"></span>

<p>&ensp;&ensp;&ensp;&ensp;请尝试使用原地算法完成。你的算法的空间复杂度应为 O(1)，时间复杂度应为 O(nodes)，nodes 为节点总数。<br>示例 1:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL</span><br><span class="line">输出: 1-&gt;3-&gt;5-&gt;2-&gt;4-&gt;NULL</span><br></pre></td></tr></table></figure>
<p>示例 2:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: 2-&gt;1-&gt;3-&gt;5-&gt;6-&gt;4-&gt;7-&gt;NULL </span><br><span class="line">输出: 2-&gt;3-&gt;6-&gt;7-&gt;1-&gt;5-&gt;4-&gt;NULL</span><br></pre></td></tr></table></figure>
<p>说明:<br>&ensp;&ensp;&ensp;&ensp;应当保持奇数节点和偶数节点的相对顺序。<br>&ensp;&ensp;&ensp;&ensp;链表的第一个节点视为奇数节点，第二个节点视为偶数节点，以此类推。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">oddEvenList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="二、解题思路"><a href="#二、解题思路" class="headerlink" title="二、解题思路"></a>二、解题思路</h3><p>&ensp;&ensp;&ensp;&ensp;看图</p>
<img src="/2021/04/30/%E9%93%BE%E8%A1%A8%EF%BC%9A%E5%A5%87%E5%81%B6%E9%93%BE%E8%A1%A8/1.png" alt="image-20210430234220085" style="zoom:80%;">

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(p-&gt;next!=<span class="literal">nullptr</span>&amp;&amp;q-&gt;next!=<span class="literal">nullptr</span>)&#123;        </span><br><span class="line">               p-&gt;next=q-&gt;next;</span><br><span class="line">               p=p-&gt;next;</span><br><span class="line">               q-&gt;next=p-&gt;next;</span><br><span class="line">               q=q-&gt;next;</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure>

<h3 id="三、我的代码"><a href="#三、我的代码" class="headerlink" title="三、我的代码"></a>三、我的代码</h3><p>&ensp;&ensp;&ensp;&ensp;直接在力扣上写的。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">oddEvenList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head==<span class="literal">nullptr</span>)</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        ListNode* p=head;</span><br><span class="line">        ListNode* head1=head-&gt;next;</span><br><span class="line">        ListNode* q=head-&gt;next;</span><br><span class="line">        <span class="keyword">while</span>(p-&gt;next!=<span class="literal">nullptr</span>&amp;&amp;q-&gt;next!=<span class="literal">nullptr</span>)&#123;        </span><br><span class="line">                p-&gt;next=q-&gt;next;</span><br><span class="line">                p=p-&gt;next;</span><br><span class="line">                q-&gt;next=p-&gt;next;</span><br><span class="line">                q=q-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        p-&gt;next=head1;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法</category>
        <category>链表</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>leetcode</tag>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title>扁平化多级双向链表</title>
    <url>/2021/04/30/%E9%93%BE%E8%A1%A8%EF%BC%9A%E6%89%81%E5%B9%B3%E5%8C%96%E5%A4%9A%E7%BA%A7%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<h3 id="一、题目描述"><a href="#一、题目描述" class="headerlink" title="一、题目描述"></a>一、题目描述</h3><p>    多级双向链表中，除了指向下一个节点和前一个节点指针之外，它还有一个子链表指针，可能指向单独的双向链表。这些子列表也可能会有一个或多个自己的子项，依此类推，生成多级数据结构，如下面的示例所示。</p>
<span id="more"></span>

<p>    给你位于列表第一级的头节点，请你扁平化列表，使所有结点出现在单级双链表中。 </p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：head &#x3D; [1,2,3,4,5,6,null,null,null,7,8,9,10,null,null,11,12]</span><br><span class="line">输出：[1,2,3,7,8,11,12,9,10,4,5,6]</span><br></pre></td></tr></table></figure>

<p>解释：</p>
<p>    输入的多级列表如下图所示：</p>
<p><img src="/2021/04/30/%E9%93%BE%E8%A1%A8%EF%BC%9A%E6%89%81%E5%B9%B3%E5%8C%96%E5%A4%9A%E7%BA%A7%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8/1.png" alt="image-20201213163356430"></p>
<p>    扁平化后的链表如下图：</p>
<p><img src="/2021/04/30/%E9%93%BE%E8%A1%A8%EF%BC%9A%E6%89%81%E5%B9%B3%E5%8C%96%E5%A4%9A%E7%BA%A7%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8/2.png" alt="image-20201213163430536"></p>
<p><strong>示例 2：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：head &#x3D; [1,2,null,3]</span><br><span class="line">输出：[1,3,2]</span><br><span class="line">解释：</span><br><span class="line"></span><br><span class="line">输入的多级列表如下图所示：</span><br><span class="line"></span><br><span class="line">  1---2---NULL</span><br><span class="line">  |</span><br><span class="line">  3---NULL</span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：head &#x3D; []</span><br><span class="line">输出：[]</span><br></pre></td></tr></table></figure>

<p>    <strong>如何表示测试用例中的多级链表？</strong></p>
<p>    以 <strong>示例 1</strong> 为例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1---2---3---4---5---6--NULL</span><br><span class="line">        |</span><br><span class="line">        7---8---9---10--NULL</span><br><span class="line">            |</span><br><span class="line">            11--12--NULL</span><br></pre></td></tr></table></figure>

<p>    序列化其中的每一级之后：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[1,2,3,4,5,6,null]</span><br><span class="line">[7,8,9,10,null]</span><br><span class="line">[11,12,null]</span><br></pre></td></tr></table></figure>

<p>    为了将每一级都序列化到一起，我们需要每一级中添加值为 null 的元素，以表示没有节点连接到上一级的上级节点。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[1,2,3,4,5,6,null]</span><br><span class="line">[null,null,7,8,9,10,null]</span><br><span class="line">[null,11,12,null]</span><br></pre></td></tr></table></figure>

<p>    合并所有序列化结果，并去除末尾的 null 。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[1,2,3,4,5,6,null,null,null,7,8,9,10,null,null,11,12]</span><br></pre></td></tr></table></figure>

<p> <strong>提示：</strong></p>
<ul>
<li>节点数目不超过 1000</li>
<li>1 &lt;= Node.val &lt;= 10^5</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">// Definition for a Node.</span></span><br><span class="line"><span class="comment">class Node &#123;</span></span><br><span class="line"><span class="comment">public:</span></span><br><span class="line"><span class="comment">    int val;</span></span><br><span class="line"><span class="comment">    Node* prev;</span></span><br><span class="line"><span class="comment">    Node* next;</span></span><br><span class="line"><span class="comment">    Node* child;</span></span><br><span class="line"><span class="comment">&#125;;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Node* <span class="title">flatten</span><span class="params">(Node* head)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//to do</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="二、解题思路"><a href="#二、解题思路" class="headerlink" title="二、解题思路"></a>二、解题思路</h3><ol>
<li><p>对于每个节点，先用双指针：p，pNext=p-&gt;next，当p-&gt;child为空时，p指针向后移动。</p>
</li>
<li><p>当p-&gt;child不为空</p>
<p>2.1将p与p-&gt;child连接为双向链表结构，并将p-&gt;child置为空；</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Node* pChild=p-&gt;child;</span><br><span class="line">p-&gt;next=pChild;</span><br><span class="line">pChild-&gt;prev=p;</span><br><span class="line">p-&gt;child=<span class="literal">nullptr</span>;</span><br></pre></td></tr></table></figure>

<p>2.2找到p-&gt;child那条子链的尾节点，并与pNext连为双向链表结构</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Node* tail=pChild;</span><br><span class="line"><span class="keyword">while</span>(tail-&gt;next!=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">	tail=tail-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line">tail-&gt;next=pNext;</span><br><span class="line"><span class="keyword">if</span>(pNext!=<span class="literal">nullptr</span>)</span><br><span class="line">	pNext-&gt;prev=tail;  </span><br></pre></td></tr></table></figure></li>
</ol>
<p><img src="/2021/04/30/%E9%93%BE%E8%A1%A8%EF%BC%9A%E6%89%81%E5%B9%B3%E5%8C%96%E5%A4%9A%E7%BA%A7%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8/3.png" alt="image-20201213205439630"></p>
<p><img src="/2021/04/30/%E9%93%BE%E8%A1%A8%EF%BC%9A%E6%89%81%E5%B9%B3%E5%8C%96%E5%A4%9A%E7%BA%A7%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8/4.png" alt="image-20201213205445673"></p>
<p><img src="/2021/04/30/%E9%93%BE%E8%A1%A8%EF%BC%9A%E6%89%81%E5%B9%B3%E5%8C%96%E5%A4%9A%E7%BA%A7%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8/5.png" alt="image-20201213205450099"></p>
<p>    以上三图是消除一条子链的情况。</p>
<h3 id="三、我的代码"><a href="#三、我的代码" class="headerlink" title="三、我的代码"></a>三、我的代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">// Definition for a Node.</span></span><br><span class="line"><span class="comment">class Node &#123;</span></span><br><span class="line"><span class="comment">public:</span></span><br><span class="line"><span class="comment">    int val;</span></span><br><span class="line"><span class="comment">    Node* prev;</span></span><br><span class="line"><span class="comment">    Node* next;</span></span><br><span class="line"><span class="comment">    Node* child;</span></span><br><span class="line"><span class="comment">&#125;;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Node* <span class="title">flatten</span><span class="params">(Node* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head==<span class="literal">nullptr</span>)</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        Node* p=head;</span><br><span class="line">        <span class="keyword">while</span>(p!=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">            Node* pNext=p-&gt;next;</span><br><span class="line">            <span class="keyword">if</span>(p-&gt;child!=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">                Node* pChild=p-&gt;child;</span><br><span class="line">                p-&gt;next=pChild;</span><br><span class="line">                pChild-&gt;prev=p;</span><br><span class="line">                p-&gt;child=<span class="literal">nullptr</span>;</span><br><span class="line">                Node* tail=pChild;</span><br><span class="line">                <span class="keyword">while</span>(tail-&gt;next!=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">                    tail=tail-&gt;next;</span><br><span class="line">                &#125;</span><br><span class="line">                tail-&gt;next=pNext;</span><br><span class="line">                <span class="keyword">if</span>(pNext!=<span class="literal">nullptr</span>)</span><br><span class="line">                    pNext-&gt;prev=tail;                </span><br><span class="line">            &#125;</span><br><span class="line">            p=p-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法</category>
        <category>链表</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>leetcode</tag>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title>神奇的双指针在链表中的应用</title>
    <url>/2021/04/30/%E9%93%BE%E8%A1%A8%EF%BC%9A%E7%A5%9E%E5%A5%87%E7%9A%84%E5%8F%8C%E6%8C%87%E9%92%88%E5%9C%A8%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8/</url>
    <content><![CDATA[<p>双指针在链表中的应用广泛，尤其涉及到有环的链表。</p>
<span id="more"></span>

<h2 id="141：环形链表1"><a href="#141：环形链表1" class="headerlink" title="141：环形链表1"></a>141：环形链表1</h2><h3 id="一、题目描述"><a href="#一、题目描述" class="headerlink" title="一、题目描述"></a>一、题目描述</h3><p>&ensp;&ensp;&ensp;&ensp;给定一个链表，判断链表中是否有环。<br>&ensp;&ensp;&ensp;&ensp;如果链表中有某个节点，可以通过连续跟踪 next 指针再次到达，则链表中存在环。为了表示给定链表中的环，我们使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。如果 pos 是 -1，则在该链表中没有环。注意：pos 不作为参数进行传递，仅仅是为了标识链表的实际情况。</p>
<p>&ensp;&ensp;&ensp;&ensp;如果链表中存在环，则返回 true 。 否则，返回 false 。<br><em>进阶</em>：<br>&ensp;&ensp;&ensp;&ensp;你能用 O(1)（即，常量）内存解决此问题吗？<br><em>提示</em>：<br>&ensp;&ensp;&ensp;&ensp;链表中节点的数目范围是 [0, 104]<br>&ensp;&ensp;&ensp;&ensp;-105 &lt;= Node.val &lt;= 105<br>&ensp;&ensp;&ensp;&ensp;pos 为 -1 或者链表中的一个 有效索引 。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">hasCycle</span><span class="params">(ListNode *head)</span> </span>&#123;</span><br><span class="line">       <span class="comment">//to do</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><img src="/2021/04/30/%E9%93%BE%E8%A1%A8%EF%BC%9A%E7%A5%9E%E5%A5%87%E7%9A%84%E5%8F%8C%E6%8C%87%E9%92%88%E5%9C%A8%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8/1.png"></p>
<h3 id="二、解题思路"><a href="#二、解题思路" class="headerlink" title="二、解题思路"></a>二、解题思路</h3><p>&ensp;&ensp;&ensp;&ensp;为了防止越界问题，每次都需提前判断指针是否为nullptr；两个指针，一快一慢，当二者相等，则有环（快指针在环中转了几圈后“追上”慢的）。</p>
<h3 id="三、我的代码"><a href="#三、我的代码" class="headerlink" title="三、我的代码"></a>三、我的代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">hasCycle</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        ListNode* p1 = head;</span><br><span class="line">        <span class="keyword">if</span> (p1 == <span class="literal">nullptr</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        ListNode* p2 = head;</span><br><span class="line">        <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (p1-&gt;next == <span class="literal">nullptr</span> || p2-&gt;next == <span class="literal">nullptr</span> || p2-&gt;next-&gt;next == <span class="literal">nullptr</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            p1 = p1-&gt;next;		<span class="comment">//跑的慢</span></span><br><span class="line">            p2 = p2-&gt;next-&gt;next;<span class="comment">//跑的快</span></span><br><span class="line">            <span class="keyword">if</span> (p1 == p2)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;            </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="142：环形链表2"><a href="#142：环形链表2" class="headerlink" title="142：环形链表2"></a>142：环形链表2</h2><h3 id="一、题目描述-1"><a href="#一、题目描述-1" class="headerlink" title="一、题目描述"></a>一、题目描述</h3><p>给定一个链表，返回链表开始入环的第一个节点。 如果链表无环，则返回 null。</p>
<p>为了表示给定链表中的环，我们使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。注意，pos 仅仅是用于标识环的情况，并不会作为参数传递到函数中。<br><em>说明：</em><br>&ensp;&ensp;&ensp;&ensp;不允许修改给定的链表。<br><em>进阶：</em><br>&ensp;&ensp;&ensp;&ensp;你是否可以使用 O(1) 空间解决此题？<br><img src="/2021/04/30/%E9%93%BE%E8%A1%A8%EF%BC%9A%E7%A5%9E%E5%A5%87%E7%9A%84%E5%8F%8C%E6%8C%87%E9%92%88%E5%9C%A8%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8/2.png" style="zoom:50%;"></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>: </span><br><span class="line">    <span class="function">ListNode *<span class="title">detectCycle</span><span class="params">(ListNode *head)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//to do</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="二、解题思路-1"><a href="#二、解题思路-1" class="headerlink" title="二、解题思路"></a>二、解题思路</h3><p>&ensp;&ensp;&ensp;&ensp;我们使用两个指针，fast 与 slow。它们起始都位于链表的头部。随后，slow 指针每次向后移动一个位置，而 fast 指针向后移动两个位置。如果链表中存在环，则 fast 指针最终将再次与slow 指针在环中相遇。</p>
<p>&ensp;&ensp;&ensp;&ensp;如下图所示，设链表中环外部分的长度为 a。slow 指针进入环后，又走了b 的距离与 fast 相遇。此时fast 指针已经走完了环的 n 圈，因此它走过的总距离为 a+n(b+c)+b=a+(n+1)b+nca+n(b+c)+b=a+(n+1)b+nc。<br><img src="/%E9%93%BE%E8%A1%A8%EF%BC%9A%E7%A5%9E%E5%A5%87%E7%9A%84%E5%8F%8C%E6%8C%87%E9%92%88%E5%9C%A8%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8/3.png"></p>
<p>&ensp;&ensp;&ensp;&ensp;根据题意，任意时刻，fast 指针走过的距离都为 slow 指针的 2 倍。因此，我们有<br>a+(n+1)b+nc=2(a+b)⟹a=c+(n−1)(b+c)<br>&ensp;&ensp;&ensp;&ensp;有了 a=c+(n-1)(b+c)a=c+(n−1)(b+c) 的等量关系，我们会发现：从相遇点到入环点的距离加上 n-1n−1 圈的环长，恰好等于从链表头部到入环点的距离。<br>&ensp;&ensp;&ensp;&ensp;因此，当发现 slow 与 fast 相遇时，我们再额外使用一个指针ptr。起始，它指向链表头部；随后，它和 slow 每次向后移动一个位置。最终，它们会在入环点相遇。<br>&ensp;&ensp;&ensp;&ensp;数学大法好！！！💀💀💀💀</p>
<h3 id="三、我的代码-1"><a href="#三、我的代码-1" class="headerlink" title="三、我的代码"></a>三、我的代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">   <span class="function">ListNode* <span class="title">detectCycle</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        ListNode* p1 = head;</span><br><span class="line">        <span class="keyword">if</span> (p1 == <span class="literal">nullptr</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        ListNode* p2 = head;</span><br><span class="line">        <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (p1-&gt;next == <span class="literal">nullptr</span> || p2-&gt;next == <span class="literal">nullptr</span> || p2-&gt;next-&gt;next == <span class="literal">nullptr</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">            p1 = p1-&gt;next;</span><br><span class="line">            p2 = p2-&gt;next-&gt;next;</span><br><span class="line">            <span class="keyword">if</span> (p1 == p2) &#123;</span><br><span class="line">                ListNode* ptr = head;</span><br><span class="line">                <span class="keyword">while</span> (ptr != p1) &#123;</span><br><span class="line">                    ptr = ptr-&gt;next;</span><br><span class="line">                    p1 = p1-&gt;next;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> ptr;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="160：相交链表"><a href="#160：相交链表" class="headerlink" title="160：相交链表"></a>160：相交链表</h2><h3 id="一、题目描述-2"><a href="#一、题目描述-2" class="headerlink" title="一、题目描述"></a>一、题目描述</h3><p>&ensp;&ensp;&ensp;&ensp;编写一个程序，找到两个单链表相交的起始节点。<br>&ensp;&ensp;&ensp;&ensp;如下面的两个链表：在节点 c1 开始相交。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">示例 1：</span><br><span class="line">输入：intersectVal &#x3D; 8, listA &#x3D; [4,1,8,4,5], listB &#x3D; [5,0,1,8,4,5], skipA &#x3D; 2, skipB &#x3D; 3</span><br><span class="line">输出：Reference of the node with value &#x3D; 8</span><br><span class="line">输入解释：相交节点的值为 8 （注意，如果两个链表相交则不能为 0）。从各自的表头开始算起，链表 A 为 [4,1,8,4,5]，链表 B 为 [5,0,1,8,4,5]。在 A 中，相交节点前有 2 个节点；在 B 中，相交节点前有 3 个节点。</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line">输入：intersectVal &#x3D; 2, listA &#x3D; [0,9,1,2,4], listB &#x3D; [3,2,4], skipA &#x3D; 3, skipB &#x3D; 1</span><br><span class="line">输出：Reference of the node with value &#x3D; 2</span><br><span class="line">输入解释：相交节点的值为 2 （注意，如果两个链表相交则不能为 0）。从各自的表头开始算起，链表 A 为 [0,9,1,2,4]，链表 B 为 [3,2,4]。在 A 中，相交节点前有 3 个节点；在 B 中，相交节点前有 1 个节点。</span><br><span class="line"></span><br><span class="line">示例 3：</span><br><span class="line">输入：intersectVal &#x3D; 0, listA &#x3D; [2,6,4], listB &#x3D; [1,5], skipA &#x3D; 3, skipB &#x3D; 2</span><br><span class="line">输出：null</span><br><span class="line">输入解释：从各自的表头开始算起，链表 A 为 [2,6,4]，链表 B 为 [1,5]。由于这两个链表不相交，所以 intersectVal 必须为 0，而 skipA 和 skipB 可以是任意值。</span><br><span class="line">解释：这两个链表不相交，因此返回 null。</span><br></pre></td></tr></table></figure>

<p>注意：<br>&ensp;&ensp;&ensp;&ensp;如果两个链表没有交点，返回 null.<br>&ensp;&ensp;&ensp;&ensp;在返回结果后，两个链表仍须保持原有的结构。<br>&ensp;&ensp;&ensp;&ensp;可假定整个链表结构中没有循环。<br>&ensp;&ensp;&ensp;&ensp;程序尽量满足 O(n) 时间复杂度，且仅用 O(1) 内存。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode *<span class="title">getIntersectionNode</span><span class="params">(ListNode *headA, ListNode *headB)</span> </span>&#123;</span><br><span class="line">    		<span class="comment">//to do</span></span><br><span class="line">       &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="二、解题思路-2"><a href="#二、解题思路-2" class="headerlink" title="二、解题思路"></a>二、解题思路</h3><p>&ensp;&ensp;&ensp;&ensp;方法一: 暴力法<br>&ensp;&ensp;&ensp;&ensp;对链表A中的每一个结点 a，遍历整个链表 B 并检查链表 B 中是否存在结点和 a相同。</p>
<p>&ensp;&ensp;&ensp;&ensp;方法二: 双指针法<br>&ensp;&ensp;&ensp;&ensp;创建两个指针 pA 和 pB，分别初始化为链表 A 和 B 的头结点，然后让它们向后逐结点遍历；当 pA 到达链表的尾部时，将它重定位到链表 B 的头结点 (你没看错，就是链表 B); 类似的，当 pB 到达链表的尾部时，将它重定位到链表 A 的头结点；若在某一时刻 pA 和 pB 相遇，则 pA/pB 为相交结点。<br>&ensp;&ensp;&ensp;&ensp;起点虽然不一样，但路程一样,终点一样,速度一样，必定同时到达。</p>
<h3 id="三、我的代码-2"><a href="#三、我的代码-2" class="headerlink" title="三、我的代码"></a>三、我的代码</h3><p>方法一：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">   <span class="function">ListNode* <span class="title">getIntersectionNode</span><span class="params">(ListNode* headA, ListNode* headB)</span> </span>&#123;</span><br><span class="line">        ListNode* pa = headA;</span><br><span class="line">        <span class="keyword">if</span> (pa == <span class="literal">nullptr</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        ListNode* pb = headB;</span><br><span class="line">        <span class="keyword">if</span> (pb == <span class="literal">nullptr</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (pa == pb)</span><br><span class="line">                    <span class="keyword">return</span> pa;</span><br><span class="line">                <span class="keyword">if</span> (pb-&gt;next == <span class="literal">nullptr</span>)</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                pb = pb-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (pa-&gt;next == <span class="literal">nullptr</span>)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            pa = pa-&gt;next;</span><br><span class="line">            pb = headB;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>方法二：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">getIntersectionNode</span><span class="params">(ListNode* headA, ListNode* headB)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = <span class="number">0</span>;</span><br><span class="line">        ListNode* pa = headA;</span><br><span class="line">        ListNode* pb = headB;</span><br><span class="line">        <span class="keyword">if</span> (pa == <span class="literal">nullptr</span> || pb == <span class="literal">nullptr</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">while</span> (n &lt; <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (pa == pb)</span><br><span class="line">                <span class="keyword">return</span> pa;</span><br><span class="line">            <span class="keyword">if</span> (pb-&gt;next == <span class="literal">nullptr</span>)</span><br><span class="line">                pb = headA, n++;<span class="comment">//不能用pb-&gt;next=headA,会改变链表结构</span></span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                pb = pb-&gt;next;</span><br><span class="line">            <span class="keyword">if</span> (pa-&gt;next == <span class="literal">nullptr</span>)</span><br><span class="line">                pa = headB;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                pa = pa-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法</category>
        <category>链表</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>leetcode</tag>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title>移除链表元素</title>
    <url>/2021/04/30/%E9%93%BE%E8%A1%A8%EF%BC%9A%E7%A7%BB%E9%99%A4%E9%93%BE%E8%A1%A8%E5%85%83%E7%B4%A0/</url>
    <content><![CDATA[<h3 id="一、题目描述"><a href="#一、题目描述" class="headerlink" title="一、题目描述"></a>一、题目描述</h3><p>&ensp;&ensp;&ensp;&ensp;删除链表中等于给定值 val 的所有节点。</p>
<span id="more"></span>

<p>示例:</p>
<pre><code>输入: 1-&gt;2-&gt;6-&gt;3-&gt;4-&gt;5-&gt;6, val = 6
输出: 1-&gt;2-&gt;3-&gt;4-&gt;5
</code></pre>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">removeElements</span><span class="params">(ListNode* head, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">		<span class="comment">//to do</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="二、解题思路"><a href="#二、解题思路" class="headerlink" title="二、解题思路"></a>二、解题思路</h3><p>&ensp;&ensp;&ensp;&ensp;当链表为空，返回nullptr;<br>&ensp;&ensp;&ensp;&ensp;确保头节点不是要删除的节点</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(head-&gt;val==val)&#123;</span><br><span class="line">         head=head-&gt;next;</span><br><span class="line">         <span class="keyword">if</span>(head==<span class="literal">nullptr</span>)</span><br><span class="line">             <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure>
<p>&ensp;&ensp;&ensp;&ensp;使用双指针p，q，两指针紧挨着，遇到目标节点则删除</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">ListNode* p=head;</span><br><span class="line">   ListNode* q=p-&gt;next;</span><br><span class="line">   <span class="keyword">while</span>(q!=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">       <span class="keyword">if</span>(q-&gt;val==val)&#123;</span><br><span class="line">           q=q-&gt;next;</span><br><span class="line">           p-&gt;next=q;</span><br><span class="line">           <span class="keyword">continue</span>;</span><br><span class="line">       &#125; </span><br><span class="line">       p=p-&gt;next;</span><br><span class="line">       q=p-&gt;next;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h3 id="三、我的代码"><a href="#三、我的代码" class="headerlink" title="三、我的代码"></a>三、我的代码</h3><p>&ensp;&ensp;&ensp;&ensp;直接在力扣上写的。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">removeElements</span><span class="params">(ListNode* head, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head==<span class="literal">nullptr</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">while</span>(head-&gt;val==val)&#123;</span><br><span class="line">            head=head-&gt;next;</span><br><span class="line">            <span class="keyword">if</span>(head==<span class="literal">nullptr</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(head-&gt;next==<span class="literal">nullptr</span>)</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        ListNode* p=head;</span><br><span class="line">        ListNode* q=p-&gt;next;</span><br><span class="line">        <span class="keyword">while</span>(q!=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(q-&gt;val==val)&#123;</span><br><span class="line">                q=q-&gt;next;</span><br><span class="line">                p-&gt;next=q;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125; </span><br><span class="line">            p=p-&gt;next;</span><br><span class="line">            q=p-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法</category>
        <category>链表</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>leetcode</tag>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title>旋转链表</title>
    <url>/2021/04/30/%E9%93%BE%E8%A1%A8%EF%BC%9A%E6%97%8B%E8%BD%AC%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<h3 id="一、题目描述"><a href="#一、题目描述" class="headerlink" title="一、题目描述"></a>一、题目描述</h3><p>给定一个链表，旋转链表，将链表每个节点向右移动 <em>k</em> 个位置，其中 <em>k</em> 是非负数。</p>
<span id="more"></span>

<p><strong>示例 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL, k &#x3D; 2</span><br><span class="line">输出: 4-&gt;5-&gt;1-&gt;2-&gt;3-&gt;NULL</span><br><span class="line">解释:</span><br><span class="line">向右旋转 1 步: 5-&gt;1-&gt;2-&gt;3-&gt;4-&gt;NULL</span><br><span class="line">向右旋转 2 步: 4-&gt;5-&gt;1-&gt;2-&gt;3-&gt;NULL</span><br></pre></td></tr></table></figure>

<p><strong>示例 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: 0-&gt;1-&gt;2-&gt;NULL, k &#x3D; 4</span><br><span class="line">输出: 2-&gt;0-&gt;1-&gt;NULL</span><br><span class="line">解释:</span><br><span class="line">向右旋转 1 步: 2-&gt;0-&gt;1-&gt;NULL</span><br><span class="line">向右旋转 2 步: 1-&gt;2-&gt;0-&gt;NULL</span><br><span class="line">向右旋转 3 步: 0-&gt;1-&gt;2-&gt;NULL</span><br><span class="line">向右旋转 4 步: 2-&gt;0-&gt;1-&gt;NULL</span><br></pre></td></tr></table></figure>

<h3 id="二、解题思路"><a href="#二、解题思路" class="headerlink" title="二、解题思路"></a>二、解题思路</h3><ol>
<li><p>先确定链表的长度</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> length=<span class="number">0</span>;</span><br><span class="line">        ListNode* p=head;</span><br><span class="line">        <span class="keyword">while</span>(p!=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">            p=p-&gt;next;</span><br><span class="line">            length++;</span><br><span class="line">        &#125;       </span><br></pre></td></tr></table></figure></li>
<li><p>当链表为空或长度为一或移动零步或移动链表的整数倍步时，返回原链表头结点指针</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(length==<span class="number">0</span>||length==<span class="number">1</span>||k==<span class="number">0</span>||k%length==<span class="number">0</span>)</span><br><span class="line">           <span class="keyword">return</span> head;</span><br></pre></td></tr></table></figure></li>
<li><p>前两步之后，另k=k%length，再使一个指针移动到原链表末端</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">k=k%length;</span><br><span class="line">   p=head;</span><br><span class="line">   <span class="keyword">while</span>(p-&gt;next!=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">   	p=p-&gt;next;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></li>
<li><p>使用双指针法，从头开始向末端移动 length-k-1步，再见链表断为两个，重新连接</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">ListNode* t1=head;</span><br><span class="line">   ListNode* t2=head-&gt;next;</span><br><span class="line">   <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;length-k<span class="number">-1</span>;i++)&#123;</span><br><span class="line">   	t1=t1-&gt;next;</span><br><span class="line">       t2=t2-&gt;next;</span><br><span class="line">   &#125;</span><br><span class="line">   t1-&gt;next=<span class="literal">nullptr</span>;</span><br><span class="line">   p-&gt;next=head;</span><br></pre></td></tr></table></figure>

<img src="/2021/04/30/%E9%93%BE%E8%A1%A8%EF%BC%9A%E6%97%8B%E8%BD%AC%E9%93%BE%E8%A1%A8/1.png" style="zoom:80%;">

<img src="/2021/04/30/%E9%93%BE%E8%A1%A8%EF%BC%9A%E6%97%8B%E8%BD%AC%E9%93%BE%E8%A1%A8/2.png" style="zoom:80%;"></li>
</ol>
<h3 id="三、我的代码"><a href="#三、我的代码" class="headerlink" title="三、我的代码"></a>三、我的代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">rotateRight</span><span class="params">(ListNode* head, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> length=<span class="number">0</span>;</span><br><span class="line">        ListNode* p=head;</span><br><span class="line">        <span class="keyword">while</span>(p!=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">            p=p-&gt;next;</span><br><span class="line">            length++;</span><br><span class="line">        &#125;       </span><br><span class="line">        <span class="keyword">if</span>(length==<span class="number">0</span>||length==<span class="number">1</span>||k==<span class="number">0</span>||k%length==<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        k=k%length;</span><br><span class="line">        p=head;</span><br><span class="line">        <span class="keyword">while</span>(p-&gt;next!=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">            p=p-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode* t1=head;</span><br><span class="line">        ListNode* t2=head-&gt;next;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;length-k<span class="number">-1</span>;i++)&#123;</span><br><span class="line">            t1=t1-&gt;next;</span><br><span class="line">            t2=t2-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        t1-&gt;next=<span class="literal">nullptr</span>;</span><br><span class="line">        p-&gt;next=head;</span><br><span class="line">        <span class="keyword">return</span> t2;</span><br><span class="line">    &#125;c</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法</category>
        <category>链表</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>leetcode</tag>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title>设计链表</title>
    <url>/2021/04/30/%E9%93%BE%E8%A1%A8%EF%BC%9A%E8%AE%BE%E8%AE%A1%E9%93%BE%E8%A1%A8%EF%BC%88%E5%8D%95%E9%93%BE%E8%A1%A8%EF%BC%89/</url>
    <content><![CDATA[<h3 id="一、题目描述"><a href="#一、题目描述" class="headerlink" title="一、题目描述"></a>一、题目描述</h3><p>&ensp;&ensp;&ensp;&ensp;设计链表的实现。您可以选择使用单链表或双链表。单链表中的节点应该具有两个属性：val 和 next。val 是当前节点的值，next 是指向下一个节点的指针/引用。如果要使用双向链表，则还需要一个属性 prev 以指示链表中的上一个节点。假设链表中的所有节点都是 0-index 的。</p>
<span id="more"></span>

<p>&ensp;&ensp;&ensp;&ensp;在链表类中实现这些功能：</p>
<p>&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;get(index)：获取链表中第 index 个节点的值。如果索引无效，则返回-1。<br>&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;addAtHead(val)：在链表的第一个元素之前添加一个值为 val 的节点。插入后，新节点将成为链表的第一个节点。<br>&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;addAtTail(val)：将值为 val 的节点追加到链表的最后一个元素。<br>&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;addAtIndex(index,val)：在链表中的第 index 个节点之前添加值为 val  的节点。如果 index 等于链表的长度，则该节点将附加到链表的末尾。如果 index 大于链表长度，则不会插入节点。如果index小于0，则在头部插入节点。<br>&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;deleteAtIndex(index)：如果索引 index 有效，则删除链表中的第 index 个节点。</p>
<p>&ensp;&ensp;&ensp;&ensp;示例：</p>
<pre><code>MyLinkedList linkedList = new MyLinkedList();
linkedList.addAtHead(1);
linkedList.addAtTail(3);
linkedList.addAtIndex(1,2);   //链表变为1-&gt; 2-&gt; 3
linkedList.get(1);            //返回2
linkedList.deleteAtIndex(1);  //现在链表是1-&gt; 3
linkedList.get(1);            //返回3
</code></pre>
<p>&ensp;&ensp;&ensp;&ensp;提示：</p>
<p>&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;所有val值都在 [1, 1000] 之内。<br>&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;操作次数将在  [1, 1000] 之内。<br>&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;请不要使用内置的 LinkedList 库。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyLinkedList</span> &#123;</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/** Initialize your data structure here. */</span></span><br><span class="line">    <span class="built_in">MyLinkedList</span>() &#123;</span><br><span class="line">       </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Get the value of the index-th node in the linked list. If the index is invalid, return -1. */</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Add a node of value val before the first element of the linked list. After the insertion, the new node will be the first node of the linked list. */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addAtHead</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">       </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Append a node of value val to the last element of the linked list. */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addAtTail</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Add a node of value val before the index-th node in the linked list. If index equals to the length of linked list, the node will be appended to the end of linked list. If index is greater than the length, the node will not be inserted. */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addAtIndex</span><span class="params">(<span class="keyword">int</span> index, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Delete the index-th node in the linked list, if the index is valid. */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">deleteAtIndex</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your MyLinkedList object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * MyLinkedList* obj = new MyLinkedList();</span></span><br><span class="line"><span class="comment"> * int param_1 = obj-&gt;get(index);</span></span><br><span class="line"><span class="comment"> * obj-&gt;addAtHead(val);</span></span><br><span class="line"><span class="comment"> * obj-&gt;addAtTail(val);</span></span><br><span class="line"><span class="comment"> * obj-&gt;addAtIndex(index,val);</span></span><br><span class="line"><span class="comment"> * obj-&gt;deleteAtIndex(index);</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>
<h3 id="二、解题思路"><a href="#二、解题思路" class="headerlink" title="二、解题思路"></a>二、解题思路</h3><p>&ensp;&ensp;&ensp;&ensp;首先定义链表节点（Node）的结构，它有一个值val，和指向下个节点的指针<em>next；故有Node(int x):val(x),next(NULL){}：定义一个节点，它的值为x，下个节点为空。<br>&ensp;&ensp;&ensp;&ensp;链表的属性、成员有链表的长度（size），指向链表头结点的指针（</em>dummy），其作用域标记为private。<br>&ensp;&ensp;&ensp;&ensp; MyLinkedList() ，初始化一个链表，长度为0，只有个dummy。<br>&ensp;&ensp;&ensp;&ensp;get(index)：先判断index是否有效：index&gt;(size-1)||index&lt;0则无效，然后生成一个指针，移到目标节点即可。<br>&ensp;&ensp;&ensp;&ensp;addAtHead(val)：初始化一个节点head，将head指向头节点，dummy指向head。<br>&ensp;&ensp;&ensp;&ensp;addAtTail(val)：遍历到尾节点，加上去即可<br>&ensp;&ensp;&ensp;&ensp;addAtIndex(index,val)：先判断index是否有效：size&lt;index则返回空值；然后将指针移到第 index 个节点之前的那个节点，插入即可（使之成为第index个节点）<br>&ensp;&ensp;&ensp;&ensp;deleteAtIndex(index)：先判断index是否有效：index&gt;=size||index&lt;0则返回空值；然后将指针移到第 index 个节点之前的那个节点，删除后面那个节点，再连接后面节点的后面节点即可。（老套娃了🐶🐶🐶）</p>
<h5 id="全场最佳：将指针移到第-index-个节点之前的那个节点"><a href="#全场最佳：将指针移到第-index-个节点之前的那个节点" class="headerlink" title="全场最佳：将指针移到第 index 个节点之前的那个节点"></a>全场最佳：将指针移到第 index 个节点之前的那个节点</h5><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//index从0开始，第一个结点的index为0，题目是这么要求的🐶</span></span><br><span class="line">	Node *head=dummy;</span><br><span class="line">      <span class="keyword">while</span>(index--)&#123;</span><br><span class="line">          head=head-&gt;next;</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure>

<h3 id="三、我的代码"><a href="#三、我的代码" class="headerlink" title="三、我的代码"></a>三、我的代码</h3><p>&ensp;&ensp;&ensp;&ensp;直接在力扣上写的。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyLinkedList</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">        <span class="keyword">int</span> val;</span><br><span class="line">        Node *next;</span><br><span class="line">        <span class="built_in">Node</span>(<span class="keyword">int</span> x):<span class="built_in">val</span>(x),<span class="built_in">next</span>(<span class="literal">NULL</span>)&#123;&#125;</span><br><span class="line">    &#125;;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> size;</span><br><span class="line">    Node *dummy;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/** Initialize your data structure here. */</span></span><br><span class="line">    <span class="built_in">MyLinkedList</span>() &#123;</span><br><span class="line">        dummy=<span class="keyword">new</span> <span class="built_in">Node</span>(<span class="number">0</span>);</span><br><span class="line">        size=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Get the value of the index-th node in the linked list. If the index is invalid, return -1. */</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(index&gt;(size<span class="number">-1</span>)||index&lt;<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        Node *head=dummy-&gt;next;</span><br><span class="line">        <span class="keyword">while</span>(index--)&#123;</span><br><span class="line">            head=head-&gt;next;            </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> head-&gt;val;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Add a node of value val before the first element of the linked list. After the insertion, the new node will be the first node of the linked list. */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addAtHead</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        Node *head=<span class="keyword">new</span> <span class="built_in">Node</span>(val);</span><br><span class="line">        head-&gt;next=dummy-&gt;next;</span><br><span class="line">        dummy-&gt;next=head;</span><br><span class="line">        size++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Append a node of value val to the last element of the linked list. */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addAtTail</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        Node *tailNode=dummy;</span><br><span class="line">        Node *newTailNode=<span class="keyword">new</span> <span class="built_in">Node</span>(val);</span><br><span class="line">        <span class="keyword">while</span>(tailNode-&gt;next!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">            tailNode=tailNode-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        tailNode-&gt;next=newTailNode;</span><br><span class="line">        size++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Add a node of value val before the index-th node in the linked list. If index equals to the length of linked list, the node will be appended to the end of linked list. If index is greater than the length, the node will not be inserted. */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addAtIndex</span><span class="params">(<span class="keyword">int</span> index, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(size&lt;index)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        Node *head=dummy;</span><br><span class="line">        Node *t=<span class="keyword">new</span> <span class="built_in">Node</span>(val);</span><br><span class="line">        <span class="keyword">while</span>(index--)&#123;</span><br><span class="line">            head=head-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        t-&gt;next=head-&gt;next;</span><br><span class="line">        head-&gt;next=t;</span><br><span class="line">        size++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Delete the index-th node in the linked list, if the index is valid. */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">deleteAtIndex</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(index&gt;=size||index&lt;<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        Node *head=dummy;</span><br><span class="line">        <span class="keyword">while</span>(index--)&#123;</span><br><span class="line">            head=head-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        Node *t=head-&gt;next;</span><br><span class="line">        head-&gt;next=head-&gt;next-&gt;next;</span><br><span class="line">        <span class="keyword">delete</span> t;</span><br><span class="line">        size--;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your MyLinkedList object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * MyLinkedList* obj = new MyLinkedList();</span></span><br><span class="line"><span class="comment"> * int param_1 = obj-&gt;get(index);</span></span><br><span class="line"><span class="comment"> * obj-&gt;addAtHead(val);</span></span><br><span class="line"><span class="comment"> * obj-&gt;addAtTail(val);</span></span><br><span class="line"><span class="comment"> * obj-&gt;addAtIndex(index,val);</span></span><br><span class="line"><span class="comment"> * obj-&gt;deleteAtIndex(index);</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法</category>
        <category>链表</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>leetcode</tag>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title>shell入门</title>
    <url>/2021/05/06/Shell%EF%BC%9AShell%E5%85%A5%E9%97%A8%E7%9F%A5%E8%AF%86/</url>
    <content><![CDATA[<h3 id="Shell概述"><a href="#Shell概述" class="headerlink" title="Shell概述"></a>Shell概述</h3><p>&ensp;&ensp;&ensp;&ensp;Shell是一个命令行解释器，它接受应用程序/用户命令，然后调用操作系统内核。</p>
<span id="more"></span>

<p><img src="/2021/05/06/Shell%EF%BC%9AShell%E5%85%A5%E9%97%A8%E7%9F%A5%E8%AF%86/shell.png"></p>
<p>&ensp;&ensp;&ensp;&ensp;Shell还是一个功能相当强大的编程语言，易编写、易调试、灵活性强。</p>
<p><a href="https://www.runoob.com/linux/linux-shell.html">Shell 教程</a></p>
<h3 id="Shell解析器"><a href="#Shell解析器" class="headerlink" title="Shell解析器"></a>Shell解析器</h3><ul>
<li><p>Linux提供的shell解析器</p>
  <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">james@james-Vostro-5471:~$ sudo cat /etc/shells</span><br><span class="line">[sudo] james 的密码： </span><br><span class="line"><span class="meta">#</span><span class="bash"> /etc/shells: valid login shells</span></span><br><span class="line">/bin/sh</span><br><span class="line">/bin/bash</span><br><span class="line">/bin/rbash</span><br><span class="line">/bin/dash</span><br></pre></td></tr></table></figure>
</li>
<li><p>bash和sh的关系（sh调用bash）</p>
  <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">root@james-Vostro-5471:/bin# ll | grep bash</span><br><span class="line">-rwxr-xr-x  1 root root 1113504 6月   7  2019 bash*</span><br><span class="line">lrwxrwxrwx  1 root root       4 3月  11  2020 rbash -&gt; bash*</span><br></pre></td></tr></table></figure></li>
<li><p>SUSE默认的shell解析器是bash</p>
  <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">james@james-Vostro-5471:~$ echo $SHELL</span><br><span class="line">/bin/bash</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="Shell脚本入门"><a href="#Shell脚本入门" class="headerlink" title="Shell脚本入门"></a>Shell脚本入门</h3><h4 id="脚本格式"><a href="#脚本格式" class="headerlink" title="脚本格式"></a>脚本格式</h4><p>&ensp;&ensp;&ensp;&ensp;脚本以#！/bin/bash开头（指定解析器）</p>
<p>&ensp;&ensp;&ensp;&ensp;范例：创建一个shell脚本，输出helloworld</p>
<p>&ensp;&ensp;&ensp;&ensp;创建文件</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">james@james-Vostro-5471:~/datas$ touch helloworld.sh</span><br><span class="line">james@james-Vostro-5471:~/datas$ vim helloworld.sh</span><br></pre></td></tr></table></figure>

<p>&ensp;&ensp;&ensp;&ensp;文件内容:</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">!/bin/bash</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;hello world&quot;</span></span><br></pre></td></tr></table></figure>

<p>&ensp;&ensp;&ensp;&ensp;执行：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">james@james-Vostro-5471:~/datas$ sh helloworld.sh</span><br><span class="line">hello world</span><br><span class="line">james@james-Vostro-5471:~/datas$ bash helloworld.sh</span><br><span class="line">hello world</span><br></pre></td></tr></table></figure>

<h4 id="脚本的常用执行方式"><a href="#脚本的常用执行方式" class="headerlink" title="脚本的常用执行方式"></a>脚本的常用执行方式</h4><p>&ensp;&ensp;&ensp;&ensp;第一种：采用bash或sh+脚本的相对路径或绝对路径（不用赋予脚本+x权限）</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">root@james-Vostro-5471:/home/james/datas# sh helloworld.sh</span><br><span class="line">hello world</span><br><span class="line">root@james-Vostro-5471:/home/james/datas# sh /home/james/datas/helloworld.sh</span><br><span class="line">hello world</span><br></pre></td></tr></table></figure>

<p>&ensp;&ensp;&ensp;&ensp;第二种：采用输入脚本的绝对路径或相对路径执行脚本（必须具有可执行权限+x）</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">root@james-Vostro-5471:/home/james/datas# ./helloworld.sh</span><br><span class="line">bash: ./helloworld.sh: 权限不够</span><br><span class="line">root@james-Vostro-5471:/home/james/datas# ll | grep helloworld.sh</span><br><span class="line">-rw-r--r--  1 james james   32 5月   6 13:06 helloworld.sh</span><br><span class="line">root@james-Vostro-5471:/home/james/datas# chmod 777 helloworld.sh</span><br><span class="line">root@james-Vostro-5471:/home/james/datas# ll |grep helloworld.sh</span><br><span class="line">-rwxrwxrwx  1 james james   32 5月   6 13:06 helloworld.sh*</span><br><span class="line">root@james-Vostro-5471:/home/james/datas# ./helloworld.sh</span><br><span class="line">hello world</span><br><span class="line">root@james-Vostro-5471:/home/james/datas# /home/james/datas/helloworld.sh</span><br><span class="line">hello world</span><br></pre></td></tr></table></figure>

<p>&ensp;&ensp;&ensp;&ensp;第一种执行方法，本质是bash解析器帮你执行脚本，所以脚本本身不需要执行权限。第二种方法，本质是脚本需要自己执行，所以需要执行权限。</p>
<h4 id="多命令处理"><a href="#多命令处理" class="headerlink" title="多命令处理"></a>多命令处理</h4><p>&ensp;&ensp;&ensp;&ensp;在/home/james/datas目录下创建一个demo.txt 在demo.txt文件中增加“this is a demo”：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">root@james-Vostro-5471:/home/james/datas# touch batch.sh</span><br><span class="line">root@james-Vostro-5471:/home/james/datas# vim batch.sh</span><br><span class="line">root@james-Vostro-5471:/home/james/datas# ll</span><br><span class="line">总用量 16</span><br><span class="line">drwxr-xr-x  2 james james 4096 5月   6 13:27 ./</span><br><span class="line">drwxr-xr-x 22 james james 4096 5月   6 13:06 ../</span><br><span class="line">-rw-r--r--  1 root  root    84 5月   6 13:27 batch.sh</span><br><span class="line">-rwxrwxrwx  1 james james   32 5月   6 13:06 helloworld.sh*</span><br><span class="line">root@james-Vostro-5471:/home/james/datas# bash batch.sh</span><br><span class="line">root@james-Vostro-5471:/home/james/datas# ll</span><br><span class="line">总用量 20</span><br><span class="line">drwxr-xr-x  2 james james 4096 5月   6 13:29 ./</span><br><span class="line">drwxr-xr-x 22 james james 4096 5月   6 13:06 ../</span><br><span class="line">-rw-r--r--  1 root  root    84 5月   6 13:27 batch.sh</span><br><span class="line">-rw-r--r--  1 root  root    15 5月   6 13:29 demo.txt</span><br><span class="line">-rwxrwxrwx  1 james james   32 5月   6 13:06 helloworld.sh*</span><br><span class="line">root@james-Vostro-5471:/home/james/datas# cat demo.txt</span><br><span class="line">this is a demo</span><br><span class="line">root@james-Vostro-5471:/home/james/datas# cat batch.sh</span><br><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line"></span><br><span class="line">cd /home/james/datas</span><br><span class="line">touch demo.txt</span><br><span class="line">echo &quot;this is a demo&quot; &gt;&gt; demo.txt</span><br></pre></td></tr></table></figure>



<h3 id="Shell中的变量"><a href="#Shell中的变量" class="headerlink" title="Shell中的变量"></a>Shell中的变量</h3><h4 id="常用系统变量"><a href="#常用系统变量" class="headerlink" title="常用系统变量"></a>常用系统变量</h4><p>&ensp;&ensp;&ensp;&ensp;$HOME(根目录) 、$PWD(当前目录)、 $SHELL(shell解析器目录)、 $USER(当前用户)等</p>
<p>&ensp;&ensp;&ensp;&ensp;范例：查看系统变量的值</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">james@james-Vostro-5471:~$ echo $HOME</span><br><span class="line">/home/james</span><br><span class="line">james@james-Vostro-5471:~$ echo $PWD</span><br><span class="line">/home/james</span><br><span class="line">james@james-Vostro-5471:~$ echo $SHELL</span><br><span class="line">/bin/bash</span><br><span class="line">james@james-Vostro-5471:~$ echo $USER</span><br><span class="line">james</span><br></pre></td></tr></table></figure>

<h4 id="自定义变量"><a href="#自定义变量" class="headerlink" title="自定义变量"></a>自定义变量</h4><ul>
<li><p>定义变量 ： 变量=值（声明变量时等号左右不能有空格）</p>
  <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">james@james-Vostro-5471:~$ M=1</span><br><span class="line">james@james-Vostro-5471:~$ echo $M</span><br><span class="line">1</span><br></pre></td></tr></table></figure></li>
<li><p>撤销变量：unset 变量</p>
  <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">james@james-Vostro-5471:~$ unset M</span><br><span class="line">james@james-Vostro-5471:~$ echo $M</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li><p>声明静态变量：readonly 变量，注意：不能unset</p>
  <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">james@james-Vostro-5471:~$ readonly B=3</span><br><span class="line">james@james-Vostro-5471:~$ echo $B</span><br><span class="line">3</span><br><span class="line">james@james-Vostro-5471:~$ unset B</span><br><span class="line">bash: unset: B: 无法取消设定: 只读 variable</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="变量定义规则"><a href="#变量定义规则" class="headerlink" title="变量定义规则"></a>变量定义规则</h4><ul>
<li>变量名称可以由字母、数字、下划线组成，但是不能以数字开头，环境变量名建议大写。</li>
<li>等号两侧不能有空格</li>
<li>在bash中，变量默认类型都是字符串类型，无法直接进行数值运算</li>
<li>变量的值如果有空格，需要使用双引号或单引号括起来</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">james@james-Vostro-5471:~$ S=1+1</span><br><span class="line">james@james-Vostro-5471:~$ echo $S</span><br><span class="line">1+1</span><br><span class="line">james@james-Vostro-5471:~$ d=zx 12 3</span><br><span class="line">12：未找到命令</span><br><span class="line">james@james-Vostro-5471:~$ d=&#x27;zx 12 3&#x27;</span><br><span class="line">james@james-Vostro-5471:~$ echo $d</span><br><span class="line">zx 12 3</span><br><span class="line">james@james-Vostro-5471:~$ </span><br></pre></td></tr></table></figure>

<h4 id="提升全局变量"><a href="#提升全局变量" class="headerlink" title="提升全局变量"></a>提升全局变量</h4><p>&ensp;&ensp;&ensp;&ensp;把局部变量提升为全局变量，可供其他shell程序使用。</p>
<p>&ensp;&ensp;&ensp;&ensp;export 变量名</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">james@james-Vostro-5471:~/datas$ vim helloworld.sh</span><br><span class="line">james@james-Vostro-5471:~/datas$ cat helloworld.sh</span><br><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line"></span><br><span class="line">echo &quot;hello world&quot;</span><br><span class="line"></span><br><span class="line">echo $D</span><br><span class="line">james@james-Vostro-5471:~/datas$ D=&#x27;bian liang&#x27;</span><br><span class="line">james@james-Vostro-5471:~/datas$ echo $D</span><br><span class="line">bian liang</span><br><span class="line">james@james-Vostro-5471:~/datas$ sh helloworld.sh</span><br><span class="line">hello world</span><br><span class="line"></span><br><span class="line">james@james-Vostro-5471:~/datas$ export D</span><br><span class="line">james@james-Vostro-5471:~/datas$ sh helloworld.sh</span><br><span class="line">hello world</span><br><span class="line">bian liang</span><br><span class="line">james@james-Vostro-5471:~/datas$ </span><br></pre></td></tr></table></figure>

<h4 id="特殊变量"><a href="#特殊变量" class="headerlink" title="特殊变量"></a>特殊变量</h4><p>1、$n</p>
<p>&ensp;&ensp;&ensp;&ensp;功能描述：n为数字，$0代表该脚本名称，包含完整路径。$1- 9 代表第一到第九个参数 ，十 以上的参数需要用大括号包含，如{10}。</p>
<p>&ensp;&ensp;&ensp;&ensp;范例：输出该脚本文件名称，输入参数1和输入参数2的值</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">james@james-Vostro-5471:~/datas$ touch parameter.sh</span><br><span class="line">james@james-Vostro-5471:~/datas$ vim parameter.sh</span><br><span class="line">james@james-Vostro-5471:~/datas$ cat parameter.sh</span><br><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line"></span><br><span class="line">echo &quot;$0 $1 $2 $3&quot;</span><br><span class="line">james@james-Vostro-5471:~/datas$ bash parameter.sh</span><br><span class="line">parameter.sh   </span><br><span class="line">james@james-Vostro-5471:~/datas$ bash parameter.sh first</span><br><span class="line">parameter.sh first  </span><br><span class="line">james@james-Vostro-5471:~/datas$ bash parameter.sh first second</span><br><span class="line">parameter.sh first second </span><br><span class="line">james@james-Vostro-5471:~/datas$ bash parameter.sh first second third</span><br><span class="line">parameter.sh first second third</span><br><span class="line">james@james-Vostro-5471:~/datas$ bash parameter.sh first second third fourth</span><br><span class="line">parameter.sh first second third</span><br><span class="line">james@james-Vostro-5471:~/datas$ </span><br></pre></td></tr></table></figure>

<p>2、$#</p>
<p>&ensp;&ensp;&ensp;&ensp;功能描述：获取所有输入参数个数，常用于循环。</p>
<p>&ensp;&ensp;&ensp;&ensp;范例：获取输入参数的个数</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">james@james-Vostro-5471:~/datas$ vim parameter.sh</span><br><span class="line">james@james-Vostro-5471:~/datas$ cat parameter.sh</span><br><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line"></span><br><span class="line">echo &quot;$0 $1 $2 $3&quot;</span><br><span class="line"></span><br><span class="line">echo $#</span><br><span class="line">james@james-Vostro-5471:~/datas$ bash parameter.sh first second third</span><br><span class="line">parameter.sh first second third</span><br><span class="line">3</span><br><span class="line">james@james-Vostro-5471:~/datas$ </span><br></pre></td></tr></table></figure>

<p>3、$*和$@</p>
<p>&ensp;&ensp;&ensp;&ensp;$* : 这个变量代表命令行中所有的参数，$*把所有的参数看成一个整体</p>
<p>&ensp;&ensp;&ensp;&ensp;$@ : 这个变量也代表命令行中所有的参数，不过$@把每个参数区分对待</p>
<p>&ensp;&ensp;&ensp;&ensp;范例：打印输出所有参数</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">james@james-Vostro-5471:~/datas$ vim parameter.sh</span><br><span class="line">james@james-Vostro-5471:~/datas$ cat parameter.sh</span><br><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line"></span><br><span class="line">echo &quot;$0 $1 $2 $3&quot;</span><br><span class="line"></span><br><span class="line">echo $#</span><br><span class="line">echo $*</span><br><span class="line">echo $@</span><br><span class="line">james@james-Vostro-5471:~/datas$ bash parameter.sh first second third</span><br><span class="line">parameter.sh first second third</span><br><span class="line">3</span><br><span class="line">first second third</span><br><span class="line">first second third</span><br><span class="line">james@james-Vostro-5471:~/datas$ </span><br></pre></td></tr></table></figure>

<p>4、$?</p>
<p>&ensp;&ensp;&ensp;&ensp;功能描述：最后一次执行的命令的返回状态。如果这个变量的值为0，证明上一个命令正确执行；如果这个变量的值为非0（具体哪个数，由命令自己来决定），则证明上一个命令执行不正确了。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">james@james-Vostro-5471:~/datas$ $?</span><br><span class="line">0：未找到命令</span><br><span class="line">james@james-Vostro-5471:~/datas$ echo $?</span><br><span class="line">127</span><br><span class="line">james@james-Vostro-5471:~/datas$ bash helloworld.sh</span><br><span class="line">hello world</span><br><span class="line">bian liang</span><br><span class="line">james@james-Vostro-5471:~/datas$ echo $?</span><br><span class="line">0</span><br></pre></td></tr></table></figure>

<h3 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h3><h4 id="1、基本语法："><a href="#1、基本语法：" class="headerlink" title="1、基本语法："></a>1、基本语法：</h4><ol>
<li><p>“$((运算式))”或“$[运算式]”</p>
</li>
<li><p>expr  +，-，*，/，%  加，减，乘，除，取余</p>
</li>
</ol>
<p>&ensp;&ensp;&ensp;&ensp;注意：expr运算符间要有空格</p>
<h4 id="2、范例：计算3-2"><a href="#2、范例：计算3-2" class="headerlink" title="2、范例：计算3+2"></a>2、范例：计算3+2</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">james@james-Vostro-5471:~/datas$ expr 3 + 2</span><br><span class="line">5</span><br><span class="line">james@james-Vostro-5471:~/datas$ s=$((3+2))</span><br><span class="line">james@james-Vostro-5471:~/datas$ echo $s</span><br><span class="line">5</span><br></pre></td></tr></table></figure>

<p>范例：计算（2+3）*4</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">james@james-Vostro-5471:~/datas$ d=$[(2+3)*4]</span><br><span class="line">james@james-Vostro-5471:~/datas$ echo $d</span><br><span class="line">20</span><br><span class="line">james@james-Vostro-5471:~/datas$ expr `expr 2 + 3` \* 4</span><br><span class="line">20</span><br></pre></td></tr></table></figure>

<h3 id="条件判断"><a href="#条件判断" class="headerlink" title="条件判断"></a>条件判断</h3><h4 id="1、语法："><a href="#1、语法：" class="headerlink" title="1、语法："></a>1、语法：</h4><p>[ condition ] (<strong>condition前后要有空格</strong>)</p>
<p>注意：条件非空即为true，如[z]返回true，[] 返回false</p>
<h4 id="2、常用条件判断"><a href="#2、常用条件判断" class="headerlink" title="2、常用条件判断"></a>2、常用条件判断</h4><p>（1）两个整数之间比较</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x3D; 字符串比较</span><br><span class="line">-lt 小于（less than） -le 小于等于 （less equal）</span><br><span class="line">-eq 等于 （equal） -gt 大于 （greater than）</span><br><span class="line">-ge 大于等于 （greater equal） -ne不等于 （Not equal）</span><br></pre></td></tr></table></figure>

<p>（2）按照文件权限进行判断</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-r 有读的权限（read） -w 有写的权限 （write）</span><br><span class="line">-x 有执行的权限 （execute）</span><br></pre></td></tr></table></figure>

<p>（3）按照文件类型进行判断</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-f 文件存在并且是一个常规文件（file）</span><br><span class="line">-e 文件存在 （existence）</span><br><span class="line">-d 文件存在并是一个目录（directory）</span><br></pre></td></tr></table></figure>

<p>范例：23是否大于等于22</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">james@james-Vostro-5471:~/datas$ [ 23 -ge 22 ]</span><br><span class="line">james@james-Vostro-5471:~/datas$ echo $?</span><br><span class="line">0</span><br><span class="line">james@james-Vostro-5471:~/datas$ [ 23 -le 22 ]</span><br><span class="line">james@james-Vostro-5471:~/datas$ echo $?</span><br><span class="line">1</span><br></pre></td></tr></table></figure>

<p>范例：查看helloworld.sh 是否具有执行权限</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">james@james-Vostro-5471:~/datas$ [ -x /home/james/datas/helloworld.sh ]</span><br><span class="line">james@james-Vostro-5471:~/datas$ echo $?</span><br><span class="line">0</span><br></pre></td></tr></table></figure>

<p>范例：判断/home/james/datas/hello.txt是否存在</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">james@james-Vostro-5471:~/datas$ [ -e /home/james/datas/hello.txt ]</span><br><span class="line">james@james-Vostro-5471:~/datas$ echo $?</span><br><span class="line">1</span><br><span class="line">james@james-Vostro-5471:~/datas$ [ -e /home/james/datas/helloworld.sh ]</span><br><span class="line">james@james-Vostro-5471:~/datas$ echo $?</span><br><span class="line">0</span><br></pre></td></tr></table></figure>

<p>（4）多条件判断（&amp;&amp;表示前一条命令执行成功时，才执行后一条命令，|| 表示上一条命令执行失败后，才执行下一条命令）[]</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">james@james-Vostro-5471:~/datas$ [ 3 -ge 2 ] &amp;&amp; echo ok || echo notok</span><br><span class="line">ok</span><br><span class="line">james@james-Vostro-5471:~/datas$ [ 3 -ge 2 ] &amp;&amp; [ ] || echo notok</span><br><span class="line">notok</span><br><span class="line">james@james-Vostro-5471:~/datas$ [ 3 -ge 2 ] &amp; echo ok</span><br><span class="line">[1] 27351</span><br><span class="line">ok</span><br></pre></td></tr></table></figure>

<h3 id="流程控制"><a href="#流程控制" class="headerlink" title="流程控制"></a>流程控制</h3><h4 id="1、if判断"><a href="#1、if判断" class="headerlink" title="1、if判断"></a>1、if判断</h4><p>语法：</p>
<pre><code>if [ 条件判断式 ]；then
 程序
 fi
 或者
 if [ 条件判断式 ]
 then
 程序
 fi
</code></pre>
<p>注意事项：</p>
<ul>
<li>[ 条件判断式 ] ，中括号和条件判断式之间必须有空格</li>
<li>if后要有空格</li>
</ul>
<p>范例：输入一个数字，如果是1，则输出one，如果是2，则输出two，如果是其他，什么也不输出。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">james@james-Vostro-5471:~/datas$ cat testIf.sh</span><br><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line"></span><br><span class="line">if [ $1 -eq 1 ];then</span><br><span class="line">    echo &quot;one&quot;</span><br><span class="line">elif [ $1 -eq 2 ]</span><br><span class="line">then</span><br><span class="line">    echo &quot;two&quot;</span><br><span class="line">fi</span><br><span class="line">james@james-Vostro-5471:~/datas$ bash testIf.sh</span><br><span class="line">testIf.sh: 第 3 行: [: -eq: 需要一元表达式</span><br><span class="line">testIf.sh: 第 5 行: [: -eq: 需要一元表达式</span><br><span class="line">james@james-Vostro-5471:~/datas$ bash testIf.sh 1</span><br><span class="line">one</span><br><span class="line">james@james-Vostro-5471:~/datas$ bash testIf.sh 2</span><br><span class="line">two</span><br><span class="line">james@james-Vostro-5471:~/datas$ bash testIf.sh 3</span><br></pre></td></tr></table></figure>

<h4 id="2、case语句"><a href="#2、case语句" class="headerlink" title="2、case语句"></a>2、case语句</h4><p>语法：</p>
<pre><code>case $变量名 in
“值1”）
如果变量的值等于1，则执行程序1
;;
“值2”）
 如果变量的值等于2，则执行程序2
;;
…省略其他分支…
*)
 如果变量的值都不是以上的值，则执行此程序
;;
esac
</code></pre>
<p>注意事项：</p>
<ul>
<li><p>case行尾必须为单词“in”，每一个模式匹配必须以右括号“）”结束。</p>
</li>
<li><p>双分号“;;”表示命令序列结束，相当于java中的break。</p>
</li>
<li><p>最后的“*）”表示默认模式，相当于java中的default</p>
</li>
</ul>
<p>范例：输入一个数字，如果是1，则输出one，如果是2，则输出two，如果是其他，输出hello</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">james@james-Vostro-5471:~/datas$ cat testCase.sh</span><br><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line"></span><br><span class="line">case $1 in</span><br><span class="line">1)</span><br><span class="line">    echo &quot;one&quot;</span><br><span class="line">;;</span><br><span class="line">2)</span><br><span class="line">    echo &quot;two&quot;</span><br><span class="line">;;</span><br><span class="line">*)</span><br><span class="line">    echo &quot;hello&quot;</span><br><span class="line">;;</span><br><span class="line">esac</span><br><span class="line">james@james-Vostro-5471:~/datas$ bash testCase.sh 1</span><br><span class="line">one</span><br><span class="line">james@james-Vostro-5471:~/datas$ bash testCase.sh 2</span><br><span class="line">two</span><br><span class="line">james@james-Vostro-5471:~/datas$ bash testCase.sh 3</span><br><span class="line">hello</span><br></pre></td></tr></table></figure>

<h4 id="3、for循环"><a href="#3、for循环" class="headerlink" title="3、for循环"></a>3、for循环</h4><p>语法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">for ((初始值；循环控制条件；变量变化))</span><br><span class="line"> do</span><br><span class="line"> 程序</span><br><span class="line"> done</span><br></pre></td></tr></table></figure>

<p>范例：从1加到100</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">james@james-Vostro-5471:~/datas$ cat testFor.sh</span><br><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line"></span><br><span class="line">s=0</span><br><span class="line">for ((i=1;i&lt;=100;++i))</span><br><span class="line">do</span><br><span class="line">    s=$[$s+$i] </span><br><span class="line">done</span><br><span class="line"></span><br><span class="line">echo $s</span><br><span class="line">james@james-Vostro-5471:~/datas$ bash testFor.sh</span><br><span class="line">5050</span><br></pre></td></tr></table></figure>

<p>语法2：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">for 变量 in 值1 值2 值3…</span><br><span class="line"> do</span><br><span class="line"> 程序</span><br><span class="line"> done</span><br></pre></td></tr></table></figure>

<p>范例：打印所有输入参数（观察 ∗ 与 *与 ∗与@的区别）</p>
<p>使用$*</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">james@james-Vostro-5471:~/datas$ cat testFor.sh</span><br><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line"></span><br><span class="line">s=0</span><br><span class="line">for i in $* </span><br><span class="line">do</span><br><span class="line">    echo &quot;打印所有参数：$i&quot; </span><br><span class="line">done</span><br><span class="line"></span><br><span class="line">james@james-Vostro-5471:~/datas$ bash testFor.sh a c v r </span><br><span class="line">打印所有参数：a</span><br><span class="line">打印所有参数：c</span><br><span class="line">打印所有参数：v</span><br><span class="line">打印所有参数：r</span><br></pre></td></tr></table></figure>

<p>使用$@</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">james@james-Vostro-5471:~/datas$ cat testFor.sh</span><br><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line"></span><br><span class="line">s=0</span><br><span class="line">for i in $@ </span><br><span class="line">do</span><br><span class="line">    echo &quot;打印所有参数：$i&quot; </span><br><span class="line">done</span><br><span class="line"></span><br><span class="line">james@james-Vostro-5471:~/datas$ bash testFor.sh</span><br><span class="line">james@james-Vostro-5471:~/datas$ bash testFor.sh adda sda</span><br><span class="line">打印所有参数：adda</span><br><span class="line">打印所有参数：sda</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">james@james-Vostro-5471:~/datas$ cat testFor.sh</span><br><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line"></span><br><span class="line">for i in &quot;$*&quot; </span><br><span class="line">do</span><br><span class="line">    echo &quot;打印所有参数：$i&quot; </span><br><span class="line">done</span><br><span class="line"></span><br><span class="line">for j in &quot;$@&quot;</span><br><span class="line">do</span><br><span class="line">    echo &quot;打印参数：$j&quot;</span><br><span class="line">done    </span><br><span class="line">james@james-Vostro-5471:~/datas$ bash testFor.sh a b c</span><br><span class="line">打印所有参数：a b c</span><br><span class="line">打印参数：a</span><br><span class="line">打印参数：b</span><br><span class="line">打印参数：c</span><br></pre></td></tr></table></figure>



<p>&ensp;&ensp;&ensp;&ensp;总结：由上图可以看出” ∗ “ 将 所 有 参 数 看 做 一 个 整 体 输 出 ， 只 循 环 一 次 ； 而 “ *”将所有参数看做一个整体输出，只循环一次；而” ∗”将所有参数看做一个整体输出，只循环一次；而”@”将输出参数分开输出，执行三次循环。</p>
<h4 id="4、while循环"><a href="#4、while循环" class="headerlink" title="4、while循环"></a>4、while循环</h4><p>语法： </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">while [ 条件判断式 ]</span><br><span class="line"> do</span><br><span class="line"> 程序</span><br><span class="line"> done</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>范例：从1加到100</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">james@james-Vostro-5471:~/datas$ cat testWhile.sh</span><br><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line"></span><br><span class="line">s=0</span><br><span class="line">i=1</span><br><span class="line">while [ $i -le 100 ]</span><br><span class="line">do</span><br><span class="line">    s=$[$s + $i]</span><br><span class="line">    i=$[$i + 1]</span><br><span class="line">done</span><br><span class="line"></span><br><span class="line">echo $s</span><br><span class="line">james@james-Vostro-5471:~/datas$ bash testWhile.sh</span><br><span class="line">5050</span><br></pre></td></tr></table></figure>

<h3 id="read读取控制台输入"><a href="#read读取控制台输入" class="headerlink" title="read读取控制台输入"></a>read读取控制台输入</h3><p>语法：read 选项 参数</p>
<p>选项：</p>
<ul>
<li>-p：指定读取值时的提示符</li>
<li>-t ：指定读取值时的时间（秒）</li>
</ul>
<p>参数：</p>
<ul>
<li>变量：指定读取值的变量名</li>
</ul>
<p>范例：提示7秒内，读取控制台输入的名称</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">james@james-Vostro-5471:~/datas$ cat testRead.sh</span><br><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line"></span><br><span class="line">read -t 7 -p &quot;input your name: &quot; NAME</span><br><span class="line">echo $NAME</span><br><span class="line">james@james-Vostro-5471:~/datas$ bash testRead.sh</span><br><span class="line">input your name: 123456</span><br><span class="line">123456</span><br></pre></td></tr></table></figure>

<h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><h4 id="系统函数"><a href="#系统函数" class="headerlink" title="系统函数"></a>系统函数</h4><p>1、basename基本语法</p>
<p>&ensp;&ensp;&ensp;&ensp;basename [string/pathname] suffix </p>
<p>&ensp;&ensp;&ensp;&ensp;功能描述：basename命令会删掉所有的前缀包括最后一个（‘/’）字符，然后将字符显示出来。</p>
<p>&ensp;&ensp;&ensp;&ensp;选项：suffix为后缀，如果suffix被指定了，basename会将pathname或string中的suffix去掉</p>
<p>范例：截取/home/zby/read.sh路径的文件名称</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">james@james-Vostro-5471:~/datas$ basename /home/james/datas/helloworld.sh</span><br><span class="line">helloworld.sh</span><br><span class="line">james@james-Vostro-5471:~/datas$ basename /home/james/datas/testIf.sh .sh</span><br><span class="line">testIf</span><br></pre></td></tr></table></figure>



<p>2、dirrame基本语法</p>
<p>&ensp;&ensp;&ensp;&ensp;dirname 文件绝对路径 </p>
<p>&ensp;&ensp;&ensp;&ensp;功能描述：从给定的包含绝对路径的文件名中去除文件名（非目录的部分），然后返回剩下的路径（目录的部分）</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">james@james-Vostro-5471:~/datas$ dirname /home/james/datas/testIf.sh</span><br><span class="line">/home/james/datas</span><br></pre></td></tr></table></figure>

<h4 id="自定义函数"><a href="#自定义函数" class="headerlink" title="自定义函数"></a>自定义函数</h4><p>1、基本语法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[function] funname [()]</span><br><span class="line">&#123;</span><br><span class="line"> Action;</span><br><span class="line"> [return int;]</span><br><span class="line">&#125;</span><br><span class="line">funname</span><br></pre></td></tr></table></figure>


<p>2、经验技巧</p>
<p>&ensp;&ensp;&ensp;&ensp;必须在调用函数的地方之前，先声明函数，shell脚本是逐行运行。不会像其他语言一样先编译。<br>&ensp;&ensp;&ensp;&ensp;函数返回值，只能通过<code>$?</code>系统变量获得，可以显示加：return返回，如果不加，将以最后一条命令运行结果，作为返回值。return后跟数值n（0-255）</p>
<p>范例：计算两个输入参数的和</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">james@james-Vostro-5471:~/datas$ cat fun.sh</span><br><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line"></span><br><span class="line">function sum()</span><br><span class="line">&#123;</span><br><span class="line">    s=0;</span><br><span class="line">    s=$[$1+$2]</span><br><span class="line">    echo $s</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">read -p &quot;input parameter1:&quot; p1</span><br><span class="line">read -p &quot;input parameter2:&quot; p2</span><br><span class="line"></span><br><span class="line">sum $p1 $p2</span><br><span class="line">james@james-Vostro-5471:~/datas$ bash fun.sh</span><br><span class="line">input parameter1:1</span><br><span class="line">input parameter2:2</span><br><span class="line">3</span><br></pre></td></tr></table></figure>

<h3 id="Shell工具"><a href="#Shell工具" class="headerlink" title="Shell工具"></a>Shell工具</h3><h4 id="cut"><a href="#cut" class="headerlink" title="cut"></a>cut</h4><p>&ensp;&ensp;&ensp;&ensp;cut的工作就是“剪”，具体地说就是在文件中负责剪切数据用的。cut命令从文件中的每一行剪切文字、字符和字段并将这些字节、字符和字段输出。</p>
<p>1、基本用法：</p>
<ul>
<li>cut [选项参数] filename</li>
<li>说明：默认分隔符是制表符</li>
</ul>
<p>2、参数说明：</p>
<ul>
<li>-f  列号，提取第几列</li>
<li>-d 分隔符，按照指定分隔符分割lie</li>
</ul>
<p>范例：数据准备</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">james@james-Vostro-5471:~/datas$ vim cut.txt</span><br><span class="line">james@james-Vostro-5471:~/datas$ cat cut.txt</span><br><span class="line">bei jing sheng yang</span><br><span class="line">shang hai xiang gang</span><br><span class="line">tian jin xia men</span><br><span class="line">wu han tai bei</span><br><span class="line">zheng zhou</span><br><span class="line">fu zhou</span><br></pre></td></tr></table></figure>

<p>&ensp;&ensp;&ensp;&ensp;切割<code>cut.txt</code>的第一列</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">james@james-Vostro-5471:~/datas$ cut -d &quot; &quot; -f 1 cut.txt</span><br><span class="line">bei</span><br><span class="line">shang</span><br><span class="line">tian</span><br><span class="line">wu</span><br><span class="line">zheng</span><br><span class="line">fu</span><br></pre></td></tr></table></figure>

<p>&ensp;&ensp;&ensp;&ensp;切割<code>cut.txt</code>的第2，3列</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">james@james-Vostro-5471:~/datas$ cut -d &quot; &quot; -f 2,3 cut.txt</span><br><span class="line">jing sheng</span><br><span class="line">hai xiang</span><br><span class="line">jin xia</span><br><span class="line">han tai</span><br><span class="line">zhou</span><br><span class="line">zhou</span><br></pre></td></tr></table></figure>

<p>&ensp;&ensp;&ensp;&ensp;切割<code>cut.txt</code>文件中的<code>shang</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">james@james-Vostro-5471:~/datas$ cat cut.txt | grep shang</span><br><span class="line">shang hai xiang gang</span><br><span class="line">james@james-Vostro-5471:~/datas$ cat cut.txt | grep shang | cut -d &quot; &quot; -f 1</span><br><span class="line">shang</span><br></pre></td></tr></table></figure>

<p>&ensp;&ensp;&ensp;&ensp;选取系统<code>PATH</code>变量值，第二个“：”开始后的所有路径：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">james@james-Vostro-5471:~/datas$ echo $PATH</span><br><span class="line">/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games:/usr/local/games:/snap/bin</span><br><span class="line">james@james-Vostro-5471:~/datas$ echo $PATH | cut -d : -f 3-</span><br><span class="line">/usr/sbin:/usr/bin:/sbin:/bin:/usr/games:/usr/local/games:/snap/bin</span><br></pre></td></tr></table></figure>

<p>&ensp;&ensp;&ensp;&ensp;切割<code>ifconfig</code>后打印<code>IP</code>地址</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">james@james-Vostro-5471:~$ ifconfig lo</span><br><span class="line">lo: flags=73&lt;UP,LOOPBACK,RUNNING&gt;  mtu 65536</span><br><span class="line">        inet 127.0.0.1  netmask 255.0.0.0</span><br><span class="line">        inet6 ::1  prefixlen 128  scopeid 0x10&lt;host&gt;</span><br><span class="line">        loop  txqueuelen 1000  (本地环回)</span><br><span class="line">        RX packets 44305  bytes 5010333 (5.0 MB)</span><br><span class="line">        RX errors 0  dropped 0  overruns 0  frame 0</span><br><span class="line">        TX packets 44305  bytes 5010333 (5.0 MB)</span><br><span class="line">        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0</span><br><span class="line"></span><br><span class="line">james@james-Vostro-5471:~$ ifconfig lo | grep &quot;inet &quot;</span><br><span class="line">        inet 127.0.0.1  netmask 255.0.0.0</span><br><span class="line">james@james-Vostro-5471:~$ ifconfig lo | grep &quot;inet &quot; | cut -d &quot; &quot; -f 10</span><br><span class="line">127.0.0.1</span><br></pre></td></tr></table></figure>

<h4 id="sed"><a href="#sed" class="headerlink" title="sed"></a>sed</h4><p>&ensp;&ensp;&ensp;&ensp;<code>sed</code>是一种流编辑器，它一次处理一行内容。处理时，把当前处理的行存储在临时缓冲区中，称为“模式空间”，接着用<code>sed</code>命令处理缓存区中的内容，处理完成后，把缓冲区的内容送往屏幕。接着处理下一行，这样不断重复，知道文件末尾。文件内容并没有改变，除非你使用重定向存储输出。</p>
<ul>
<li><p>基本用法：</p>
<p>  sed [选项参数] ‘command’ filename</p>
</li>
<li><p>参数说明</p>
<p>  -e 直接在命令模式上进行sed的动作编辑</p>
</li>
<li><p>命令功能描述</p>
<p>  a 新增，a的后面可以接字符串，在下一行出现</p>
<p>  d 删除</p>
<p>  s 查找并替换</p>
</li>
</ul>
<p>范例：数据准备</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">james@james-Vostro-5471:~$ vim sed.txt</span><br><span class="line">james@james-Vostro-5471:~$ cat sed.txt</span><br><span class="line">abcd aaaa</span><br><span class="line">zxcv aaas</span><br><span class="line">dasd qwdd</span><br><span class="line">ad ad</span><br><span class="line">dc da</span><br><span class="line">da ee</span><br></pre></td></tr></table></figure>

<p>&ensp;&ensp;&ensp;&ensp;将<code>aa cc</code>这个字符串插入到<code>sed.txt</code>第二行下打印</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">james@james-Vostro-5471:~$ sed &quot;2a aa cc&quot; sed.txt</span><br><span class="line">abcd aaaa</span><br><span class="line">zxcv aaas</span><br><span class="line">aa cc</span><br><span class="line">dasd qwdd</span><br><span class="line">ad ad</span><br><span class="line">dc da</span><br><span class="line">da ee</span><br><span class="line">james@james-Vostro-5471:~$ cat sed.txt</span><br><span class="line">abcd aaaa</span><br><span class="line">zxcv aaas</span><br><span class="line">dasd qwdd</span><br><span class="line">ad ad</span><br><span class="line">dc da</span><br><span class="line">da ee</span><br></pre></td></tr></table></figure>

<p>&ensp;&ensp;&ensp;&ensp;删除 <code>sed.txt</code> 中包含<code>d</code>的行</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">james@james-Vostro-5471:~$ sed &quot;/d/d&quot; sed.txt</span><br><span class="line">zxcv aaas</span><br></pre></td></tr></table></figure>

<p>&ensp;&ensp;&ensp;&ensp;将<code>sed.txt</code>文件中的<code>aa</code>替换为<code>pp</code>(<code>g</code>表示global，全部替换)</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">james@james-Vostro-5471:~$ sed &quot;s/aa/pp/g&quot; sed.txt</span><br><span class="line">abcd pppp</span><br><span class="line">zxcv ppas</span><br><span class="line">dasd qwdd</span><br><span class="line">ad ad</span><br><span class="line">dc da</span><br><span class="line">da ee</span><br></pre></td></tr></table></figure>

<p>&ensp;&ensp;&ensp;&ensp;将<code>sed.txt</code>文件中的第二行删除并将<code>aaa</code>替换为<code>qf</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">james@james-Vostro-5471:~$ sed -e &quot;2d&quot; -e &quot;s/aaa/qf/g&quot; sed.txt</span><br><span class="line">abcd qfa</span><br><span class="line">dasd qwdd</span><br><span class="line">ad ad</span><br><span class="line">dc da</span><br><span class="line">da ee</span><br></pre></td></tr></table></figure>

<h4 id="awk"><a href="#awk" class="headerlink" title="awk"></a>awk</h4><p>&ensp;&ensp;&ensp;&ensp;一个强大的文本分析工具，把文件逐行的读入，以空格为默认的分割符并将每行切片，切开的部分再进行分析处理。<br>1.基本用法</p>
<p>&ensp;&ensp;&ensp;&ensp;awk [选项参数] ‘pattern1 {action} pattern2 {action}…’ filename</p>
<p>&ensp;&ensp;&ensp;&ensp;pattern :  表示AWK在数据中查找的内容，就是匹配模式</p>
<p>&ensp;&ensp;&ensp;&ensp;action：在找到匹配内容时所执行的一系列命令。</p>
<p>参数说明</p>
<ul>
<li>-F   指定输入文件拆分隔离</li>
<li>-v   赋值一个用户定义变量</li>
</ul>
<p>范例：数据准备(/etc/passwd文件)</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">james@james-Vostro-5471:~/datas$ sudo cp /etc/passwd ./</span><br><span class="line">[sudo] james 的密码： </span><br><span class="line">james@james-Vostro-5471:~/datas$ ls</span><br><span class="line">batch.sh  demo.txt  helloworsudold.sh  passwd       testFor.sh  testRead.sh</span><br><span class="line">cut.txt   fun.sh    parameter.sh   testCase.sh  testIf.sh   testWhile.sh</span><br><span class="line">james@james-Vostro-5471:~/datas$ cat passwd</span><br><span class="line">root:x:0:0:root:/root:/bin/bash</span><br><span class="line">daemon:x:1:1:daemon:/usr/sbin:/usr/sbin/nologin</span><br><span class="line">bin:x:2:2:bin:/bin:/usr/sbin/nologin</span><br><span class="line">sys:x:3:3:sys:/dev:/usr/sbin/nologin</span><br><span class="line">sync:x:4:65534:sync:/bin:/bin/sync</span><br><span class="line">games:x:5:60:games:/usr/games:/usr/sbin/nologin</span><br><span class="line">man:x:6:12:man:/var/cache/man:/usr/sbin/nologin</span><br><span class="line">lp:x:7:7:lp:/var/spool/lpd:/usr/sbin/nologin</span><br><span class="line">mail:x:8:8:mail:/var/mail:/usr/sbin/nologin</span><br><span class="line">news:x:9:9:news:/var/spool/news:/usr/sbin/nologin</span><br><span class="line">uucp:x:10:10:uucp:/var/spool/uucp:/usr/sbin/nologin</span><br><span class="line">proxy:x:13:13:proxy:/bin:/usr/sbin/nologin</span><br><span class="line">www-data:x:33:33:www-data:/var/www:/usr/sbin/nologin</span><br><span class="line">backup:x:34:34:backup:/var/backups:/usr/sbin/nologin</span><br><span class="line">list:x:38:38:Mailing List Manager:/var/list:/usr/sbin/nologin</span><br><span class="line">irc:x:39:39:ircd:/var/run/ircd:/usr/sbin/nologin</span><br><span class="line">gnats:x:41:41:Gnats Bug-Reporting System (admin):/var/lib/gnats:/usr/sbin/nologin</span><br><span class="line">nobody:x:65534:65534:nobody:/nonexistent:/usr/sbin/nologin</span><br><span class="line">systemd-network:x:100:102:systemd Network Management,,,:/run/systemd/netif:/usr/sbin/nologin</span><br><span class="line">systemd-resolve:x:101:103:systemd Resolver,,,:/run/systemd/resolve:/usr/sbin/nologin</span><br><span class="line">syslog:x:102:106::/home/syslog:/usr/sbin/nologin</span><br><span class="line">messagebus:x:103:107::/nonexistent:/usr/sbin/nologin</span><br><span class="line">_apt:x:104:65534::/nonexistent:/usr/sbin/nologin</span><br><span class="line">uuidd:x:105:111::/run/uuidd:/usr/sbin/nologin</span><br><span class="line">avahi-autoipd:x:106:112:Avahi autoip daemon,,,:/var/lib/avahi-autoipd:/usr/sbin/nologin</span><br><span class="line">usbmux:x:107:46:usbmux daemon,,,:/var/lib/usbmux:/usr/sbin/nologin</span><br><span class="line">dnsmasq:x:108:65534:dnsmasq,,,:/var/lib/misc:/usr/sbin/nologin</span><br><span class="line">rtkit:x:109:114:RealtimeKit,,,:/proc:/usr/sbin/nologin</span><br><span class="line">cups-pk-helper:x:110:116:user for cups-pk-helper service,,,:/home/cups-pk-helper:/usr/sbin/nologin</span><br><span class="line">speech-dispatcher:x:111:29:Speech Dispatcher,,,:/var/run/speech-dispatcher:/bin/false</span><br><span class="line">whoopsie:x:112:117::/nonexistent:/bin/false</span><br><span class="line">kernoops:x:113:65534:Kernel Oops Tracking Daemon,,,:/:/usr/sbin/nologin</span><br><span class="line">saned:x:114:119::/var/lib/saned:/usr/sbin/nologin</span><br><span class="line">pulse:x:115:120:PulseAudio daemon,,,:/var/run/pulse:/usr/sbin/nologin</span><br><span class="line">avahi:x:116:122:Avahi mDNS daemon,,,:/var/run/avahi-daemon:/usr/sbin/nologin</span><br><span class="line">colord:x:117:123:colord colour management daemon,,,:/var/lib/colord:/usr/sbin/nologin</span><br><span class="line">hplip:x:118:7:HPLIP system user,,,:/var/run/hplip:/bin/false</span><br><span class="line">geoclue:x:119:124::/var/lib/geoclue:/usr/sbin/nologin</span><br><span class="line">gnome-initial-setup:x:120:65534::/run/gnome-initial-setup/:/bin/false</span><br><span class="line">gdm:x:121:125:Gnome Display Manager:/var/lib/gdm3:/bin/false</span><br><span class="line">james:x:1000:1000:James,,,:/home/james:/bin/bash</span><br></pre></td></tr></table></figure>

<p>&ensp;&ensp;&ensp;&ensp;搜索<code>passwd</code>文件以<code>root</code>关键字开头的所有行，并输出该行的第一列和第七列，中间以“，”号分割。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">james@james-Vostro-5471:~/datas$ awk -F : &#x27;/^root/ &#123;print $7&#125;&#x27; passwd</span><br><span class="line">/bin/bash</span><br><span class="line">james@james-Vostro-5471:~/datas$ awk -F : &#x27;/^root/ &#123;print $1&quot;,&quot;$7&#125;&#x27; passwd</span><br><span class="line">root,/bin/bash</span><br><span class="line">james@james-Vostro-5471:~/datas$ </span><br></pre></td></tr></table></figure>

<p>&ensp;&ensp;&ensp;&ensp;只显示<code>passwd</code>的第一列和第七列，以逗号分割，且在所有行前面添加列名<code>user</code>，<code>shell</code> 在最后一行添加<code>gqw, /bin/zuihsuai</code>。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">james@james-Vostro-5471:~/datas$ awk -F : &#x27;BEGIN&#123;print &quot;user,shell&quot;&#125;&#123;print $1&quot;,&quot;$7&#125; END&#123;print &quot;gqw,/bin/zuihuai&quot;&#125;&#x27; passwd</span><br><span class="line">user,shell</span><br><span class="line">root,/bin/bash</span><br><span class="line">daemon,/usr/sbin/nologin</span><br><span class="line">bin,/usr/sbin/nologin</span><br><span class="line">sys,/usr/sbin/nologin</span><br><span class="line">sync,/bin/sync</span><br><span class="line">games,/usr/sbin/nologin</span><br><span class="line">man,/usr/sbin/nologin</span><br><span class="line">lp,/usr/sbin/nologin</span><br><span class="line">mail,/usr/sbin/nologin</span><br><span class="line">news,/usr/sbin/nologin</span><br><span class="line">uucp,/usr/sbin/nologin</span><br><span class="line">…………………………………………………………………………………………</span><br></pre></td></tr></table></figure>

<p>注意：</p>
<ul>
<li><code>BEGIN</code>在所有数据读取行之前执行</li>
<li><code>END</code> 在所有数据执行之后执行</li>
</ul>
<p>&ensp;&ensp;&ensp;&ensp;将passwd文件中的用户id增加数值1并输出</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">james@james-Vostro-5471:~/datas$ awk -F : &#x27;&#123;print $3&#125;&#x27; passwd</span><br><span class="line">0</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">………………………………………………………………………………………………………………</span><br><span class="line">james@james-Vostro-5471:~/datas$ awk -F : -v i=1 &#x27;&#123;print $3+i&#125;&#x27; passwd</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">…………………………………………………………………………………………………………………………</span><br></pre></td></tr></table></figure>

<p>2.<code>awk</code>的内置变量 </p>
<table>
<thead>
<tr>
<th align="center">变量</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">FILENAME</td>
<td align="center">文件名</td>
</tr>
<tr>
<td align="center">NR</td>
<td align="center">已读的记录数</td>
</tr>
<tr>
<td align="center">NF</td>
<td align="center">浏览记录的域的个数（切割后，列的个数）</td>
</tr>
</tbody></table>
<p>范例：统计<code>passwd</code>文件名，每行的行号，每行的列数。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">james@james-Vostro-5471:~/datas$ awk -F : &#x27;&#123;print FILENAME&quot;,&quot;NR&quot;,&quot;NF&#125;&#x27; passwd</span><br><span class="line">passwd,1,7</span><br><span class="line">passwd,2,7</span><br><span class="line">passwd,3,7</span><br><span class="line">passwd,4,7</span><br><span class="line">passwd,5,7</span><br><span class="line">passwd,6,7</span><br><span class="line">passwd,7,7</span><br><span class="line">passwd,8,7</span><br><span class="line">………………………………………………………………</span><br></pre></td></tr></table></figure>

<p>&ensp;&ensp;&ensp;&ensp;切割<code>inet</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">james@james-Vostro-5471:~/datas$ ifconfig lo |grep &quot;inet &quot;</span><br><span class="line">        inet 127.0.0.1  netmask 255.0.0.0</span><br><span class="line">james@james-Vostro-5471:~/datas$ ifconfig lo |grep &quot;inet &quot; | awk -F &quot; &quot; &#x27;&#123;print $2&#125;&#x27;</span><br><span class="line">127.0.0.1</span><br></pre></td></tr></table></figure>

<p>&ensp;&ensp;&ensp;&ensp;查询<code>cut.txt</code>中空行所在的行号</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">james@james-Vostro-5471:~/datas$ cat cut.txt</span><br><span class="line"></span><br><span class="line">bei jing sheng yang</span><br><span class="line"></span><br><span class="line">shang hai xiang gang</span><br><span class="line">tian jin xia men</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">wu han tai bei</span><br><span class="line">zheng zhou</span><br><span class="line">fu zhou</span><br><span class="line">james@james-Vostro-5471:~/datas$ awk &#x27;/^$/&#123;print NR&#125;&#x27; cut.txt</span><br><span class="line">1</span><br><span class="line">3</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td></tr></table></figure>

<h4 id="sort"><a href="#sort" class="headerlink" title="sort"></a>sort</h4><p>&ensp;&ensp;&ensp;&ensp;sort命令是在Linux里非常有用，它将文件进行排序，并将排序的结果标准输出。</p>
<p>基本语法： sort 选项 参数</p>
<ul>
<li>-n 依照数值大小排序</li>
<li>-r 以相反的顺序来排序</li>
<li>-t 设置排序时所用的分隔字符</li>
<li>-k 指定需要排序的列</li>
</ul>
<p>&ensp;&ensp;&ensp;&ensp;参数： 指定待排序的文件列表</p>
<p>范例：</p>
<p>数据准备：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">james@james-Vostro-5471:~/datas$ vim sort.txt</span><br><span class="line">james@james-Vostro-5471:~/datas$ cat sort.txt</span><br><span class="line">aa:12:5.4</span><br><span class="line">ba:14:67</span><br><span class="line">kl:421:4</span><br><span class="line">er:00:5</span><br><span class="line">hj:213:00</span><br></pre></td></tr></table></figure>

<p>按照 “:” 分割后的第三列倒序排序</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">james@james-Vostro-5471:~/datas$ sort -t : -k 3 -n sort.txt</span><br><span class="line">hj:213:00</span><br><span class="line">kl:421:4</span><br><span class="line">er:00:5</span><br><span class="line">aa:12:5.4</span><br><span class="line">ba:14:67</span><br></pre></td></tr></table></figure>

<p>用第二列的数值进行倒序排序</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">james@james-Vostro-5471:~/datas$ sort -t : -nrk 2 sort.txt</span><br><span class="line">kl:421:4</span><br><span class="line">hj:213:00</span><br><span class="line">ba:14:67</span><br><span class="line">aa:12:5.4</span><br><span class="line">er:00:5</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>shell</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>shell</tag>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>遍历二叉树的几个算法题</title>
    <url>/2021/05/07/%E4%BA%8C%E5%8F%89%E6%A0%91%EF%BC%9A%E9%81%8D%E5%8E%86%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%87%A0%E4%B8%AA%E7%AE%97%E6%B3%95%E9%A2%98/</url>
    <content><![CDATA[<p>&ensp;&ensp;&ensp;&ensp;对于二叉树的遍历模板，运用到实际题目中才能熟练掌握其精髓，下面是以前做过的相关算法题，现在整理了出来。</p>
<span id="more"></span>

<h4 id="98-验证二叉搜索树"><a href="#98-验证二叉搜索树" class="headerlink" title="98. 验证二叉搜索树"></a><a href="https://leetcode-cn.com/problems/validate-binary-search-tree/">98. 验证二叉搜索树</a></h4><p>&ensp;&ensp;&ensp;&ensp;给定一个二叉树，判断其是否是一个有效的二叉搜索树。</p>
<p>&ensp;&ensp;&ensp;&ensp;假设一个二叉搜索树具有如下特征：</p>
<ul>
<li>  节点的左子树只包含<strong>小于</strong>当前节点的数。</li>
<li>  节点的右子树只包含<strong>大于</strong>当前节点的数。</li>
<li>  所有左子树和右子树自身必须也是二叉搜索树。</li>
</ul>
<p><strong>示例 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入:</span><br><span class="line">    2</span><br><span class="line">   &#x2F; \</span><br><span class="line">  1   3</span><br><span class="line">输出: true</span><br></pre></td></tr></table></figure>

<p><strong>示例 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入:</span><br><span class="line">    5</span><br><span class="line">   &#x2F; \</span><br><span class="line">  1   4</span><br><span class="line">     &#x2F; \</span><br><span class="line">    3   6</span><br><span class="line">输出: false</span><br><span class="line">解释: 输入为: [5,1,4,null,null,3,6]。</span><br><span class="line">     根节点的值为 5 ，但是其右子节点值为 4 。</span><br></pre></td></tr></table></figure>

<p><strong>思路与代码</strong>：</p>
<p>&ensp;&ensp;&ensp;&ensp;遍历每个节点，记录好它的边界值，比如对于<code>root</code>的左子节点，它的最大值小于<code>root-&gt;val</code>，对于<code>root</code>的右子节点，它的最小值大于<code>root-&gt;val</code>。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isValidBST</span><span class="params">(TreeNode* root)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">isValidBST</span>(root, <span class="literal">nullptr</span>, <span class="literal">nullptr</span>);</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">//min, max 负责记录边界值</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isValidBST</span><span class="params">(TreeNode* root, TreeNode* min, TreeNode* max)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(min != <span class="literal">nullptr</span> &amp;&amp; root-&gt;val &lt;= min-&gt;val)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(max != <span class="literal">nullptr</span> &amp;&amp; root-&gt;val &gt;= max-&gt;val)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">isValidBST</span>(root-&gt;left, min, root)</span><br><span class="line">                &amp;&amp; <span class="built_in">isValidBST</span>(root-&gt;right, root, max);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h4 id="102-二叉树的层序遍历"><a href="#102-二叉树的层序遍历" class="headerlink" title="102. 二叉树的层序遍历"></a><a href="https://leetcode-cn.com/problems/binary-tree-level-order-traversal/">102. 二叉树的层序遍历</a></h4><p>&ensp;&ensp;&ensp;&ensp;给你一个二叉树，请你返回其按 <strong>层序遍历</strong> 得到的节点值。 （即逐层地，从左到右访问所有节点）。</p>
<p><strong>示例：</strong><br>&ensp;&ensp;&ensp;&ensp;二叉树：<code>[3,9,20,null,null,15,7]</code>,</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">  3</span><br><span class="line"> &#x2F; \</span><br><span class="line">9  20</span><br><span class="line">  &#x2F;  \</span><br><span class="line"> 15   7</span><br></pre></td></tr></table></figure>

<p>&ensp;&ensp;&ensp;&ensp;返回其层序遍历结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[</span><br><span class="line">  [3],</span><br><span class="line">  [9,20],</span><br><span class="line">  [15,7]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p>&ensp;&ensp;&ensp;&ensp;思路与代码：有递归和迭代两种。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">levelOrder</span>(TreeNode* root) </span><br><span class="line">    &#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; ans;</span><br><span class="line">        <span class="built_in">pre</span>(root, <span class="number">0</span>, ans);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">pre</span><span class="params">(TreeNode* root, <span class="keyword">int</span> depth, vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; &amp;ans)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="comment">//先序遍历，遍历过程中记录层数</span></span><br><span class="line">        <span class="keyword">if</span> (depth &gt;= ans.<span class="built_in">size</span>())</span><br><span class="line">            ans.<span class="built_in">push_back</span>(vector&lt;<span class="keyword">int</span>&gt; &#123;&#125;);</span><br><span class="line">        ans[depth].<span class="built_in">push_back</span>(root-&gt;val);</span><br><span class="line">        <span class="built_in">pre</span>(root-&gt;left, depth + <span class="number">1</span>, ans);</span><br><span class="line">        <span class="built_in">pre</span>(root-&gt;right, depth + <span class="number">1</span>, ans);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>&ensp;&ensp;&ensp;&ensp;另一解法</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">levelOrder</span>(TreeNode* root) </span><br><span class="line">    &#123;</span><br><span class="line">        queue&lt;TreeNode*&gt; que;</span><br><span class="line">        que.<span class="built_in">push</span>(root);</span><br><span class="line">        vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">        <span class="keyword">while</span> (que.<span class="built_in">size</span>() != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> size = que.<span class="built_in">size</span>();</span><br><span class="line">            vector&lt;<span class="keyword">int</span>&gt; level;</span><br><span class="line">            <span class="keyword">while</span> (size --) &#123;</span><br><span class="line">                TreeNode* cur = que.<span class="built_in">front</span>();</span><br><span class="line">                que.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="keyword">if</span> (!cur) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                level.<span class="built_in">push_back</span>(cur-&gt;val);</span><br><span class="line">                que.<span class="built_in">push</span>(cur-&gt;left);</span><br><span class="line">                que.<span class="built_in">push</span>(cur-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (level.<span class="built_in">size</span>() != <span class="number">0</span>) &#123;</span><br><span class="line">                res.<span class="built_in">push_back</span>(level);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h4 id="230-二叉搜索树中第K小的元素"><a href="#230-二叉搜索树中第K小的元素" class="headerlink" title="230. 二叉搜索树中第K小的元素"></a><a href="https://leetcode-cn.com/problems/kth-smallest-element-in-a-bst/">230. 二叉搜索树中第K小的元素</a></h4><p>&ensp;&ensp;&ensp;&ensp;给定一个二叉搜索树的根节点 <code>root</code> ，和一个整数 <code>k</code> ，请你设计一个算法查找其中第 <code>k</code> 个最小元素（从 1 开始计数）。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">    3</span><br><span class="line">   &#x2F; \</span><br><span class="line">  1   4</span><br><span class="line">   \   </span><br><span class="line">    2   </span><br><span class="line">输入：root &#x3D; [3,1,4,null,2], k &#x3D; 1</span><br><span class="line">输出：1</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">        5</span><br><span class="line">       &#x2F; \</span><br><span class="line">      3   6</span><br><span class="line">     &#x2F; \  </span><br><span class="line">    2   4 </span><br><span class="line">   &#x2F;</span><br><span class="line">  1 </span><br><span class="line">输入：root &#x3D; [5,3,6,2,4,null,null,1], k &#x3D; 3</span><br><span class="line">输出：3</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li>  树中的节点数为 <code>n</code> 。</li>
<li>  <code>1 &lt;= k &lt;= n &lt;= 104</code></li>
<li>  <code>0 &lt;= Node.val &lt;= 104</code></li>
</ul>
<p><strong>进阶：</strong>如果二叉搜索树经常被修改（插入/删除操作）并且你需要频繁地查找第 <code>k</code> 小的值，你将如何优化算法？</p>
<p><strong>思路与代码</strong>：</p>
<p>&ensp;&ensp;&ensp;&ensp;BST的中序遍历为升序数组，所以一边中序遍历一边记录已查找的个数即可。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> rank = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">traves</span><span class="params">(TreeNode* root, <span class="keyword">int</span> k)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">traves</span>(root-&gt;left, k);</span><br><span class="line"></span><br><span class="line">        ++rank;</span><br><span class="line">        <span class="keyword">if</span>(rank == k)</span><br><span class="line">        &#123;</span><br><span class="line">            res = root-&gt;val;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;           </span><br><span class="line"></span><br><span class="line">        <span class="built_in">traves</span>(root-&gt;right, k);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">kthSmallest</span><span class="params">(TreeNode* root, <span class="keyword">int</span> k)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">traves</span>(root,k);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="236-二叉树的最近公共祖先"><a href="#236-二叉树的最近公共祖先" class="headerlink" title="236. 二叉树的最近公共祖先"></a><a href="https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-tree/">236. 二叉树的最近公共祖先</a></h4><p>    给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。</p>
<p>    最近公共祖先的定义为：“对于有根树 T 的两个节点 p、q，最近公共祖先表示为一个节点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（<strong>一个节点也可以是它自己的祖先</strong>）。” </p>
<p><strong>示例 1：</strong></p>
<p><img src="/2021/05/07/%E4%BA%8C%E5%8F%89%E6%A0%91%EF%BC%9A%E9%81%8D%E5%8E%86%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%87%A0%E4%B8%AA%E7%AE%97%E6%B3%95%E9%A2%98/1.png" alt="img"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：root &#x3D; [3,5,1,6,2,0,8,null,null,7,4], p &#x3D; 5, q &#x3D; 1</span><br><span class="line">输出：3</span><br><span class="line">解释：节点 5 和节点 1 的最近公共祖先是节点 3 。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<p><img src="/2021/05/07/%E4%BA%8C%E5%8F%89%E6%A0%91%EF%BC%9A%E9%81%8D%E5%8E%86%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%87%A0%E4%B8%AA%E7%AE%97%E6%B3%95%E9%A2%98/2.png" alt="img"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：root &#x3D; [3,5,1,6,2,0,8,null,null,7,4], p &#x3D; 5, q &#x3D; 4</span><br><span class="line">输出：5</span><br><span class="line">解释：节点 5 和节点 4 的最近公共祖先是节点 5 。因为根据定义最近公共祖先节点可以为节点本身。</span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：root &#x3D; [1,2], p &#x3D; 1, q &#x3D; 2</span><br><span class="line">输出：1</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li>  树中节点数目在范围 <code>[2, 105]</code> 内。</li>
<li>  <code>-109 &lt;= Node.val &lt;= 109</code></li>
<li>  所有 <code>Node.val</code> <code>互不相同</code> 。</li>
<li>  <code>p != q</code></li>
<li>  <code>p</code> 和 <code>q</code> 均存在于给定的二叉树中。</li>
</ul>
<p><strong>思路与代码</strong>：</p>
<p>    递归思想, 对以root为根的(子)树进行查找p和q, 如果root == null || p || q 直接返回root，表示对于当前树的查找已经完毕, 否则对左右子树进行查找, 根据左右子树的返回值判断:</p>
<ul>
<li>  左右子树的返回值都不为<code>nullptr</code>，由于值唯一左右子树的返回值就是<code>p</code>和<code>q</code>, 此时<code>root</code>为LCA</li>
<li>  左右子树返回值只有一个不为<code>nullptr</code>, 说明只有<code>p</code>和<code>q</code>存在与左或右子树中, 最先找到的那个节点为LCA</li>
<li>  左右子树返回值均为<code>nullptr</code>, <code>p</code>和<code>q</code>均不在树中, 返回<code>nullptr</code></li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">lowestCommonAncestor</span><span class="params">(TreeNode* root, TreeNode* p, TreeNode* q)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">if</span>(root == p || root == q)</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line"></span><br><span class="line">        TreeNode* left = <span class="built_in">lowestCommonAncestor</span>(root-&gt;left, p, q);</span><br><span class="line">        TreeNode* right = <span class="built_in">lowestCommonAncestor</span>(root-&gt;right, p, q);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(left != <span class="literal">nullptr</span> &amp;&amp; right != <span class="literal">nullptr</span>)</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        <span class="keyword">if</span>(left == <span class="literal">nullptr</span> &amp;&amp; right == <span class="literal">nullptr</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">return</span> left == <span class="literal">nullptr</span> ? right : left;          </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h4 id="538-把二叉搜索树转换为累加树"><a href="#538-把二叉搜索树转换为累加树" class="headerlink" title="538. 把二叉搜索树转换为累加树"></a><a href="https://leetcode-cn.com/problems/convert-bst-to-greater-tree/">538. 把二叉搜索树转换为累加树</a></h4><p>&ensp;&ensp;&ensp;&ensp;给出二叉 <strong>搜索</strong> 树的根节点，该树的节点值各不相同，请你将其转换为累加树（Greater Sum Tree），使每个节点 <code>node</code> 的新值等于原树中大于或等于 <code>node.val</code> 的值之和。</p>
<p>&ensp;&ensp;&ensp;&ensp;提醒一下，二叉搜索树满足下列约束条件：</p>
<ul>
<li>  节点的左子树仅包含键 <strong>小于</strong> 节点键的节点。</li>
<li>  节点的右子树仅包含键 <strong>大于</strong> 节点键的节点。</li>
<li>  左右子树也必须是二叉搜索树。</li>
</ul>
<p><strong>示例 1：</strong></p>
<p><strong><img src="/2021/05/07/%E4%BA%8C%E5%8F%89%E6%A0%91%EF%BC%9A%E9%81%8D%E5%8E%86%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%87%A0%E4%B8%AA%E7%AE%97%E6%B3%95%E9%A2%98/3.png" alt="img" style="zoom:33%;"></strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：[4,1,6,0,2,5,7,null,null,null,3,null,null,null,8]</span><br><span class="line">输出：[30,36,21,36,35,26,15,null,null,null,33,null,null,null,8]</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：root &#x3D; [0,null,1]</span><br><span class="line">输出：[1,null,1]</span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：root &#x3D; [1,0,2]</span><br><span class="line">输出：[3,3,2]</span><br></pre></td></tr></table></figure>

<p><strong>示例 4：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：root &#x3D; [3,2,4,1]</span><br><span class="line">输出：[7,9,4,10]</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li>  树中的节点数介于 <code>0</code> 和 <code>104</code> 之间。</li>
<li>  每个节点的值介于 <code>-104</code> 和 <code>104</code> 之间。</li>
<li>  树中的所有值 <strong>互不相同</strong> 。</li>
<li>  给定的树为二叉搜索树</li>
</ul>
<p><strong>思路与代码</strong>：</p>
<p>&ensp;&ensp;&ensp;&ensp;这不就是中序遍历中，每一个节点的值加上后面所有结点的值的遍历结果吗？为了方便累加，我们改变中序遍历的顺序，先遍历右子树，再遍历左子树。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="function">TreeNode* <span class="title">convertBST</span><span class="params">(TreeNode* root)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="built_in">travers</span>(root);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">travers</span><span class="params">(TreeNode* root)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="built_in">travers</span>(root-&gt;right);</span><br><span class="line"></span><br><span class="line">        sum += root-&gt;val;</span><br><span class="line">        root-&gt;val = sum;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">travers</span>(root-&gt;left);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h4 id="652-寻找重复的子树"><a href="#652-寻找重复的子树" class="headerlink" title="652. 寻找重复的子树"></a><a href="https://leetcode-cn.com/problems/find-duplicate-subtrees/">652. 寻找重复的子树</a></h4><p>&ensp;&ensp;&ensp;&ensp;给定一棵二叉树，返回所有重复的子树。对于同一类的重复子树，你只需要返回其中任意<strong>一棵</strong>的根结点即可。</p>
<p>&ensp;&ensp;&ensp;&ensp;两棵树重复是指它们具有相同的结构以及相同的结点值。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">    1</span><br><span class="line">   &#x2F; \</span><br><span class="line">  2   3</span><br><span class="line"> &#x2F;   &#x2F; \</span><br><span class="line">4   2   4</span><br><span class="line">   &#x2F;</span><br><span class="line">  4</span><br></pre></td></tr></table></figure>

<p>下面是两个重复的子树：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">  2</span><br><span class="line"> &#x2F;</span><br><span class="line">4</span><br></pre></td></tr></table></figure>

<p>和</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">4</span><br></pre></td></tr></table></figure>

<p>&ensp;&ensp;&ensp;&ensp;因此，你需要以列表的形式返回上述重复子树的根结点。</p>
<p><strong>思路与代码</strong>：</p>
<p>&ensp;&ensp;&ensp;&ensp;采用将二叉树序列化的形式，建立哈希表，统计每次出现的次数，添加到结果集当中。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;TreeNode*&gt; <span class="title">findDuplicateSubtrees</span><span class="params">(TreeNode* root)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">          vector&lt;TreeNode*&gt; result;</span><br><span class="line">          unordered_map&lt;string,<span class="keyword">int</span>&gt; mp;</span><br><span class="line">          <span class="built_in">helper</span>(root, result, mp);</span><br><span class="line"></span><br><span class="line">          <span class="keyword">return</span> result;  </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">string <span class="title">helper</span><span class="params">(TreeNode* root, </span></span></span><br><span class="line"><span class="function"><span class="params">                vector&lt;TreeNode*&gt; &amp;result, </span></span></span><br><span class="line"><span class="function"><span class="params">                unordered_map&lt;string,<span class="keyword">int</span>&gt; &amp;mp)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root)</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;#&quot;</span>;</span><br><span class="line"></span><br><span class="line">        string str = <span class="built_in">helper</span>(root-&gt;left, result, mp) + <span class="string">&quot;,&quot;</span> + </span><br><span class="line">                     <span class="built_in">helper</span>(root-&gt;right, result, mp) + <span class="string">&quot;,&quot;</span> + </span><br><span class="line">                     <span class="built_in">to_string</span>(root-&gt;val);</span><br><span class="line">                     </span><br><span class="line">        <span class="keyword">if</span>(mp[str] == <span class="number">1</span>)</span><br><span class="line">            result.<span class="built_in">push_back</span>(root);</span><br><span class="line">        mp[str]++;</span><br><span class="line">        <span class="keyword">return</span> str;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="700-二叉搜索树中的搜索"><a href="#700-二叉搜索树中的搜索" class="headerlink" title="700. 二叉搜索树中的搜索"></a><a href="https://leetcode-cn.com/problems/search-in-a-binary-search-tree/">700. 二叉搜索树中的搜索</a></h4><p>&ensp;&ensp;&ensp;&ensp;给定二叉搜索树（BST）的根节点和一个值。 你需要在BST中找到节点值等于给定值的节点。 返回以该节点为根的子树。 如果节点不存在，则返回 NULL。</p>
<p>&ensp;&ensp;&ensp;&ensp;例如，</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">给定二叉搜索树:</span><br><span class="line"></span><br><span class="line">        4</span><br><span class="line">       &#x2F; \</span><br><span class="line">      2   7</span><br><span class="line">     &#x2F; \</span><br><span class="line">    1   3</span><br><span class="line"></span><br><span class="line">和值: 2</span><br></pre></td></tr></table></figure>

<p>&ensp;&ensp;&ensp;&ensp;你应该返回如下子树:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">  2     </span><br><span class="line"> &#x2F; \   </span><br><span class="line">1   3</span><br></pre></td></tr></table></figure>

<p>&ensp;&ensp;&ensp;&ensp;在上述示例中，如果要找的值是 <code>5</code>，但因为没有节点值为 <code>5</code>，我们应该返回 <code>NULL</code>。</p>
<p><strong>思路与代码</strong>：</p>
<p>&ensp;&ensp;&ensp;&ensp;没什么好说的，直接遍历即可。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">searchBST</span><span class="params">(TreeNode* root, <span class="keyword">int</span> val)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">if</span>(val &gt; root-&gt;val)</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">searchBST</span>(root-&gt;right, val);</span><br><span class="line">        <span class="keyword">if</span>(val &lt; root-&gt;val)</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">searchBST</span>(root-&gt;left, val);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="701-二叉搜索树中的插入操作"><a href="#701-二叉搜索树中的插入操作" class="headerlink" title="701. 二叉搜索树中的插入操作"></a><a href="https://leetcode-cn.com/problems/insert-into-a-binary-search-tree/">701. 二叉搜索树中的插入操作</a></h4><p>&ensp;&ensp;&ensp;&ensp;给定二叉搜索树（BST）的根节点和要插入树中的值，将值插入二叉搜索树。 返回插入后二叉搜索树的根节点。 输入数据 <strong>保证</strong> ，新值和原始二叉搜索树中的任意节点值都不同。</p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>注意</strong>，可能存在多种有效的插入方式，只要树在插入后仍保持为二叉搜索树即可。 你可以返回 <strong>任意有效的结果</strong> 。</p>
<p><strong>示例 1：</strong></p>
<img src="/2021/05/07/%E4%BA%8C%E5%8F%89%E6%A0%91%EF%BC%9A%E9%81%8D%E5%8E%86%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%87%A0%E4%B8%AA%E7%AE%97%E6%B3%95%E9%A2%98/4.jpg" alt="img" style="zoom:50%;">

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：root &#x3D; [4,2,7,1,3], val &#x3D; 5</span><br><span class="line">输出：[4,2,7,1,3,5]</span><br><span class="line">解释：另一个满足题目要求可以通过的树是：</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：root &#x3D; [40,20,60,10,30,50,70], val &#x3D; 25</span><br><span class="line">输出：[40,20,60,10,30,50,70,null,null,25]</span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：root &#x3D; [4,2,7,1,3,null,null,null,null,null,null], val &#x3D; 5</span><br><span class="line">输出：[4,2,7,1,3,5]</span><br></pre></td></tr></table></figure>

<p> <strong>提示：</strong></p>
<ul>
<li>  给定的树上的节点数介于 <code>0</code> 和 <code>10^4</code> 之间</li>
<li>  每个节点都有一个唯一整数值，取值范围从 <code>0</code> 到 <code>10^8</code></li>
<li>  <code>-10^8 &lt;= val &lt;= 10^8</code></li>
<li>  新值和原始二叉搜索树中的任意节点值都不同</li>
</ul>
<p><strong>思路与代码</strong>：</p>
<p>&ensp;&ensp;&ensp;&ensp;遍历找到合适的位置，再插入。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">insertIntoBST</span><span class="params">(TreeNode* root, <span class="keyword">int</span> val)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">TreeNode</span>(val);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(val &gt; root-&gt;val)</span><br><span class="line">            root-&gt;right = <span class="built_in">insertIntoBST</span>(root-&gt;right, val);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            root-&gt;left = <span class="built_in">insertIntoBST</span>(root-&gt;left, val);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="450-删除二叉搜索树中的节点"><a href="#450-删除二叉搜索树中的节点" class="headerlink" title="450. 删除二叉搜索树中的节点"></a><a href="https://leetcode-cn.com/problems/delete-node-in-a-bst/">450. 删除二叉搜索树中的节点</a></h4><p>&ensp;&ensp;&ensp;&ensp;给定一个二叉搜索树的根节点 <strong>root</strong> 和一个值 <strong>key</strong>，删除二叉搜索树中的 <strong>key</strong> 对应的节点，并保证二叉搜索树的性质不变。返回二叉搜索树（有可能被更新）的根节点的引用。</p>
<p>&ensp;&ensp;&ensp;&ensp;一般来说，删除节点可分为两个步骤：</p>
<ol>
<li> 首先找到需要删除的节点；</li>
<li> 如果找到了，删除它。</li>
</ol>
<p><strong>说明：</strong> 要求算法时间复杂度为 O(h)，h 为树的高度。</p>
<p><strong>示例:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">root &#x3D; [5,3,6,2,4,null,7]</span><br><span class="line">key &#x3D; 3</span><br><span class="line"></span><br><span class="line">    5</span><br><span class="line">   &#x2F; \</span><br><span class="line">  3   6</span><br><span class="line"> &#x2F; \   \</span><br><span class="line">2   4   7</span><br><span class="line"></span><br><span class="line">给定需要删除的节点值是 3，所以我们首先找到 3 这个节点，然后删除它。</span><br><span class="line"></span><br><span class="line">一个正确的答案是 [5,4,6,2,null,null,7], 如下图所示。</span><br><span class="line"></span><br><span class="line">    5</span><br><span class="line">   &#x2F; \</span><br><span class="line">  4   6</span><br><span class="line"> &#x2F;     \</span><br><span class="line">2       7</span><br><span class="line"></span><br><span class="line">另一个正确答案是 [5,2,6,null,4,null,7]。</span><br><span class="line"></span><br><span class="line">    5</span><br><span class="line">   &#x2F; \</span><br><span class="line">  2   6</span><br><span class="line">   \   \</span><br><span class="line">    4   7</span><br></pre></td></tr></table></figure>

<p><strong>思路与代码</strong>：</p>
<p>&ensp;&ensp;&ensp;&ensp;要删除的节点<code>A</code>有三种情况：</p>
<p>&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;<code>A</code>恰好是末端节点，两个子节点都为空，那么它可以当场去世了。</p>
<p>&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;<code>A</code>只有一个非空子节点，那么它要让这个孩子接替自己的位置。</p>
<p>&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;<code>A</code>有两个子节点，麻烦了，为了不破坏 BST 的性质，<code>A</code>必须找到左子树中最大的那个节点，或者右子树中最小的那个节点来接替自己。我采用第二种方式。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">getMin</span><span class="params">(TreeNode* root)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(root-&gt;left)</span><br><span class="line">            root = root-&gt;left;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">TreeNode* <span class="title">deleteNode</span><span class="params">(TreeNode* root, <span class="keyword">int</span> key)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">if</span>(key &gt; root-&gt;val)</span><br><span class="line">            root-&gt;right = <span class="built_in">deleteNode</span>(root-&gt;right, key);</span><br><span class="line">        <span class="keyword">if</span>(key &lt; root-&gt;val)</span><br><span class="line">            root-&gt;left = <span class="built_in">deleteNode</span>(root-&gt;left, key);</span><br><span class="line">        <span class="keyword">if</span>(key == root-&gt;val)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(!root-&gt;left) <span class="keyword">return</span> root-&gt;right;</span><br><span class="line">            <span class="keyword">if</span>(!root-&gt;right) <span class="keyword">return</span> root-&gt;left;</span><br><span class="line"></span><br><span class="line">            TreeNode* minNode = <span class="built_in">getMin</span>(root-&gt;right);</span><br><span class="line">            root-&gt;val = minNode-&gt;val;</span><br><span class="line">            root-&gt;right = <span class="built_in">deleteNode</span>(root-&gt;right, minNode-&gt;val);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><a href="https://mp.weixin.qq.com/s?__biz=MzAxODQxMDM0Mw==&mid=2247488128&idx=2&sn=b8fb3fd2917f9ac86127054741cd5877&chksm=9bd7ec88aca0659ee0185b657663169169493e9df2063fa4d28b38a0b4d0dd698d0301937898&scene=21#wechat_redirect">原创 | 手把手刷二叉搜索树（第二期） (qq.com)</a></p>
]]></content>
      <categories>
        <category>算法</category>
        <category>二叉树</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>二叉树</tag>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>排列组合之子集</title>
    <url>/2021/05/09/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E5%AD%A6%EF%BC%9A%E5%AD%90%E9%9B%86/</url>
    <content><![CDATA[<p>&ensp;&ensp;排列组合子集问题都是用回溯算法解决，解决子集的问题与解决排列大致相同。</p>
<span id="more"></span>

<h3 id="一、子集"><a href="#一、子集" class="headerlink" title="一、子集"></a>一、子集</h3><h4 id="1-1题目"><a href="#1-1题目" class="headerlink" title="1.1题目"></a>1.1题目</h4><p>&ensp;&ensp;&ensp;&ensp;给你一个整数数组 <code>nums</code> ，数组中的元素 <strong>互不相同</strong> 。返回该数组所有可能的子集（幂集）。</p>
<p>解集 <strong>不能</strong> 包含重复的子集。你可以按 <strong>任意顺序</strong> 返回解集。</p>
<p> <strong>示例 1：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：nums &#x3D; [1,2,3]</span><br><span class="line">输出：[[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：nums &#x3D; [0]</span><br><span class="line">输出：[[],[0]]</span><br></pre></td></tr></table></figure>

<p> <strong>提示：</strong></p>
<ul>
<li>  <code>1 &lt;= nums.length &lt;= 10</code></li>
<li>  <code>-10 &lt;= nums[i] &lt;= 10</code></li>
<li>  <code>nums</code> 中的所有元素 <strong>互不相同</strong></li>
</ul>
<h4 id="1-2思路与代码"><a href="#1-2思路与代码" class="headerlink" title="1.2思路与代码"></a>1.2思路与代码</h4><p>&ensp;&ensp;&ensp;&ensp;照着《排列组合之排列》的基本思路，改变一下代码：</p>
<ul>
<li>  每一步都要加入<code>ans</code></li>
<li>  递归的时候改变起点</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; ans;</span><br><span class="line"></span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">subsets</span>(vector&lt;<span class="keyword">int</span>&gt;&amp; nums) </span><br><span class="line">    &#123;</span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt; track;</span><br><span class="line">        <span class="built_in">backtrack</span>(nums, <span class="number">0</span>, track);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">backtrack</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> start, vector&lt;<span class="keyword">int</span>&gt;&amp; track)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        ans.<span class="built_in">push_back</span>(track);</span><br><span class="line">        <span class="comment">// 注意 i 从 start 开始递增</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = start; i &lt; nums.<span class="built_in">size</span>(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 做选择</span></span><br><span class="line">            track.<span class="built_in">push_back</span>(nums[i]);</span><br><span class="line">            <span class="comment">// 回溯</span></span><br><span class="line">            <span class="built_in">backtrack</span>(nums, i + <span class="number">1</span>, track);</span><br><span class="line">            <span class="comment">// 撤销选择</span></span><br><span class="line">            track.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="二、子集-II"><a href="#二、子集-II" class="headerlink" title="二、子集 II"></a>二、子集 II</h3><p>&ensp;&ensp;&ensp;&ensp;给你一个整数数组 <code>nums</code> ，其中可能包含重复元素，请你返回该数组所有可能的子集（幂集）。</p>
<p>&ensp;&ensp;&ensp;&ensp;解集 <strong>不能</strong> 包含重复的子集。返回的解集中，子集可以按 <strong>任意顺序</strong> 排列。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：nums &#x3D; [1,2,2]</span><br><span class="line">输出：[[],[1],[1,2],[1,2,2],[2],[2,2]]</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：nums &#x3D; [0]</span><br><span class="line">输出：[[],[0]]</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li>  <code>1 &lt;= nums.length &lt;= 10</code></li>
<li>  <code>-10 &lt;= nums[i] &lt;= 10</code></li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    set&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; ans;</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">subsetsWithDup</span>(vector&lt;<span class="keyword">int</span>&gt;&amp; nums) </span><br><span class="line">    &#123;</span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt; track;</span><br><span class="line">        <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line">        <span class="built_in">backtrack</span>(nums, <span class="number">0</span>, track);</span><br><span class="line">        vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">res</span>(ans.<span class="built_in">begin</span>(), ans.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">backtrack</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> start, vector&lt;<span class="keyword">int</span>&gt;&amp; track)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        ans.<span class="built_in">insert</span>(track);</span><br><span class="line">        <span class="comment">// 注意 i 从 start 开始递增</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = start; i &lt; nums.<span class="built_in">size</span>(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 做选择</span></span><br><span class="line">            track.<span class="built_in">push_back</span>(nums[i]);</span><br><span class="line">            <span class="comment">// 回溯</span></span><br><span class="line">            <span class="built_in">backtrack</span>(nums, i + <span class="number">1</span>, track);</span><br><span class="line">            <span class="comment">// 撤销选择</span></span><br><span class="line">            track.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><a href="https://mp.weixin.qq.com/s?__biz=MzAxODQxMDM0Mw==&mid=2247485007&idx=1&sn=ceb42ba2f341af34953d158358c61f7c&chksm=9bd7f847aca071517fe0889d2679ead78b40caf6978ebc1d3d8355d6693acc7ec3aca60823f0&scene=21#wechat_redirect">回溯算法团灭排列/组合/子集问题</a></p>
]]></content>
      <categories>
        <category>算法</category>
        <category>数学</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>leetcode</tag>
        <tag>数学</tag>
        <tag>回溯</tag>
        <tag>排列组合</tag>
      </tags>
  </entry>
  <entry>
    <title>排列组合之排列</title>
    <url>/2021/05/09/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E5%AD%A6%EF%BC%9A%E6%8E%92%E5%88%97/</url>
    <content><![CDATA[<p>&ensp;&ensp;&ensp;&ensp;排列组合子集问题都是用回溯算法解决，下面以<code>leetcode</code>中相关的习题为例进行分析。</p>
<span id="more"></span>

<h3 id="一、-全排列"><a href="#一、-全排列" class="headerlink" title="一、 全排列"></a>一、 全排列</h3><h4 id="1-1题目"><a href="#1-1题目" class="headerlink" title="1.1题目"></a>1.1题目</h4><p>&ensp;&ensp;&ensp;&ensp;给定一个 <strong>没有重复</strong> 数字的序列，返回其所有可能的全排列。</p>
<p><strong>示例:</strong></p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">输入: [1,2,3]</span><br><span class="line">输出:</span><br><span class="line">[</span><br><span class="line">  [1,2,3],</span><br><span class="line">  [1,3,2],</span><br><span class="line">  [2,1,3],</span><br><span class="line">  [2,3,1],</span><br><span class="line">  [3,1,2],</span><br><span class="line">  [3,2,1]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<h4 id="1-2思路与代码"><a href="#1-2思路与代码" class="headerlink" title="1.2思路与代码"></a>1.2思路与代码</h4><p>大体思路如下：</p>
<ul>
<li>  第一步：从n个数中选取第一个排列的第一个元素，如1；</li>
<li>  第一步：从n个数中选取第一个排列的第二个元素，如2；</li>
<li>  ……</li>
<li>  第n步：从n个数中选取第一个排列的第n个元素，如n；</li>
</ul>
<p>&ensp;&ensp;&ensp;&ensp;当然不能选重复的。到此，第一个排列已经选出来了。那么第二个排列怎么选呢？</p>
<p>&ensp;&ensp;&ensp;&ensp;上一个排列执行到第n步后，这个函数不再执行，进行回溯，那么就会回到第n-1步，这时前面的n-1个数都已经选过了，所以第n-1步选择的就会是n了，然后第n步选择的就是n-1。</p>
<p>&ensp;&ensp;&ensp;&ensp;所以第一个排列是：1 2 3 。。。n-1 n；</p>
<p>&ensp;&ensp;&ensp;&ensp;第二个是：1 2 3 。。。n n-1；</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; ans;</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">permute</span>(vector&lt;<span class="keyword">int</span>&gt;&amp; nums) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums.<span class="built_in">size</span>() == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> ans;</span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt; track;</span><br><span class="line">        <span class="built_in">backtrack</span>(nums, track);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">backtrack</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, vector&lt;<span class="keyword">int</span>&gt;&amp; track)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(track.<span class="built_in">size</span>() == nums.<span class="built_in">size</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            ans.<span class="built_in">push_back</span>(track);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 做选择</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">find</span>(track.<span class="built_in">begin</span>(), track.<span class="built_in">end</span>(), nums[i]) != track.<span class="built_in">end</span>())</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 回溯</span></span><br><span class="line">            track.<span class="built_in">push_back</span>(nums[i]);</span><br><span class="line">            <span class="built_in">backtrack</span>(nums, track);</span><br><span class="line">            <span class="comment">// 撤销选择</span></span><br><span class="line">            track.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<img src="/2021/05/09/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E5%AD%A6%EF%BC%9A%E6%8E%92%E5%88%97/1.png" alt="image-20210508234947950" style="zoom:50%;">

<p>&ensp;&ensp;&ensp;&ensp;还有另外一种实现的方法，有着很好的用处，可以方便的解决一些搜索的题目。思路就是我选择了一个元素，那么就把这个元素交换到当前这个位置，就不用开一个数组标记了。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; ans;</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">permute</span>(vector&lt;<span class="keyword">int</span>&gt;&amp; nums) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums.<span class="built_in">size</span>() == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> ans;</span><br><span class="line">        <span class="built_in">backtrack</span>(nums, <span class="number">0</span>, nums.<span class="built_in">size</span>());</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">backtrack</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> start, <span class="keyword">const</span> <span class="keyword">int</span> size)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(start == size)</span><br><span class="line">        &#123;</span><br><span class="line">            ans.<span class="built_in">push_back</span>(nums);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">            </span><br><span class="line">        <span class="comment">// 注意 i 从 start 开始递增</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = start; i &lt; size; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 做选择</span></span><br><span class="line">            <span class="built_in">swap</span>(nums[i], nums[start]);</span><br><span class="line">            <span class="comment">// 递归</span></span><br><span class="line">            <span class="built_in">backtrack</span>(nums, start + <span class="number">1</span>, size);</span><br><span class="line">            <span class="comment">// 撤销选择</span></span><br><span class="line">            <span class="built_in">swap</span>(nums[i], nums[start]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="二、全排列-II"><a href="#二、全排列-II" class="headerlink" title="二、全排列 II"></a>二、全排列 II</h3><h4 id="2-1题目"><a href="#2-1题目" class="headerlink" title="2.1题目"></a>2.1题目</h4><p>&ensp;&ensp;&ensp;&ensp;给定一个可包含重复数字的序列 <code>nums</code> ，<strong>按任意顺序</strong> 返回所有不重复的全排列。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：nums &#x3D; [1,1,2]</span><br><span class="line">输出：</span><br><span class="line">[[1,1,2],</span><br><span class="line"> [1,2,1],</span><br><span class="line"> [2,1,1]]</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：nums &#x3D; [1,2,3]</span><br><span class="line">输出：[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li>  <code>1 &lt;= nums.length &lt;= 8</code></li>
<li>  <code>-10 &lt;= nums[i] &lt;= 10</code></li>
</ul>
<h4 id="2-2思路与代码"><a href="#2-2思路与代码" class="headerlink" title="2.2思路与代码"></a>2.2思路与代码</h4><p>&ensp;&ensp;&ensp;&ensp;基本算法不需过多改变，可以增加一个查询判断即可；也可以巧用数据结构以简化代码，既然涉及到去重，那么用<code>set</code>代替<code>vector</code>即可。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    set&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">permuteUnique</span>(vector&lt;<span class="keyword">int</span>&gt;&amp; nums) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">backtrack</span>(nums, <span class="number">0</span>, nums.<span class="built_in">size</span>());</span><br><span class="line">        vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">ans</span>(res.<span class="built_in">begin</span>(), res.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">backtrack</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> start, <span class="keyword">const</span> <span class="keyword">int</span> size)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(start == size)</span><br><span class="line">        &#123;</span><br><span class="line">            res.<span class="built_in">insert</span>(nums);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">            </span><br><span class="line">        <span class="comment">// 注意 i 从 start 开始递增</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = start; i &lt; size; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 做选择</span></span><br><span class="line">            <span class="built_in">swap</span>(nums[i], nums[start]);</span><br><span class="line">            <span class="comment">// 递归</span></span><br><span class="line">            <span class="built_in">backtrack</span>(nums, start + <span class="number">1</span>, size);</span><br><span class="line">            <span class="comment">// 撤销选择</span></span><br><span class="line">            <span class="built_in">swap</span>(nums[i], nums[start]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><a href="https://mp.weixin.qq.com/s?__biz=MzAxODQxMDM0Mw==&mid=2247485007&idx=1&sn=ceb42ba2f341af34953d158358c61f7c&chksm=9bd7f847aca071517fe0889d2679ead78b40caf6978ebc1d3d8355d6693acc7ec3aca60823f0&scene=21#wechat_redirect">回溯算法团灭排列/组合/子集问题</a></p>
<p><a href="https://mp.weixin.qq.com/s?__biz=MzAxODQxMDM0Mw==&mid=2247484709&idx=1&sn=1c24a5c41a5a255000532e83f38f2ce4&chksm=9bd7fb2daca0723be888b30345e2c5e64649fc31a00b05c27a0843f349e2dd9363338d0dac61&scene=21#wechat_redirect">回溯算法详解（修订版） (qq.com)</a></p>
]]></content>
      <categories>
        <category>算法</category>
        <category>数学</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>leetcode</tag>
        <tag>数学</tag>
        <tag>回溯</tag>
        <tag>排列组合</tag>
      </tags>
  </entry>
  <entry>
    <title>杨辉三角相关</title>
    <url>/2021/05/09/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E5%AD%A6%EF%BC%9A%E6%9D%A8%E8%BE%89%E4%B8%89%E8%A7%92%E7%9B%B8%E5%85%B3/</url>
    <content><![CDATA[<h3 id="一、杨辉三角"><a href="#一、杨辉三角" class="headerlink" title="一、杨辉三角"></a>一、杨辉三角</h3><p>&ensp;&ensp;&ensp;&ensp;杨辉三角，是<a href="https://baike.baidu.com/item/%E4%BA%8C%E9%A1%B9%E5%BC%8F%E7%B3%BB%E6%95%B0/6763242">二项式系数</a>在三角形中的一种几何排列。</p>
<span id="more"></span>

<p><img src="/2021/05/09/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E5%AD%A6%EF%BC%9A%E6%9D%A8%E8%BE%89%E4%B8%89%E8%A7%92%E7%9B%B8%E5%85%B3/1.png" alt="查看源图像"></p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>在写代码时遇到阶乘，要用杨辉三角相关公式，不让时间复杂度太大。</strong></p>
<h3 id="二、例题"><a href="#二、例题" class="headerlink" title="二、例题"></a>二、例题</h3><h4 id="2-1"><a href="#2-1" class="headerlink" title="2.1"></a>2.1</h4><p>&ensp;&ensp;&ensp;&ensp;给定一个非负整数 numRows，生成杨辉三角的前 numRows 行。</p>
<p>&ensp;&ensp;&ensp;&ensp;在杨辉三角中，每个数是它左上方和右上方的数的和。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">示例:</span><br><span class="line">输入: <span class="number">5</span></span><br><span class="line">输出:</span><br><span class="line">[</span><br><span class="line">     [<span class="number">1</span>],</span><br><span class="line">    [<span class="number">1</span>,<span class="number">1</span>],</span><br><span class="line">   [<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>],</span><br><span class="line">  [<span class="number">1</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">1</span>],</span><br><span class="line"> [<span class="number">1</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">4</span>,<span class="number">1</span>]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p>&ensp;&ensp;&ensp;&ensp;代码</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">generate</span>(<span class="keyword">int</span> numRows) </span><br><span class="line">    &#123; </span><br><span class="line">        vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; ans;</span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt; temp;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numRows ; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            temp.<span class="built_in">push_back</span>(<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>; j &lt; i + <span class="number">1</span> ; ++j)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(j &lt; i)   temp.<span class="built_in">push_back</span>(ans[i<span class="number">-1</span>][j]+ans[i<span class="number">-1</span>][j<span class="number">-1</span>]);</span><br><span class="line">                <span class="keyword">if</span>(j == i)  temp.<span class="built_in">push_back</span>(<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            ans.<span class="built_in">push_back</span>(temp);</span><br><span class="line">            temp.<span class="built_in">clear</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h4 id="2-2"><a href="#2-2" class="headerlink" title="2.2"></a>2.2</h4><p>&ensp;&ensp;&ensp;&ensp;给定一个非负索引 <em>k</em>，其中 <em>k</em> ≤ 33，返回杨辉三角的第 <em>k</em> 行。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">示例:</span><br><span class="line">输入: 3</span><br><span class="line">输出: [1,3,3,1]</span><br></pre></td></tr></table></figure>

<p>&ensp;&ensp;&ensp;&ensp;递推式<img src="/2021/05/09/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E5%AD%A6%EF%BC%9A%E6%9D%A8%E8%BE%89%E4%B8%89%E8%A7%92%E7%9B%B8%E5%85%B3/2.png" alt="image-20210307172241629">表明，当前行第 i 项的计算只与上一行第 i-1 项及第 i 项有关。因此我们可以倒着计算当前行，这样计算到第 i 项时，第 i−1 项仍然是上一行的值。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">getRow</span><span class="params">(<span class="keyword">int</span> rowIndex)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">row</span><span class="params">(rowIndex + <span class="number">1</span>)</span></span>;</span><br><span class="line">        row[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= rowIndex; ++i) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &gt; <span class="number">0</span>; --j) </span><br><span class="line">            &#123;</span><br><span class="line">                row[j] += row[j - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> row;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>&ensp;&ensp;&ensp;&ensp;由组合数公式</p>
<p>&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;<img src="/2021/05/09/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E5%AD%A6%EF%BC%9A%E6%9D%A8%E8%BE%89%E4%B8%89%E8%A7%92%E7%9B%B8%E5%85%B3/3.png" alt="image-20210307172802452">     </p>
<p>&ensp;&ensp;&ensp;&ensp;可以得到同一行的相邻组合数的关系</p>
<p>&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;<img src="/2021/05/09/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E5%AD%A6%EF%BC%9A%E6%9D%A8%E8%BE%89%E4%B8%89%E8%A7%92%E7%9B%B8%E5%85%B3/4.png" alt="image-20210307172822607"></p>
<p>&ensp;&ensp;&ensp;&ensp;由于<img src="/2021/05/09/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E5%AD%A6%EF%BC%9A%E6%9D%A8%E8%BE%89%E4%B8%89%E8%A7%92%E7%9B%B8%E5%85%B3/5.png" alt="image-20210307172841470"></p>
<p>&ensp;&ensp;&ensp;&ensp; 利用上述公式我们可以在线性时间计算出第 n 行的所有组合数。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">getRow</span><span class="params">(<span class="keyword">int</span> rowIndex)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">row</span><span class="params">(rowIndex + <span class="number">1</span>)</span></span>;</span><br><span class="line">        row[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= rowIndex; ++i) </span><br><span class="line">        &#123;</span><br><span class="line">            row[i] = <span class="number">1LL</span> * row[i - <span class="number">1</span>] * (rowIndex - i + <span class="number">1</span>) / i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> row;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>&ensp;&ensp;&ensp;&ensp;复杂度分析</p>
<p>&ensp;&ensp;&ensp;&ensp;时间复杂度：O(rowIndex)。</p>
<p>&ensp;&ensp;&ensp;&ensp;空间复杂度：O(1)，不考虑返回值的空间占用。</p>
<h4 id="2-3"><a href="#2-3" class="headerlink" title="2.3"></a>2.3</h4><p>&ensp;&ensp;&ensp;&ensp;小Q有X首长度为A的不同的歌和Y首长度为B的不同的歌，现在小Q想用这些歌组成一个总长度正好为K的歌单，每首歌最多只能在歌单中出现一次，在不考虑歌单内歌曲的先后顺序的情况下，请问有多少种组成歌单的方法。</p>
<p><strong>输入描述:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">每个输入包含一个测试用例。</span><br><span class="line">每个测试用例的第一行包含一个整数，表示歌单的总长度K(1&lt;&#x3D;K&lt;&#x3D;1000)。</span><br><span class="line">接下来的一行包含四个正整数，分别表示歌的第一种长度A(A&lt;&#x3D;10)和数量X(X&lt;&#x3D;100)以及歌的第二种长度B(B&lt;&#x3D;10)和数量Y(Y&lt;&#x3D;100)。保证A不等于B。</span><br></pre></td></tr></table></figure>

<p><strong>输出描述:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输出一个整数,表示组成歌单的方法取模。因为答案可能会很大,输出对1000000007取模的结果。</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">示例1</span><br><span class="line">输入</span><br><span class="line">5</span><br><span class="line">2 3 3 3</span><br><span class="line">输出</span><br><span class="line">9</span><br></pre></td></tr></table></figure>

<p><strong>思路与代码</strong>：</p>
<p>&ensp;&ensp;&ensp;&ensp;选取歌曲的过程即为组合的过程，为了减少时间复杂度，使用杨辉三角的公式。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//核心是计算阶乘</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">int</span> k, a, x, b, y, i, j;</span><br><span class="line">   <span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">   <span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> c[<span class="number">101</span>][<span class="number">101</span>];</span><br><span class="line">   <span class="keyword">while</span>(cin&gt;&gt;k)</span><br><span class="line">   &#123;</span><br><span class="line">       cin &gt;&gt; a &gt;&gt; x &gt;&gt; b &gt;&gt; y;</span><br><span class="line">       c[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">       <span class="comment">//j</span></span><br><span class="line">       <span class="keyword">for</span>( i=<span class="number">1</span>; i &lt;= <span class="number">100</span>; i++)</span><br><span class="line">       &#123;</span><br><span class="line">           c[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">           <span class="keyword">for</span>(j = <span class="number">1</span>; j &lt;= <span class="number">100</span>; j++)</span><br><span class="line">           &#123;</span><br><span class="line">               c[i][j] = (c[i<span class="number">-1</span>][j<span class="number">-1</span>] + c[i<span class="number">-1</span>][j]) % <span class="number">1000000007</span>;</span><br><span class="line">           &#125;</span><br><span class="line">	   &#125;  		</span><br><span class="line">   		</span><br><span class="line">   		<span class="keyword">for</span>(i = <span class="number">0</span>; i &lt;= k /a &amp;&amp; i &lt;= x; i++)</span><br><span class="line">        &#123;</span><br><span class="line">   			<span class="keyword">if</span>( (k - i * a) % b == <span class="number">0</span> &amp;&amp; (k - i * a) / b &lt;= y)</span><br><span class="line">   				count=(count + (c[x][i] * c[y][( k - i * a) / b]) % <span class="number">1000000007</span>) % <span class="number">1000000007</span>;</span><br><span class="line">		&#125;</span><br><span class="line">   		cout &lt;&lt; count &lt;&lt; endl;</span><br><span class="line">   	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法</category>
        <category>数学</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>排列组合</tag>
        <tag>杨辉三角</tag>
      </tags>
  </entry>
  <entry>
    <title>排列组合之组合</title>
    <url>/2021/05/09/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E5%AD%A6%EF%BC%9A%E7%BB%84%E5%90%88/</url>
    <content><![CDATA[<p>&ensp;排列组合子集问题都是用回溯算法解决，解决组合的问题就是解决子集是把符合情况的中间节点加入结果。</p>
<span id="more"></span>

<h3 id="一、-组合"><a href="#一、-组合" class="headerlink" title="一、 组合"></a>一、 组合</h3><p>    给定两个整数 n 和 k，返回 1 … <em>n</em> 中所有可能的 k 个数的组合。</p>
<p><strong>示例:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: n &#x3D; 4, k &#x3D; 2</span><br><span class="line">输出:</span><br><span class="line">[</span><br><span class="line">  [2,4],</span><br><span class="line">  [3,4],</span><br><span class="line">  [2,3],</span><br><span class="line">  [1,2],</span><br><span class="line">  [1,3],</span><br><span class="line">  [1,4],</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">combine</span>(<span class="keyword">int</span> n, <span class="keyword">int</span> k) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (n &lt;= <span class="number">0</span> || k &lt;= <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt; track;</span><br><span class="line">        <span class="built_in">backtrack</span>(n, k, <span class="number">1</span>, track);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">backtrack</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> n, <span class="keyword">const</span> <span class="keyword">int</span> k, <span class="keyword">int</span> start, vector&lt;<span class="keyword">int</span>&gt;&amp; track)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// 到达树的底部</span></span><br><span class="line">        <span class="keyword">if</span> (k == track.<span class="built_in">size</span>()) </span><br><span class="line">        &#123;</span><br><span class="line">            res.<span class="built_in">push_back</span>(track);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 注意 i 从 start 开始递增</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = start; i &lt;= n; i++) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 做选择</span></span><br><span class="line">            track.<span class="built_in">push_back</span>(i);</span><br><span class="line">            <span class="built_in">backtrack</span>(n, k, i + <span class="number">1</span>, track);</span><br><span class="line">            <span class="comment">// 撤销选择</span></span><br><span class="line">            track.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="二、组合总和"><a href="#二、组合总和" class="headerlink" title="二、组合总和"></a>二、组合总和</h3><p>    给定一个<strong>无重复元素</strong>的数组 <code>candidates</code> 和一个目标数 <code>target</code> ，找出 <code>candidates</code> 中所有可以使数字和为 <code>target</code> 的组合。</p>
<p>    <code>candidates</code> 中的数字可以无限制重复被选取。</p>
<p><strong>说明：</strong></p>
<ul>
<li>  所有数字（包括 <code>target</code>）都是正整数。</li>
<li>  解集不能包含重复的组合。 </li>
</ul>
<p><strong>示例 1：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：candidates &#x3D; [2,3,6,7], target &#x3D; 7,</span><br><span class="line">所求解集为：</span><br><span class="line">[</span><br><span class="line">  [7],</span><br><span class="line">  [2,2,3]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：candidates &#x3D; [2,3,5], target &#x3D; 8,</span><br><span class="line">所求解集为：</span><br><span class="line">[</span><br><span class="line">  [2,2,2,2],</span><br><span class="line">  [2,3,3],</span><br><span class="line">  [3,5]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li>  <code>1 &lt;= candidates.length &lt;= 30</code></li>
<li>  <code>1 &lt;= candidates[i] &lt;= 200</code></li>
<li>  <code>candidate</code> 中的每个元素都是独一无二的。</li>
<li>  <code>1 &lt;= target &lt;= 500</code></li>
</ul>
<p><a href="https://leetcode-cn.com/problems/combination-sum/solution/zu-he-zong-he-by-leetcode-solution/">组合总和</a></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; ans;</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">combinationSum</span>(vector&lt;<span class="keyword">int</span>&gt;&amp; candidates, <span class="keyword">int</span> target) </span><br><span class="line">    &#123;</span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt; track;</span><br><span class="line">        <span class="built_in">dfs</span>(candidates, target, track, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; candidates, <span class="keyword">int</span> target, vector&lt;<span class="keyword">int</span>&gt;&amp; track, <span class="keyword">int</span> idx)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (idx == candidates.<span class="built_in">size</span>()) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (target == <span class="number">0</span>) </span><br><span class="line">        &#123;</span><br><span class="line">            ans.<span class="built_in">emplace_back</span>(track);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 直接跳过</span></span><br><span class="line">        <span class="built_in">dfs</span>(candidates, target, track, idx + <span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 选择当前数</span></span><br><span class="line">        <span class="keyword">if</span> (target - candidates[idx] &gt;= <span class="number">0</span>) </span><br><span class="line">        &#123;</span><br><span class="line">            track.<span class="built_in">emplace_back</span>(candidates[idx]);</span><br><span class="line">            <span class="built_in">dfs</span>(candidates, target - candidates[idx], track, idx);</span><br><span class="line">            track.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="三、组合总和-II"><a href="#三、组合总和-II" class="headerlink" title="三、组合总和 II"></a>三、组合总和 II</h3><p>    给定一个数组 <code>candidates</code> 和一个目标数 <code>target</code> ，找出 <code>candidates</code> 中所有可以使数字和为 <code>target</code> 的组合。</p>
<p>    <code>candidates</code> 中的每个数字在每个组合中只能使用一次。</p>
<p><strong>说明：</strong></p>
<ul>
<li>  所有数字（包括目标数）都是正整数。</li>
<li>  解集不能包含重复的组合。 </li>
</ul>
<p><strong>示例 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: candidates &#x3D; [10,1,2,7,6,1,5], target &#x3D; 8,</span><br><span class="line">所求解集为:</span><br><span class="line">[</span><br><span class="line">  [1, 7],</span><br><span class="line">  [1, 2, 5],</span><br><span class="line">  [2, 6],</span><br><span class="line">  [1, 1, 6]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p><a href></a></p>
<p><strong>示例 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: candidates &#x3D; [2,5,2,1,2], target &#x3D; 5,</span><br><span class="line">所求解集为:</span><br><span class="line">[</span><br><span class="line">  [1,2,2],</span><br><span class="line">  [5]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p><a href="https://leetcode-cn.com/problems/combination-sum-ii/solution/zu-he-zong-he-ii-by-leetcode-solution/">组合总和 II - 组合总和 II - 力扣（LeetCode） (leetcode-cn.com)</a></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    vector&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; freq;</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; ans;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; sequence;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> pos, <span class="keyword">int</span> rest)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (rest == <span class="number">0</span>) &#123;</span><br><span class="line">            ans.<span class="built_in">push_back</span>(sequence);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (pos == freq.<span class="built_in">size</span>() || rest &lt; freq[pos].first) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">dfs</span>(pos + <span class="number">1</span>, rest);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> most = <span class="built_in">min</span>(rest / freq[pos].first, freq[pos].second);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= most; ++i) &#123;</span><br><span class="line">            sequence.<span class="built_in">push_back</span>(freq[pos].first);</span><br><span class="line">            <span class="built_in">dfs</span>(pos + <span class="number">1</span>, rest - i * freq[pos].first);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= most; ++i) &#123;</span><br><span class="line">            sequence.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">combinationSum2</span>(vector&lt;<span class="keyword">int</span>&gt;&amp; candidates, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        <span class="built_in">sort</span>(candidates.<span class="built_in">begin</span>(), candidates.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num: candidates) &#123;</span><br><span class="line">            <span class="keyword">if</span> (freq.<span class="built_in">empty</span>() || num != freq.<span class="built_in">back</span>().first) &#123;</span><br><span class="line">                freq.<span class="built_in">emplace_back</span>(num, <span class="number">1</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                ++freq.<span class="built_in">back</span>().second;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">dfs</span>(<span class="number">0</span>, target);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>算法</category>
        <category>数学</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>leetcode</tag>
        <tag>数学</tag>
        <tag>回溯</tag>
        <tag>排列组合</tag>
      </tags>
  </entry>
  <entry>
    <title>任务调度器</title>
    <url>/2021/05/15/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E7%BB%84%EF%BC%9A%E4%BB%BB%E5%8A%A1%E8%B0%83%E5%BA%A6%E5%99%A8/</url>
    <content><![CDATA[<h3 id="一、题目"><a href="#一、题目" class="headerlink" title="一、题目"></a>一、题目</h3><p>&ensp;&ensp;&ensp;&ensp;给你一个用字符数组 <code>tasks</code> 表示的 CPU 需要执行的任务列表。其中每个字母表示一种不同种类的任务。任务可以以任意顺序执行，并且每个任务都可以在 1 个单位时间内执行完。在任何一个单位时间，CPU 可以完成一个任务，或者处于待命状态。</p>
<span id="more"></span>

<p>&ensp;&ensp;&ensp;&ensp;然而，两个 <strong>相同种类</strong> 的任务之间必须有长度为整数 <code>n</code> 的冷却时间，因此至少有连续 <code>n</code> 个单位时间内 CPU 在执行不同的任务，或者在待命状态。</p>
<p>&ensp;&ensp;&ensp;&ensp;你需要计算完成所有任务所需要的 <strong>最短时间</strong> 。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：tasks &#x3D; [&quot;A&quot;,&quot;A&quot;,&quot;A&quot;,&quot;B&quot;,&quot;B&quot;,&quot;B&quot;], n &#x3D; 2</span><br><span class="line">输出：8</span><br><span class="line">解释：A -&gt; B -&gt; (待命) -&gt; A -&gt; B -&gt; (待命) -&gt; A -&gt; B</span><br><span class="line">     在本示例中，两个相同类型任务之间必须间隔长度为 n &#x3D; 2 的冷却时间，而执行一个任务只需要一个单位时间，所以中间出现了（待命）状态。 </span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：tasks &#x3D; [&quot;A&quot;,&quot;A&quot;,&quot;A&quot;,&quot;B&quot;,&quot;B&quot;,&quot;B&quot;], n &#x3D; 0</span><br><span class="line">输出：6</span><br><span class="line">解释：在这种情况下，任何大小为 6 的排列都可以满足要求，因为 n &#x3D; 0</span><br><span class="line">[&quot;A&quot;,&quot;A&quot;,&quot;A&quot;,&quot;B&quot;,&quot;B&quot;,&quot;B&quot;]</span><br><span class="line">[&quot;A&quot;,&quot;B&quot;,&quot;A&quot;,&quot;B&quot;,&quot;A&quot;,&quot;B&quot;]</span><br><span class="line">[&quot;B&quot;,&quot;B&quot;,&quot;B&quot;,&quot;A&quot;,&quot;A&quot;,&quot;A&quot;]</span><br><span class="line">...</span><br><span class="line">诸如此类</span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：tasks &#x3D; [&quot;A&quot;,&quot;A&quot;,&quot;A&quot;,&quot;A&quot;,&quot;A&quot;,&quot;A&quot;,&quot;B&quot;,&quot;C&quot;,&quot;D&quot;,&quot;E&quot;,&quot;F&quot;,&quot;G&quot;], n &#x3D; 2</span><br><span class="line">输出：16</span><br><span class="line">解释：一种可能的解决方案是：</span><br><span class="line">     A -&gt; B -&gt; C -&gt; A -&gt; D -&gt; E -&gt; A -&gt; F -&gt; G -&gt; A -&gt; (待命) -&gt; (待命) -&gt; A -&gt; (待命) -&gt; (待命) -&gt; A</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li>  <code>1 &lt;= task.length &lt;= 104</code></li>
<li>  <code>tasks[i]</code> 是大写英文字母</li>
<li>  <code>n</code> 的取值范围为 <code>[0, 100]</code></li>
</ul>
<h3 id="二、思路和代码"><a href="#二、思路和代码" class="headerlink" title="二、思路和代码"></a>二、思路和代码</h3><p>使用公式<code>(everyCharacterCount[0] - 1) * (n + 1) + theMostKinds</code></p>
<ul>
<li>  假设数组 [“A”,”A”,”A”,”B”,”B”,”C”]，n = 2，A的频率最高，记为<code>everyCharacterCount[0] = 3</code>，所以两个<code>A</code>之间必须间隔2个任务，才能满足题意并且是最短时间（两个<code>A</code>的间隔大于2的总时间必然不是最短），因此执行顺序为： A-&gt;X-&gt;X-&gt;A-&gt;X-&gt;X-&gt;A，这里的<code>X</code>表示除了<code>A</code>以外其他字母，或者是待命，不用关心具体是什么，反正用来填充两个<code>A</code>的间隔的。上面执行顺序的规律是： 有<code>count - 1</code>个<code>A</code>，其中每个<code>A</code>需要搭配<code>n</code>个<code>X</code>，再加上最后一个<code>A</code>，所以总时间为 <code>(count - 1) * (n + 1) + 1</code></li>
<li>  要注意可能会出现多个频率相同且都是最高的任务，比如 [“A”,”A”,”A”,”B”,”B”,”B”,”C”,”C”]，所以最后会剩下一个<code>A</code>和一个<code>B</code>，因此最后要加上频率最高的不同任务的个数 <code>theMostKinds</code></li>
<li>  公式算出的值可能会比数组的长度小，如[“A”,”A”,”B”,”B”]，n = 0，此时要取数组的长度</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">leastInterval</span><span class="params">(vector&lt;<span class="keyword">char</span>&gt;&amp; tasks, <span class="keyword">int</span> n)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> tasksNum = tasks.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">everyCharacterCount</span><span class="params">(<span class="number">26</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">char</span>&amp; c : tasks)</span><br><span class="line">        &#123;</span><br><span class="line">            ++everyCharacterCount[c - <span class="string">&#x27;A&#x27;</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">sort</span>(everyCharacterCount.<span class="built_in">rbegin</span>(), everyCharacterCount.<span class="built_in">rend</span>());</span><br><span class="line">        <span class="keyword">int</span> theMostKinds = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (theMostKinds &lt; everyCharacterCount.<span class="built_in">size</span>() &amp;&amp; </span><br><span class="line">                   everyCharacterCount[theMostKinds] == everyCharacterCount[<span class="number">0</span>])</span><br><span class="line">              &#123;</span><br><span class="line">                  ++theMostKinds;</span><br><span class="line">              &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(tasksNum, (everyCharacterCount[<span class="number">0</span>] - <span class="number">1</span>) * (n + <span class="number">1</span>) + theMostKinds);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><a href="https://leetcode-cn.com/problems/task-scheduler/solution/tong-zi-by-popopop/">【任务调度器】C++ 桶子_配图理解 - 任务调度器 - 力扣（LeetCode） (leetcode-cn.com)</a></p>
]]></content>
      <categories>
        <category>算法</category>
        <category>数组</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title>数组元素与下标</title>
    <url>/2021/05/15/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E7%BB%84%EF%BC%9A%E5%85%83%E7%B4%A0%E4%B8%8E%E4%B8%8B%E6%A0%87/</url>
    <content><![CDATA[<p>&ensp;&ensp;&ensp;&ensp;在有关数组的算法题中，经常会对数组的元素限定范围，通常为<code>1 ~ nums.size()</code>，这样的题目往往可以把数组元素和其下标联系起来。</p>
<span id="more"></span>

<h3 id="一、寻找重复数"><a href="#一、寻找重复数" class="headerlink" title="一、寻找重复数"></a><a href="https://leetcode-cn.com/problems/find-the-duplicate-number/">一、寻找重复数</a></h3><h4 id="1-1题目"><a href="#1-1题目" class="headerlink" title="1.1题目"></a>1.1题目</h4><p>&ensp;&ensp;&ensp;&ensp;给定一个包含 <code>n + 1</code> 个整数的数组 <code>nums</code> ，其数字都在 <code>1</code> 到 <code>n</code> 之间（包括 <code>1</code> 和 <code>n</code>），可知至少存在一个重复的整数。</p>
<p>&ensp;&ensp;&ensp;&ensp;假设 <code>nums</code> 只有 <strong>一个重复的整数</strong> ，找出 <strong>这个重复的数</strong> 。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：nums &#x3D; [1,3,4,2,2]</span><br><span class="line">输出：2</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：nums &#x3D; [3,1,3,4,2]</span><br><span class="line">输出：3</span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：nums &#x3D; [1,1]</span><br><span class="line">输出：1</span><br></pre></td></tr></table></figure>

<p><strong>示例 4：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：nums &#x3D; [1,1,2]</span><br><span class="line">输出：1</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li>  <code>2 &lt;= n &lt;= 3 * 104</code></li>
<li>  <code>nums.length == n + 1</code></li>
<li>  <code>1 &lt;= nums[i] &lt;= n</code></li>
<li>  <code>nums</code> 中 <strong>只有一个整数</strong> 出现 <strong>两次或多次</strong> ，其余整数均只出现 <strong>一次</strong></li>
</ul>
<h4 id="1-2思路与代码"><a href="#1-2思路与代码" class="headerlink" title="1.2思路与代码"></a>1.2思路与代码</h4><p>&ensp;&ensp;&ensp;&ensp;先说一下自己一开始的思路，本来想先排序，再遍历，但这样明显低估了本题，时间复杂度太大。后来联想到了<a href="https://leetcode-cn.com/problems/first-missing-positive/">leetcode: 41</a>，由于面试时遇到过此题，对其印象深刻，故写了相似的算法：</p>
<ol>
<li> 把数组中的元素<strong>归位</strong>，比如数组中的 1 放在数组第1个位置， 2 放在数组第2个位置……</li>
<li> 当 <code>nums[i] != i + 1</code>时，若<code>nums[i] == nums[nums[i] - 1]</code>，说明<code>nums[i]</code>就是要找的数</li>
<li> 当 <code>nums[i] != i + 1</code>时，若<code>nums[i] != nums[nums[i] - 1]</code>，交换<code>nums[i]</code>和<code>nums[nums[i] - 1]</code></li>
<li> 必须确保再找到目标之前，<code>nums[i] = i + 1</code>（所以交换的过程可能是多个）</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findDuplicate</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] == i + <span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (nums[i] != i + <span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums[i] == nums[nums[i] - <span class="number">1</span>])</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">return</span> nums[i];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="built_in">swap</span>(nums[i], nums[nums[i] - <span class="number">1</span>]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums[nums.<span class="built_in">size</span>() - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>&ensp;&ensp;&ensp;&ensp;运行之后，发现时间复杂度还是太高，仅仅比排序好了一点。看了一眼评论区，在大佬的启发下写了快慢指针的解题方法。</p>
<p>&ensp;&ensp;&ensp;&ensp;快慢指针思想：<code>fast</code> 和 <code>slow</code> 是指针，<code>nums[slow]</code> 表示取指针对应的元素注意 <code>nums</code> 数组中的数字都是在 <code>1</code> 到 <code>n</code> 之间的(在数组中进行游走不会越界)，因为有重复数字的出现，所以这个游走必然是成环的，环的入口就是重复的元素，即按照寻找链表环入口的思路来做。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findDuplicate</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> slow = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> fast = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            slow = nums[slow];</span><br><span class="line">            fast = nums[nums[fast]];</span><br><span class="line">            <span class="keyword">if</span> (slow == fast)</span><br><span class="line">            &#123;</span><br><span class="line">                fast = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">while</span> (nums[slow] != nums[fast])</span><br><span class="line">                &#123;</span><br><span class="line">                    slow = nums[slow];</span><br><span class="line">                    fast = nums[fast];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> nums[slow];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="二、找到所有数组中消失的数字"><a href="#二、找到所有数组中消失的数字" class="headerlink" title="二、找到所有数组中消失的数字"></a><a href="https://leetcode-cn.com/problems/find-all-numbers-disappeared-in-an-array/">二、找到所有数组中消失的数字</a></h3><h4 id="2-1题目"><a href="#2-1题目" class="headerlink" title="2.1题目"></a>2.1题目</h4><p>&ensp;&ensp;&ensp;&ensp;给定一个范围在 1 ≤ a[i] ≤ <em>n</em> ( <em>n</em> = 数组大小 ) 的 整型数组，数组中的元素一些出现了两次，另一些只出现一次。</p>
<p>&ensp;&ensp;&ensp;&ensp;找到所有在 [1, <em>n</em>] 范围之间没有出现在数组中的数字。</p>
<p>&ensp;&ensp;&ensp;&ensp;能在不使用额外空间且时间复杂度为*O(n)*的情况下完成这个任务吗? 你可以假定返回的数组不算在额外空间内。</p>
<p><strong>示例:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入:</span><br><span class="line">[4,3,2,7,8,2,3,1]</span><br><span class="line">输出:</span><br><span class="line">[5,6]</span><br></pre></td></tr></table></figure>

<h4 id="2-2思路与代码"><a href="#2-2思路与代码" class="headerlink" title="2.2思路与代码"></a>2.2思路与代码</h4><p>&ensp;&ensp;&ensp;&ensp;数组的元素有范围，便可以将它们与自己的下标联系起来。这里采用力扣评论区的一个方法：将所有正数作为数组下标，置对应数组值为负值。那么，仍为正数的位置即为（未出现过）消失的数字。</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">举个例子：</span><br><span class="line">原始数组：[4,3,2,7,8,2,3,1]</span><br><span class="line">重置后为：[-4,-3,-2,-7,8,2,-3,-1]</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">findDisappearedNumbers</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            nums[<span class="built_in">abs</span>(nums[i]) - <span class="number">1</span>] = -<span class="built_in">abs</span>(nums[<span class="built_in">abs</span>(nums[i])<span class="number">-1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt; ans;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] &gt; <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                ans.<span class="built_in">push_back</span>(i + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法</category>
        <category>数组</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>数组</tag>
        <tag>下标</tag>
      </tags>
  </entry>
  <entry>
    <title>子数组相关算法问题</title>
    <url>/2021/05/15/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E7%BB%84%EF%BC%9A%E5%AD%90%E6%95%B0%E7%BB%84%E7%9B%B8%E5%85%B3/</url>
    <content><![CDATA[<p>&ensp;&ensp;&ensp;&ensp;对与数组题，有一类题喜欢对数组的子序列做文章，这篇博客便搜集了几道相关的题目。</p>
<span id="more"></span>

<h3 id="一、最大子序和"><a href="#一、最大子序和" class="headerlink" title="一、最大子序和"></a><a href="https://leetcode-cn.com/problems/maximum-subarray/">一、最大子序和</a></h3><h4 id="1-1题目"><a href="#1-1题目" class="headerlink" title="1.1题目"></a>1.1题目</h4><p>&ensp;&ensp;&ensp;&ensp;给定一个整数数组 <code>nums</code> ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：nums &#x3D; [-2,1,-3,4,-1,2,1,-5,4]</span><br><span class="line">输出：6</span><br><span class="line">解释：连续子数组 [4,-1,2,1] 的和最大，为 6 。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：nums &#x3D; [1]</span><br><span class="line">输出：1</span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：nums &#x3D; [0]</span><br><span class="line">输出：0</span><br></pre></td></tr></table></figure>

<p><strong>示例 4：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：nums &#x3D; [-1]</span><br><span class="line">输出：-1</span><br></pre></td></tr></table></figure>

<p><strong>示例 5：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：nums &#x3D; [-100000]</span><br><span class="line">输出：-100000</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li>  <code>1 &lt;= nums.length &lt;= 3 * 104</code></li>
<li>  <code>-105 &lt;= nums[i] &lt;= 105</code></li>
</ul>
<h4 id="1-2思路与代码："><a href="#1-2思路与代码：" class="headerlink" title="1.2思路与代码："></a>1.2思路与代码：</h4><p>&ensp;&ensp;&ensp;&ensp;很明显是动态规划来解决，<code>dp[i]</code> 用来记载下标 <code>0 ~ i</code> 之间的最大子序和，由于 <code>dp[i]</code> 只与 <code>dp[i - 1]</code> 有关：<code>dp[i] = max&#123;dp[i - 1] + nums[i], nums[i]&#125;</code>。</p>
<p>&ensp;&ensp;&ensp;&ensp;所以无需数组 <code>dp[]</code>，用一个变量 <code>sum</code> 记载即可，另有 <code>ans</code> 记录最大值。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxSubArray</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">const</span> <span class="keyword">int</span> &amp;i : nums)</span><br><span class="line">        &#123;</span><br><span class="line">            sum = sum &gt; <span class="number">0</span> ? sum + i : i; </span><br><span class="line">            ans = ans &gt; sum ? ans : sum;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h3 id="二、乘积最大子数组"><a href="#二、乘积最大子数组" class="headerlink" title="二、乘积最大子数组"></a><a href="https://leetcode-cn.com/problems/maximum-product-subarray/">二、乘积最大子数组</a></h3><h4 id="2-1题目"><a href="#2-1题目" class="headerlink" title="2.1题目"></a>2.1题目</h4><p>&ensp;&ensp;&ensp;&ensp;你一个整数数组 <code>nums</code> ，请你找出数组中乘积最大的连续子数组（该子数组中至少包含一个数字），并返回该子数组所对应的乘积。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [2,3,-2,4]</span><br><span class="line">输出: 6</span><br><span class="line">解释: 子数组 [2,3] 有最大乘积 6。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [-2,0,-1]</span><br><span class="line">输出: 0</span><br><span class="line">解释: 结果不能为 2, 因为 [-2,-1] 不是子数组。</span><br></pre></td></tr></table></figure>

<h4 id="2-2思路与代码"><a href="#2-2思路与代码" class="headerlink" title="2.2思路与代码"></a>2.2思路与代码</h4><p>&ensp;&ensp;&ensp;&ensp;与最大子序和类似，本题也要用动态规划。</p>
<p>&ensp;&ensp;&ensp;&ensp;首先假设存在某个最大乘积，然后对数组遍历，在经过每个元素的时候，有以下四种情况：</p>
<ul>
<li>如果该元素为正数：<ul>
<li>  如果到上一个元素为止的最大乘积也是正数，那么直接乘上就好了，同样的最大乘积也会变得更大</li>
<li>  如果到上一个元素为止的最大乘积是负数，那么最大乘积就会变成该元素本身，且连续性被断掉</li>
</ul>
</li>
<li>如果该元素为负数：<ul>
<li>  如果到上一个元素为止的最大乘积也是负数，那么直接乘上就好了，同样的最大乘积也会变得更大</li>
<li>  如果到上一个元素为止的最大乘积是正数，那么最大乘积就会不变，且连续性被断掉</li>
</ul>
</li>
</ul>
<p>&ensp;&ensp;&ensp;&ensp;以上四种情况中说到的最大乘积都是临时最大乘积，每遍历新的元素都需要进行比较来确定真正的最大乘积。</p>
<p>&ensp;&ensp;&ensp;&ensp;如果细心的话就可以发现，如果要得到乘以当前元素以后的最大乘积，需要记录最大乘积，也要记录最小乘积，因为最小值可能翻身变最大值。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxProduct</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> minValue = <span class="number">1</span>, maxValue = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> ans = INT_MIN;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> it = nums.<span class="built_in">begin</span>(); it != nums.<span class="built_in">end</span>(); ++it)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (*it &lt; <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">swap</span>(minValue, maxValue);</span><br><span class="line">            &#125;</span><br><span class="line">            maxValue = <span class="built_in">max</span>((*it) * maxValue, *it);</span><br><span class="line">            minValue = <span class="built_in">min</span>((*it) * minValue, *it);</span><br><span class="line"></span><br><span class="line">            ans = ans &gt; maxValue ? ans : maxValue;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h3 id="三、最短无序连续子数组"><a href="#三、最短无序连续子数组" class="headerlink" title="三、最短无序连续子数组"></a><a href="https://leetcode-cn.com/problems/shortest-unsorted-continuous-subarray/">三、最短无序连续子数组</a></h3><h4 id="3-1题目"><a href="#3-1题目" class="headerlink" title="3.1题目"></a>3.1题目</h4><p>&ensp;&ensp;&ensp;&ensp;给你一个整数数组 <code>nums</code> ，你需要找出一个 <strong>连续子数组</strong> ，如果对这个子数组进行升序排序，那么整个数组都会变为升序排序。</p>
<p>&ensp;&ensp;&ensp;&ensp;请你找出符合题意的 <strong>最短</strong> 子数组，并输出它的长度。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：nums &#x3D; [2,6,4,8,10,9,15]</span><br><span class="line">输出：5</span><br><span class="line">解释：你只需要对 [6, 4, 8, 10, 9] 进行升序排序，那么整个表都会变为升序排序。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：nums &#x3D; [1,2,3,4]</span><br><span class="line">输出：0</span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：nums &#x3D; [1]</span><br><span class="line">输出：0</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li>  <code>1 &lt;= nums.length &lt;= 104</code></li>
<li>  <code>-105 &lt;= nums[i] &lt;= 105</code></li>
</ul>
<p> <strong>进阶：</strong>你可以设计一个时间复杂度为 <code>O(n)</code> 的解决方案吗？</p>
<h4 id="3-2思路与代码"><a href="#3-2思路与代码" class="headerlink" title="3.2思路与代码"></a>3.2思路与代码</h4><p>&ensp;&ensp;&ensp;&ensp;将数组拷贝一份并进行排序，然后我们比较原数组和排序后的数组的元素来决定最左边和最右边不匹配的元素。它们之间的子数组就是要求的最短无序子数组。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findUnsortedSubarray</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">sortedNums</span><span class="params">(nums)</span></span>;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">sort</span>(sortedNums.<span class="built_in">begin</span>(), sortedNums.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] != sortedNums[i])</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            ++count;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (count == nums.<span class="built_in">size</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = nums.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] != sortedNums[i])</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            ++count;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums.<span class="built_in">size</span>() - count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法</category>
        <category>数组</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>数组</tag>
        <tag>子数组</tag>
      </tags>
  </entry>
  <entry>
    <title>除自身以外数组的乘积</title>
    <url>/2021/05/15/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E7%BB%84%EF%BC%9A%E9%99%A4%E8%87%AA%E8%BA%AB%E4%BB%A5%E5%A4%96%E6%95%B0%E7%BB%84%E7%9A%84%E4%B9%98%E7%A7%AF/</url>
    <content><![CDATA[<h3 id="一、题目"><a href="#一、题目" class="headerlink" title="一、题目"></a>一、题目</h3><p>&ensp;&ensp;&ensp;&ensp;给你一个长度为 <em>n</em> 的整数数组 <code>nums</code>，其中 <em>n</em> &gt; 1，返回输出数组 <code>output</code> ，其中 <code>output[i]</code> 等于 <code>nums</code> 中除 <code>nums[i]</code> 之外其余各元素的乘积。 </p>
<span id="more"></span>

<p><strong>示例:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [1,2,3,4]</span><br><span class="line">输出: [24,12,8,6]</span><br></pre></td></tr></table></figure>

<p> <strong>提示：</strong>题目数据保证数组之中任意元素的全部前缀元素和后缀（甚至是整个数组）的乘积都在 32 位整数范围内。</p>
<p><strong>说明:</strong> 请<strong>不要使用除法，</strong>且在 O(<em>n</em>) 时间复杂度内完成此题。</p>
<p><strong>进阶：</strong><br>&ensp;&ensp;&ensp;&ensp;你可以在常数空间复杂度内完成这个题目吗？（ 出于对空间复杂度分析的目的，输出数组<strong>不被视为</strong>额外空间。）</p>
<h3 id="二、思路与代码"><a href="#二、思路与代码" class="headerlink" title="二、思路与代码"></a>二、思路与代码</h3><p>&ensp;&ensp;&ensp;&ensp;刚开始想到的是用一个半角矩阵保存数组中<code>i ~ j</code>之间元素的乘积，但是这样时间复杂度太大，会超时。所以改用其它思路优化时间复杂度。</p>
<p>&ensp;&ensp;&ensp;&ensp;我们不必将所有数字的乘积除以给定索引处的数字得到相应的答案，而是利用索引左侧所有数字的乘积和右侧所有数字的乘积（即前缀与后缀）相乘得到答案。（官方解释）</p>
<p>&ensp;&ensp;&ensp;&ensp;所以建立两个数组<code>vector&lt;int&gt; left</code>与<code>vector&lt;int&gt; right</code>，其中<code>left[i]</code>表示数组元素<code>nums[i]</code>的左边元素的乘积，<code>right[i]</code>表示数组元素<code>nums[i]</code>的右边边元素的乘积。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">productExceptSelf</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> numsLength = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">left</span><span class="params">(numsLength)</span></span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">right</span><span class="params">(numsLength)</span></span>;</span><br><span class="line">        </span><br><span class="line">        left[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; numsLength; ++i) </span><br><span class="line">        &#123;</span><br><span class="line">            left[i] = nums[i - <span class="number">1</span>] * left[i - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        right[numsLength - <span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = numsLength - <span class="number">2</span>; i &gt;= <span class="number">0</span>; --i) </span><br><span class="line">        &#123;</span><br><span class="line">            right[i] = nums[i + <span class="number">1</span>] * right[i + <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//vector&lt;int&gt; ans(numsLength);</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numsLength; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            left[i] = left[i] * right[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>&ensp;&ensp;&ensp;&ensp;leetcode评论区总有大佬，看其优化空间：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">productExceptSelf</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> n=nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> left=<span class="number">1</span>,right=<span class="number">1</span>;     <span class="comment">//left：从左边累乘，right：从右边累乘</span></span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">res</span><span class="params">(n,<span class="number">1</span>)</span></span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;++i)    <span class="comment">//最终每个元素其左右乘积进行相乘得出结果</span></span><br><span class="line">        &#123;</span><br><span class="line">            res[i]*=left;       <span class="comment">//乘以其左边的乘积</span></span><br><span class="line">            left*=nums[i];</span><br><span class="line">            </span><br><span class="line">            res[n<span class="number">-1</span>-i]*=right;  <span class="comment">//乘以其右边的乘积</span></span><br><span class="line">            right*=nums[n<span class="number">-1</span>-i];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">       </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法</category>
        <category>数组</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title>数据酷客习题知识整理</title>
    <url>/2021/05/15/%E8%AF%BE%E5%A0%82%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E5%AF%BC%E8%AE%BA%EF%BC%9A%E6%95%B0%E6%8D%AE%E9%85%B7%E5%AE%A2%E4%B9%A0%E9%A2%98%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/</url>
    <content><![CDATA[<p>&ensp;&ensp;&ensp;&ensp;分为两部分，前一部分老师给的考试前的参考习题，后一部分是平常三次作业。只归纳了选择题，代码题没有整理。</p>
<span id="more"></span>

<h3 id="一、考前作业整理"><a href="#一、考前作业整理" class="headerlink" title="一、考前作业整理"></a>一、考前作业整理</h3><ol>
<li><p>关联规则</p>
<ul>
<li>  关联规则探寻数据集各个<strong>特征</strong>之间的联系</li>
<li>  关联规则挖掘属于<strong>无监督学习算法</strong></li>
<li>  典型应用场景：<strong>推荐系统</strong></li>
<li>Aprior算法需要重复扫描数据集，生成频繁项集</li>
</ul>
</li>
<li><p>过度拟合</p>
<ul>
<li>  机器学习模型在<strong>训练集</strong>上的误差称为<strong>训练误差</strong></li>
<li>  机器学习模型在<strong>测试集</strong>上的误差称为<strong>泛化误差</strong></li>
<li>  使用机器学习模型拟合训练集，<strong>训练误差小，泛化误差大，称为过度拟合现象</strong></li>
<li><strong>训练误差通常会随着模型复杂度的升高越来越小</strong>，同时也更容易造成过度拟合现象</li>
</ul>
</li>
<li><p>Logistic标准化算法：Logistic会改变数据分布，是非线性映射，σ(0)=0.5</p>
</li>
<li><p>One-Hot编码</p>
<ul>
<li>  <strong>分类模型</strong>常用的预处理方法之一</li>
<li>  将<code>k</code>个取值的离散型特征转化为<code>k</code>个二元特征</li>
<li>  编码后的<strong>特征之间距离相同</strong>，<strong>没有次序关系</strong></li>
<li>编码后的特征存在<strong>多重共线性</strong>的问题</li>
</ul>
</li>
<li><p>数据离散化</p>
<ul>
<li>  <strong>聚类离散化和卡方离散化</strong>都可以采用<strong>自底向上</strong>的策略进行簇或者区间的合并</li>
<li>  等距离散化对离群值<strong>敏感</strong></li>
<li>  等频离散化为了保持离散化后区间的样本数大致相同，会将相似的样本划入到不同的子区间内</li>
<li><strong>信息增益离散化</strong>采用<strong>自顶向下</strong>的分裂策略</li>
</ul>
</li>
<li><p>线性回归模型的目标函数为$\Longrightarrow$残差平方和</p>
</li>
<li><p>回归算法</p>
<ul>
<li>  回归算法可以用最小二乘法求解</li>
<li>  最大似然估计可以得到和最小二乘法相同的结果</li>
<li>  加入绝对值是lasso回归，平方项（L2正则化）是岭回归</li>
<li>回归算法也会产生过拟合问题</li>
</ul>
</li>
<li><p>假定一个4次多项式回归模型即可很好拟合数据集x，那么</p>
<ul>
<li>  与4次多项式相比，使用2次多项式拟合x，<strong>偏差会变大，方差会变大</strong></li>
<li>与4次多项式相比，使用7次多项式拟合x，<strong>偏差会变小，方差会变大</strong></li>
</ul>
</li>
<li><p>岭回归</p>
<ul>
<li>  岭回归使用<strong>L2范数</strong>作为<strong>惩罚项</strong></li>
<li>  岭回归的<strong>回归系数</strong>可以找到解析解</li>
<li>  当惩罚系数为<strong>零</strong>时，岭回归退化为<strong>线性回归</strong>模型</li>
<li>当惩罚系数趋于<strong>无穷大</strong>时，回归系数会趋近于<strong>零</strong></li>
</ul>
</li>
<li><p>正则化路径</p>
<ul>
<li>  正则化路径指回归系数随着惩罚系数增大而变化的曲线</li>
<li>  正则化路径可以用来分析变量是否存在共线性，也可以用来做变量选择</li>
<li>  岭回归的正则化路径称为岭迹，岭迹波动大，说明回归参数存在多重共线性</li>
<li>随着惩罚系数增大，LASSO的回归系数会<strong>逐渐</strong>减少到零</li>
</ul>
</li>
<li><p>逻辑回归模型</p>
<ul>
<li>  逻辑回归通常<strong>用于分类</strong></li>
<li>  逻辑回归<strong>不用于</strong>回归</li>
<li>  逻辑回归也能够解决线性不可分问题</li>
<li>逻辑回归可用<strong>极大似然</strong>估计系数</li>
</ul>
</li>
<li><p><strong>度量相似度</strong>的方法</p>
<ul>
<li>  汉明距离</li>
<li>  马氏距离</li>
<li>KL散度</li>
</ul>
</li>
<li><p>衡量<strong>决策树节点不纯度</strong>的度量方式</p>
<ul>
<li>  Gini指数</li>
<li>  信息熵</li>
<li>误分率</li>
</ul>
</li>
<li><p>决策树常见算法</p>
<ul>
<li>  ID3，ID3算法使用信息增益作为不纯度的度量</li>
<li>  CART</li>
<li>C4.5</li>
</ul>
</li>
<li><p><strong>FP Growth</strong>是关联规则算法，属于无监督学习的模型</p>
</li>
<li><p>决策树算法在<strong>第一次分裂</strong>时采用的策略是$\Longrightarrow$贪心策略</p>
</li>
<li><p>决策树剪枝</p>
<ul>
<li>  决策树算法会产生<strong>层数太多</strong>，<strong>节点数过多</strong>的树，因此需要对树进行剪枝处理</li>
<li>  预剪枝会依据节点的不纯度设置阈值从而决定是否分裂</li>
<li>  后剪枝使用自定义的整体损失函数衡量决策树的优劣，对比剪枝前后的决策树决定是否实施剪枝操作</li>
</ul>
</li>
<li><pre><code> 【单选】给定特征x1、x2、x3和标签y，如下表所示
 
 x1    x2    x3    y
 1    1    1    A
 1    1    0    A
 0    0    0    A
 0    1    0    B
 1    0    1    B
 0    1    1    B
 利用上面的数据建立朴素贝叶斯模型，现有一待测样本x=(1,0,0)，则下列说法正确的是 （1）
 选项1
 p(y=B|x)=1/5
 选项2
 p(y=A|x)=1/54
 选项3
 p(y=A|x)=3/5
 选项4
 p(y=B|x)=1/27
</code></pre>
</li>
<li><p>集成方法</p>
<ul>
<li>  集成方法中的基模型之间具有差异性</li>
<li>  集成方法通常能获得比单个模型更好的预测性能</li>
<li>集成方法能够增强单个模型的表达能力</li>
</ul>
</li>
<li><p>聚类模型</p>
<ul>
<li>  聚类模型属于无监督学习</li>
<li>  聚类模型的本质是寻找数据集内在的分布结构</li>
<li>  聚类使得同簇的样本相似度高，簇间的样本相似度低。</li>
<li>  聚类常作为其他分析任务的前置过程，如数据清洗</li>
<li>  推荐系统可以看做是聚类模型的一种应用场景</li>
<li>  聚类模型可以用于文本处理，如情感分析</li>
<li>决策树算法可以用来解决聚类的任务</li>
</ul>
</li>
<li><p>聚类算法</p>
<ul>
<li>  轮廓系数综合了簇的凝聚度和分离度两个指标</li>
<li>  rand指数取值<strong>越大</strong>意味着聚类结果与真实情况<strong>越吻合</strong>。</li>
<li>  聚类评价指标分为外部和内部指标</li>
<li>Jaccard系数是用来比较样本集中的相似性和分散性的一个概率</li>
</ul>
</li>
<li><p>给定数据集和初始的簇个数，运行两次K-means算法得到的结果：两次结果可能相同也可能不同</p>
</li>
<li><p>K-means算法应用在哪些数据上能产生好的效果：具有有圆形轮廓的数据集</p>
</li>
<li><p>K-means算法采用应分配的策略，也就是将样本直接分配给距离最近的簇。而软分配的策略则是给出样本分数各个簇的概率。下列哪些算法采用了软分配的策略：高斯混合模型、Fuzzy K-means算法</p>
</li>
<li><p>K-means算法的效果依赖于初始质心的选择，对离群值敏感</p>
</li>
<li><p>k近邻算法</p>
<ul>
<li>  k近邻算法对异常数据不敏感</li>
<li>  k近邻算法是一种有监督学习</li>
<li>  k近邻算法需要占用大量内存空间</li>
<li>k近邻算法无训练过程</li>
</ul>
</li>
<li><p>为了让K-means算法获得全局最优的结果，下列可以采取的有</p>
<ul>
<li>  尝试不同的质心选择</li>
<li>  设定不同的簇的个数</li>
<li>调整算法的迭代次数</li>
</ul>
</li>
<li><p>支持向量机</p>
<ul>
<li>  支持向量机的目标是<strong>最大化</strong>分割线两侧的间隔</li>
<li>  支持向量机在边界线上的点称为支持向量</li>
<li>  支持向量机可以转换成对偶问题</li>
<li>支持向量机的划分需要d-1维超平面，d是特征空间的维度</li>
</ul>
</li>
<li><p>核方法</p>
<ul>
<li>  kernel方法不需要知道变换的具体形式</li>
<li>  核矩阵满足半正定性质</li>
<li>  核函数把特征映射到高维空间中</li>
<li>核函数让数据在新空间中线性可分</li>
</ul>
</li>
<li><p>主成分分析的优点</p>
<ul>
<li>  低维空间的每一个特征都能够写成高维特征的线性加权形式，为理解低维数据提供了便利</li>
<li>  没有需要调参的超参数，且具有全局最优解</li>
<li>计算效率较高</li>
</ul>
</li>
<li><p>去掉缺失值较多的特征可以使得降维效果更好</p>
</li>
<li><p>在PCA中，如果特征值分解后的各个特征值大致相等，则PCA的降维效果变差</p>
</li>
<li><p>主成分分析是最著名的数据降维方法</p>
<ul>
<li>  主成分分析是一种无监督方法</li>
<li>  它的目标是使得数据在低维空间中的方差最大</li>
<li>  主成分的最大数量不能超过原特征数</li>
<li>所有主成分之间互相正交</li>
</ul>
</li>
<li><p>关于PCA与LDA的比较</p>
<ul>
<li>  PCA和LDA都是线性降维方法</li>
<li>  LDA是有监督方法，PCA是无监督方法</li>
<li>  PCA和LDA都可以通过拉格朗日求解其最优化问题</li>
<li>PCA的目标是最大化数据的方差，LDA的目标是最大化不同类之间的距离</li>
</ul>
</li>
<li><p>关于介数中心度和紧密中心度</p>
<ul>
<li>  介数中心度衡量节点在连接其他节点时的桥接作用</li>
<li>  介数中心度是除节点v作为起点或终点的经过节点v的最短路径数量除以所有的最短路径数量</li>
<li>  紧密中心度衡量的是节点距离所有其他点的远近关系</li>
<li>紧密中心度越大越靠近中心.</li>
</ul>
</li>
<li><p>Spark运算速度比Hadoop快的原因：Spark支持DAG执行机制，以及内存运算</p>
</li>
<li><p>大数据分析的主要困难</p>
<ul>
<li>  数据类型复杂</li>
<li>  数据维度高</li>
<li>数据量大</li>
</ul>
</li>
<li><p>关于模型评价指标</p>
<ul>
<li>  召回率(recall)是判定为正类的正类/所有实际正类样本</li>
<li>  F1值是兼顾精确率和召回率的指标</li>
<li>AUC指在ROC曲线下方的面积</li>
</ul>
</li>
</ol>
<h3 id="二、三次作业整理"><a href="#二、三次作业整理" class="headerlink" title="二、三次作业整理"></a>二、三次作业整理</h3><ol>
<li><p>非结构化数据：视频、图像、网页</p>
</li>
<li><p>使用科学的方法研究数据的学科：机器学习、统计学</p>
</li>
<li><p>数据分析面临的困难：数据量大、数据维度高、数据包含的噪音大</p>
</li>
<li><p>机器学习的基本概念</p>
<ul>
<li>  机器学习模型是建立在输入数据和模型输出之间的映射关系</li>
<li>  训练集是用来训练模型的数据集</li>
<li>测试集是用来测试模型真实泛化能力的数据集</li>
</ul>
</li>
<li><p>与传统互联网行业大数据相比，现代大数据具备的特点：</p>
<ul>
<li>  数据体积更大</li>
<li>  数据产生速度更快</li>
<li>  具有总价值上升，价值密度下降</li>
<li>数据种类更丰富</li>
</ul>
</li>
<li><p>关于数据的说法</p>
<ul>
<li>  数据的类别有多种多样</li>
<li>  数据库中的一列代表一个特征</li>
<li>  一组数据平均值会受异常值影响</li>
<li>数据点之间的距离满足 dij+djk≥dik</li>
</ul>
</li>
<li><p>对于特征工程，就是人工地设计输入变量</p>
</li>
<li><p>特征选择的方式：过滤式、封装式、嵌入式</p>
</li>
<li><p>近年来，大数据受到整个社会的广泛关注。推动大数据行业发展的三大主要推动力包括：</p>
<ul>
<li>  丰富的数据源。特别是文本、语音和视频等非结构化数据。</li>
<li>  模型和计算能力的大幅提升。例如深度学习技术的发展和GPU、分布式计算的发展。</li>
<li>广泛的应用场景。来自现实社会的广泛应用需求推动了大数据行业的发展，例如营销、广告、金融、交通、医疗等。</li>
</ul>
</li>
<li><p>对数据进行分组，既可以使用分类模型，也可以使用聚类模型。</p>
</li>
<li><p>删除法</p>
<ul>
<li>  删除法包括删除数据样本和删除数据特征</li>
<li>  特征存在的缺失值对分析目标影响不大时，可以删除该特征</li>
<li>删除法虽减少了数据数量，但不一定会减少数据的信息量</li>
</ul>
</li>
<li><p>均值填补</p>
<ul>
<li>  均值填补在处理非数值型特征时，会使用众数来代替缺失值</li>
<li>  均值填补会导致数据样本多集中在均值或者众数附近，降低数据样本的方差</li>
<li>  均值填补不考虑特征之间的相关性</li>
<li>基于模型的填补将缺失特征当做目标特征，其余特征作为输入特征，建立分类或者回归模型，预测缺失值</li>
</ul>
</li>
<li><p>特征编码</p>
<ul>
<li>  特征编码将非数值型特征转换为数值型特征</li>
<li>  特征编码包括数字编码，one-hot编码和哑变量编码等方式</li>
<li>  数字编码的缺点是在原始特征的基础上引入了次序关系</li>
</ul>
</li>
</ol>
]]></content>
      <categories>
        <category>课堂学习笔记</category>
        <category>数据科学导引</category>
      </categories>
      <tags>
        <tag>课堂学习笔记</tag>
        <tag>数据科学导引</tag>
        <tag>数据酷客</tag>
      </tags>
  </entry>
  <entry>
    <title>HDFS生产环境中的操作</title>
    <url>/2021/05/22/Hadoop%E4%B9%8BHDFS%EF%BC%9AHDFS%E5%9C%A8%E7%94%9F%E4%BA%A7%E7%8E%AF%E5%A2%83%E4%B8%AD%E7%9A%84%E6%93%8D%E4%BD%9C/</url>
    <content><![CDATA[<h3 id="一、HDFS-Shell操作"><a href="#一、HDFS-Shell操作" class="headerlink" title="一、HDFS Shell操作"></a>一、HDFS Shell操作</h3><h4 id="1-1基本语法"><a href="#1-1基本语法" class="headerlink" title="1.1基本语法"></a>1.1基本语法</h4><ul>
<li>  hadoop fs 具体命令 </li>
<li>  hdfs dfs 具体命令 </li>
</ul>
<span id="more"></span>

<p>&ensp;&ensp;&ensp;&ensp;两个是完全相同的。</p>
<h4 id="1-2命令大全"><a href="#1-2命令大全" class="headerlink" title="1.2命令大全"></a>1.2命令大全</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hdfs dfs</span><br><span class="line">          [-appendToFile &lt;localsrc&gt; ... &lt;dst&gt;]</span><br><span class="line">          [-cat [-ignoreCrc] &lt;src&gt; ...]</span><br><span class="line">          [-checksum &lt;src&gt; ...]</span><br><span class="line">          [-chgrp [-R] GROUP PATH...]</span><br><span class="line">          [-chmod [-R] &lt;MODE[,MODE]... | OCTALMODE&gt; PATH...]</span><br><span class="line">          [-chown [-R] [OWNER][:[GROUP]] PATH...]</span><br><span class="line">          [-copyFromLocal [-f] [-p] &lt;localsrc&gt; ... &lt;dst&gt;]</span><br><span class="line">          [-copyToLocal [-p] [-ignoreCrc] [-crc] &lt;src&gt; ... &lt;localdst&gt;]</span><br><span class="line">          [-count [-q] &lt;path&gt; ...]</span><br><span class="line">          [-cp [-f] [-p] &lt;src&gt; ... &lt;dst&gt;]</span><br><span class="line">          [-createSnapshot &lt;snapshotDir&gt; [&lt;snapshotName&gt;]]</span><br><span class="line">          [-deleteSnapshot &lt;snapshotDir&gt; &lt;snapshotName&gt;]</span><br><span class="line">          [-df [-h] [&lt;path&gt; ...]]</span><br><span class="line">          [-du [-s] [-h] &lt;path&gt; ...]</span><br><span class="line">          [-expunge]</span><br><span class="line">          [-get [-p] [-ignoreCrc] [-crc] &lt;src&gt; ... &lt;localdst&gt;]</span><br><span class="line">          [-getfacl [-R] &lt;path&gt;]</span><br><span class="line">          [-getmerge [-nl] &lt;src&gt; &lt;localdst&gt;]</span><br><span class="line">          [-help [cmd ...]]</span><br><span class="line">          [-ls [-d] [-h] [-R] [&lt;path&gt; ...]]</span><br><span class="line">          [-mkdir [-p] &lt;path&gt; ...]</span><br><span class="line">          [-moveFromLocal &lt;localsrc&gt; ... &lt;dst&gt;]</span><br><span class="line">          [-moveToLocal &lt;src&gt; &lt;localdst&gt;]</span><br><span class="line">          [-mv &lt;src&gt; ... &lt;dst&gt;]</span><br><span class="line">          [-put [-f] [-p] &lt;localsrc&gt; ... &lt;dst&gt;]</span><br><span class="line">          [-renameSnapshot &lt;snapshotDir&gt; &lt;oldName&gt; &lt;newName&gt;]</span><br><span class="line">          [-rm [-f] [-r|-R] [-skipTrash] &lt;src&gt; ...]</span><br><span class="line">          [-rmdir [--ignore-fail-on-non-empty] &lt;dir&gt; ...]</span><br><span class="line">          [-setfacl [-R] [&#123;-b|-k&#125; &#123;-m|-x &lt;acl_spec&gt;&#125; &lt;path&gt;]|[--set &lt;acl_spec&gt; &lt;path&gt;]]</span><br><span class="line">          [-setrep [-R] [-w] &lt;rep&gt; &lt;path&gt; ...]</span><br><span class="line">          [-stat [format] &lt;path&gt; ...]</span><br><span class="line">          [-tail [-f] &lt;file&gt;]</span><br><span class="line">          [-test -[defsz] &lt;path&gt;]</span><br><span class="line">          [-text [-ignoreCrc] &lt;src&gt; ...]</span><br><span class="line">          [-touchz &lt;path&gt; ...]</span><br><span class="line">          [-usage [cmd ...]]</span><br><span class="line">12345678910111213141516171819202122232425262728293031323334353637</span><br></pre></td></tr></table></figure>

<h4 id="1-3常用命令"><a href="#1-3常用命令" class="headerlink" title="1.3常用命令"></a>1.3常用命令</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">-help：查看命令的使用方式</span><br><span class="line">hdfs dfs -help rm</span><br><span class="line"></span><br><span class="line">-ls: 显示目录信息</span><br><span class="line">hdfs dfs -ls /</span><br><span class="line"></span><br><span class="line">-mkdir：在hdfs上创建目录</span><br><span class="line">hdfs dfs -mkdir /bigdata</span><br><span class="line">hdfs dfs -mkdir -p /kgc/test</span><br><span class="line"></span><br><span class="line">-moveFromLocal从本地剪切粘贴到HDFS文件系统</span><br><span class="line">hdfs dfs -moveFromLocal  ./hello.txt  /kgc/test</span><br><span class="line"></span><br><span class="line">-appendToFile  ：追加一个文件到已经存在的文件末尾</span><br><span class="line">hdfs dfs -appendToFile test1.txt /kgc/test/hello.txt</span><br><span class="line"></span><br><span class="line">-cat ：显示文件内容</span><br><span class="line">hdfs dfs -cat /kgc/test/hello.txt</span><br><span class="line"></span><br><span class="line">-tail：显示一个文件的末尾</span><br><span class="line">hdfs dfs -tail /kgc/test/hello.txt</span><br><span class="line"></span><br><span class="line">-chgrp 、-chmod、-chown：linux文件系统中的用法一样，修改文件所属权限</span><br><span class="line">hdfs dfs -chmod  666  /kgc/test/hello.txt</span><br><span class="line">hdfs dfs -chown  kgc:kgc   /kgc/test/hello.txt</span><br><span class="line"></span><br><span class="line">-copyFromLocal：从本地文件系统中拷贝文件到hdfs路径去</span><br><span class="line">hdfs dfs -copyFromLocal README.txt /</span><br><span class="line"></span><br><span class="line">-copyToLocal：从hdfs拷贝到本地</span><br><span class="line">hdfs dfs -copyToLocal /kgc/test/hello.txt ./</span><br><span class="line"></span><br><span class="line">-cp ：从hdfs的一个路径拷贝到hdfs的另一个路径</span><br><span class="line">hdfs dfs -cp /kgc/test/hello.txt /hello1.txt</span><br><span class="line"></span><br><span class="line">-mv：在hdfs目录中移动文件</span><br><span class="line">hdfs dfs -mv /hello1.txt /kgc/test/</span><br><span class="line"></span><br><span class="line">-get：等同于copyToLocal，就是从hdfs下载文件到本地</span><br><span class="line">hdfs dfs -get /kgc/test/hello.txt ./</span><br><span class="line"></span><br><span class="line">-getmerge  ：合并下载多个文件，比如hdfs的目录 /aaa/下有多个文件:log.1, log.2,log.3,...</span><br><span class="line">hdfs dfs -getmerge /user/kgc/test/* ./merge.txt</span><br><span class="line"></span><br><span class="line">-put：等同于copyFromLocal</span><br><span class="line">hdfs dfs -put ./merge.txt /user/kgc/test/</span><br><span class="line"></span><br><span class="line">-rm：删除文件或文件夹</span><br><span class="line">hdfs dfs -rm /user/kgc/test/merge.txt</span><br><span class="line"></span><br><span class="line">-rmdir：删除空目录</span><br><span class="line">hdfs dfs -rmdir /test</span><br><span class="line"></span><br><span class="line">-du统计文件夹的大小信息</span><br><span class="line">hdfs dfs -du -s -h /user/kgc/test</span><br><span class="line">hdfs dfs -du -h /user/kgc/test</span><br><span class="line"></span><br><span class="line">-setrep：设置hdfs中文件的副本数量</span><br><span class="line">hdfs dfs -setrep 10 /kgc/test/hello.txt</span><br><span class="line">1234567891011121314151617181920212223242526272829303132333435363738394041</span><br></pre></td></tr></table></figure>



<h3 id="二、HDFS-的-API-操作"><a href="#二、HDFS-的-API-操作" class="headerlink" title="二、HDFS 的 API 操作"></a>二、HDFS 的 API 操作</h3><h4 id="2-1-客户端环境准备"><a href="#2-1-客户端环境准备" class="headerlink" title="2.1 客户端环境准备"></a>2.1 客户端环境准备</h4><p>&ensp;&ensp;&ensp;&ensp;1）找到资料包路径下的 Windows 依赖文件夹，拷贝 hadoop-3.1.0 到非中文路径（比如 d:\）。 </p>
<p>&ensp;&ensp;&ensp;&ensp;2）配置 HADOOP_HOME 环境变量</p>
<p><img src="/2021/05/22/Hadoop%E4%B9%8BHDFS%EF%BC%9AHDFS%E5%9C%A8%E7%94%9F%E4%BA%A7%E7%8E%AF%E5%A2%83%E4%B8%AD%E7%9A%84%E6%93%8D%E4%BD%9C/1.png" alt="image-20210520193441823"></p>
<p>&ensp;&ensp;&ensp;&ensp;3）配置 Path 环境变量。</p>
<p><img src="/2021/05/22/Hadoop%E4%B9%8BHDFS%EF%BC%9AHDFS%E5%9C%A8%E7%94%9F%E4%BA%A7%E7%8E%AF%E5%A2%83%E4%B8%AD%E7%9A%84%E6%93%8D%E4%BD%9C/2.png" alt="image-20210520193459128"></p>
<p>&ensp;&ensp;&ensp;&ensp;验证 Hadoop 环境变量是否正常。双击 winutils.exe，如果页面一闪而过不报错，就是正常的。</p>
<p>&ensp;&ensp;&ensp;&ensp;4）在 IDEA 中创建一个 Maven 工程 HdfsClientDemo，并导入相应的依赖坐标+日志添加</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.hadoop<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>hadoop-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.1.3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.12<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.slf4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>slf4j-log4j12<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.7.30<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>&ensp;&ensp;&ensp;&ensp;在项目的 src/main/resources 目录下，新建一个文件，命名为“log4j.properties”，在文件 中填入</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">log4j.rootLogger&#x3D;INFO, stdout </span><br><span class="line">log4j.appender.stdout&#x3D;org.apache.log4j.ConsoleAppender </span><br><span class="line">log4j.appender.stdout.layout&#x3D;org.apache.log4j.PatternLayout </span><br><span class="line">log4j.appender.stdout.layout.ConversionPattern&#x3D;%d %p [%c] - %m%n </span><br><span class="line">log4j.appender.logfile&#x3D;org.apache.log4j.FileAppender </span><br><span class="line">log4j.appender.logfile.File&#x3D;target&#x2F;spring.log </span><br><span class="line">log4j.appender.logfile.layout&#x3D;org.apache.log4j.PatternLayout </span><br><span class="line">log4j.appender.logfile.layout.ConversionPattern&#x3D;%d %p [%c] - %m%n</span><br></pre></td></tr></table></figure>

<p>&ensp;&ensp;&ensp;&ensp;5）创建包名：com.james.hdfs </p>
<p>&ensp;&ensp;&ensp;&ensp;6）创建 HdfsClient 类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HdfsClient</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testMkdirs</span><span class="params">()</span> <span class="keyword">throws</span> IOException, URISyntaxException, </span></span><br><span class="line"><span class="function">InterruptedException </span>&#123;</span><br><span class="line">    <span class="comment">// 1 获取文件系统</span></span><br><span class="line">    Configuration configuration = <span class="keyword">new</span> Configuration();</span><br><span class="line">    <span class="comment">// FileSystem fs = FileSystem.get(new URI(&quot;hdfs://hadoop102:8020&quot;), configuration);</span></span><br><span class="line">    FileSystem fs = FileSystem.get(<span class="keyword">new</span> URI(<span class="string">&quot;hdfs://hadoop102:8020&quot;</span>), configuration,<span class="string">&quot;atguigu&quot;</span>);</span><br><span class="line">    <span class="comment">// 2 创建目录</span></span><br><span class="line">    fs.mkdirs(<span class="keyword">new</span> Path(<span class="string">&quot;/xiyou/huaguoshan/&quot;</span>));</span><br><span class="line">    <span class="comment">// 3 关闭资源</span></span><br><span class="line">    fs.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&ensp;&ensp;&ensp;&ensp;7）执行程序：客户端去操作 HDFS 时，是有一个用户身份的。默认情况下，HDFS 客户端 API 会从采 用 Windows 默认用户访问 HDFS，会报权限异常错误。所以在访问 HDFS 时，一定要配置用户。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">org.apache.hadoop.security.AccessControlException: Permission denied: </span><br><span class="line">user&#x3D;56576, access&#x3D;WRITE, </span><br><span class="line">inode&#x3D;&quot;&#x2F;xiyou&#x2F;huaguoshan&quot;:james:supergroup:drwxr-xr-x</span><br></pre></td></tr></table></figure>



<h4 id="2-2HDFS的API操作"><a href="#2-2HDFS的API操作" class="headerlink" title="2.2HDFS的API操作"></a>2.2HDFS的API操作</h4><p>&ensp;&ensp;&ensp;&ensp;HDFS 文件上传（测试参数优先级）</p>
<p>&ensp;&ensp;&ensp;&ensp;1）编写源代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testCopyFromLocalFile</span><span class="params">()</span> <span class="keyword">throws</span> IOException, </span></span><br><span class="line"><span class="function">InterruptedException, URISyntaxException </span>&#123;</span><br><span class="line">    <span class="comment">// 1 获取文件系统</span></span><br><span class="line">    Configuration configuration = <span class="keyword">new</span> Configuration();</span><br><span class="line">    configuration.set(<span class="string">&quot;dfs.replication&quot;</span>, <span class="string">&quot;2&quot;</span>);</span><br><span class="line">    FileSystem fs = FileSystem.get(<span class="keyword">new</span> URI(<span class="string">&quot;hdfs://hadoop102:8020&quot;</span>), configuration, <span class="string">&quot;atguigu&quot;</span>);</span><br><span class="line">    <span class="comment">// 2 上传文件</span></span><br><span class="line">    fs.copyFromLocalFile(<span class="keyword">new</span> Path(<span class="string">&quot;d:/sunwukong.txt&quot;</span>), <span class="keyword">new</span> Path(<span class="string">&quot;/xiyou/huaguoshan&quot;</span>));</span><br><span class="line">   <span class="comment">// 3 关闭资源</span></span><br><span class="line">    fs.close();</span><br><span class="line">｝</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>&ensp;&ensp;&ensp;&ensp;2）将 hdfs-site.xml 拷贝到项目的 resources 资源目录下</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="meta">&lt;?xml-stylesheet type=&quot;text/xsl&quot; href=&quot;configuration.xsl&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">name</span>&gt;</span>dfs.replication<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">value</span>&gt;</span>1<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span>  </span><br></pre></td></tr></table></figure>

<p>&ensp;&ensp;&ensp;&ensp;3）参数优先级 </p>
<p>&ensp;&ensp;&ensp;&ensp;参数优先级排序：（1）客户端代码中设置的值 &gt;（2）ClassPath 下的用户自定义配置文 件 &gt;（3）然后是服务器的自定义配置（xxx-site.xml）&gt;（4）服务器的默认配置（xxx-default.xml）</p>
<p>&ensp;&ensp;&ensp;&ensp;HDFS 文件下载</p>
<p>&ensp;&ensp;&ensp;&ensp;HDFS 文件更名和移动</p>
<p>&ensp;&ensp;&ensp;&ensp;HDFS 删除文件和目录</p>
<p>&ensp;&ensp;&ensp;&ensp;HDFS 文件详情查看</p>
<p>&ensp;&ensp;&ensp;&ensp;HDFS 文件和文件夹判断</p>
<p><a href="https://www.bilibili.com/video/BV1Qp4y1n7EN?p=1">尚硅谷丨大数据Hadoop 3.x（2021全新升级/部署+源码+实战）_哔哩哔哩 (゜-゜)つロ 干杯~-bilibili</a></p>
]]></content>
      <categories>
        <category>数据研发</category>
        <category>Hadoop</category>
        <category>HDFS</category>
      </categories>
      <tags>
        <tag>数据研发</tag>
        <tag>Hadoop</tag>
        <tag>HDFS</tag>
      </tags>
  </entry>
  <entry>
    <title>HDFS简介</title>
    <url>/2021/05/22/Hadoop%E4%B9%8BHDFS%EF%BC%9AHDFS%E6%A6%82%E8%BF%B0/</url>
    <content><![CDATA[<h3 id="一、HDFS简介"><a href="#一、HDFS简介" class="headerlink" title="一、HDFS简介"></a>一、HDFS简介</h3><h4 id="1-1、HDFS产生背景"><a href="#1-1、HDFS产生背景" class="headerlink" title="1.1、HDFS产生背景"></a>1.1、HDFS产生背景</h4><p>&ensp;&ensp;&ensp;&ensp;随着数据量越来越大，在一个操作系统管辖的范围内存不下了，那么就分配到更多的操作系统管理的磁盘中，但是不方便管理和维护，迫切需要一种系统来管理多台机器上的文件，这就是分布式文件管理系统。HDFS只是分布式文件管理系统中的一种。</p>
<span id="more"></span>

<h4 id="1-2、HDFS概念"><a href="#1-2、HDFS概念" class="headerlink" title="1.2、HDFS概念"></a>1.2、HDFS概念</h4><p>&ensp;&ensp;&ensp;&ensp;HDFS（Hadoop Distributed File System），它是基于<strong>流数据</strong>访问模式的一个文件系统，用于存储文件，通过目录树来定位文件；其次，它是分布式的，由很多服务器联合起来实现其功能，集群中的服务器有各自的角色。<br>&ensp;&ensp;&ensp;&ensp;HDFS的设计适合一次写入，多次读出的场景，且不支持文件的修改。适合用来做数据分析，并不适合用来做网盘应用。</p>
<blockquote>
<p>流数据  是指数千个数据源 持续生成 的数据，可以理解为随时间延续而 无限增长 的动态数据集合。<br>通俗点说，如果把数据比如成一个水库，那么流进去的水，就是流数据（就像我们听的音乐，属于音乐流；而看到的文字、图片这些较为固定的，一次性下载的，形成不了流）。</p>
</blockquote>
<p>&ensp;&ensp;&ensp;&ensp;在Hadoop生态圈中，HDFS属于底层基础，负责存储文件。<br><img src="/2021/05/22/Hadoop%E4%B9%8BHDFS%EF%BC%9AHDFS%E6%A6%82%E8%BF%B0/1.png" alt="在这里插入图片描述"></p>
<h3 id="二、HDFS优缺点"><a href="#二、HDFS优缺点" class="headerlink" title="二、HDFS优缺点"></a>二、HDFS优缺点</h3><p><strong>优点：</strong></p>
<ol>
<li>高容错性：<ul>
<li>  数据自动保存多个副本。它通过增加副本的形式，提高容错性。</li>
<li>  某一个副本丢失以后，它可以自动恢复。</li>
</ul>
</li>
<li>适合大数据处理。两个维度：数据规模和文件规模<ul>
<li>  数据规模：能够处理数据规模达到 GB、TB、甚至PB级别的数据。</li>
<li>  文件规模：能够处理百万规模以上的文件数量，数量相当之大。</li>
</ul>
</li>
<li> 支持流式数据访问。一次性写入，多次读取（一个数据集一旦生成，就会被复制分发到不同的存储节点，各节点可以进行读取/访问）；保证数据一致性。</li>
<li> 可构建在廉价机器上，通过多副本机制，提高可靠性。</li>
<li> 适合批处理。移动计算而非移动数据；数据位置暴露给计算框架。</li>
</ol>
<p><strong>缺点：</strong></p>
<ol>
<li> 不适合低延时数据访问，比如毫秒级的存储数据，是做不到的。</li>
<li>无法高效的对大量小文件进行存储（重点）<ul>
<li>  存储大量小文件的话，它会占用 NameNode大量的内存来存储文件、目录和块信息。这样是不可取的，因为NameNode的内存总是有限的。</li>
<li>  小文件存储的寻道时间会超过读取时间，它违反了HDFS的设计目标。</li>
</ul>
</li>
<li>不支持并发写入、文件随机修改<ul>
<li>  一个文件只能有一个写，不允许多个线程同时写。</li>
<li>  仅支持数据 append（追加），不支持文件的随机修改。</li>
</ul>
</li>
</ol>
<h3 id="三、HDFS组成架构"><a href="#三、HDFS组成架构" class="headerlink" title="三、HDFS组成架构"></a>三、HDFS组成架构</h3><img src="/2021/05/22/Hadoop%E4%B9%8BHDFS%EF%BC%9AHDFS%E6%A6%82%E8%BF%B0/2.png" alt="image-20210516142136473" style="zoom:100%;">

<h4 id="3-1-NameNode节点"><a href="#3-1-NameNode节点" class="headerlink" title="3.1 NameNode节点"></a>3.1 NameNode节点</h4><p>&ensp;&ensp;&ensp;&ensp;当用户访问数据文件时，为了保证能够读取到每一个数据块， HDFS有一个专门 <code>负责保存文件属性信息</code>的节点，这个节点就是 <strong>NameNode</strong> 节点（即 名称节点 ），它是一个主管、管理者。</p>
<h5 id="3-1-1节点职责"><a href="#3-1-1节点职责" class="headerlink" title="3.1.1节点职责"></a>3.1.1节点职责</h5><p><strong>① 管理维护HDFS的命名空间</strong></p>
<p>&ensp;&ensp;&ensp;&ensp;NameNode管理HDFS系统的命名空间，维护文件系统树以及文件系统树中所有文件的元数据。管理这些信息的的文件分别是 <strong>edits</strong>（操作日志文件） 和 <strong>fsimage</strong>（命名空间镜像文件） 。</p>
<blockquote>
<p>  editlog(操作日志)：在NameNode启动的情况下，对HDFS进行的各种操作进行记录。（HDFS客户端执行的所有操作都会被记录到editlog文件中，这些文件由edits文件保存）</p>
<p>  fsimage：包含HDFS中的元信息（比如修改时间、访问时间、数据块信息等）。</p>
</blockquote>
<p><strong>② 管理数据块（Block）映射信息</strong></p>
<p>&ensp;&ensp;&ensp;&ensp;负责管理数据块上所有的元数据信息（管理DataNode上数据块的均衡，维持副本数量）。</p>
<p><strong>③ 接收客户端的请求</strong><br>&ensp;&ensp;&ensp;&ensp;接收客户端文件上传、下载、创建目录等的请求。</p>
<h4 id="3-2-DataNode节点"><a href="#3-2-DataNode节点" class="headerlink" title="3.2 DataNode节点"></a>3.2 DataNode节点</h4><p>&ensp;&ensp;&ensp;&ensp;HDFS首先把大文件切分成若干个小的数据块，再把这些数据块写入不同的节点，这个 <code>负责保存文件数据</code>的节点就是 <strong>DataNode</strong> 节点（即 数据节点 ）。</p>
<h5 id="3-2-1-节点职责"><a href="#3-2-1-节点职责" class="headerlink" title="3.2.1 节点职责"></a>3.2.1 节点职责</h5><p>&ensp;&ensp;&ensp;&ensp;DataNode节点 负责存储数据，把Block(数据块)以Linux文件的形式保存在磁盘上，并根据Block标识和字节范围来读写块数据。</p>
<p>&ensp;&ensp;&ensp;&ensp;其职责有以下三个方面（NameNode下达命令，DataNode执行实际的操作）：</p>
<p><strong>① 保存数据块</strong><br>&ensp;&ensp;&ensp;&ensp;一个数据块会在多个DataNode进行冗余备份（在某一个DataNode最多只有一个备份）。</p>
<p><strong>② 负责客户端对数据块的IO请求</strong><br>&ensp;&ensp;&ensp;&ensp;在客户端执行写操作时，DataNode之间会相互通信，保证写操作的一致性。</p>
<p><strong>③ 定期和NameNode进行心跳通信，接受NameNode的指令</strong><br>&ensp;&ensp;&ensp;&ensp;如果NameNode节点10分钟没有收到DataNode的心跳信息，就会将其上的数据块复制到其他DataNode节点。</p>
<p>&ensp;&ensp;&ensp;&ensp;因此，<code>NameNode节点上并不会永久保存DataNode节点上的数据块信息</code>，而是通过与DataNode节点心跳联系的方式，来更新节点上的映射表，以此减轻负担。</p>
<h4 id="3-3-SecondaryNameNode节点"><a href="#3-3-SecondaryNameNode节点" class="headerlink" title="3.3 SecondaryNameNode节点"></a>3.3 SecondaryNameNode节点</h4><p>&ensp;&ensp;&ensp;&ensp;HDFS有一个定期创建命名空间的检查点(CheckPoint)操作的节点，也就是SecondaryNameNode节点（即 第二名称节点）。</p>
<p>&ensp;&ensp;&ensp;&ensp;出于可靠性考虑，SecondaryNameNode节点与NameNode节点<code>通常运行在不同的机器上</code>，且SecondaryNameNode节点与NameNode节点的<code>内存要一样大</code>。</p>
<p>&ensp;&ensp;&ensp;&ensp;并非NameNode的<a href="https://baike.baidu.com/item/%E7%83%AD%E5%A4%87">热备</a>。当NameNode挂掉的时候，它并不能马上替换NameNode并提供服务。</p>
<blockquote>
<p>  问题：一般情况下，一个集群中的SecondaryNameNode节点也是只有一个的原因是什么？<br>  答：因为如果多的话，会增加NameNode的压力，使其忙于元数据的传输/接收、日志的传输/切换，从而导致性能下降；同时，NameNode节点也不支持做并发检查点。</p>
</blockquote>
<h5 id="3-3-1-节点职责"><a href="#3-3-1-节点职责" class="headerlink" title="3.3.1 节点职责"></a>3.3.1 节点职责</h5><p><strong>①辅助NameNode，分担其工作量。</strong></p>
<p><strong>②定期合并Fsimage和Edits，并推送给NameNode。</strong></p>
<p><strong>③在紧急情况下，可辅助恢复NameNode。</strong></p>
<h4 id="3-4-Client客户端"><a href="#3-4-Client客户端" class="headerlink" title="3.4 Client客户端"></a>3.4 Client客户端</h4><ol>
<li> 文件切分。文件上传 HDFS 的时候，Client 将文件切分成一个一个的Block，然后进行存储。</li>
<li> 与NameNode交互，获取文件的位置信息。</li>
<li> 与DataNode交互，读取或者写入数据。</li>
<li> Client提供一些命令来管理HDFS，比如启动或者关闭HDFS。</li>
<li> Client可以通过一些命令来访问HDFS。</li>
</ol>
<hr>
<h3 id="四、HDFS-文件块大小"><a href="#四、HDFS-文件块大小" class="headerlink" title="四、HDFS 文件块大小"></a>四、HDFS 文件块大小</h3><p>&ensp;&ensp;&ensp;&ensp;HDFS中的文件在物理上是分块存储（block），块的大小可以通过配置参数(dfs.blocksize)来规定，默认大小在 hadoop2.x / 3.x 版本中是128M， hadoop1.x 版本中是 64M 。</p>
<img src="/2021/05/22/Hadoop%E4%B9%8BHDFS%EF%BC%9AHDFS%E6%A6%82%E8%BF%B0/3.png" alt="image-20210520191749176" style="zoom: 80%;">

<blockquote>
<p>  问题：HDFS数据块默认大小为128M（Hadoop2.2之前为64M），将HDFS的数据块设置得很大的目的是什么？（传统数据块只有512个字节）</p>
<p>  答：为了减少寻址开销，让HDFS的文件传输时间由传输速率决定（如果块设置得足够大，从磁盘传输数据的时间会明显大于定位这个块开始位置所需的时间）。</p>
</blockquote>
<blockquote>
<p>  思考：为什么块的大小不能设置太小，也不能设置太大?<br>  (1)HDFS的块设置太小，会增加寻址时间，程序一直在找块的开始位置;<br>  (2)如果块设置的太大，从磁盘传输数据的时间会明显大于定位这个块开<br>  始位置所需的时间。导致程序在处理这块数据时,会非常慢<br>  总结：HDFS块的大小设置主要取决于磁盘传输速率</p>
</blockquote>
<p><a href="https://blog.csdn.net/qq_45069279/article/details/114483365">(4条消息) 一文了解 HDFS 及其组成框架_苜苜的烂笔头的博客-CSDN博客_hdfs</a></p>
<p><a href="https://blog.csdn.net/qq_45069279/article/details/114734679">(4条消息) 干货满满，图文详解 HDFS 的 工作机制 及其原理_苜苜的烂笔头的博客-CSDN博客</a></p>
<p><a href="https://www.bilibili.com/video/BV1Qp4y1n7EN?p=1">尚硅谷丨大数据Hadoop 3.x（2021全新升级/部署+源码+实战）_哔哩哔哩 (゜-゜)つロ 干杯~-bilibili</a></p>
]]></content>
      <categories>
        <category>数据研发</category>
        <category>Hadoop</category>
        <category>HDFS</category>
      </categories>
      <tags>
        <tag>数据研发</tag>
        <tag>Hadoop</tag>
        <tag>HDFS</tag>
      </tags>
  </entry>
  <entry>
    <title>HDFS的各个节点工作机制</title>
    <url>/2021/05/22/Hadoop%E4%B9%8BHDFS%EF%BC%9AHDFS%E7%9A%84%E5%90%84%E4%B8%AA%E8%8A%82%E7%82%B9%E5%B7%A5%E4%BD%9C%E6%9C%BA%E5%88%B6/</url>
    <content><![CDATA[<p>&ensp;&ensp;&ensp;&ensp;本文主要总结了NameNode、SecondaryNameNode和DataNode的工作机制。</p>
<span id="more"></span>

<h3 id="一、NameNode和SecondaryNameNode"><a href="#一、NameNode和SecondaryNameNode" class="headerlink" title="一、NameNode和SecondaryNameNode"></a>一、NameNode和SecondaryNameNode</h3><h4 id="1-1-NameNode和Secondary-NameNode工作机制"><a href="#1-1-NameNode和Secondary-NameNode工作机制" class="headerlink" title="1.1 NameNode和Secondary NameNode工作机制"></a>1.1 NameNode和Secondary NameNode工作机制</h4><img src="/2021/05/22/Hadoop%E4%B9%8BHDFS%EF%BC%9AHDFS%E7%9A%84%E5%90%84%E4%B8%AA%E8%8A%82%E7%82%B9%E5%B7%A5%E4%BD%9C%E6%9C%BA%E5%88%B6/1.png" alt="image-20210520205518555" style="zoom:80%;">

<p>第一阶段：NameNode启动</p>
<ol>
<li> 第一次启动NameNode格式化后，创建fsimage和edits文件。如果不是第一次启动，直接加载编辑日志和镜像文件到内存。</li>
<li> 客户端对元数据进行增删改的请求</li>
<li> namenode记录操作日志，更新滚动日志。</li>
<li> namenode在内存中对数据进行增删改</li>
</ol>
<p>第二阶段：Secondary NameNode工作</p>
<ol>
<li> Secondary NameNode询问namenode是否需要checkpoint，直接带回namenode是否检查结果。</li>
<li> Secondary NameNode请求执行checkpoint。</li>
<li> namenode滚动正在写的edits日志</li>
<li> 将滚动前的编辑日志和镜像文件拷贝到Secondary NameNode</li>
<li> Secondary NameNode加载编辑日志和镜像文件到内存，并合并。</li>
<li> 生成新的镜像文件fsimage.chkpoint</li>
<li> 拷贝fsimage.chkpoint到namenode</li>
<li> namenode将fsimage.chkpoint重新命名成fsimage</li>
</ol>
<h4 id="1-2-Fsimage和Edits"><a href="#1-2-Fsimage和Edits" class="headerlink" title="1.2 Fsimage和Edits"></a>1.2 Fsimage和Edits</h4><blockquote>
<p>思考：NameNode 中的元数据是存储在哪里的？</p>
<p>首先，我们做个假设，如果存储在 NameNode 节点的磁盘中，因为经常需要进行随机访 问，还有响应客户请求，必然是效率过低。因此，元数据需要存放在内存中。但如果只存在 内存中，一旦断电，元数据丢失，整个集群就无法工作了。因此产生在磁盘中备份元数据的 FsImage。 这样又会带来新的问题，当在内存中的元数据更新时，如果同时更新 FsImage，就会导 致效率过低，但如果不更新，就会发生一致性问题，一旦 NameNode 节点断电，就会产生数 据丢失。因此，引入 Edits 文件（只进行追加操作，效率很高）。每当元数据有更新或者添 加元数据时，修改内存中的元数据并追加到 Edits 中。这样，一旦 NameNode 节点断电，可 以通过 FsImage 和 Edits 的合并，合成元数据。 但是，如果长时间添加数据到 Edits 中，会导致该文件数据过大，效率降低，而且一旦 断电，恢复元数据需要的时间过长。因此，需要定期进行 FsImage 和 Edits 的合并，如果这 个操作由NameNode节点完成，又会效率过低。因此，引入一个新的节点SecondaryNamenode， 专门用于 FsImage 和 Edits 的合并。</p>
</blockquote>
<h5 id="1-2-1概念"><a href="#1-2-1概念" class="headerlink" title="1.2.1概念"></a>1.2.1概念</h5><p>Namenode被格式化之后,将在 opt/module/hadoop-3.].3/ data/tmp/dfs/name/curren目录中产生如下文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">fsimage 0C00000CC0CO0O0COCO</span><br><span class="line">fsimage 0C00000CC000000[OC0 md5</span><br><span class="line">seen txid</span><br><span class="line">VERSICN</span><br></pre></td></tr></table></figure>

<p>&ensp;&ensp;&ensp;&ensp;(1) Fsimage.文件:HDFS文件系统元数据的一个永久性的检査点,其中包含HDFS文件系统的所有目<br>录和文件 inode的序列化信息。</p>
<p>&ensp;&ensp;&ensp;&ensp;(2) Edits文件:存放IDFS文件系统的所有更新操作的路径,文件系统客户端执行的所有写操作首先<br>会被记录到 Edits文件中</p>
<p>&ensp;&ensp;&ensp;&ensp;(3) scen txid文件保存的是一个数字,就是最后一个cdis的数字</p>
<p>&ensp;&ensp;&ensp;&ensp;(4)每次 Namenodef启动的时候都会将 Simac文件读入内存,加载Edis里面的更新操作,保证内存<br>中的元数据信息是最新的、同步的,可以看成 Namenode启动的时候就将 Fsimage和Fdis文件进行了合并</p>
<h5 id="1-2-2使用oiv和oev命令查看fsimage和edits文件"><a href="#1-2-2使用oiv和oev命令查看fsimage和edits文件" class="headerlink" title="1.2.2使用oiv和oev命令查看fsimage和edits文件"></a>1.2.2使用oiv和oev命令查看fsimage和edits文件</h5><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 1.查看oiv和oev命令</span></span><br><span class="line">  hdfs</span><br><span class="line">  oiv                  apply the offline fsimage viewer to an fsimage</span><br><span class="line">  oev                  apply the offline edits viewer to an edits file</span><br><span class="line"><span class="meta">#</span><span class="bash"> 2.oiv查看fsimage文件</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 基本语法</span></span><br><span class="line">  hdfs oiv -p 文件类型 -i镜像文件 -o 转换后文件输出路径</span><br><span class="line"><span class="meta">#</span><span class="bash"> 案例实操</span></span><br><span class="line">  hdfs oiv -p XML -i fsimage_0000000000000000023 -o /opt/install/hadoop/fsimage.xml</span><br><span class="line">  cat opt/install/hadoop/fsimage.xml</span><br><span class="line">  将显示的xml文件内容拷贝到eclipse中创建的xml文件中，并格式化。</span><br><span class="line"><span class="meta">#</span><span class="bash"> 3.oev查看edits文件</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 基本语法</span></span><br><span class="line">  hdfs oev -p 文件类型 -i编辑日志 -o 转换后文件输出路径</span><br><span class="line"><span class="meta">#</span><span class="bash"> 案例实操</span></span><br><span class="line">  hdfs oev -p XML -i </span><br><span class="line">  edits_0000000000000000012-0000000000000000013 -o /opt/install/hadoop/edits.xml</span><br><span class="line"></span><br><span class="line">  cat /opt/install/hadoop/edits.xml</span><br><span class="line">  将显示的xml文件内容拷贝到eclipse中创建的xml文件中，并格式化。</span><br><span class="line">1234567891011121314151617181920</span><br></pre></td></tr></table></figure>

<h4 id="1-3-checkpoint时间设置"><a href="#1-3-checkpoint时间设置" class="headerlink" title="1.3 checkpoint时间设置"></a>1.3 checkpoint时间设置</h4><p>&ensp;&ensp;&ensp;&ensp;（1）通常情况下，SecondaryNameNode每隔一小时执行一次。</p>
<p>&ensp;&ensp;&ensp;&ensp;（2）一分钟检查一次操作次数，当操作次数达到1百万时，SecondaryNameNode执行一次。</p>
<h3 id="二、DataNode"><a href="#二、DataNode" class="headerlink" title="二、DataNode"></a>二、DataNode</h3><h4 id="2-1-DataNode-工作机制"><a href="#2-1-DataNode-工作机制" class="headerlink" title="2.1 DataNode 工作机制"></a>2.1 DataNode 工作机制</h4><img src="/2021/05/22/Hadoop%E4%B9%8BHDFS%EF%BC%9AHDFS%E7%9A%84%E5%90%84%E4%B8%AA%E8%8A%82%E7%82%B9%E5%B7%A5%E4%BD%9C%E6%9C%BA%E5%88%B6/2.png" alt="image-20210520205906636" style="zoom:80%;">

<p>&ensp;&ensp;&ensp;&ensp;（1）一个数据块在 DataNode 上以文件形式存储在磁盘上，包括两个文件，一个是数据本身，一个是元数据包括数据块的长度，块数据的校验和，以及时间戳。 </p>
<p>&ensp;&ensp;&ensp;&ensp;（2）DataNode 启动后向 NameNode 注册，通过后，周期性（6 小时）的向 NameNode 上 报所有的块信息。 DN 向 NN 汇报当前解读信息的时间间隔，默认 6 小时；DN 扫描自己节点块信息列表的时间，默认 6 小时 ;</p>
<p>&ensp;&ensp;&ensp;&ensp;（3）心跳是每 3 秒一次，心跳返回结果带有 NameNode 给该 DataNode 的命令如复制块 数据到另一台机器，或删除某个数据块。如果超过 10 分钟没有收到某个 DataNode 的心跳， 则认为该节点不可用。 </p>
<p>&ensp;&ensp;&ensp;&ensp;（4）集群运行中可以安全加入和退出一些机器。</p>
<h4 id="2-2-数据完整性"><a href="#2-2-数据完整性" class="headerlink" title="2.2 数据完整性"></a>2.2 数据完整性</h4><p>&ensp;&ensp;&ensp;&ensp;如下是 DataNode 节点保证数据完整性的方法。 </p>
<ol>
<li> 当 DataNode 读取 Block 的时候，它会计算 CheckSum。 </li>
<li> 如果计算后的 CheckSum，与 Block 创建时值不一样，说明 Block 已经损坏。</li>
<li> Client 读取其他 DataNode 上的 Block。 </li>
<li> 常见的校验算法 crc（32），md5（128），sha1（160） </li>
<li> DataNode 在其文件创建后周期验证 CheckSum。</li>
</ol>
<h4 id="2-3-掉线时限参数设置"><a href="#2-3-掉线时限参数设置" class="headerlink" title="2.3 掉线时限参数设置"></a>2.3 掉线时限参数设置</h4><img src="/2021/05/22/Hadoop%E4%B9%8BHDFS%EF%BC%9AHDFS%E7%9A%84%E5%90%84%E4%B8%AA%E8%8A%82%E7%82%B9%E5%B7%A5%E4%BD%9C%E6%9C%BA%E5%88%B6/3.png" alt="image-20210520210251978" style="zoom:80%;">



<p><a href="https://www.bilibili.com/video/BV1Qp4y1n7EN?p=1">尚硅谷丨大数据Hadoop 3.x（2021全新升级/部署+源码+实战）_哔哩哔哩 (゜-゜)つロ 干杯~-bilibili</a></p>
<p><a href="https://blog.csdn.net/qq_45069279/article/details/114527428">(4条消息) 太强了， SecondaryNameNode 的工作流程_苜苜的烂笔头的博客-CSDN博客</a></p>
]]></content>
      <categories>
        <category>数据研发</category>
        <category>Hadoop</category>
        <category>HDFS</category>
      </categories>
      <tags>
        <tag>数据研发</tag>
        <tag>Hadoop</tag>
        <tag>HDFS</tag>
      </tags>
  </entry>
  <entry>
    <title>HDFS读写</title>
    <url>/2021/05/22/Hadoop%E4%B9%8BHDFS%EF%BC%9AHDFS%E8%AF%BB%E5%86%99/</url>
    <content><![CDATA[<p>&ensp;&ensp;&ensp;介绍HDFS读写流程相关的知识和操作，这是数据研发面试时的一个重点。</p>
<span id="more"></span>

<h3 id="一、-机架感知"><a href="#一、-机架感知" class="headerlink" title="一、 机架感知"></a>一、 机架感知</h3><h4 id="1-1-设计机架感知的目的（副本存储节点选择）"><a href="#1-1-设计机架感知的目的（副本存储节点选择）" class="headerlink" title="1.1 设计机架感知的目的（副本存储节点选择）"></a>1.1 设计机架感知的目的（副本存储节点选择）</h4><p>&ensp;&ensp;&ensp;&ensp;机架感知的设计，考虑到两个方面：</p>
<ol>
<li> 不同节点之间的通信，希望在同一<a href="https://www.zhihu.com/question/52578218">机架</a>内进行（<code>Hadoop</code>集群会分布在很多机架上），而不是跨机架；</li>
<li> 为了提高容错能力，<code>NameNode</code> （名称节点）会尽可能把 数据块的副本 放在多个机架上。</li>
</ol>
<p>&ensp;&ensp;&ensp;&ensp;官方说明 <a href="http://hadoop.apache.org/docs/r3.1.3/hadoop-project-dist/hadoop-hdfs/HdfsDesign.html#Data_Replication">http://hadoop.apache.org/docs/r3.1.3/hadoop-project-dist/hadoop-hdfs/HdfsDesign.html#Data_Replication</a></p>
<h4 id="1-2-网络拓扑-节点距离计算"><a href="#1-2-网络拓扑-节点距离计算" class="headerlink" title="1.2 网络拓扑-节点距离计算"></a>1.2 网络拓扑-节点距离计算</h4><h5 id="1-2-1-网络拓扑图介绍"><a href="#1-2-1-网络拓扑图介绍" class="headerlink" title="1.2.1 网络拓扑图介绍"></a>1.2.1 网络拓扑图介绍</h5><p>&ensp;&ensp;<code>&amp;ensp;&amp;ensp;DataNode</code> 的<a href="https://zhuanlan.zhihu.com/p/267710797#:~:text=%E7%BD%91%E7%BB%9C%E6%8B%93%E6%89%91%E6%98%AF%E7%BD%91%E7%BB%9C%E5%BD%A2%E7%8A%B6,%E4%BB%A5%E5%8F%8A%E6%B7%B7%E5%90%88%E5%9E%8B%E7%BB%93%E6%9E%84%E7%AD%89%E3%80%82">网络拓扑</a>图如下：</p>
<p><img src="/2021/05/22/Hadoop%E4%B9%8BHDFS%EF%BC%9AHDFS%E8%AF%BB%E5%86%99/1.png" alt="image-20210520201704429"></p>
<h5 id="1-2-2-功能分析"><a href="#1-2-2-功能分析" class="headerlink" title="1.2.2 功能分析"></a>1.2.2 功能分析</h5><p>&ensp;&ensp;&ensp;&ensp;默认情况下，<code>HDFS </code>不能 自动判断 集群中各个 <code>DataNode</code> 的网络拓扑情况，集群默认都处在同一个机架名为 <code>/default-rack</code>的机架上（在这种情况下，任何一台 <code>DataNode</code> 机器，不管在物理上是否是属于同一个机架，都会被认为是在同一个机架下）。</p>
<p>&ensp;&ensp;&ensp;&ensp;通常，我们通过外在脚本实现机架感知，需要配置 <code>net.topology.script.file.name</code>属性（属性值一般是一个可执行脚本文件的路径）。脚本接收一个值，再输出一个值（一般都是接收 IP地址 ，输出这个地址所对应的 机架信息 ）。</p>
<h3 id="二、-副本冗余存储策略"><a href="#二、-副本冗余存储策略" class="headerlink" title="二、 副本冗余存储策略"></a>二、 副本冗余存储策略</h3><p>&ensp;&ensp;&ensp;&ensp;HDFS 上的文件对应的数据块保存有多个副本（<strong>默认保存3个副本</strong>），且提供容错机制 ，副本丢失或宕机（即死机）时自动恢复。</p>
<h4 id="2-1-策略的介绍"><a href="#2-1-策略的介绍" class="headerlink" title="2.1 策略的介绍"></a>2.1 策略的介绍</h4><p>&ensp;&ensp;&ensp;&ensp;下面，以保存 3个副本 为例：<br><img src="/2021/05/22/Hadoop%E4%B9%8BHDFS%EF%BC%9AHDFS%E8%AF%BB%E5%86%99/2.png" alt="在这里插入图片描述"></p>
<ol>
<li> 第一个副本（副本一）：放置在上传文件的数据节点上（若是在集群外提交，则随机挑选一个 <strong>CPU比较空闲</strong>、<strong>磁盘不太满</strong> 的节点）。</li>
<li> 第二个副本（副本二）：放置在与第一个副本<strong>不同</strong>的机架的节点上。</li>
<li> 第三个副本（副本三）：放置在与第二个副本<strong>相同</strong>机架的其他节点上。</li>
<li> 如果有更多副本，那么这些副本随机选择节点存放。</li>
</ol>
<p>&ensp;&ensp;&ensp;&ensp;需要注意的是，副本并不都是均匀分布在不同的机架上。</p>
<h4 id="2-2-策略的优点"><a href="#2-2-策略的优点" class="headerlink" title="2.2 策略的优点"></a>2.2 策略的优点</h4><p>副本冗余存储策略，主要有三个优点：</p>
<ol>
<li> 减少了机架间的 数据传输 ，提高了<strong>写操作</strong>的效率。（不会影响数据的可靠性和可用性，因为机架的错误远远比节点的错误小）</li>
<li> 减少了读取数据时所需的<strong>网络传输总带宽</strong>。（因为数据块只放在两个不同的机架上）</li>
<li> 在不损害数据可靠性和读取性能的情况下，改进了<strong>写操作</strong>的性能。（一个副本在一个机架的一个节点上，另外两个副本在另一个机架的不同节点上，其他副本则均匀分布在剩下的机架中。如  2.1 所介绍。）</li>
</ol>
<h3 id="三、HDFS读写流程"><a href="#三、HDFS读写流程" class="headerlink" title="三、HDFS读写流程"></a>三、HDFS读写流程</h3><h4 id="3-1-HDFS写数据流程"><a href="#3-1-HDFS写数据流程" class="headerlink" title="3.1 HDFS写数据流程"></a>3.1 HDFS写数据流程</h4><img src="/2021/05/22/Hadoop%E4%B9%8BHDFS%EF%BC%9AHDFS%E8%AF%BB%E5%86%99/3.png" alt="image-20210520202421789" style="zoom:80%;">

<p><strong>流程</strong>：</p>
<ol>
<li> 客户端通过<code>Distributed FileSystem</code>模块向<code>NameNode</code>请求上传文件，<code>NameNode</code>检查目标文件是否已存在，父目录是否存在。</li>
<li> <code>NameNode</code>返回是否可以上传。不能上传会返回异常。</li>
<li> 确定可以上传，客户端请求第一个 <code>Block</code> 上传到哪几个<code>datanode</code>服务器上。</li>
<li> <code>NameNode</code>返回3个<code>datanode</code>节点，假定分别为<code>dn1</code>、<code>dn2</code>、<code>dn3</code>。</li>
<li> 客户端通过<code>FSDataOutputStream</code>模块请求<code>dn1</code>上传数据，<code>dn1</code>收到请求会继续调用<code>dn2</code>，然后<code>dn2</code>调用<code>dn3</code>，将这个通信管道建立完成。</li>
<li> <code>dn1</code>、<code>dn2</code>、<code>dn3</code>逐级应答客户端。</li>
<li> 客户端开始往<code>dn1</code>上传第一个<code>block</code>（先从磁盘读取数据放到一个本地内存缓存），以<code>packet</code>（64KB）为单位，<code>dn1</code>收到一个<code>packet</code>就会传给<code>dn2</code>，<code>dn2</code>传给<code>dn3</code>；<code>dn1</code>每传一个<code>packet</code>会放入一个应答队列等待应答。</li>
<li> 当一个<code>block</code>传输完成之后，客户端再次请求<code>NameNode</code>上传第二个<code>block</code>的服务器。（重复执行3-7步）。</li>
</ol>
<blockquote>
<p>⑴ 客户端调用 DistributedFileSystem 对象的 create() 方法创建一个文件输出流对象。</p>
<p>⑵ DistributedFileSystem 对象远程的 NameNode 节点发起一次 <a href="https://zhuanlan.zhihu.com/p/36427583">RPC调用</a> ，NameNode 检查这个文件 是否存在 ，以及客户端 是否有权限 新建文件。</p>
<p>⑶ 客户端调用 FSDataOutputStream 对象的 write() 方法写数据（数据鲜卑写入缓冲区，再被切分为一个个数据包）。</p>
<p>⑷ 每个数据包被发送到由 NameNode 节点分配的一组数据节点中的一个数据节点上，在这组数据节点组成的管道上依次传输数据包。</p>
<p>⑸ 管道上的节点按反向顺序返回确认信息，最终由管道的第一个数据节点将整条管道的确认信息发送给客户端。</p>
<p>⑹ 客户端完成写入，调用 close() 方法关闭文件输出流。</p>
<p>⑺ 通知 NameNode 文件写入成功。</p>
</blockquote>
<h5 id="FSDataOutputStream-类介绍"><a href="#FSDataOutputStream-类介绍" class="headerlink" title="FSDataOutputStream 类介绍"></a>FSDataOutputStream 类介绍</h5><p>&ensp;&ensp;&ensp;&ensp;FSDataOutputStream 输入流类的常用方法：</p>
<table>
<thead>
<tr>
<th>方法名</th>
<th>返回值</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>write(byte[] b)</td>
<td>void</td>
<td>将数组 b 中的所有字节写入输出流</td>
</tr>
<tr>
<td>write(byte[] buf,int off,int len)</td>
<td>void</td>
<td>将字节组写入底层输出流，写入的字节从 off 偏移量开始，写入长度为 len</td>
</tr>
<tr>
<td>flush()</td>
<td>void</td>
<td>刷新数据输出流（缓冲区内容被强制写入流中）</td>
</tr>
</tbody></table>
<p>&ensp;&ensp;&ensp;&ensp;<code>len </code>指定读操作的最大字节数。</p>
<h4 id="3-2-HDFS读数据流程"><a href="#3-2-HDFS读数据流程" class="headerlink" title="3.2 HDFS读数据流程"></a>3.2 HDFS读数据流程</h4><img src="/2021/05/22/Hadoop%E4%B9%8BHDFS%EF%BC%9AHDFS%E8%AF%BB%E5%86%99/4.png" alt="image-20210520203712825" style="zoom:80%;">

<ol>
<li> 首先调用<code>FileSystem.open()</code>方法，获取到<code>DistributedFileSystem</code>实例</li>
<li> <code>DistributedFileSystem</code> 向<code>Namenode</code>发起<code>RPC</code>(远程过程调用)请求获得文件的开始部分或全部<code>block</code>列表，对于每个返回的块，都包含块所在的<code>DataNode</code>地址。这些<code>DataNode</code>会按照<code>Hadoop</code>定义的集群拓扑结构得出客户端的距离，然后再进行排序。如果客户端本身就是一个<code>DataNode</code>，那么他将从本地读取文件。</li>
<li> <code>DistributedFileSystem</code>会向客户端client返回一个支持文件定位的输入流对象<code>FSDataInputStream</code>，用于客户端读取数据。<code>FSDataInputStream</code>包含一个<code>DFSInputStream</code>对象，这个对象用来管理<code>DataNode</code>和<code>NameNode</code>之间的I/O</li>
<li> 客户端调用<code>read()</code>方法，<code>DFSInputStream</code>就会找出离客户端最近的<code>datanode</code>并连接<code>datanode</code></li>
<li> <code>DFSInputStream</code>对象中包含文件开始部分的数据块所在的<code>DataNode</code>地址，首先它会连接包含文件第一个块最近<code>DataNode</code>。随后，在数据流中重复调用<code>read()</code>函数，直到这个块全部读完为止。如果第一个<code>block</code>块的数据读完，就会关闭指向第一个<code>block</code>块的<code>datanode</code>连接，接着读取下一个<code>block</code>块</li>
<li> 如果第一批<code>block</code>都读完了，<code>DFSInputStream</code>就会去<code>NameNode</code>拿下一批<code>blocks</code>的<code>location</code>，然后继续读，如果所有的<code>block</code>块都读完，这时就会关闭掉所有的流。</li>
</ol>
<p><strong>FSDataInputStream</strong> 类介绍</p>
<p>&ensp;&ensp;&ensp;&ensp;FSDataInputStream 输入流类的常用方法：</p>
<table>
<thead>
<tr>
<th>方法名</th>
<th>返回值</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>read(ByteBuffer buf)</td>
<td>int</td>
<td>读取并写入 buf 缓冲区，返回所读的字节数</td>
</tr>
<tr>
<td>read(long pos,byte[] buf,int offset,int len)</td>
<td>int</td>
<td>从输入流的指定位置开始，把数据读入缓冲区。</td>
</tr>
<tr>
<td>readFully(long pos,byte[] buf)</td>
<td>void</td>
<td>从指定位置开始，读取所有数据到缓冲区</td>
</tr>
<tr>
<td>seek(long offset)</td>
<td>void</td>
<td>指向输入流的第 offset 字节</td>
</tr>
<tr>
<td>releaseBuffer(ByteBuffer buf)</td>
<td>void</td>
<td>删除指定的缓冲区</td>
</tr>
</tbody></table>
<p>&ensp;&ensp;&ensp;&ensp;<em>pos</em> 指定从输入流中读取数据的位置；<em>offset</em> 指定数据写入缓冲区的位置（偏移量）；<em>len</em> 指定读操作的最大字节数。</p>
<p>&ensp;&ensp;&ensp;&ensp;<code>HDFS</code>如何控制客户端读取哪个副本节点数据 ?<br>&ensp;&ensp;&ensp;&ensp;<code>HDFS</code>满足客户端访问副本数据的最近原则。即客户端距离哪个副本数据最近，HDFS就让哪个节点把数据给客户端。</p>
<p><a href="https://blog.csdn.net/qq_45069279/article/details/114734679">(4条消息) 干货满满，图文详解 HDFS 的 工作机制 及其原理_苜苜的烂笔头的博客-CSDN博客</a></p>
]]></content>
      <categories>
        <category>数据研发</category>
        <category>Hadoop</category>
        <category>HDFS</category>
      </categories>
      <tags>
        <tag>数据研发</tag>
        <tag>Hadoop</tag>
        <tag>HDFS</tag>
      </tags>
  </entry>
  <entry>
    <title>Hadoop简介</title>
    <url>/2021/05/22/Hadoop%EF%BC%9AHadoop%E7%AE%80%E4%BB%8B/</url>
    <content><![CDATA[<h3 id="一、Hadoop是什么"><a href="#一、Hadoop是什么" class="headerlink" title="一、Hadoop是什么?"></a>一、Hadoop是什么?</h3><p>&ensp;&ensp;&ensp;&ensp;Hadoop是一个由Apache基金会所开发的分布式系统基础架构，它的 HDFA 、 MapReduce 、 HBase 分别是Google的GFS、MapReduce、BigTable这三个思想的实现。</p>
<span id="more"></span>

<p>&ensp;&ensp;&ensp;&ensp;主要解决<strong>海量数据的存储和海量数据的分析计算</strong>问题</p>
<p>&ensp;&ensp;&ensp;&ensp;广义上来说，HADOOP通常是指一个更广泛的概念——HADOOP生态圈</p>
<blockquote>
<p><strong>Google公司三篇论文的思想：</strong></p>
<ol>
<li> GFS的思想：描述了一个分布式文件系统的设计思路。（HDFS是这篇论文思想的实现）</li>
<li> MapReduce的思想：分散任务，汇总结果。（Hadoop的MapReduce与MapReduce论文中的实现思路一样）</li>
<li> BigTable的思想：一个分布式的结构化数据存储系统的设计思路。（HBase是这篇论文思想的实现。HBase是一个分布式、面向列的开源数据库，它是在Hadoop基础上提供类似BigTable的能力。）</li>
</ol>
</blockquote>
<h3 id="二、Hadoop发行版本："><a href="#二、Hadoop发行版本：" class="headerlink" title="二、Hadoop发行版本："></a>二、Hadoop发行版本：</h3><p>Apache、Cloudera、Hortonworks（需要明确自己使用的版本）</p>
<ul>
<li>  Apache版本最原始（最基础）的版本，对于入门学习最好</li>
<li>  Cloudera在大型互联网企业中用的较多</li>
<li>  Hortonworks文档较好</li>
</ul>
<h3 id="三、Hadoop优势"><a href="#三、Hadoop优势" class="headerlink" title="三、Hadoop优势"></a>三、Hadoop优势</h3><ul>
<li>  <strong>高可靠性：</strong>Hadoop底层维护多个数据副本，所以即使Hadoop某个计算元素或存储出现故障，也不会导致数据的丢失。</li>
<li>  <strong>高扩展性：</strong>在集群间分配任务数据，可方便的扩展数以千计的节点。</li>
<li>  <strong>高效性：</strong>在MapReduce的思想下，Hadoop是并行工作的，以加快任务处理速度。</li>
<li>  <strong>高容错性：</strong>能够自动将失败的任务重新分配。</li>
</ul>
<h3 id="四、Hadooo组成"><a href="#四、Hadooo组成" class="headerlink" title="四、Hadooo组成"></a>四、Hadooo组成</h3><h4 id="4-1、Hadoop1-x-到-Hadoop2-x"><a href="#4-1、Hadoop1-x-到-Hadoop2-x" class="headerlink" title="4.1、Hadoop1.x 到 Hadoop2.x"></a>4.1、Hadoop1.x 到 Hadoop2.x</h4><ul>
<li>  Hadoop1.x组成：HDFS、MapReduce</li>
<li>  Hadoop2.x组成：HDFS、MapReduce、YARN</li>
<li>  在1.x时代，Hadoop中的 Mapreduce 同时处理业务逻辑运和资源的调度,耦合性较大。</li>
<li>  在 Hadoop2,x时代,增加了Yarn。Yarn只负责资源的调度 MapReduce 只负责运算。</li>
</ul>
<h4 id="4-2、Hadoop2-x-到-Hadoop3-x"><a href="#4-2、Hadoop2-x-到-Hadoop3-x" class="headerlink" title="4.2、Hadoop2.x 到 Hadoop3.x"></a>4.2、Hadoop2.x 到 Hadoop3.x</h4><ol>
<li> jdk的最低依赖从1.7变成1.8。</li>
<li> hadoop-client 这个依赖分为 hadoop-client-api 和 hadoop-client-runtime 两个依赖。</li>
<li> 采用 Timeline Server v2 版本。</li>
<li> HDFS 支持可擦除编码（Erasure Encoding）。</li>
<li> 支持随机 Container 和分布式调度。</li>
<li> MR进行了 Task 级别的本地优化。</li>
<li> 多个端口被改动。</li>
<li> 支持多个 Standby 状态的 NameNode 。</li>
<li> DataNode内部添加了负载均衡。</li>
<li> 支持 微软（Azure） 和 阿里（Aliyun） 的分布式文件系统。</li>
</ol>
<h3 id="五、Hadoop运行环境搭建"><a href="#五、Hadoop运行环境搭建" class="headerlink" title="五、Hadoop运行环境搭建"></a>五、Hadoop运行环境搭建</h3><p>&ensp;&ensp;&ensp;&ensp;Hadoop安装模式有三种：单机模式（Standalone Mode）、伪分布式模式（Pseudo-Distributed Mode）、完全分布式模式（Fully-Distributed Mode）。</p>
<h4 id="5-1-单机模式"><a href="#5-1-单机模式" class="headerlink" title="5.1 单机模式"></a>5.1 单机模式</h4><p>&ensp;&ensp;&ensp;&ensp;单机模式是指Hadoop运行在一台主机上，按默认配置以非分布式模式运行一个java进程。</p>
<p><strong>特点：</strong></p>
<ol>
<li> <em>没有</em> 分布式文件系统，直接在本地操作系统的文件系统进行读 / 写 。</li>
<li> 不需要加载任何Hadoop守护进程。</li>
<li> 一般用户本地MapReduce调试。</li>
<li> Hadoop的默认模式。</li>
</ol>
<h4 id="5-2-伪分布式模式"><a href="#5-2-伪分布式模式" class="headerlink" title="5.2 伪分布式模式"></a>5.2 伪分布式模式</h4><p>&ensp;&ensp;&ensp;&ensp;伪分布式模式是指Hadoop运行在一台主机上，使用多个java进程，模仿完全分布式模式的节点。</p>
<p><strong>特点：</strong></p>
<ol>
<li> 有完全分布式模式的<em>全部功能</em> 。</li>
<li> 常用于调试程序。</li>
<li> 只有一个节点。</li>
</ol>
<h4 id="5-3-完全分布式模式"><a href="#5-3-完全分布式模式" class="headerlink" title="5.3 完全分布式模式"></a>5.3 完全分布式模式</h4><p>&ensp;&ensp;&ensp;&ensp;完全分布式模式也称做 <em>集群模式</em> 。</p>
<p><strong>特点：</strong></p>
<ol>
<li> 将Hadoop运行在多台主机中，各主机按照相关配置运行相应的Hadoop守护进程。</li>
<li> 真正的分布式环境。</li>
<li> 可用于实际生产环境。</li>
</ol>
<h3 id="六、hadoop生态圈"><a href="#六、hadoop生态圈" class="headerlink" title="六、hadoop生态圈"></a>六、hadoop生态圈</h3><p><strong>生态圈的常用组件：</strong></p>
<table>
<thead>
<tr>
<th>组件</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>HDFS</td>
<td>分布式文件系统</td>
</tr>
<tr>
<td>YARN</td>
<td>资源调度框架</td>
</tr>
<tr>
<td>HBase</td>
<td>建立在hadoop文件系统之上的分布式列式数据库</td>
</tr>
<tr>
<td>Hive</td>
<td>hadoop上的大数据数据仓库</td>
</tr>
<tr>
<td>MapReduce</td>
<td>分布式并行编程模型</td>
</tr>
<tr>
<td>Pig</td>
<td>查询大型半结构化数据集的分析平台</td>
</tr>
<tr>
<td>Flume</td>
<td>一个高可用、高可靠、分布式的海量日志采集、聚合和传输的系统</td>
</tr>
<tr>
<td>Zookeeper</td>
<td>提供分布式协调一致性服务</td>
</tr>
<tr>
<td>Sqoop</td>
<td>在传统数据库与Hadoop数据存储和处理平台间进行数据传递的工具</td>
</tr>
<tr>
<td>Mahout</td>
<td>提供一些可扩展的机器学习领域经典算法的实现</td>
</tr>
<tr>
<td>Ambari</td>
<td>Hadoop快速部署工具，支持 Apache Hadoop 集群的供应、管理和监控</td>
</tr>
</tbody></table>
<h3 id="七、常用端口号"><a href="#七、常用端口号" class="headerlink" title="七、常用端口号"></a>七、常用端口号</h3><h4 id="Namenode-端口"><a href="#Namenode-端口" class="headerlink" title="Namenode 端口:"></a>Namenode 端口:</h4><table>
<thead>
<tr>
<th>2.x端口</th>
<th>3.x端口</th>
<th>name</th>
<th>desc</th>
</tr>
</thead>
<tbody><tr>
<td>50470</td>
<td>9871</td>
<td>dfs.namenode.https-address</td>
<td>The namenode secure http server address and port.</td>
</tr>
<tr>
<td><strong>50070</strong></td>
<td><strong>9870</strong></td>
<td>dfs.namenode.http-address</td>
<td>The address and the base port where the dfs namenode web ui will listen on.</td>
</tr>
<tr>
<td>8020</td>
<td>9820</td>
<td>fs.defaultFS</td>
<td>指定HDFS运行时nameNode地址</td>
</tr>
</tbody></table>
<hr>
<h4 id="Secondary-NN-端口"><a href="#Secondary-NN-端口" class="headerlink" title="Secondary NN 端口:"></a>Secondary NN 端口:</h4><table>
<thead>
<tr>
<th>2.x端口</th>
<th>3.x端口</th>
<th>name</th>
<th>desc</th>
</tr>
</thead>
<tbody><tr>
<td>50091</td>
<td>9869</td>
<td>dfs.namenode.secondary.https-address</td>
<td>The secondary namenode HTTPS server address and port</td>
</tr>
<tr>
<td>50090</td>
<td>9868</td>
<td>dfs.namenode.secondary.http-address</td>
<td>The secondary namenode HTTPS server address and port</td>
</tr>
</tbody></table>
<hr>
<h4 id="Datanode-端口"><a href="#Datanode-端口" class="headerlink" title="Datanode 端口:"></a>Datanode 端口:</h4><table>
<thead>
<tr>
<th>2.x端口</th>
<th>3.x端口</th>
<th>name</th>
<th>desc</th>
</tr>
</thead>
<tbody><tr>
<td>50020</td>
<td>9867</td>
<td>dfs.datanode.ipc.address</td>
<td>The datanode ipc server address and port.</td>
</tr>
<tr>
<td>50010</td>
<td>9866</td>
<td>dfs.datanode.address</td>
<td>The datanode server address and port for data transfer.</td>
</tr>
<tr>
<td>50475</td>
<td>9865</td>
<td>dfs.datanode.https.address</td>
<td>The datanode secure http server address and port</td>
</tr>
<tr>
<td>50075</td>
<td>9864</td>
<td>dfs.datanode.http.address</td>
<td>The datanode http server address and por</td>
</tr>
</tbody></table>
<h4 id="Yarn-端口"><a href="#Yarn-端口" class="headerlink" title="Yarn 端口"></a>Yarn 端口</h4><table>
<thead>
<tr>
<th>2.x端口</th>
<th>3.x端口</th>
<th>name</th>
<th>desc</th>
</tr>
</thead>
<tbody><tr>
<td><strong>8088</strong></td>
<td><strong>8088</strong></td>
<td>yarn.resourcemanager.webapp.address</td>
<td>http服务端口</td>
</tr>
</tbody></table>
<img src="/2021/05/22/Hadoop%EF%BC%9AHadoop%E7%AE%80%E4%BB%8B/1.png" alt="image-20210520210812940" style="zoom:80%;">

<blockquote>
<p>1，namenode http端口：50070</p>
<p>2，datanode http端口：50075</p>
<p>3，secondaryNameNode 节点http端口号：50090</p>
<p>4，datanode后端访问端口号：50010</p>
<p>5，fs 端口号：9000</p>
<p>6，yarn http端口号：8088</p>
<p>7，历史服务器web访问端口号：19888</p>
</blockquote>
<p><a href="https://www.bilibili.com/video/BV1Qp4y1n7EN?p=1">尚硅谷丨大数据Hadoop 3.x（2021全新升级/部署+源码+实战）_哔哩哔哩 (゜-゜)つロ 干杯~-bilibili</a></p>
<p><a href="https://blog.csdn.net/qq_45069279/article/details/105947443?ops_request_misc=%7B%22request_id%22:%22162107389816780366553176%22,%22scm%22:%2220140713.130102334.pc_all.%22%7D&request_id=162107389816780366553176&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_v2~hot_rank-1-105947443.first_rank_v2_pc_rank_v29&utm_term=hadoop&spm=1018.2226.3001.4187">(4条消息) 万字详解，Hadoop大数据技术简介及 伪分布式集群搭建快速入门教程_苜苜的烂笔头的博客-CSDN博客</a></p>
]]></content>
      <categories>
        <category>数据研发</category>
        <category>Hadoop</category>
      </categories>
      <tags>
        <tag>数据研发</tag>
        <tag>Hadoop</tag>
      </tags>
  </entry>
  <entry>
    <title>散列表总结</title>
    <url>/2021/05/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%9A%E6%95%A3%E5%88%97%E8%A1%A8/</url>
    <content><![CDATA[<h3 id="一、简介"><a href="#一、简介" class="headerlink" title="一、简介"></a>一、简介</h3><p>&ensp;&ensp;&ensp;&ensp;<code>哈希表</code>（<code>Hash table</code>，也叫<code>散列表</code>），是根据关键字而直接进行访问的数据结构。也就是说，它通过把关键字映射到表中一个位置来访问记录，以加快查找的速度。</p>
<span id="more"></span>

<p>&ensp;&ensp;&ensp;&ensp;通常，我们把这个关键字称为 <code>Key</code>，把对应的记录称为 <code>Value</code>，所以也可以说是通过 <code>Key</code> 访问一个映射表来得到 <code>Value</code> 的地址。而这个<code>映射</code>，也叫作<code>散列函数</code>或者<code>哈希函数</code>，存放记录的数组叫作<code>散列表</code>。</p>
<p>&ensp;&ensp;&ensp;&ensp;我们把表的大小记作 <code>Table Size</code>，并将其理解为散列数据结构的一部分而不仅仅是浮动于全局的某个变量。</p>
<p>&ensp;&ensp;&ensp;&ensp;每个关键字被映射到从<code>0</code>到 <code>Tablesize-1</code>这个范围中的某个数，并且被放到适当的单元中。这个映射就叫作<code>散列函数</code>(hash function)，理想情况下它应该算起来简单并且应该保证任何两个不同的关键字都要映射到不同的单元。但是，这显然是不可能的，因为单元的数目是有限的，而关键字实际上是用不完的。因此，我们寻找一个散列函数,该函数要在单元之间均匀地分配关键字。</p>
<p>&ensp;&ensp;&ensp;&ensp;这就是散列的基本想法。剩下的问题就是要选择一个函数，决定当两个关键字散列到同个值的时候（这叫作<code>冲突</code>（collision））应该做什么以及如何确定散列表的大小。</p>
<blockquote>
<p>优点：一对一的查找效率很高；</p>
<p>缺点：一个关键字可能对应多个散列地址；需要查找一个范围时，效果不好。</p>
<p>散列冲突：不同的关键字经过散列函数的计算得到了相同的散列地址。</p>
<p>好的散列函数=计算简单+分布均匀（计算得到的散列地址分布均匀）</p>
<p>哈希表是种数据结构，它可以提供快速的插入操作和查找操作。</p>
<p>优缺点</p>
<p>优点：不论哈希表中有多少数据，查找、插入、删除（有时包括删除）只需要接近常量的时间即0(1）的时间级。实际上，这只需要几条机器指令。</p>
<p>哈希表运算得非常快，在计算机程序中，如果需要在一秒种内查找上千条记录通常使用哈希表（例如拼写检查器)哈希表的速度明显比树快，树的操作通常需要O(N)的时间级。哈希表不仅速度快，编程实现也相对容易。</p>
<p>如果不需要有序遍历数据，并且可以提前预测数据量的大小。那么哈希表在速度和易用性方面是无与伦比的。</p>
<p>缺点：它是基于数组的，数组创建后难于扩展，某些哈希表被基本填满时，性能下降得非常严重，所以程序员必须要清楚表中将要存储多少数据（或者准备好定期地把数据转移到更大的哈希表中，这是个费时的过程）。</p>
</blockquote>
<h3 id="二、散列函数"><a href="#二、散列函数" class="headerlink" title="二、散列函数"></a>二、散列函数</h3><p>&ensp;&ensp;&ensp;&ensp;如果输入的关键字是<code>整数</code>，则一般合理的方法就是直接返回 Key mod Tablesize，除非<code>Key</code>巧具有某些不理想的性质。在这种情况下，散列函数的选择需要仔细地考虑。</p>
<p>&ensp;&ensp;&ensp;&ensp;若表的大小是10而关键字都以0为个位，则此时上述标准的散列函数就是一个坏的选择。其原因是（………………）。而为了避免上面那样的情况，好的办法通常是<strong>保证表的大小是素数</strong>。当输入的关键字是随机整数时，这个函数此时不仅算起来非常简单而且关键字的分配也很均匀。</p>
<p>&ensp;&ensp;&ensp;&ensp;通常，关键字是字符串。在这种情形下,散列函数需要仔细选择。下面介绍《数据结构与算法分析》中的三种方法。</p>
<p>&ensp;&ensp;&ensp;&ensp;第一种：把字符串中字符的<code>ASCI</code>码值加起来。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">hash</span><span class="params">(<span class="keyword">const</span> string key, <span class="keyword">int</span> tablesize)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> hashval = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">char</span> ch : key)</span><br><span class="line">         hashva1 += Ch;</span><br><span class="line">    <span class="keyword">return</span> hashval % tablesize;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&ensp;&ensp;&ensp;&ensp;这个散列函数实现起来简单而且能够很快地算出答案。不过，如果表过大，则函数将不会很好地分配关键字。例如，设 <code>Tablesize = 10007</code>(10007是<code>素数</code>)，并设所有的关键字均为 <code>8</code> 个或更少个字符长。由于<code>ASCI</code>字符的值最多是<code>127</code>，因此散列函数只能假设值在 <code>0</code> 和 <code>1016</code> 之间，其 <code>1016</code> 为 <code>127*8</code>。显然这不是一种合理的分配。</p>
<p>&ensp;&ensp;&ensp;&ensp;第二种：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">hash</span><span class="params">(<span class="keyword">const</span> string key, <span class="keyword">int</span> tablesize)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (key[<span class="number">0</span>] + <span class="number">27</span> * key[<span class="number">1</span>] + <span class="number">729</span> * key[<span class="number">2</span>]) % tablesize;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&ensp;&ensp;&ensp;这个散列函数假设<code>Key</code>至少有 3 个字符。值 27 英文字母表的字母外加一个空格的个数，729是<code>27^2</code>。该函数只考査前 3 个字符，但是，假如它们是随机的，而表的大小像前面那样还是10007，那么我们就会得到一个合理的均衡分布。但英文不是随机的，虽然3个字符(忽略空格)有<code>26^3=17576</code>种可能的组合，但查验合理的足够大的联机词典却揭示：3个字母的不同组合数实际只有2851。即使这些组合没有冲突,也不过只有表的28%被真正散列到。<strong>因此，虽然很容易计算，但是，如果散列表就算大小适当，那么这个函数也还是不合适的。</strong></p>
<p>&ensp;&ensp;&ensp;&ensp;第三种：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 字符串对象的散列例程</span></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(<span class="keyword">const</span> string &amp; key, <span class="keyword">int</span> tablesize)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> hashval = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">char</span> ch : key)</span><br><span class="line">      hashval = <span class="number">37</span> * hashval + ch;</span><br><span class="line">    <span class="keyword">return</span> hashval % tablesize</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&ensp;&ensp;&ensp;&ensp;这个散列函数涉及到关键字中的所有字符，并且一般可以分布得很好(它计算<img src="/2021/05/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%9A%E6%95%A3%E5%88%97%E8%A1%A8/../Typora%E5%9B%BE%E7%89%87/image-20210522011156229.png" alt="image-20210522011156229" style="zoom:50%;">,并将结果限制在适当的范围)。程序根据 Horner 法则计算一个(37的)多项式函数。例如，计算h<del>k</del> = k<del>0</del> + 37k<del>1</del> + 37^2^k<del>2</del>的另一种方式是借助于公式 h<del>k</del> = ((k<del>2</del>) * 37 + k<del>1</del>) * 37 + k<del>0</del> 进行。 Horner 法则将其扩展到用于 n 次多项式。<br>&ensp;&ensp;&ensp;&ensp;这个散列函数利用到以下事实：允许溢出，同时用到  unsigned int 型量以避免引进负数。</p>
<p>&ensp;&ensp;&ensp;&ensp;这个散列函数就表的分布而言未必是最好的,但是确实具有极其简单的优点而且速度也很快。如果关键字特别长，那么该散列函数计算起来将会花费过多的时间，在这种情况下通常的经验是不使用所有的字符。此时关键字的长度和性质将影响选择。例如,关键字可能是完整的街道地址，散列函数可以包括街道地址的几个字符，也许还有城市名和邮政区码的儿个字符。有些程序设计人员通过只使用奇数位置上的字符来实现他们的散列函数，这里有这么一层想法：用计算散列函数节省下的时间来补偿轻微地不均匀分布的函数。</p>
<blockquote>
<p>哈希函数比较常用的实现方法比较多，通常需要考虑几个因素：关键字的长度、哈希表的大小、关键字的分布情况、记录的查找频率，等等。</p>
<p>下面简单介绍几种哈希函数。</p>
<ul>
<li>  直接寻址法：取关键字或关键字的某个线性函数值为散列地址。</li>
<li>  数字分析法：通过对数据的分析，发现数据中冲突较少的部分，并构造散列地址。例如同学们的学号，通常同一届学生的学号，其中前面的部分差别不太大，所以用后面的部分来构造散列地址。</li>
<li>  平方取中法：当无法确定关键字里哪几位的分布相对比较均匀时，可以先求出关键字的平方值，然后按需要取平方值的中间几位作为散列地址。这是因为：计算平方之后的中间几位和关键字中的每一位都相关，所以不同的关键字会以较高的概率产生不同的散列地址。</li>
<li>  取随机数法：使用一个随机函数，取关键字的随机值作为散列地址，这种方式通常用于关键字长度不同的场合。</li>
<li>  除留取余法：取关键字被某个不大于散列表的表长 n 的数 m 除后所得的余数 p 为散列地址。这种方式也可以在用过其他方法后再使用。该函数对 m 的选择很重要，一般取素数或者直接用 n。</li>
</ul>
</blockquote>
<h3 id="三、分离链接法"><a href="#三、分离链接法" class="headerlink" title="三、分离链接法"></a>三、分离链接法</h3><p>&ensp;&ensp;&ensp;&ensp;解决冲突的第一种方法通常叫作分离链接法( separate chaining)，其做法是将散列到同个值的所有元素保留到一个链表中。哈希表有多种不同的实现方法，这是最常用的一种方法，我们可以理解为“链表的数组”。</p>
<img src="/2021/05/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%9A%E6%95%A3%E5%88%97%E8%A1%A8/4.png" alt="image-20210522014355022">

<p>&ensp;&ensp;&ensp;散列表存储一个链表数组,它们在构造函数中被指定。</p>
<p>&ensp;&ensp;&ensp;左边很明显是个数组，数组的每个成员包括一个指针，指向一个链表的头，当然这个链表可能为空，也可能元素很多。我们根据元素的一些特征把元素分配到不同的链表中去，也是根据这些特征，找到正确的链表，再从链表中找出这个元素。</p>
<p>&ensp;&ensp;&ensp;为执行一次 <code>查询</code>，我们使用散列函数来确定究竟遍历哪个链表。然后再在适当的链表中执行一次查找。为执行 Insert，我们检查相应的链表看看该元素是否已经处在相应的位置(如果允许插入重复元，那么通常要留出一个额外的数据成员，当出现匹配事件时这个数据成员增1)。如果这个元素是个新的元素，那么它将被插入到链表的前端，这不仅因为方便，而且还因为常常发生这样的事实：新近插入的元素最有可能不久又被访问。</p>
<blockquote>
<p>冲突的处理方式还也有很多，下面介绍几种。</p>
<ul>
<li>  开放地址法（也叫开放寻址法）：实际上就是当需要存储值时，对Key哈希之后，发现这个地址已经有值了，这时该怎么办？不能放在这个地址，不然之前的映射会被覆盖。这时对计算出来的地址进行一个探测再哈希，比如往后移动一个地址，如果没人占用，就用这个地址。如果超过最大长度，则可以对总长度取余。这里移动的地址是产生冲突时的增列序量。</li>
<li>  再哈希法：在产生冲突之后，使用关键字的其他部分继续计算地址，如果还是有冲突，则继续使用其他部分再计算地址。这种方式的缺点是时间增加了。</li>
<li>  建立一个公共溢出区：这种方式是建立一个公共溢出区，当地址存在冲突时，把新的地址放在公共溢出区里。</li>
</ul>
</blockquote>
<h3 id="四、不用链表的散列表"><a href="#四、不用链表的散列表" class="headerlink" title="四、不用链表的散列表"></a>四、不用链表的散列表</h3><p>&ensp;&ensp;&ensp;分离链接散列算法的缺点是使用一些链表。由于给新单元分配地址需要时间(特别是在其他语言中),因此这就导致算法的速度有些减慢，同时算法实际上还要求对第二种数据结构实现。另外一种不用链表解决冲突的方法是尝试另外一些单元，直到找出空的单元为止。一般地，单元 h<del>0</del>(x)，h<del>1</del>(x)，h<del>2</del>(x)，…相继被试选,其中 h<del>i</del>(x) = ( hash(x) + f(i)）mod TableSize，且 f(0) = 0。函数f是冲突解决方法。因为所有的数据都要置入表内，所以这种解决方案所要的表要比分离链接散列的表大。一般说来，对于不使用分离链接的散列表来说，其装填子应该低于 λ=0.5。我们把这样的表叫作探测散列表( probing hash table)。</p>
<ol>
<li>线性探测法<br> 在线性探测法中,函数 f 是 i 的线性函数,典型的情形是 f(i) = i。这相当于相继探测逐个单元(必要时可以回绕)以查找出一个空单元。</li>
<li>平方探测法<br> 平方探测是消除线性探测中一次聚集问题的冲突解决方法。平方探测是我们通常预期冲突函数为二次的探测方法。流行的选择是 f(i) = i^2^。</li>
<li>双散列<br> 我们将要考察的最后一个冲突解决方案是双散列( double hashing)。对于双散列,一种流行的选择是 f(i) = i * hash<del>2</del>(x)。这个公式是说，我们将第二个散列函数应用到 x  在距离hash<del>2</del>(x)，2hash<del>2</del>(x),…等处探测。hash<del>2</del>(x)选择得不好将会是灾难性的。</li>
</ol>
<h3 id="五、再散列"><a href="#五、再散列" class="headerlink" title="五、再散列"></a>五、再散列</h3><p>&ensp;&ensp;&ensp;对于使用平方探测的开放定址散列法( open addressing hashing)，如果散列表填得太满，那么操作的运行时间将消耗过长，且插入操作可能失败。这可能发生在有太多的删除和插入的场合。此时，一种解决方法是建立另外一个大约两倍大的表(而且使用一个相关的新散列函数)，扫描整个原始散列表,计算每个(未删除的）元素的新散列值并将其插入到新表中。</p>
<p>&ensp;&ensp;&ensp;再散列可以用平方探测以多种方法实现。一种做法是只要表满到一半就再散列。另一种极端的做法是只有当插入失败时才再散列。第三种方法即所谓的途中策略( middle-of-the-road strategy)：当散列表到达某一特定的装填因子时进行再散列。由于随着装填因子的增长散列表的性能确实在下降，因此，以好的截止手段实现的第三种策略可能是最好的策略。</p>
<p>例：</p>
<ul>
<li><strong>1）</strong>将元素13， 15， 24 和 6 插入到大小为 7 的开放定址散列表中：散列函数是 h（X） = X mod 7；设使用线性探测方法解决冲突问题， 插入结果得到的散列表表示在下图中：<br>  ![]<img src="/2021/05/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%9A%E6%95%A3%E5%88%97%E8%A1%A8/1.png"></li>
<li><strong>2）</strong>如果将 23 插入表中， 那么从<strong>下图</strong>可以看到， 插入后的表将有超过70% 的单元是满的，因为表填得过满， 所以我们建立一个新表；该表的大小为 17， 因为17是原表大小两倍后的第一个素数；新的散列函数为 h(X) = X mod 17；扫描原来的表， 并将元素 6, 15, 23 , 24 以及13 插入到新表中， 如<strong>下图</strong>所示：<br>  ![]<img src="/2021/05/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%9A%E6%95%A3%E5%88%97%E8%A1%A8/2.png"><br>  ![]<img src="/2021/05/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%9A%E6%95%A3%E5%88%97%E8%A1%A8/3.png"></li>
</ul>
<h3 id="六、散列表的适用场景"><a href="#六、散列表的适用场景" class="headerlink" title="六、散列表的适用场景"></a>六、散列表的适用场景</h3><p>   根据散列表的特点可以想到，散列表比较适合无序、需要快速访问的情况。</p>
<p><strong>缓存</strong></p>
<p>   通常我们开发程序时，对一些常用的信息会做缓存，用的就是散列表，比如我们要缓存用户的信息，一般用户的信息都会有唯一标识的字段，比如 ID。这时做缓存，可以把 ID 作为 Key，而 Value 用来存储用户的详细信息，这里的 Value 通常是一个对象（高级语言中的术语，前面提到过），包含用户的一些关键字段，比如名字、年龄等。</p>
<p>   在我们每次需要获取一个用户的信息时，就不用与数据库这类的本地磁盘存储交互了（其实在大多数时候，数据库可能与我们的服务不在一台机器上，还会有相应的网络性能损耗），可以直接从内存中得到结果。这样不仅能够快速获取数据，也能够减轻数据库的压力。</p>
<p>   有时我们要查询一些数据，这些数据与其他数据是有关联的，如果我们进行数据库的关联查询，那么效率会非常低，这时可以分为两部分进行查询：将被关联的部分放入散列表中，只需要遍历一遍；对于另一部分数据，则通过程序手动关联，速度会很快，并且由于我们是通过散列表的 Key、Value 的对应关系对应数据的，所以性能也会比较好。</p>
<p><strong>快速查找</strong></p>
<p>   这里说的查找，不是排序，而是在集合中找出是否存在指定的元素。</p>
<p>   这样的场景很多，比如我们要在指定的用户列表中查找是否存在指定的用户，这时就可以使用散列表了。在这个场景下使用的散列表其实是在上面提到的 Set 类型，实际上不需要 Value 这个值。</p>
<p>   还有一个场景，我们一般对网站的操作会有个IP地址黑名单，我们认为某些 IP 有大量的非法操作，于是封锁了这些 IP 对我们网站的访问。这个 IP 是如何存储的呢？就是用的散列表。当一个访问行为发送过来时，我们会获取其 IP，判断其是否存在于黑名单中，如果存在，则禁止其访问。这种情况也是使用的 Set。</p>
<p>   当然，对于上面说的两个例子，用列表也是可以实现的，但是访问速度会受到很大的影响，尤其是列表越来越长时，查找速度会很慢。散列表则不会。</p>
<p>参考：《数据结构与算法分析 C++描述版》</p>
<p><a href="https://blog.csdn.net/duan19920101/article/details/51579136">(4条消息) 哈希表（散列表）原理详解_那年聪聪-CSDN博客_哈希表</a></p>
<p><a href="http://data.biancheng.net/view/107.html">散列表（哈希表）及其存储结构和特点详解 (biancheng.net)</a></p>
]]></content>
      <categories>
        <category>算法</category>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>数据结构</tag>
        <tag>散列表</tag>
      </tags>
  </entry>
  <entry>
    <title>单调栈总结</title>
    <url>/2021/05/23/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%9A%E5%8D%95%E8%B0%83%E6%A0%88/</url>
    <content><![CDATA[<p>&ensp;&ensp;&ensp;&ensp;<strong>主要解决 Next Great Number 一类算法问题</strong>，会有很多的变形，但其核心便是找到下一个更大的元素从而解题。</p>
<span id="more"></span>

<h3 id="一、单调栈简介"><a href="#一、单调栈简介" class="headerlink" title="一、单调栈简介"></a>一、单调栈简介</h3><h4 id="1-1什么是单调栈？"><a href="#1-1什么是单调栈？" class="headerlink" title="1.1什么是单调栈？"></a>1.1什么是单调栈？</h4><p>    从名字上就听的出来，单调栈中存放的数据应该是有序的，所以单调栈也分为<strong>单调递增栈</strong>和<strong>单调递减栈</strong></p>
<ul>
<li>  单调递增栈：单调递增栈就是从<strong>栈顶到栈底</strong>数据是单调递增</li>
<li>  单调递减栈：单调递减栈就是从<strong>栈顶到栈底</strong>数据是单调递减</li>
</ul>
<h4 id="1-2模拟单调栈的数据push和pop"><a href="#1-2模拟单调栈的数据push和pop" class="headerlink" title="1.2模拟单调栈的数据push和pop"></a>1.2模拟单调栈的数据push和pop</h4><blockquote>
<p>  模拟实现一个递增单调栈：</p>
</blockquote>
<p>    现在有一组数10，3，7，4，12。从左到右依次入栈，则如果<strong>栈为空</strong>或<strong>入栈元素值小于栈顶元素值</strong>，则入栈；否则，如果入栈则会破坏栈的单调性，则需要把比入栈元素小的元素全部出栈。单调递减的栈反之。</p>
<ul>
<li>  10入栈时，栈为空，直接入栈，栈内元素为10。</li>
<li>  3入栈时，栈顶元素10比3大，则入栈，栈内元素为10，3。</li>
<li>  7入栈时，栈顶元素3比7小，则栈顶元素出栈，此时栈顶元素为10，比7大，则7入栈，栈内元素为10，7。</li>
<li>  4入栈时，栈顶元素7比4大，则入栈，栈内元素为10，7，4。</li>
<li>  12入栈时，栈顶元素4比12小，4出栈，此时栈顶元素为7，仍比12小，栈顶元素7继续出栈，此时栈顶元素为10，仍比12小，10出栈，此时栈为空，12入栈，栈内元素为12。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">nextGreaterElement</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">res</span><span class="params">(nums.size())</span></span>; <span class="comment">// 存放答案的数组</span></span><br><span class="line">    stack&lt;<span class="keyword">int</span>&gt; s;</span><br><span class="line">    <span class="comment">// 倒着往栈里放</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = nums.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) </span><br><span class="line">    &#123;       </span><br><span class="line">        <span class="keyword">while</span> (!s.<span class="built_in">empty</span>() &amp;&amp; s.<span class="built_in">top</span>() &lt;= nums[i]) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 需要把比入栈元素小的元素全部出栈</span></span><br><span class="line">            s.<span class="built_in">pop</span>();</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// nums[i] 身后的 next great number，无则 -1</span></span><br><span class="line">        res[i] = s.<span class="built_in">empty</span>() ? <span class="number">-1</span> : s.<span class="built_in">top</span>();</span><br><span class="line">        <span class="comment">// </span></span><br><span class="line">        s.<span class="built_in">push</span>(nums[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="二、相关算法题目"><a href="#二、相关算法题目" class="headerlink" title="二、相关算法题目"></a>二、相关算法题目</h3><h4 id="2-1下一个更大元素-I"><a href="#2-1下一个更大元素-I" class="headerlink" title="2.1下一个更大元素 I"></a><a href="https://leetcode-cn.com/problems/next-greater-element-i/">2.1下一个更大元素 I</a></h4><h5 id="2-1-1题目"><a href="#2-1-1题目" class="headerlink" title="2.1.1题目"></a>2.1.1题目</h5><p>    给你两个 <strong>没有重复元素</strong> 的数组 <code>nums1</code> 和 <code>nums2</code> ，其中<code>nums1</code> 是 <code>nums2</code> 的子集。</p>
<p>    请你找出 <code>nums1</code> 中每个元素在 <code>nums2</code> 中的下一个比其大的值。</p>
<p>    <code>nums1</code> 中数字 <code>x</code> 的下一个更大元素是指 <code>x</code> 在 <code>nums2</code> 中对应位置的右边的第一个比 <code>x</code> 大的元素。如果不存在，对应位置输出 <code>-1</code> 。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: nums1 &#x3D; [4,1,2], nums2 &#x3D; [1,3,4,2].</span><br><span class="line">输出: [-1,3,-1]</span><br><span class="line">解释:</span><br><span class="line">    对于 num1 中的数字 4 ，你无法在第二个数组中找到下一个更大的数字，因此输出 -1 。</span><br><span class="line">    对于 num1 中的数字 1 ，第二个数组中数字1右边的下一个较大数字是 3 。</span><br><span class="line">    对于 num1 中的数字 2 ，第二个数组中没有下一个更大的数字，因此输出 -1 。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: nums1 &#x3D; [2,4], nums2 &#x3D; [1,2,3,4].</span><br><span class="line">输出: [3,-1]</span><br><span class="line">解释:</span><br><span class="line">    对于 num1 中的数字 2 ，第二个数组中的下一个较大数字是 3 。</span><br><span class="line">    对于 num1 中的数字 4 ，第二个数组中没有下一个更大的数字，因此输出 -1 。</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li>  <code>1 &lt;= nums1.length &lt;= nums2.length &lt;= 1000</code></li>
<li>  <code>0 &lt;= nums1[i], nums2[i] &lt;= 104</code></li>
<li>  <code>nums1</code>和<code>nums2</code>中所有整数 <strong>互不相同</strong></li>
<li>  <code>nums1</code> 中的所有整数同样出现在 <code>nums2</code> 中</li>
</ul>
<p><strong>进阶：</strong>你可以设计一个时间复杂度为 <code>O(nums1.length + nums2.length)</code> 的解决方案吗？</p>
<h5 id="2-1-2思路和代码"><a href="#2-1-2思路和代码" class="headerlink" title="2.1.2思路和代码"></a>2.1.2思路和代码</h5><p>    这是找下一个更大元素的变形，只是把两个数组对应联系在了一起，由于数组中的整数互不相同，所以我们用一个哈希表做映射即可。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">nextGreaterElement</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums1, vector&lt;<span class="keyword">int</span>&gt;&amp; nums2)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">ans</span><span class="params">(nums1.size())</span></span>;</span><br><span class="line">        unordered_map&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; ansMap;</span><br><span class="line">        stack&lt;<span class="keyword">int</span>&gt; s;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = nums2.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span>(!s.<span class="built_in">empty</span>() &amp;&amp; s.<span class="built_in">top</span>() &lt;= nums2[i])</span><br><span class="line">            &#123;</span><br><span class="line">                s.<span class="built_in">pop</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> temp = s.<span class="built_in">empty</span>() ? <span class="number">-1</span> : s.<span class="built_in">top</span>();</span><br><span class="line">            ansMap[nums2[i]] = temp;</span><br><span class="line">            s.<span class="built_in">push</span>(nums2[i]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums1.<span class="built_in">size</span>(); ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            ans[i] = ansMap[nums1[i]];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h4 id="2-2下一个更大元素-II"><a href="#2-2下一个更大元素-II" class="headerlink" title="2.2下一个更大元素 II"></a><a href="https://leetcode-cn.com/problems/next-greater-element-ii/">2.2下一个更大元素 II</a></h4><h5 id="2-2-1题目"><a href="#2-2-1题目" class="headerlink" title="2.2.1题目"></a>2.2.1题目</h5><p>    给定一个循环数组（最后一个元素的下一个元素是数组的第一个元素），输出每个元素的下一个更大元素。数字 x 的下一个更大的元素是按数组遍历顺序，这个数字之后的第一个比它更大的数，这意味着你应该循环地搜索它的下一个更大的数。如果不存在，则输出 -1。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [1,2,1]</span><br><span class="line">输出: [2,-1,2]</span><br><span class="line">解释: 第一个 1 的下一个更大的数是 2；</span><br><span class="line">数字 2 找不到下一个更大的数； </span><br><span class="line">第二个 1 的下一个最大的数需要循环搜索，结果也是 2。</span><br></pre></td></tr></table></figure>

<p><strong>注意:</strong> 输入数组的长度不会超过 10000。</p>
<h5 id="2-2-2思路和代码"><a href="#2-2-2思路和代码" class="headerlink" title="2.2.2思路和代码"></a>2.2.2思路和代码</h5><p>    可以把这个数组连接一个相同的数组，然后套用算法模板。当然，我们可以不用构造新数组，而是利用循环数组的技巧来模拟数组长度翻倍的效果。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">nextGreaterElements</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">ans</span><span class="params">(nums.size())</span></span>;</span><br><span class="line">        stack&lt;<span class="keyword">int</span>&gt; s;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span> * nums.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span>(!s.<span class="built_in">empty</span>() &amp;&amp; s.<span class="built_in">top</span>() &lt;= nums[i % nums.<span class="built_in">size</span>()])</span><br><span class="line">            &#123;</span><br><span class="line">                s.<span class="built_in">pop</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            ans[i % nums.<span class="built_in">size</span>()] = s.<span class="built_in">empty</span>() ? <span class="number">-1</span> : s.<span class="built_in">top</span>();</span><br><span class="line">            s.<span class="built_in">push</span>(nums[i % nums.<span class="built_in">size</span>()]);</span><br><span class="line">        &#125;</span><br><span class="line">        ans.<span class="built_in">resize</span>(nums.<span class="built_in">size</span>());</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="2-3一月有多少天"><a href="#2-3一月有多少天" class="headerlink" title="2.3一月有多少天"></a>2.3一月有多少天</h4><h5 id="2-3-1题目"><a href="#2-3-1题目" class="headerlink" title="2.3.1题目"></a>2.3.1题目</h5><p>    给你一个数组<code>T</code>，这个数组存放的是近几天的天气气温，你返回一个等长的数组，计算：<strong>对于每一天，你还要至少等多少天才能等到一个更暖和的气温；如果等不到那一天，填 0</strong>。</p>
<p>    函数签名如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vector&lt;int&gt; dailyTemperatures(vector&lt;int&gt;&amp; T);</span><br></pre></td></tr></table></figure>

<p>    比如说给你输入<code>T = [73,74,75,71,69,76]</code>，你返回<code>[1,1,3,2,1,0]</code>。</p>
<p>    解释：第一天 73 华氏度，第二天 74 华氏度，比 73 大，所以对于第一天，只要等一天就能等到一个更暖和的气温，后面的同理。</p>
<p>    这个问题本质上也是找 Next Greater Number，只不过现在不是问你 Next Greater Number 是多少，而是问你当前距离 Next Greater Number 的距离而已。</p>
<h5 id="2-3-2思路和代码"><a href="#2-3-2思路和代码" class="headerlink" title="2.3.2思路和代码"></a>2.3.2思路和代码</h5><p>    相同的思路，直接调用单调栈的算法模板，稍作改动就可以，直接上代码吧：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">dailyTemperatures</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; T)</span> </span>&#123;</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">res</span><span class="params">(T.size())</span></span>;</span><br><span class="line">    <span class="comment">// 这里放元素索引，而不是元素</span></span><br><span class="line">    stack&lt;<span class="keyword">int</span>&gt; s; </span><br><span class="line">    <span class="comment">/* 单调栈模板 */</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = T.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">while</span> (!s.<span class="built_in">empty</span>() &amp;&amp; T[s.<span class="built_in">top</span>()] &lt;= T[i]) &#123;</span><br><span class="line">            s.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 得到索引间距</span></span><br><span class="line">        res[i] = s.<span class="built_in">empty</span>() ? <span class="number">0</span> : (s.<span class="built_in">top</span>() - i); </span><br><span class="line">        <span class="comment">// 将索引入栈，而不是元素</span></span><br><span class="line">        s.<span class="built_in">push</span>(i); </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-4柱状图中最大的矩形"><a href="#2-4柱状图中最大的矩形" class="headerlink" title="2.4柱状图中最大的矩形"></a><a href="https://leetcode-cn.com/problems/largest-rectangle-in-histogram/">2.4柱状图中最大的矩形</a></h4><h5 id="2-4-1题目"><a href="#2-4-1题目" class="headerlink" title="2.4.1题目"></a>2.4.1题目</h5><p>&ensp;&ensp;&ensp;&ensp;给定 <em>n</em> 个非负整数，用来表示柱状图中各个柱子的高度。每个柱子彼此相邻，且宽度为 1 。</p>
<p>&ensp;&ensp;&ensp;&ensp;求在该柱状图中，能够勾勒出来的矩形的最大面积。 </p>
<img src="/2021/05/23/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%9A%E5%8D%95%E8%B0%83%E6%A0%88/1.png">

<p>&ensp;&ensp;&ensp;&ensp;以上是柱状图的示例，其中每个柱子的宽度为 1，给定的高度为 <code>[2,1,5,6,2,3]</code>。 </p>
<img src="/2021/05/23/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%9A%E5%8D%95%E8%B0%83%E6%A0%88/2.png">

<p>&ensp;&ensp;&ensp;&ensp;图中阴影部分为所能勾勒出的最大矩形面积，其面积为 <code>10</code> 个单位。 </p>
<p><strong>示例:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [2,1,5,6,2,3]</span><br><span class="line">输出: 10</span><br></pre></td></tr></table></figure>

<h5 id="2-4-2思路和代码"><a href="#2-4-2思路和代码" class="headerlink" title="2.4.2思路和代码"></a>2.4.2思路和代码</h5><p>&ensp;&ensp;&ensp;&ensp;一道难度比较大的题目，看了官方的题解才知道有单调栈这个解法。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">largestRectangleArea</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; heights)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = heights.<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;int&gt; left(n), right(n, n);</span><br><span class="line">        </span><br><span class="line">        stack&lt;<span class="keyword">int</span>&gt; mono_stack;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">while</span> (!mono_stack.<span class="built_in">empty</span>() &amp;&amp; heights[mono_stack.<span class="built_in">top</span>()] &gt;= heights[i]) &#123;</span><br><span class="line">                right[mono_stack.<span class="built_in">top</span>()] = i;</span><br><span class="line">                mono_stack.<span class="built_in">pop</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            left[i] = (mono_stack.<span class="built_in">empty</span>() ? <span class="number">-1</span> : mono_stack.<span class="built_in">top</span>());</span><br><span class="line">            mono_stack.<span class="built_in">push</span>(i);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            ans = <span class="built_in">max</span>(ans, (right[i] - left[i] - <span class="number">1</span>) * heights[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><a href="https://leetcode-cn.com/problems/largest-rectangle-in-histogram/solution/zhu-zhuang-tu-zhong-zui-da-de-ju-xing-by-leetcode-/">柱状图中最大的矩形</a></p>
<p><a href="https://mp.weixin.qq.com/s?__biz=MzAxODQxMDM0Mw==&mid=2247487704&idx=1&sn=eb9ac24c644aa0950638c9b20384e982&chksm=9bd7eed0aca067c6b4424c40b7f234c815f83edfbb5efc9f51581335f110e9577114a528f3ec&scene=21#wechat_redirect">单调栈模板</a></p>
]]></content>
      <categories>
        <category>算法</category>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>数据结构</tag>
        <tag>单调栈</tag>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>回文子串</title>
    <url>/2021/05/29/%E7%AE%97%E6%B3%95%E4%B8%8E%E5%AD%97%E7%AC%A6%E4%B8%B2%EF%BC%9A%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2/</url>
    <content><![CDATA[<h3 id="一、题目"><a href="#一、题目" class="headerlink" title="一、题目"></a>一、题目</h3><p>    给定一个字符串，你的任务是计算这个字符串中有多少个回文子串。</p>
<p>    具有不同开始位置或结束位置的子串，即使是由相同的字符组成，也会被视作不同的子串。</p>
<span id="more"></span>

<p> <strong>示例 1：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：&quot;abc&quot;</span><br><span class="line">输出：3</span><br><span class="line">解释：三个回文子串: &quot;a&quot;, &quot;b&quot;, &quot;c&quot;</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：&quot;aaa&quot;</span><br><span class="line">输出：6</span><br><span class="line">解释：6个回文子串: &quot;a&quot;, &quot;a&quot;, &quot;a&quot;, &quot;aa&quot;, &quot;aa&quot;, &quot;aaa&quot;</span><br></pre></td></tr></table></figure>

<p> <strong>提示：</strong></p>
<ul>
<li>  输入的字符串长度不会超过 1000 。</li>
</ul>
<h3 id="二、思路与代码"><a href="#二、思路与代码" class="headerlink" title="二、思路与代码"></a>二、思路与代码</h3><p>    首先我最先想到思路是<strong>递归</strong>，先计算开始位置的字符和它后面的字符能否构成回文子串及构成的个数，然后开始的位置递归后移，移动到末尾结束。</p>
<p>    时间复杂度比较大<code>O(n*n*n)</code>。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution </span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    int ans &#x3D; 0;</span><br><span class="line">    int countSubstrings(string s) </span><br><span class="line">    &#123; </span><br><span class="line">        if (s.empty())</span><br><span class="line">            return 0;</span><br><span class="line">        help(s, 0);  </span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line">    void help(string&amp; s, int start)</span><br><span class="line">    &#123;</span><br><span class="line">        if (start &gt;&#x3D; s.size())</span><br><span class="line">        &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        int begin &#x3D; start;</span><br><span class="line">        for (int last &#x3D; begin; last &lt; s.size(); ++last)</span><br><span class="line">        &#123;</span><br><span class="line">            int i &#x3D; last;</span><br><span class="line">            while (begin &lt;&#x3D; i &amp;&amp; s[begin] &#x3D;&#x3D; s[i])</span><br><span class="line">            &#123;</span><br><span class="line">                if (begin &#x3D;&#x3D; i || begin + 1 &#x3D;&#x3D; i)</span><br><span class="line">                &#123;</span><br><span class="line">                    ++ans;</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">                --i;</span><br><span class="line">                ++begin;</span><br><span class="line">            &#125;</span><br><span class="line">            begin &#x3D; start;</span><br><span class="line">        &#125;</span><br><span class="line">        help(s, start + 1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>然后便是<strong>中心扩展法</strong>：</p>
<p>    这是一个比较巧妙的方法，实质的思路和动态规划的思路类似。</p>
<p>    比如对一个字符串 ababa，选择最中间的 a 作为中心点，往两边扩散，第一次扩散发现 left 指向的是 b，right 指向的也是 b，所以是回文串，继续扩散，同理 ababa 也是回文串。</p>
<p>    这个是确定了一个中心点后的寻找的路径，然后我们只要寻找到所有的中心点，问题就解决了。</p>
<p>    中心点一共有多少个呢？看起来像是和字符串长度相等，但你会发现，如果是这样，上面的例子永远也搜不到 abab，想象一下单个字符的哪个中心点扩展可以得到这个子串？似乎不可能。所以中心点不能只有单个字符构成，还要包括两个字符，比如上面这个子串 abab，就可以有中心点 ba 扩展一次得到，所以最终的中心点由 2 * len - 1 个，分别是 len 个单字符和 len - 1 个双字符。</p>
<p>    如果上面看不太懂的话，还可以看看下面几个问题：</p>
<ol>
<li><p>为什么有 2 * len - 1 个中心点？</p>
<ul>
<li><p>  aba 有5个中心点，分别是 a、b、c、ab、ba</p>
</li>
<li><p>  abba 有7个中心点，分别是 a、b、b、a、ab、bb、ba</p>
</li>
</ul>
</li>
<li><p>什么是中心点？</p>
<ul>
<li>  中心点即 left 指针和 right 指针初始化指向的地方，可能是一个也可能是两个</li>
</ul>
</li>
<li><p>为什么不可能是三个或者更多？</p>
<ul>
<li>  因为 3 个可以由 1 个扩展一次得到，4 个可以由两个扩展一次得到</li>
</ul>
</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">countSubstrings</span><span class="params">(string s)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = s.<span class="built_in">size</span>(), ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span> * n - <span class="number">1</span>; ++i) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> l = i / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">int</span> r = i / <span class="number">2</span> + i % <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">while</span> (l &gt;= <span class="number">0</span> &amp;&amp; r &lt; n &amp;&amp; s[l] == s[r]) </span><br><span class="line">            &#123;</span><br><span class="line">                --l;</span><br><span class="line">                ++r;</span><br><span class="line">                ++ans;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>还可以使用<strong>动态规划</strong>来进行解决：</p>
<ul>
<li>  状态：dp[i][j] 表示字符串s在[i,j]区间的子串是否是一个回文串。</li>
<li>  状态转移方程：当 s[i] == s[j] &amp;&amp; (j - i &lt; 2 || dp[i + 1][j - 1]) 时，dp[i][j]=true，否则为false</li>
</ul>
<p>这个状态转移方程是什么意思呢？</p>
<ul>
<li>  当只有一个字符时，比如 a 自然是一个回文串。</li>
<li>  当有两个字符时，如果是相等的，比如 aa，也是一个回文串。</li>
<li>  当有三个及以上字符时，比如 ababa 这个字符记作串 1，把两边的 a 去掉，也就是 bab 记作串 2，可以看出只要串2是一个回文串，那么左右各多了一个 a 的串 1 必定也是回文串。所以当 s[i]==s[j] 时，自然要看 dp[i+1][j-1] 是不是一个回文串。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">countSubstrings</span><span class="params">(string s)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> strLength = s.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        vector&lt;vector&lt;<span class="keyword">bool</span>&gt;&gt; <span class="built_in">dp</span>(strLength, vector&lt;<span class="keyword">bool</span>&gt;(strLength));</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; s.<span class="built_in">length</span>(); j++) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= j; i++) </span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (s[i] == s[j] &amp;&amp; (j - i &lt; <span class="number">2</span> || dp[i + <span class="number">1</span>][j - <span class="number">1</span>])) </span><br><span class="line">                &#123;</span><br><span class="line">                    dp[i][j] = <span class="literal">true</span>;</span><br><span class="line">                    ans++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<p><a href="https://leetcode-cn.com/problems/palindromic-substrings/solution/liang-dao-hui-wen-zi-chuan-de-jie-fa-xiang-jie-zho/">两道回文子串的解法（详解中心扩展法） - 回文子串 - 力扣（LeetCode） (leetcode-cn.com)</a></p>
]]></content>
      <categories>
        <category>算法</category>
        <category>字符串</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>leetcode</tag>
        <tag>动态规划</tag>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title>外观数列</title>
    <url>/2021/05/29/%E7%AE%97%E6%B3%95%E4%B8%8E%E5%AD%97%E7%AC%A6%E4%B8%B2%EF%BC%9A%E5%A4%96%E8%A7%82%E6%95%B0%E5%88%97/</url>
    <content><![CDATA[<h3 id="一、题目"><a href="#一、题目" class="headerlink" title="一、题目"></a>一、题目</h3><p>&ensp;&ensp;&ensp;&ensp;给定一个正整数 <code>n</code> ，输出外观数列的第 <code>n</code> 项。</p>
<p>&ensp;&ensp;&ensp;&ensp;「外观数列」是一个整数序列，从数字 1 开始，序列中的每一项都是对前一项的描述。</p>
<span id="more"></span>

<p>&ensp;&ensp;&ensp;&ensp;你可以将其视作是由递归公式定义的数字字符串序列：</p>
<ul>
<li>  <code>countAndSay(1) = &quot;1&quot;</code></li>
<li>  <code>countAndSay(n)</code> 是对 <code>countAndSay(n-1)</code> 的描述，然后转换成另一个数字字符串。</li>
</ul>
<p>&ensp;&ensp;&ensp;&ensp;前五项如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.     1</span><br><span class="line">2.     11</span><br><span class="line">3.     21</span><br><span class="line">4.     1211</span><br><span class="line">5.     111221</span><br><span class="line">第一项是数字 1 </span><br><span class="line">描述前一项，这个数是 1 即 “ 一 个 1 ”，记作 &quot;11&quot;</span><br><span class="line">描述前一项，这个数是 11 即 “ 二 个 1 ” ，记作 &quot;21&quot;</span><br><span class="line">描述前一项，这个数是 21 即 “ 一 个 2 + 一 个 1 ” ，记作 &quot;1211&quot;</span><br><span class="line">描述前一项，这个数是 1211 即 “ 一 个 1 + 一 个 2 + 二 个 1 ” ，记作 &quot;111221&quot;</span><br></pre></td></tr></table></figure>

<p>&ensp;&ensp;&ensp;&ensp;要 <strong>描述</strong> 一个数字字符串，首先要将字符串分割为 <strong>最小</strong> 数量的组，每个组都由连续的最多 <strong>相同字符</strong> 组成。然后对于每个组，先描述字符的数量，然后描述字符，形成一个描述组。要将描述转换为数字字符串，先将每组中的字符数量用数字替换，再将所有描述组连接起来。 </p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>示例 1：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：n &#x3D; 1</span><br><span class="line">输出：&quot;1&quot;</span><br><span class="line">解释：这是一个基本样例。</span><br></pre></td></tr></table></figure>

<p>&ensp;&ensp;&ensp;&ensp;<strong>示例 2：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：n &#x3D; 4</span><br><span class="line">输出：&quot;1211&quot;</span><br><span class="line">解释：</span><br><span class="line">countAndSay(1) &#x3D; &quot;1&quot;</span><br><span class="line">countAndSay(2) &#x3D; 读 &quot;1&quot; &#x3D; 一 个 1 &#x3D; &quot;11&quot;</span><br><span class="line">countAndSay(3) &#x3D; 读 &quot;11&quot; &#x3D; 二 个 1 &#x3D; &quot;21&quot;</span><br><span class="line">countAndSay(4) &#x3D; 读 &quot;21&quot; &#x3D; 一 个 2 + 一 个 1 &#x3D; &quot;12&quot; + &quot;11&quot; &#x3D; &quot;1211&quot;</span><br></pre></td></tr></table></figure>

<h3 id="二、思路与代码"><a href="#二、思路与代码" class="headerlink" title="二、思路与代码"></a>二、思路与代码</h3><p>&ensp;&ensp;&ensp;&ensp;第<code>n</code>个字符串实际上就是对第<code>n + 1</code>个字符串的描述，所以很容易想到使用递归。当<code>n==1</code>时，字符串为“1”，一步步求出第<code>n</code>个字符串即可。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">countAndSay</span><span class="params">(<span class="keyword">int</span> n)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">1</span>) <span class="keyword">return</span> <span class="string">&quot;1&quot;</span>;</span><br><span class="line">        string pre = <span class="built_in">countAndSay</span>(n<span class="number">-1</span>);</span><br><span class="line">        string ans;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; pre.<span class="built_in">size</span>(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (pre[i] == pre[i + <span class="number">1</span>])</span><br><span class="line">            &#123;</span><br><span class="line">                count++;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            ans += (count + <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">            ans += pre[i];</span><br><span class="line">            count = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法</category>
        <category>字符串</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>leetcode</tag>
        <tag>字符串</tag>
        <tag>递归</tag>
      </tags>
  </entry>
  <entry>
    <title>字符串相乘</title>
    <url>/2021/05/29/%E7%AE%97%E6%B3%95%E4%B8%8E%E5%AD%97%E7%AC%A6%E4%B8%B2%EF%BC%9A%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9B%B8%E4%B9%98/</url>
    <content><![CDATA[<h3 id="一、题目"><a href="#一、题目" class="headerlink" title="一、题目"></a>一、题目</h3><p>&ensp;&ensp;&ensp;&ensp;给定两个以字符串形式表示的非负整数 <code>num1</code> 和 <code>num2</code>，返回 <code>num1</code> 和 <code>num2</code> 的乘积，它们的乘积也表示为字符串形式。</p>
<span id="more"></span>

<p><strong>示例 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: num1 &#x3D; &quot;2&quot;, num2 &#x3D; &quot;3&quot;</span><br><span class="line">输出: &quot;6&quot;</span><br></pre></td></tr></table></figure>

<p><strong>示例 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: num1 &#x3D; &quot;123&quot;, num2 &#x3D; &quot;456&quot;</span><br><span class="line">输出: &quot;56088&quot;</span><br></pre></td></tr></table></figure>

<p><strong>说明：</strong></p>
<ol>
<li> <code>num1</code> 和 <code>num2</code> 的长度小于110。</li>
<li> <code>num1</code> 和 <code>num2</code> 只包含数字 <code>0-9</code>。</li>
<li> <code>num1</code> 和 <code>num2</code> 均不以零开头，除非是数字 0 本身。</li>
<li> <strong>不能使用任何标准库的大数类型（比如 BigInteger）</strong>或<strong>直接将输入转换为整数来处理</strong>。</li>
</ol>
<h3 id="二、思路与代码"><a href="#二、思路与代码" class="headerlink" title="二、思路与代码"></a>二、思路与代码</h3><p>&ensp;&ensp;&ensp;&ensp;简单的双重循环，遍历 <code>num2</code> 每一位与 <code>num1</code> 进行相乘，将每一步的结果进行累加。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">multiply</span><span class="params">(string num1, string num2)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> num1Length = num1.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> num2Length = num2.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">string <span class="title">ans</span><span class="params">(num1Length + num2Length, <span class="string">&#x27;0&#x27;</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = num1Length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = num2Length - <span class="number">1</span>; j &gt;= <span class="number">0</span>; --j)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> temp = (ans[i + j + <span class="number">1</span>] - <span class="string">&#x27;0&#x27;</span>) + (num1[i] - <span class="string">&#x27;0&#x27;</span>) * (num2[j] - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">                ans[i + j + <span class="number">1</span>] = temp % <span class="number">10</span> + <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">                ans[i + j] += temp /<span class="number">10</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; num1Length + num2Length; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (ans[i] != <span class="string">&#x27;0&#x27;</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> ans.<span class="built_in">substr</span>(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;0&quot;</span>;</span><br><span class="line">    &#125;    </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法</category>
        <category>字符串</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>leetcode</tag>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title>验证回文串</title>
    <url>/2021/05/29/%E7%AE%97%E6%B3%95%E4%B8%8E%E5%AD%97%E7%AC%A6%E4%B8%B2%EF%BC%9A%E9%AA%8C%E8%AF%81%E5%9B%9E%E6%96%87%E4%B8%B2/</url>
    <content><![CDATA[<h3 id="一、题目"><a href="#一、题目" class="headerlink" title="一、题目"></a>一、题目</h3><p>&ensp;&ensp;&ensp;&ensp;给定一个字符串，验证它是否是回文串，只考虑字母和数字字符，可以忽略字母的大小写。</p>
<span id="more"></span>

<p>&ensp;&ensp;&ensp;&ensp;<strong>说明：</strong>本题中，我们将空字符串定义为有效的回文串。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: &quot;A man, a plan, a canal: Panama&quot;</span><br><span class="line">输出: true</span><br></pre></td></tr></table></figure>

<p><strong>示例 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: &quot;race a car&quot;</span><br><span class="line">输出: false</span><br></pre></td></tr></table></figure>

<h3 id="二、思路与代码"><a href="#二、思路与代码" class="headerlink" title="二、思路与代码"></a>二、思路与代码</h3><p>&ensp;&ensp;&ensp;&ensp;很简单，双指针相向遍历即可，难点在条件的判断。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isPalindrome</span><span class="params">(string s)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> start = <span class="number">0</span>, end = s.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> startValue = <span class="number">0</span>, endValue = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (start &lt;= end)</span><br><span class="line">        &#123;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (s[start] &gt;= <span class="string">&#x27;A&#x27;</span> &amp;&amp; s[start] &lt;= <span class="string">&#x27;Z&#x27;</span> || </span><br><span class="line">                s[start] &gt;= <span class="string">&#x27;a&#x27;</span> &amp;&amp; s[start] &lt;= <span class="string">&#x27;z&#x27;</span> ||</span><br><span class="line">                s[start] &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; s[start] &lt;= <span class="string">&#x27;9&#x27;</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                startValue = s[start] &gt;= <span class="string">&#x27;a&#x27;</span> ? s[start] - <span class="string">&#x27;a&#x27;</span> : s[start] - <span class="string">&#x27;A&#x27;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                ++start;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (s[end] &gt;= <span class="string">&#x27;A&#x27;</span> &amp;&amp; s[end] &lt;= <span class="string">&#x27;Z&#x27;</span> || </span><br><span class="line">                s[end] &gt;= <span class="string">&#x27;a&#x27;</span> &amp;&amp; s[end] &lt;= <span class="string">&#x27;z&#x27;</span> ||</span><br><span class="line">                s[end] &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; s[end] &lt;= <span class="string">&#x27;9&#x27;</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                endValue = s[end] &gt;= <span class="string">&#x27;a&#x27;</span> ? s[end] - <span class="string">&#x27;a&#x27;</span> : s[end] - <span class="string">&#x27;A&#x27;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                --end;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (startValue != endValue)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            ++start;</span><br><span class="line">            --end;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法</category>
        <category>字符串</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>leetcode</tag>
        <tag>字符串</tag>
        <tag>双指针</tag>
      </tags>
  </entry>
  <entry>
    <title>数组中的第K个最大元素</title>
    <url>/2021/05/29/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E7%BB%84%EF%BC%9A%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E7%AC%ACK%E4%B8%AA%E6%9C%80%E5%A4%A7%E5%85%83%E7%B4%A0/</url>
    <content><![CDATA[<h3 id="一、题目"><a href="#一、题目" class="headerlink" title="一、题目"></a>一、题目</h3><p>&ensp;&ensp;&ensp;&ensp;在未排序的数组中找到第 <strong>k</strong> 个最大的元素。请注意，你需要找的是数组排序后的第 k 个最大的元素，而不是第 k 个不同的元素。</p>
<span id="more"></span>

<p><strong>示例 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [3,2,1,5,6,4] 和 k &#x3D; 2</span><br><span class="line">输出: 5</span><br></pre></td></tr></table></figure>

<p><strong>示例 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [3,2,3,1,2,4,5,5,6] 和 k &#x3D; 4</span><br><span class="line">输出: 4</span><br></pre></td></tr></table></figure>

<p><strong>说明:</strong></p>
<p>&ensp;&ensp;&ensp;&ensp;你可以假设 k 总是有效的，且 1 ≤ k ≤ 数组的长度。</p>
<h3 id="二、思路与代码"><a href="#二、思路与代码" class="headerlink" title="二、思路与代码"></a>二、思路与代码</h3><h4 id="1-基于快速排序的解题思路"><a href="#1-基于快速排序的解题思路" class="headerlink" title="1.基于快速排序的解题思路"></a>1.基于快速排序的解题思路</h4><p>&ensp;&ensp;&ensp;&ensp;最容易想到的思路是排序，排完后，倒数第 k 个即为所求值。如果调用库函数，虽然很简单，但明显不是题目或者面试官想要的。最起码，得手撸一个快速排序：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findKthLargest</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">myQuicksort</span>(nums, <span class="number">0</span>, nums.<span class="built_in">size</span>() - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">myQuicksort</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (low &gt;= high)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 随机值，防止用例中出现一些“恶心的”测试用例</span></span><br><span class="line">        <span class="keyword">int</span> pivot = <span class="built_in">rand</span>() % (high - low + <span class="number">1</span>) + low;</span><br><span class="line">        <span class="built_in">swap</span>(nums[low], nums[pivot]);</span><br><span class="line">        pivot = low;</span><br><span class="line">        <span class="keyword">int</span> i = low + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> j = low + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (j &lt;= high)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[j] &lt; nums[pivot])</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">swap</span>(nums[i], nums[j]);</span><br><span class="line">                ++i;</span><br><span class="line">            &#125;</span><br><span class="line">            ++j;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">swap</span>(nums[pivot], nums[i - <span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">if</span> (i == numsk)</span><br><span class="line">        <span class="built_in">myQuicksort</span>(nums, low, i - <span class="number">2</span>);</span><br><span class="line">        <span class="built_in">myQuicksort</span>(nums, i, high);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>&ensp;&ensp;&ensp;&ensp;由此可以发现每次经过「划分」操作后，我们一定可以确定一个元素的最终位置，即 x 的最终位置为 q，并且保证 a[l⋯q−1] 中的每个元素小于等于 a[q]，且 a[q] 小于等于 a[q+1⋯r] 中的每个元素。所以只要某次划分的 q 为倒数第 k 个下标的时候，我们就已经找到了答案。 我们只关心这一点，至于 a[l⋯q−1] 和 a[q+1⋯r] 是否是有序的，我们不关心。故改进算法：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findKthLargest</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;        </span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">myQuicksort</span>(nums, <span class="number">0</span>, nums.<span class="built_in">size</span>() - <span class="number">1</span>, k);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">myQuicksort</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> low, <span class="keyword">int</span> high, <span class="keyword">int</span> k)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> pivot = <span class="built_in">rand</span>() % (high - low + <span class="number">1</span>) + low;</span><br><span class="line">        <span class="built_in">swap</span>(nums[low], nums[pivot]);</span><br><span class="line">        pivot = low;</span><br><span class="line">        <span class="keyword">int</span> i = low + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> j = low + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (j &lt;= high)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[j] &lt; nums[pivot])</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">swap</span>(nums[i], nums[j]);</span><br><span class="line">                ++i;</span><br><span class="line">            &#125;</span><br><span class="line">            ++j;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 判断当前元素的位置与第k大的元素位置的前后次序</span></span><br><span class="line">        <span class="keyword">int</span> flag = i - <span class="number">1</span> -(nums.<span class="built_in">size</span>() - k); </span><br><span class="line">        <span class="built_in">swap</span>(nums[pivot], nums[i - <span class="number">1</span>]);</span><br><span class="line">        <span class="comment">// 正好在目标位置</span></span><br><span class="line">        <span class="keyword">if</span> (flag == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> nums[i - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 当前位置偏右，向左查</span></span><br><span class="line">        <span class="keyword">if</span> (flag &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">myQuicksort</span>(nums, low, i - <span class="number">2</span>, k);</span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="comment">//向右查</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">myQuicksort</span>(nums, i, high, k);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="2-基于堆排序的解题思路"><a href="#2-基于堆排序的解题思路" class="headerlink" title="2.基于堆排序的解题思路"></a>2.基于堆排序的解题思路</h4><p>&ensp;&ensp;&ensp;&ensp;首先采用堆排序的数据结构：优先队列。优先队列容器与队列一样，只能从队尾插入元素，从队首删除元素。但是它有一个特性，就是队列中最大的元素总是位于队首（默认），所以出队时，并非按照先进先出的原则进行，而是将当前队列中最大的元素出队。</p>
<p>&ensp;&ensp;&ensp;&ensp;所以见所有元素加入一个优先队列，然后删除相应数目的“最大值”，即得到目标元素。（可以判断k的大小来决定使用最大堆或最小堆）</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findKthLargest</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        priority_queue&lt;<span class="keyword">int</span>&gt; p1;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            p1.<span class="built_in">push</span>(nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; k; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            p1.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> p1.<span class="built_in">top</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>&ensp;&ensp;&ensp;&ensp;与其看对优先队列特性的掌握，面试官更想看你对堆排序的掌握，所以下面看堆排序代码（力扣官方）：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    void maxHeapify(vector&lt;int&gt;&amp; a, int i, int heapSize) &#123;</span><br><span class="line">        int l &#x3D; i * 2 + 1, r &#x3D; i * 2 + 2, largest &#x3D; i;</span><br><span class="line">        if (l &lt; heapSize &amp;&amp; a[l] &gt; a[largest]) &#123;</span><br><span class="line">            largest &#x3D; l;</span><br><span class="line">        &#125; </span><br><span class="line">        if (r &lt; heapSize &amp;&amp; a[r] &gt; a[largest]) &#123;</span><br><span class="line">            largest &#x3D; r;</span><br><span class="line">        &#125;</span><br><span class="line">        if (largest !&#x3D; i) &#123;</span><br><span class="line">            swap(a[i], a[largest]);</span><br><span class="line">            maxHeapify(a, largest, heapSize);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    void buildMaxHeap(vector&lt;int&gt;&amp; a, int heapSize) &#123;</span><br><span class="line">        for (int i &#x3D; heapSize &#x2F; 2; i &gt;&#x3D; 0; --i) &#123;</span><br><span class="line">            maxHeapify(a, i, heapSize);</span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int findKthLargest(vector&lt;int&gt;&amp; nums, int k) &#123;</span><br><span class="line">        int heapSize &#x3D; nums.size();</span><br><span class="line">        buildMaxHeap(nums, heapSize);</span><br><span class="line">        for (int i &#x3D; nums.size() - 1; i &gt;&#x3D; nums.size() - k + 1; --i) &#123;</span><br><span class="line">            swap(nums[0], nums[i]);</span><br><span class="line">            --heapSize;</span><br><span class="line">            maxHeapify(nums, 0, heapSize);</span><br><span class="line">        &#125;</span><br><span class="line">        return nums[0];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法</category>
        <category>数组</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>leetcode</tag>
        <tag>数组</tag>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title>旋转图像</title>
    <url>/2021/04/23/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E5%AD%A6%EF%BC%9A%E6%97%8B%E8%BD%AC%E5%9B%BE%E5%83%8F/</url>
    <content><![CDATA[<h3 id="一、题目"><a href="#一、题目" class="headerlink" title="一、题目"></a>一、题目</h3><p>&ensp;&ensp;&ensp;&ensp;给定一个 <em>n</em> × <em>n</em> 的二维矩阵 <code>matrix</code> 表示一个图像。请你将图像顺时针旋转 90 度。</p>
<p>&ensp;&ensp;&ensp;&ensp;你必须在**<a href="https://baike.baidu.com/item/%E5%8E%9F%E5%9C%B0%E7%AE%97%E6%B3%95"> 原地</a>** 旋转图像，这意味着你需要直接修改输入的二维矩阵。<strong>请不要</strong> 使用另一个矩阵来旋转图像。 </p>
<span id="more"></span>

<p><strong>示例 1：</strong><br>$$<br>\begin{bmatrix}<br>   1 &amp; 2 &amp; 3 \<br>   4 &amp; 5 &amp; 6 \<br>   7 &amp; 8 &amp; 9<br> \end{bmatrix} \tag{1}<br>$$<br>​                                                                                                $\Downarrow$</p>
<p>$$<br>\begin{bmatrix}<br>   7 &amp; 4 &amp; 1 \<br>   8 &amp; 5 &amp; 2 \<br>   9 &amp; 6 &amp; 3<br> \end{bmatrix} \tag{2}<br>$$</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：matrix &#x3D; [[1,2,3],[4,5,6],[7,8,9]]</span><br><span class="line">输出：[[7,4,1],[8,5,2],[9,6,3]]</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong><br>$$<br>\begin{bmatrix}<br>   5 &amp; 1 &amp; 9 &amp; 11 \<br>   2 &amp; 4 &amp; 8 &amp; 10 \<br>   13 &amp; 3 &amp; 6 &amp; 7 \<br>   15 &amp; 14 &amp; 12 &amp; 16<br> \end{bmatrix} \tag{3}<br>$$<br>​                                                                                                $\Downarrow$</p>
<p>$$<br>\begin{bmatrix}<br>   15 &amp; 13 &amp; 2 &amp; 5 \<br>   14 &amp; 3 &amp; 4 &amp; 1 \<br>   12 &amp; 6 &amp; 8 &amp; 9 \<br>   16 &amp; 7 &amp; 10 &amp; 11<br> \end{bmatrix} \tag{4}<br>$$</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：matrix &#x3D; [[5,1,9,11],[2,4,8,10],[13,3,6,7],[15,14,12,16]]</span><br><span class="line">输出：[[15,13,2,5],[14,3,4,1],[12,6,8,9],[16,7,10,11]]</span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：matrix &#x3D; [[1]]</span><br><span class="line">输出：[[1]]</span><br></pre></td></tr></table></figure>

<p><strong>示例 4：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：matrix &#x3D; [[1,2],[3,4]]</span><br><span class="line">输出：[[3,1],[4,2]]</span><br></pre></td></tr></table></figure>

<p> <strong>提示：</strong></p>
<ul>
<li>  <code>matrix.length == n</code></li>
<li>  <code>matrix[i].length == n</code></li>
<li>  <code>1 &lt;= n &lt;= 20</code></li>
<li>  <code>-1000 &lt;= matrix[i][j] &lt;= 1000</code></li>
</ul>
<h3 id="二、思路与代码"><a href="#二、思路与代码" class="headerlink" title="二、思路与代码"></a>二、思路与代码</h3><p>&ensp;&ensp;&ensp;&ensp;找个中间矩阵：</p>
<p>&ensp;&ensp;&ensp;&ensp;由于矩阵中的行列从 0 开始计数，因此对于矩阵中的元素 matrix[i][j]，在旋转后，它的新位置为 maxtrix[j][n − i − 1]。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">rotate</span><span class="params">(vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; matrix)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = matrix.<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">temp</span>(matrix);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; ++j)</span><br><span class="line">            &#123;</span><br><span class="line">                matrix[j][n - i - <span class="number">1</span>] = temp[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>&ensp;&ensp;&ensp;&ensp;用翻转代替旋转：</p>
<p><img src="/2021/04/23/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E5%AD%A6%EF%BC%9A%E6%97%8B%E8%BD%AC%E5%9B%BE%E5%83%8F/1.png" alt="image-20210424180702106"></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">rotate</span><span class="params">(vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; matrix)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = matrix.<span class="built_in">size</span>();</span><br><span class="line">        <span class="comment">// 水平翻转</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n / <span class="number">2</span>; ++i) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; ++j) </span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">swap</span>(matrix[i][j], matrix[n - i - <span class="number">1</span>][j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 主对角线翻转</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; ++j) </span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">swap</span>(matrix[i][j], matrix[j][i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法</category>
        <category>数学</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>leetcode</tag>
        <tag>数学</tag>
        <tag>矩阵</tag>
      </tags>
  </entry>
  <entry>
    <title>格雷编码</title>
    <url>/2021/05/26/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E5%AD%A6%EF%BC%9A%E6%A0%BC%E9%9B%B7%E7%BC%96%E7%A0%81/</url>
    <content><![CDATA[<h3 id="一、题目"><a href="#一、题目" class="headerlink" title="一、题目"></a>一、题目</h3><p>&ensp;&ensp;&ensp;&ensp;格雷编码是一个二进制数字系统，在该系统中，两个连续的数值仅有一个位数的差异。</p>
<span id="more"></span>

<p>&ensp;&ensp;&ensp;&ensp;给定一个代表编码总位数的非负整数 <em>n</em>，打印其格雷编码序列。即使有多个不同答案，你也只需要返回其中一种。</p>
<blockquote>
<p>  格雷编码序列必须以 0 开头。 </p>
</blockquote>
<p><strong>示例 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: 2</span><br><span class="line">输出: [0,1,3,2]</span><br><span class="line">解释:</span><br><span class="line">00 - 0</span><br><span class="line">01 - 1</span><br><span class="line">11 - 3</span><br><span class="line">10 - 2</span><br><span class="line"></span><br><span class="line">对于给定的 n，其格雷编码序列并不唯一。</span><br><span class="line">例如，[0,2,3,1] 也是一个有效的格雷编码序列。</span><br><span class="line"></span><br><span class="line">00 - 0</span><br><span class="line">10 - 2</span><br><span class="line">11 - 3</span><br><span class="line">01 - 1</span><br></pre></td></tr></table></figure>

<p><strong>示例 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: 0</span><br><span class="line">输出: [0]</span><br><span class="line">解释: 我们定义格雷编码序列必须以 0 开头。</span><br><span class="line">     给定编码总位数为 n 的格雷编码序列，其长度为 2n。当 n &#x3D; 0 时，长度为 20 &#x3D; 1。</span><br><span class="line">     因此，当 n &#x3D; 0 时，其格雷编码序列为 [0]。</span><br></pre></td></tr></table></figure>

<h3 id="二、思路与代码"><a href="#二、思路与代码" class="headerlink" title="二、思路与代码"></a>二、思路与代码</h3><h4 id="2-1-暴力解"><a href="#2-1-暴力解" class="headerlink" title="2.1 暴力解"></a>2.1 暴力解</h4><p>&ensp;&ensp;&ensp;&ensp;没有啥神奇的思路，只能一个个试，具体算法如下：</p>
<ol>
<li> 分析：相邻两个数的[汉明距离](<a href="https://baike.baidu.com/item/%E6%B1%89%E6%98%8E%E8%B7%9D%E7%A6%BB">汉明距离_百度百科 (baidu.com)</a>)为<code>1</code>，差值只能是 { 1，-1，2，-2，4，-4，8，-8，……，pow(2, n - 1)，-pow(2, n - 1) }；答案的元素是<code>[ 1, pow(2, n - 1)]</code>之间的值</li>
<li> 设偏移数组 offset =  { 1，-1，2，-2，4，-4，8，-8，……，pow(2, n - 1)，-pow(2, n - 1) }，布尔数组<code>isUsed</code>表示<code>[ 1, pow(2, n - 1)]</code>的某个元素是否已被用到。</li>
<li> 确定结果的第一个元素为<code>0</code>，然后对下一个元素进行挑选（下一个元素即是当前元素加上某一偏移量且满足条件限制的情况）</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:    </span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">grayCode</span><span class="params">(<span class="keyword">int</span> n)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">ans</span><span class="params">(<span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(pow(<span class="number">2</span>, n)), <span class="number">0</span>)</span></span>;</span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt; offset;</span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">bool</span>&gt; <span class="title">isUsed</span><span class="params">(<span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(pow(<span class="number">2</span>, n)), <span class="literal">false</span>)</span></span>;</span><br><span class="line">        </span><br><span class="line">        isUsed[<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            offset.<span class="built_in">push_back</span>(<span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(<span class="built_in">pow</span>(<span class="number">2</span>, i)));</span><br><span class="line">            offset.<span class="built_in">push_back</span>(-<span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(<span class="built_in">pow</span>(<span class="number">2</span>, i)));</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; ans.<span class="built_in">size</span>(); ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">help</span>(i, ans, offset, isUsed);</span><br><span class="line">        &#125;    </span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">help</span><span class="params">(<span class="keyword">int</span> index, vector&lt;<span class="keyword">int</span>&gt;&amp; ans, vector&lt;<span class="keyword">int</span>&gt;&amp; offset, vector&lt;<span class="keyword">bool</span>&gt;&amp; isUsed)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> target;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; offset.<span class="built_in">size</span>(); ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            target = ans[index - <span class="number">1</span>] + offset[i];</span><br><span class="line">            <span class="keyword">if</span> (target &gt; <span class="number">0</span> &amp;&amp; target &lt; ans.<span class="built_in">size</span>() &amp;&amp; !isUsed[target] &amp;&amp; <span class="built_in">hammingDistance</span>(target, ans[index - <span class="number">1</span>]) == <span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                ans[index] = target;</span><br><span class="line">                isUsed[target] = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">hammingDistance</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = x ^ y;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (n != <span class="number">0</span>) </span><br><span class="line">        &#123;</span><br><span class="line">            n = n &amp; (n - <span class="number">1</span>);</span><br><span class="line">            ++res;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="2-2-leetcode题解"><a href="#2-2-leetcode题解" class="headerlink" title="2.2 leetcode题解"></a>2.2 leetcode题解</h4><p>&ensp;&ensp;&ensp;&ensp;这道题的核心其实在于了解格雷编码是如何形成的。</p>
<p>&ensp;&ensp;&ensp;&ensp;第一个点，如果我们有 n bits，那么相应的我们会有 2^n^ 个格雷编码，假设 n=2，那么我们相应的会有 4 个格雷编码。所以我们先求出有多少个格雷编码也就是 2^n^ ，等价于 1 &lt;&lt; n 也就是将 1 向左移动 n 位。假设n为2，那么0001向左移动两位就是0100也就变成了4.</p>
<p>&ensp;&ensp;&ensp;&ensp;第二个点，格雷编码如何形成。同样以n = 2解析:</p>
<ul>
<li>  公式为 (i ^ i) / 2 (i &gt;&gt; 1)</li>
<li>  0 ^ 0 = 00 ^ 00 = 00 = 0 计算(i/2): 0/2 = 0</li>
<li>  1 ^ 0 = 01 ^ 00 = 01 = 1 计算(i/2): 1/2 = 0</li>
<li>  2 ^ 1 = 10 ^ 01 = 11 = 3 计算(i/2): 2/2 = 1</li>
<li>  3 ^ 1 = 11 ^ 01 = 10 = 2 计算(i/2): 3/2 = 1</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">grayCode</span><span class="params">(<span class="keyword">int</span> n)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt; ans;</span><br><span class="line">        <span class="keyword">int</span> powN = <span class="number">1</span> &lt;&lt; n;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; powN; ++i)</span><br><span class="line">            ans.<span class="built_in">push_back</span>(i^i&gt;&gt;<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法</category>
        <category>数学</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>leetcode</tag>
        <tag>位运算</tag>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title>螺旋矩阵</title>
    <url>/2021/05/25/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E5%AD%A6%EF%BC%9A%E8%9E%BA%E6%97%8B%E7%9F%A9%E9%98%B5/</url>
    <content><![CDATA[<h3 id="一、螺旋矩阵"><a href="#一、螺旋矩阵" class="headerlink" title="一、螺旋矩阵"></a><a href="https://leetcode-cn.com/problems/spiral-matrix/">一、螺旋矩阵</a></h3><h4 id="1-1-题目"><a href="#1-1-题目" class="headerlink" title="1.1 题目"></a>1.1 题目</h4><p>&ensp;&ensp;&ensp;&ensp;给你一个 <code>m</code> 行 <code>n</code> 列的矩阵 <code>matrix</code> ，请按照 <strong>顺时针螺旋顺序</strong> ，返回矩阵中的所有元素。</p>
<span id="more"></span>

<p> <strong>示例 1：</strong></p>
<p><img src="/2021/05/25/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E5%AD%A6%EF%BC%9A%E8%9E%BA%E6%97%8B%E7%9F%A9%E9%98%B5/1.png" alt="img"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：matrix &#x3D; [[1,2,3],[4,5,6],[7,8,9]]</span><br><span class="line">输出：[1,2,3,6,9,8,7,4,5]</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<p><img src="/2021/05/25/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E5%AD%A6%EF%BC%9A%E8%9E%BA%E6%97%8B%E7%9F%A9%E9%98%B5/2.png" alt="img"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：matrix &#x3D; [[1,2,3,4],[5,6,7,8],[9,10,11,12]]</span><br><span class="line">输出：[1,2,3,4,8,12,11,10,9,5,6,7]</span><br></pre></td></tr></table></figure>

<h4 id="1-2-思路和代码"><a href="#1-2-思路和代码" class="headerlink" title="1.2 思路和代码"></a>1.2 思路和代码</h4><p>&ensp;&ensp;&ensp;&ensp;可以一层一层地遍历矩阵，只需要设计好判断条件，用递归或者迭代都可以。基本思路如下：</p>
<ol>
<li> 首先设定上下左右边界</li>
<li> 其次向右移动到最右，此时第一行因为已经使用过了，可以将其从图中删去，体现在代码中就是重新定义上边界</li>
<li> 判断若重新定义后，上下边界交错，表明螺旋矩阵遍历结束，跳出循环，返回答案</li>
<li> 若上下边界不交错，则遍历还未结束，接着向下向左向上移动，操作过程与第一，二步同理</li>
<li> 不断循环以上步骤，直到某两条边界交错，跳出循环，返回答案</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; ans;</span><br><span class="line">    </span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">spiralOrder</span><span class="params">(vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; matrix)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(matrix.<span class="built_in">empty</span>()) <span class="keyword">return</span> ans;</span><br><span class="line">        <span class="built_in">spiralOrder</span>(matrix, <span class="number">0</span>, matrix.<span class="built_in">size</span>() - <span class="number">1</span>, <span class="number">0</span>, matrix[<span class="number">0</span>].<span class="built_in">size</span>() - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">spiralOrder</span><span class="params">(vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; matrix, <span class="keyword">int</span> up, <span class="keyword">int</span> down, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = left; i &lt;= right; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            ans.<span class="built_in">push_back</span>(matrix[up][i]); <span class="comment">//向右移动直到最右</span></span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">if</span>(++up &gt; down)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span>; <span class="comment">//重新设定上边界，若上边界大于下边界，则遍历遍历完成，下同</span></span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = up; i &lt;= down; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            ans.<span class="built_in">push_back</span>(matrix[i][right]); <span class="comment">//向下</span></span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">if</span>(--right &lt; left)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span>; <span class="comment">//重新设定有边界</span></span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = right; i &gt;= left; --i)</span><br><span class="line">        &#123;</span><br><span class="line">            ans.<span class="built_in">push_back</span>(matrix[down][i]); <span class="comment">//向左</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(--down &lt; up)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span>; <span class="comment">//重新设定下边界</span></span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = down; i &gt;= up; --i)</span><br><span class="line">        &#123;</span><br><span class="line">            ans.<span class="built_in">push_back</span>(matrix[i][left]); <span class="comment">//向上</span></span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">if</span>(++left &gt; right)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span>; <span class="comment">//重新设定左边界</span></span><br><span class="line">        &#125; </span><br><span class="line">        <span class="built_in">spiralOrder</span>(matrix, up, down, left, right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>迭代法见：<a href="https://leetcode-cn.com/problems/spiral-matrix/solution/cxiang-xi-ti-jie-by-youlookdeliciousc-3/">C++ 详细题解 - 螺旋矩阵 - 力扣（LeetCode） (leetcode-cn.com)</a></p>
<h3 id="二、螺旋矩阵-II"><a href="#二、螺旋矩阵-II" class="headerlink" title="二、螺旋矩阵 II"></a><a href="https://leetcode-cn.com/problems/spiral-matrix-ii/">二、螺旋矩阵 II</a></h3><h4 id="2-1-题目"><a href="#2-1-题目" class="headerlink" title="2.1 题目"></a>2.1 题目</h4><p>&ensp;&ensp;&ensp;&ensp;给你一个正整数 <code>n</code> ，生成一个包含 <code>1</code> 到 <code>n2</code> 所有元素，且元素按顺时针顺序螺旋排列的 <code>n x n</code> 正方形矩阵 <code>matrix</code> 。 </p>
<p><strong>示例 1：</strong></p>
<p><img src="/2021/05/25/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E5%AD%A6%EF%BC%9A%E8%9E%BA%E6%97%8B%E7%9F%A9%E9%98%B5/3.png" alt="img"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：n &#x3D; 3</span><br><span class="line">输出：[[1,2,3],[8,9,4],[7,6,5]]</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：n &#x3D; 1</span><br><span class="line">输出：[[1]]</span><br></pre></td></tr></table></figure>

<p> <strong>提示：</strong></p>
<ul>
<li>  <code>1 &lt;= n &lt;= 20</code></li>
</ul>
<h4 id="2-2-思路与代码"><a href="#2-2-思路与代码" class="headerlink" title="2.2 思路与代码"></a>2.2 思路与代码</h4><p>&ensp;&ensp;&ensp;&ensp;先创建好矩阵，然后螺旋遍历即可，遍历代码参考上一题。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">generateMatrix</span>(<span class="keyword">int</span> n) </span><br><span class="line">    &#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">ans</span>(n, <span class="built_in">vector</span>(n, <span class="number">-1</span>));</span><br><span class="line">        <span class="built_in">spiralOrder</span>(ans, <span class="number">0</span>, n - <span class="number">1</span>, <span class="number">0</span>, n - <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">spiralOrder</span><span class="params">(vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; ans, <span class="keyword">int</span> up, <span class="keyword">int</span> down, <span class="keyword">int</span> left, <span class="keyword">int</span> right, <span class="keyword">int</span> start)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = left; i &lt;= right; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            ans[up][i] = start++; <span class="comment">//向右移动直到最右</span></span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">if</span>(++up &gt; down)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span>; <span class="comment">//重新设定上边界，若上边界大于下边界，则遍历遍历完成，下同</span></span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = up; i &lt;= down; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            ans[i][right] = start++; <span class="comment">//向下</span></span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">if</span>(--right &lt; left)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span>; <span class="comment">//重新设定有边界</span></span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = right; i &gt;= left; --i)</span><br><span class="line">        &#123;</span><br><span class="line">            ans[down][i] = start++; <span class="comment">//向左</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(--down &lt; up)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span>; <span class="comment">//重新设定下边界</span></span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = down; i &gt;= up; --i)</span><br><span class="line">        &#123;</span><br><span class="line">            ans[i][left] = start++; <span class="comment">//向上</span></span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">if</span>(++left &gt; right)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span>; <span class="comment">//重新设定左边界</span></span><br><span class="line">        &#125; </span><br><span class="line">        <span class="built_in">spiralOrder</span>(ans, up, down, left, right, start);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法</category>
        <category>数学</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>leetcode</tag>
        <tag>数学</tag>
        <tag>矩阵</tag>
      </tags>
  </entry>
  <entry>
    <title>MapReduce序列化</title>
    <url>/2021/06/06/Hadoop%E4%B9%8BMapReduce%EF%BC%9AMapReduce%E5%BA%8F%E5%88%97%E5%8C%96/</url>
    <content><![CDATA[<h3 id="一、序列化概述"><a href="#一、序列化概述" class="headerlink" title="一、序列化概述"></a>一、序列化概述</h3><h4 id="1-1-什么是序列化"><a href="#1-1-什么是序列化" class="headerlink" title="1.1 什么是序列化"></a>1.1 什么是序列化</h4><p>&ensp;&ensp;&ensp;&ensp;序列化就是把内存中的对象，转换成字节序列（或其他数据传输协议）以便于存储到磁盘（持久化）和网络传输。</p>
<p>&ensp;&ensp;&ensp;&ensp;反序列化就是将收到字节序列（或其他数据传输协议）或者是磁盘的持久化数据，转换成内存中的对象。 </p>
<span id="more"></span>

<h4 id="1-2-为什么要序列化"><a href="#1-2-为什么要序列化" class="headerlink" title="1.2 为什么要序列化"></a>1.2 为什么要序列化</h4><p>&ensp;&ensp;&ensp;&ensp;一般来说，“活的”对象只生存在内存里，关机断电就没有了。而且“活的”对象只能由本地的进程使用，不能被发送到网络上的另外一台计算机。 然而序列化可以存储“活的” 对象，可以将“活的”对象发送到远程计算机。 </p>
<h4 id="1-3-为什么不用-Java-的序列化"><a href="#1-3-为什么不用-Java-的序列化" class="headerlink" title="1.3 为什么不用 Java 的序列化"></a>1.3 为什么不用 Java 的序列化</h4><p>&ensp;&ensp;&ensp;&ensp;Java 的序列化是一个重量级序列化框架（Serializable），一个对象被序列化后，会附带 很多额外的信息（各种校验信息，Header，继承体系等），不便于在网络中高效传输。所以， Hadoop 自己开发了一套序列化机制（Writable）。</p>
<h4 id="1-4-Hadoop-序列化特点："><a href="#1-4-Hadoop-序列化特点：" class="headerlink" title="1.4 Hadoop 序列化特点："></a>1.4 Hadoop 序列化特点：</h4><p>（1）紧凑 ：高效使用存储空间。</p>
<p>（2）快速：读写数据的额外开销小。 </p>
<p>（3）互操作：支持多语言的交互。</p>
<img src="/2021/06/06/Hadoop%E4%B9%8BMapReduce%EF%BC%9AMapReduce%E5%BA%8F%E5%88%97%E5%8C%96/1.png" alt="image-20210525001129486" style="zoom:50%;">



<h3 id="二、-自定义-bean-对象实现序列化接口（Writable）"><a href="#二、-自定义-bean-对象实现序列化接口（Writable）" class="headerlink" title="二、 自定义 bean 对象实现序列化接口（Writable）"></a>二、 自定义 bean 对象实现序列化接口（Writable）</h3><p>&ensp;&ensp;&ensp;&ensp;在企业开发中往往常用的基本序列化类型不能满足所有需求，比如在 Hadoop 框架内部传递一个 bean 对象，那么该对象就需要实现序列化接口。 </p>
<p>&ensp;&ensp;&ensp;&ensp;具体实现 bean 对象序列化步骤如下 7 步：</p>
<p>（1）必须实现 Writable 接口 </p>
<p>（2）反序列化时，需要反射调用空参构造函数，所以必须有空参构造 </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">FlowBean</span><span class="params">()</span> </span>&#123; </span><br><span class="line">    <span class="keyword">super</span>(); </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p>（3）重写序列化方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span> </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(DataOutput out)</span> <span class="keyword">throws</span> IOException </span>&#123; </span><br><span class="line">    out.writeLong(upFlow);</span><br><span class="line">    out.writeLong(downFlow); </span><br><span class="line">    out.writeLong(sumFlow); </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p>（4）重写反序列化方法 </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span> </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">readFields</span><span class="params">(DataInput in)</span> <span class="keyword">throws</span> IOException </span>&#123; </span><br><span class="line">    upFlow = in.readLong(); </span><br><span class="line">    downFlow = in.readLong(); </span><br><span class="line">    sumFlow = in.readLong(); </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p>（5）注意反序列化的顺序和序列化的顺序完全一致 </p>
<p>（6）要想把结果显示在文件中，需要重写 toString()，可用”\t”分开，方便后续用。 </p>
<p>（7）如果需要将自定义的 bean 放在 key 中传输，则还需要实现 Comparable 接口，因为 MapReduce 框中的 Shuffle 过程要求对 key 必须能排序。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span> </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(FlowBean o)</span> </span>&#123; </span><br><span class="line">    <span class="comment">// 倒序排列，从大到小 </span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.sumFlow &gt; o.getSumFlow() ? -<span class="number">1</span> : <span class="number">1</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="三、序列化案例实操"><a href="#三、序列化案例实操" class="headerlink" title="三、序列化案例实操"></a>三、序列化案例实操</h3><h4 id="1）需求"><a href="#1）需求" class="headerlink" title="1）需求"></a>1）需求</h4><p>&ensp;&ensp;&ensp;&ensp;统计每一个手机号耗费的总上行流量、总下行流量、总流量。</p>
<p>&ensp;&ensp;&ensp;&ensp;输入数据格式：</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">7     13560436666   120.196.100.99     1116        954           200</span><br><span class="line">id     手机号码        网络ip           上行流量     下行流量       网络状态码</span><br></pre></td></tr></table></figure>

<p>&ensp;&ensp;&ensp;&ensp;期望输出数据格式</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">13560436666      1116        954        2070</span><br><span class="line">手机号码          上行流量     下行流量      总流量</span><br></pre></td></tr></table></figure>

<h4 id="2）需求分析"><a href="#2）需求分析" class="headerlink" title="2）需求分析"></a>2）需求分析</h4><img src="/2021/06/06/Hadoop%E4%B9%8BMapReduce%EF%BC%9AMapReduce%E5%BA%8F%E5%88%97%E5%8C%96/2.png" alt="image-20210525003626609" style="zoom:67%;">

<h4 id="3）编写-MapReduce-程序"><a href="#3）编写-MapReduce-程序" class="headerlink" title="3）编写 MapReduce 程序"></a>3）编写 MapReduce 程序</h4><p>（1）编写流量统计的 Bean 对象</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.mapreduce.writable;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.io.Writable;</span><br><span class="line"><span class="keyword">import</span> java.io.DataInput;</span><br><span class="line"><span class="keyword">import</span> java.io.DataOutput;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="comment">//1 继承 Writable 接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FlowBean</span> <span class="keyword">implements</span> <span class="title">Writable</span> </span>&#123;</span><br><span class="line">     <span class="keyword">private</span> <span class="keyword">long</span> upFlow; <span class="comment">//上行流量</span></span><br><span class="line">     <span class="keyword">private</span> <span class="keyword">long</span> downFlow; <span class="comment">//下行流量</span></span><br><span class="line">     <span class="keyword">private</span> <span class="keyword">long</span> sumFlow; <span class="comment">//总流量</span></span><br><span class="line">     <span class="comment">//2 提供无参构造</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="title">FlowBean</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">//3 提供三个参数的 getter 和 setter 方法</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getUpFlow</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     	<span class="keyword">return</span> upFlow;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUpFlow</span><span class="params">(<span class="keyword">long</span> upFlow)</span> </span>&#123;</span><br><span class="line">     	<span class="keyword">this</span>.upFlow = upFlow;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getDownFlow</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    	 <span class="keyword">return</span> downFlow;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setDownFlow</span><span class="params">(<span class="keyword">long</span> downFlow)</span> </span>&#123;</span><br><span class="line">     	<span class="keyword">this</span>.downFlow = downFlow;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getSumFlow</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     	<span class="keyword">return</span> sumFlow;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSumFlow</span><span class="params">(<span class="keyword">long</span> sumFlow)</span> </span>&#123;</span><br><span class="line">    	 <span class="keyword">this</span>.sumFlow = sumFlow;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSumFlow</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    	 <span class="keyword">this</span>.sumFlow = <span class="keyword">this</span>.upFlow + <span class="keyword">this</span>.downFlow;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">//4 实现序列化和反序列化方法,注意顺序一定要保持一致</span></span><br><span class="line">     <span class="meta">@Override</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(DataOutput dataOutput)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">         dataOutput.writeLong(upFlow);</span><br><span class="line">         dataOutput.writeLong(downFlow);</span><br><span class="line">         dataOutput.writeLong(sumFlow);</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="meta">@Override</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">readFields</span><span class="params">(DataInput dataInput)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">         <span class="keyword">this</span>.upFlow = dataInput.readLong();</span><br><span class="line">         <span class="keyword">this</span>.downFlow = dataInput.readLong();</span><br><span class="line">         <span class="keyword">this</span>.sumFlow = dataInput.readLong();</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">//5 重写 ToString</span></span><br><span class="line">     <span class="meta">@Override</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     	<span class="keyword">return</span> upFlow + <span class="string">&quot;\t&quot;</span> + downFlow + <span class="string">&quot;\t&quot;</span> + sumFlow;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（2）编写 Mapper 类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.mapreduce.writable;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.io.LongWritable;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.io.Text;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.mapreduce.Mapper;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FlowMapper</span> <span class="keyword">extends</span> <span class="title">Mapper</span>&lt;<span class="title">LongWritable</span>, <span class="title">Text</span>, <span class="title">Text</span>, <span class="title">FlowBean</span>&gt; </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">     <span class="keyword">private</span> Text outK = <span class="keyword">new</span> Text();</span><br><span class="line">     <span class="keyword">private</span> FlowBean outV = <span class="keyword">new</span> FlowBean();</span><br><span class="line">     </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">     <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">map</span><span class="params">(LongWritable key, Text value, Context context)</span> </span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> IOException, InterruptedException </span>&#123;</span><br><span class="line">         <span class="comment">//1 获取一行数据,转成字符串</span></span><br><span class="line">         String line = value.toString();</span><br><span class="line">         <span class="comment">//2 切割数据</span></span><br><span class="line">         String[] split = line.split(<span class="string">&quot;\t&quot;</span>);</span><br><span class="line">         <span class="comment">//3 抓取我们需要的数据:手机号,上行流量,下行流量</span></span><br><span class="line">         String phone = split[<span class="number">1</span>];</span><br><span class="line">         String up = split[split.length - <span class="number">3</span>];</span><br><span class="line">         String down = split[split.length - <span class="number">2</span>];</span><br><span class="line">         <span class="comment">//4 封装 outK outV</span></span><br><span class="line">         outK.set(phone);</span><br><span class="line">             outV.setUpFlow(Long.parseLong(up));</span><br><span class="line">         outV.setDownFlow(Long.parseLong(down));</span><br><span class="line">         outV.setSumFlow();</span><br><span class="line">         <span class="comment">//5 写出 outK outV</span></span><br><span class="line">         context.write(outK, outV);</span><br><span class="line"> 	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（3）编写 Reducer 类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.mapreduce.writable;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.io.Text;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.mapreduce.Reducer;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FlowReducer</span> <span class="keyword">extends</span> <span class="title">Reducer</span>&lt;<span class="title">Text</span>, <span class="title">FlowBean</span>, <span class="title">Text</span>, <span class="title">FlowBean</span>&gt; </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">     <span class="keyword">private</span> FlowBean outV = <span class="keyword">new</span> FlowBean();</span><br><span class="line">     <span class="meta">@Override</span></span><br><span class="line">     <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">reduce</span><span class="params">(Text key, Iterable&lt;FlowBean&gt; values, Context </span></span></span><br><span class="line"><span class="function"><span class="params">    context)</span> <span class="keyword">throws</span> IOException, InterruptedException </span>&#123;</span><br><span class="line">         <span class="keyword">long</span> totalUp = <span class="number">0</span>;</span><br><span class="line">         <span class="keyword">long</span> totalDown = <span class="number">0</span>;</span><br><span class="line">         <span class="comment">//1 遍历 values,将其中的上行流量,下行流量分别累加</span></span><br><span class="line">         <span class="keyword">for</span> (FlowBean flowBean : values) &#123;</span><br><span class="line">             totalUp += flowBean.getUpFlow();</span><br><span class="line">             totalDown += flowBean.getDownFlow();</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="comment">//2 封装 outKV</span></span><br><span class="line">         outV.setUpFlow(totalUp);</span><br><span class="line">         outV.setDownFlow(totalDown);</span><br><span class="line">         outV.setSumFlow();</span><br><span class="line">         <span class="comment">//3 写出 outK outV</span></span><br><span class="line">         context.write(key,outV);</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>（4）编写 Driver 驱动类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.mapreduce.writable;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.conf.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.fs.Path;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.io.Text;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.mapreduce.Job;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.mapreduce.lib.input.FileInputFormat;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.mapreduce.lib.output.FileOutputFormat;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FlowDriver</span> </span>&#123;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, </span></span><br><span class="line"><span class="function">    ClassNotFoundException, InterruptedException </span>&#123;</span><br><span class="line">         <span class="comment">//1 获取 job 对象</span></span><br><span class="line">         Configuration conf = <span class="keyword">new</span> Configuration();</span><br><span class="line">         Job job = Job.getInstance(conf);</span><br><span class="line">         <span class="comment">//2 关联本 Driver 类</span></span><br><span class="line">            job.setJarByClass(FlowDriver.class);</span><br><span class="line">         <span class="comment">//3 关联 Mapper 和 Reducer</span></span><br><span class="line">         job.setMapperClass(FlowMapper.class);</span><br><span class="line">         job.setReducerClass(FlowReducer.class);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//4 设置 Map 端输出 KV 类型</span></span><br><span class="line">         job.setMapOutputKeyClass(Text.class);</span><br><span class="line">         job.setMapOutputValueClass(FlowBean.class);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//5 设置程序最终输出的 KV 类型</span></span><br><span class="line">         job.setOutputKeyClass(Text.class);</span><br><span class="line">         job.setOutputValueClass(FlowBean.class);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//6 设置程序的输入输出路径</span></span><br><span class="line">         FileInputFormat.setInputPaths(job, <span class="keyword">new</span> Path(<span class="string">&quot;D:\\inputflow&quot;</span>));</span><br><span class="line">         FileOutputFormat.setOutputPath(job, <span class="keyword">new</span> Path(<span class="string">&quot;D:\\flowoutput&quot;</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//7 提交 Job</span></span><br><span class="line">         <span class="keyword">boolean</span> b = job.waitForCompletion(<span class="keyword">true</span>);</span><br><span class="line">         System.exit(b ? <span class="number">0</span> : <span class="number">1</span>);</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><a href="https://www.bilibili.com/video/BV1Qp4y1n7EN?p=1">尚硅谷丨大数据Hadoop 3.x（2021全新升级/部署+源码+实战）_哔哩哔哩 (゜-゜)つロ 干杯~-bilibili</a></p>
]]></content>
      <categories>
        <category>数据研发</category>
        <category>Hadoop</category>
        <category>MapReduce</category>
      </categories>
      <tags>
        <tag>数据研发</tag>
        <tag>Hadoop</tag>
        <tag>MapReduce</tag>
      </tags>
  </entry>
  <entry>
    <title>MapReduce概述</title>
    <url>/2021/06/06/Hadoop%E4%B9%8BMapReduce%EF%BC%9AMapReduce%E6%A6%82%E8%BF%B0/</url>
    <content><![CDATA[<h3 id="一、MapReduce简介"><a href="#一、MapReduce简介" class="headerlink" title="一、MapReduce简介"></a>一、MapReduce简介</h3><h4 id="1-1、MapReduce产生背景"><a href="#1-1、MapReduce产生背景" class="headerlink" title="1.1、MapReduce产生背景"></a>1.1、MapReduce产生背景</h4><p>&ensp;&ensp;&ensp;&ensp;海量数据在单机上处理因为硬件资源限制，无法胜任，而一旦将单机版程序扩展到集群来分布式运行，将极大增加程序的复杂度和开发难度，引入mapreduce框架后，开发人员可以将绝大部分工作集中在业务逻辑的开发上，而将分布式计算中的复杂性交由框架来处理。</p>
<span id="more"></span>

<h4 id="1-2、MapReduce"><a href="#1-2、MapReduce" class="headerlink" title="1.2、MapReduce"></a>1.2、MapReduce</h4><ol>
<li> MapReduce 是一个分布式运算程序的编程框架，是用户开发“基于 Hadoop 的数据分析应用”的核心框架。 </li>
<li> MapReduce 核心功能是将用户编写的业务逻辑代码和自带默认组件整合成一个完整的分布式运算程序，并发运行在一个 Hadoop 集群上。</li>
<li> MapReduce以一种可靠的，具有容错能力的方式并行地处理上TB级别的海量数据集。主要用于搜索领域，解决海量数据的计算问题。</li>
<li> MapReduce有两个阶段组成：Map和Reduce，用户只需实现map()和reduce()两个函数，即可实现分布式计算。</li>
</ol>
<blockquote>
<p>  关键词：编程框架、并行处理、可靠且容错、大规模集群、海量数据集</p>
</blockquote>
<h3 id="二、MapReduce优缺点"><a href="#二、MapReduce优缺点" class="headerlink" title="二、MapReduce优缺点"></a>二、MapReduce优缺点</h3><h4 id="2-1-优点"><a href="#2-1-优点" class="headerlink" title="2.1 优点"></a>2.1 优点</h4><ol>
<li> MapReduce 易于编程 它简单的实现一些接口，就可以完成一个分布式程序，这个分布式程序可以分布到大量 廉价的 PC 机器上运行。也就是说你写一个分布式程序，跟写一个简单的串行程序是一模一 样的。就是因为这个特点使得 MapReduce 编程变得非常流行。</li>
<li> 良好的扩展性 当你的计算资源不能得到满足的时候，你可以通过简单的增加机器来扩展它的计算能力。</li>
<li> 高容错性 MapReduce 设计的初衷就是使程序能够部署在廉价的 PC 机器上，这就要求它具有很高 的容错性。比如其中一台机器挂了，它可以把上面的计算任务转移到另外一个节点上运行， 不至于这个任务运行失败，而且这个过程不需要人工参与，而完全是由 Hadoop 内部完成的。 </li>
<li> 适合 PB 级以上海量数据的离线处理 可以实现上千台服务器集群并发工作，提供数据处理能力。 </li>
</ol>
<h4 id="2-2-缺点"><a href="#2-2-缺点" class="headerlink" title="2.2 缺点"></a>2.2 缺点</h4><ol>
<li> 不擅长实时计算，无法像 MySQL 一样，在毫秒或者秒级内返回结果。 </li>
<li> 不擅长流式计算，流式计算的输入数据是动态的，而 MapReduce 的输入数据集是静态的，不能动态变化。 这是因为 MapReduce 自身的设计特点决定了数据源必须是静态的。 </li>
<li> 不擅长 DAG（有向无环图）计算，多个应用程序存在依赖关系，后一个应用程序的输入为前一个的输出。在这种情况下， MapReduce 并不是不能做，而是使用后，每个 MapReduce 作业的输出结果都会写入到磁盘， 会造成大量的磁盘 IO，导致性能非常的低下。</li>
</ol>
<h3 id="三、MapReduce-核心编程思想"><a href="#三、MapReduce-核心编程思想" class="headerlink" title="三、MapReduce 核心编程思想"></a>三、MapReduce 核心编程思想</h3><img src="/2021/06/06/Hadoop%E4%B9%8BMapReduce%EF%BC%9AMapReduce%E6%A6%82%E8%BF%B0/Blog/source/_posts/Hadoop%E4%B9%8BMapReduce%EF%BC%9AMapReduce%E6%A6%82%E8%BF%B0/1.png" alt="image-20210524233824290" style="zoom: 67%;">

<p>（1）分布式的运算程序往往需要分成至少 2 个阶段。 </p>
<p>（2）第一个阶段的 MapTask 并发实例，完全并行运行，互不相干。 </p>
<p>（3）第二个阶段的 ReduceTask 并发实例互不相干，但是他们的数据依赖于上一个阶段 的所有 MapTask 并发实例的输出。 </p>
<p>（4）MapReduce 编程模型只能包含一个 Map 阶段和一个 Reduce 阶段，如果用户的业 务逻辑非常复杂，那就只能多个 MapReduce 程序，串行运行。</p>
<h3 id="四、MapReduce-进程"><a href="#四、MapReduce-进程" class="headerlink" title="四、MapReduce 进程"></a>四、MapReduce 进程</h3><p>一个完整的 MapReduce 程序在分布式运行时有三类实例进程： </p>
<ol>
<li> MrAppMaster：负责整个程序的过程调度及状态协调。 </li>
<li> MapTask：负责 Map 阶段的整个数据处理流程。 </li>
<li> ReduceTask：负责 Reduce 阶段的整个数据处理流程。</li>
</ol>
<h3 id="五、MR程序运行流程"><a href="#五、MR程序运行流程" class="headerlink" title="五、MR程序运行流程"></a>五、MR程序运行流程</h3><img src="/2021/06/06/Hadoop%E4%B9%8BMapReduce%EF%BC%9AMapReduce%E6%A6%82%E8%BF%B0/2.png" alt="image-20210524234251631" style="zoom:50%;">

<ol>
<li> 一个mr程序启动的时候，最先启动的是MRAppMaster，MRAppMaster启动后根据本次job的描述信息，计算出需要的maptask实例数量，然后向集群申请机器启动相应数量的maptask进程</li>
<li>maptask进程启动之后，根据给定的数据切片范围进行数据处理，主体流程为：<ul>
<li>  利用客户指定的inputformat来获取RecordReader读取数据，形成输入KV对</li>
<li>  将输入KV对传递给客户定义的map()方法，做逻辑运算，并将map()方法输出的KV对收集到缓存</li>
<li>  将缓存中的KV对按照K分区排序后不断溢写到磁盘文件</li>
</ul>
</li>
<li> MRAppMaster监控到所有maptask进程任务完成之后，会根据客户指定的参数启动相应数量的reducetask进程，并告知reducetask进程要处理的数据范围（数据分区）</li>
<li> Reducetask进程启动之后，根据MRAppMaster告知的待处理数据所在位置，从若干台maptask运行所在机器上获取到若干个maptask输出结果文件，并在本地进行重新归并排序，然后按照相同key的KV为一个组，调用客户定义的reduce()方法进行逻辑运算，并收集运算输出的结果KV，然后调用客户指定的outputformat将结果数据输出到外部存储</li>
</ol>
<h3 id="六、常用数据序列化类型"><a href="#六、常用数据序列化类型" class="headerlink" title="六、常用数据序列化类型"></a>六、常用数据序列化类型</h3><table>
<thead>
<tr>
<th align="center">Java 类型</th>
<th align="center">Hadoop Writable 类型</th>
</tr>
</thead>
<tbody><tr>
<td align="center">Boolean</td>
<td align="center">BooleanWritable</td>
</tr>
<tr>
<td align="center">Byte</td>
<td align="center">ByteWritable</td>
</tr>
<tr>
<td align="center">Int</td>
<td align="center">IntWritable</td>
</tr>
<tr>
<td align="center">Float</td>
<td align="center">FloatWritable</td>
</tr>
<tr>
<td align="center">Long</td>
<td align="center">LongWritable</td>
</tr>
<tr>
<td align="center">Double</td>
<td align="center">DoubleWritable</td>
</tr>
<tr>
<td align="center"><strong>String</strong></td>
<td align="center"><strong>Text</strong></td>
</tr>
<tr>
<td align="center">Map</td>
<td align="center">MapWritable</td>
</tr>
<tr>
<td align="center">Array</td>
<td align="center">ArrayWritable</td>
</tr>
<tr>
<td align="center">Null</td>
<td align="center">NullWritable</td>
</tr>
</tbody></table>
<h3 id="七、MapReduce-编程规范"><a href="#七、MapReduce-编程规范" class="headerlink" title="七、MapReduce 编程规范"></a>七、MapReduce 编程规范</h3><p>&ensp;&ensp;&ensp;&ensp;用户编写的程序分成三个部分：Mapper、Reducer 和 Driver。</p>
<h4 id="7-1-Mapper阶段"><a href="#7-1-Mapper阶段" class="headerlink" title="7.1 Mapper阶段"></a>7.1 Mapper阶段</h4><p>（1）用户自定义的Mapper要继承自己的父类 </p>
<p>（2）Mapper的输入数据是KV对的形式（KV的类型可自定义） </p>
<p>（3）Mapper中的业务逻辑写在map()方法中 </p>
<p>（4）Mapper的输出数据是KV对的形式（KV的类型可自定义） </p>
<p>（5）map()方法（MapTask进程）对每一个调用一次</p>
<h4 id="7-2-Reducer阶段"><a href="#7-2-Reducer阶段" class="headerlink" title="7.2 Reducer阶段"></a>7.2 Reducer阶段</h4><p>（1）用户自定义的Reducer要继承自己的父类</p>
<p>（2）Reducer的输入数据类型对应Mapper的输出数据类型，也是KV </p>
<p>（3）Reducer的业务逻辑写在reduce()方法中 </p>
<p>（4）ReduceTask进程对每一组相同 &lt;k，v&gt; 的组调用一次reduce()方法 </p>
<h4 id="7-3-Driver阶段"><a href="#7-3-Driver阶段" class="headerlink" title="7.3 Driver阶段"></a>7.3 Driver阶段</h4><p>    相当于YARN集群的客户端，用于提交我们整个程序到YARN集群，提交的是封装了MapReduce程序相关运行参数的job对象。</p>
]]></content>
      <categories>
        <category>数据研发</category>
        <category>Hadoop</category>
        <category>MapReduce</category>
      </categories>
      <tags>
        <tag>数据研发</tag>
        <tag>Hadoop</tag>
        <tag>MapReduce</tag>
      </tags>
  </entry>
  <entry>
    <title>MapTask 与ReduceTask工作机制</title>
    <url>/2021/06/06/Hadoop%E4%B9%8BMapReduce%EF%BC%9AMapTask%20%E4%B8%8EReduceTask%E5%B7%A5%E4%BD%9C%E6%9C%BA%E5%88%B6/</url>
    <content><![CDATA[<h3 id="一、MapTask-工作机制"><a href="#一、MapTask-工作机制" class="headerlink" title="一、MapTask 工作机制"></a>一、MapTask 工作机制</h3><p><img src="/2021/06/06/Hadoop%E4%B9%8BMapReduce%EF%BC%9AMapTask%20%E4%B8%8EReduceTask%E5%B7%A5%E4%BD%9C%E6%9C%BA%E5%88%B6/1.png" alt="image-20210602002046304"></p>
<span id="more"></span>

<p>（1）Read 阶段：MapTask 通过 InputFormat 获得的 RecordReader，从输入 InputSplit 中 解析出一个个 key/value。 </p>
<p>（2）Map 阶段：该节点主要是将解析出的 key/value 交给用户编写 map()函数处理，并 产生一系列新的 key/value。</p>
<p>（3）Collect 收集阶段：在用户编写 map()函数中，当数据处理完成后，一般会调用 OutputCollector.collect()输出结果。在该函数内部，它会将生成的 key/value 分区（调用 Partitioner），并写入一个环形内存缓冲区中。 </p>
<p>（4）Spill 阶段：即“溢写”，当环形缓冲区满后，MapReduce 会将数据写到本地磁盘上， 生成一个临时文件。需要注意的是，将数据写入本地磁盘之前，先要对数据进行一次本地排序，并在必要时对数据进行合并、压缩等操作。 溢写阶段详情： </p>
<ul>
<li><p>  步骤 1：利用快速排序算法对缓存区内的数据进行排序，排序方式是，先按照分区编号 Partition 进行排序，然后按照 key 进行排序。这样，经过排序后，数据以分区为单位聚集在 一起，且同一分区内所有数据按照 key 有序。 </p>
</li>
<li><p>  步骤 2：按照分区编号由小到大依次将每个分区中的数据写入任务工作目录下的临时文 件 output/spillN.out（N 表示当前溢写次数）中。如果用户设置了 Combiner，则写入文件之 前，对每个分区中的数据进行一次聚集操作。 </p>
</li>
<li><p>  步骤 3：将分区数据的元信息写到内存索引数据结构 SpillRecord 中，其中每个分区的元 信息包括在临时文件中的偏移量、压缩前数据大小和压缩后数据大小。如果当前内存索引大 小超过 1MB，则将内存索引写到文件 output/spillN.out.index 中。 </p>
</li>
</ul>
<p>（5）Merge 阶段：当所有数据处理完成后，MapTask 对所有临时文件进行一次合并， 以确保最终只会生成一个数据文件。</p>
<p>    当所有数据处理完后，MapTask 会将所有临时文件合并成一个大文件，并保存到文件 output/file.out 中，同时生成相应的索引文件 output/file.out.index。 </p>
<p>    在进行文件合并过程中，MapTask 以分区为单位进行合并。对于某个分区，它将采用多 轮递归合并的方式。每轮合并 mapreduce.task.io.sort.factor（默认 10）个文件，并将产生的文 件重新加入待合并列表中，对文件排序后，重复以上过程，直到最终得到一个大文件。</p>
<p>    让每个 MapTask 最终只生成一个数据文件，可避免同时打开大量文件和同时读取大量 小文件产生的随机读取带来的开销。</p>
<h3 id="二、ReduceTask-工作机制"><a href="#二、ReduceTask-工作机制" class="headerlink" title="二、ReduceTask 工作机制"></a>二、ReduceTask 工作机制</h3><p><img src="/2021/06/06/Hadoop%E4%B9%8BMapReduce%EF%BC%9AMapTask%20%E4%B8%8EReduceTask%E5%B7%A5%E4%BD%9C%E6%9C%BA%E5%88%B6/2.png" alt="image-20210602002323621"></p>
<p>（1）Copy 阶段：ReduceTask 从各个 MapTask 上远程拷贝一片数据，并针对某一片数 据，如果其大小超过一定阈值，则写到磁盘上，否则直接放到内存中。 </p>
<p>（2）Sort 阶段：在远程拷贝数据的同时，ReduceTask 启动了两个后台线程对内存和磁 盘上的文件进行合并，以防止内存使用过多或磁盘上文件过多。按照 MapReduce 语义，用 户编写 reduce()函数输入数据是按 key 进行聚集的一组数据。为了将 key 相同的数据聚在一 起，Hadoop 采用了基于排序的策略。由于各个 MapTask 已经实现对自己的处理结果进行了 局部排序，因此，ReduceTask 只需对所有数据进行一次归并排序即可。 </p>
<p>（3）Reduce 阶段：reduce()函数将计算结果写到 HDFS 上。</p>
<h3 id="三、ReduceTask-并行度决定机制"><a href="#三、ReduceTask-并行度决定机制" class="headerlink" title="三、ReduceTask 并行度决定机制"></a>三、ReduceTask 并行度决定机制</h3><p>回顾：MapTask 并行度由切片个数决定，切片个数由输入文件和切片规则决定。 </p>
<p>思考：ReduceTask 并行度由谁决定？</p>
<p> 1）设置 ReduceTask 并行度（个数） ReduceTask 的并行度同样影响整个 Job 的执行并发度和执行效率，但与 MapTask 的并 发数由切片数决定不同，ReduceTask 数量的决定是可以直接手动设置： </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 默认值是 1，手动设置为 4</span></span><br><span class="line">job.setNumReduceTasks(<span class="number">4</span>);</span><br></pre></td></tr></table></figure>

<p>2）实验：测试 ReduceTask 多少合适 </p>
<p>（1）实验环境：1 个 Master 节点，16 个 Slave 节点：CPU:8GHZ，内存: 2G </p>
<p>（2）实验结论： </p>
<p> <img src="/2021/06/06/Hadoop%E4%B9%8BMapReduce%EF%BC%9AMapTask%20%E4%B8%8EReduceTask%E5%B7%A5%E4%BD%9C%E6%9C%BA%E5%88%B6/3.png" alt="image-20210602002658758"></p>
<p>（3）注意事项 </p>
<p>  （1）ReduceTask=0，表示没有Reduce阶段，输出文件个数和Map个数一致。 </p>
<p>  （2）ReduceTask默认值就是1，所以输出文件个数为一个。 </p>
<p>  （3）如果数据分布不均匀，就有可能在Reduce阶段产生数据倾斜 </p>
<p>  （4）ReduceTask数量并不是任意设置，还要考虑业务逻辑需求，有些情况下，需要计算全 局汇总结果，就只能有1个ReduceTask。 </p>
<p>  （5）具体多少个ReduceTask，需要根据集群性能而定。 </p>
<p>  （6）如果分区数不是1，但是ReduceTask为1，是否执行分区过程。答案是：不执行分区过 程。因为在MapTask的源码中，执行分区的前提是先判断ReduceNum个数是否大于1。不大于1 肯定不执行。</p>
<h3 id="四、MapReduce-开发总结"><a href="#四、MapReduce-开发总结" class="headerlink" title="四、MapReduce 开发总结"></a>四、MapReduce 开发总结</h3><p> 1）输入数据接口：InputFormat </p>
<ul>
<li>  默认使用的实现类是：TextInputFormat </li>
<li>  TextInputFormat 的功能逻辑是：一次读一行文本，然后将该行的起始偏移量作为 key，行内容作为 value 返回。 </li>
<li>  CombineTextInputFormat 可以把多个小文件合并成一个切片处理，提高处理效率。</li>
</ul>
<p> 2）逻辑处理接口：Mapper  用户根据业务需求实现其中三个方法：map() setup() cleanup () </p>
<p> 3）Partitioner 分区 </p>
<ul>
<li>  有默认实现 HashPartitioner，逻辑是根据 key 的哈希值和 numReduces 来返回一个 分区号；key.hashCode()&amp;Integer.MAXVALUE % numReduces </li>
<li>  如果业务上有特别的需求，可以自定义分区。 </li>
</ul>
<p>4）Comparable 排序 </p>
<ul>
<li>  当我们用自定义的对象作为 key 来输出时，就必须要实现 WritableComparable 接 口，重写其中的 compareTo()方法。</li>
<li>  部分排序：对最终输出的每一个文件进行内部排序。</li>
<li>  全排序：对所有数据进行排序，通常只有一个 Reduce。 </li>
<li>  二次排序：排序的条件有两个。</li>
</ul>
<p> 5）Combiner 合并 Combiner 合并可以提高程序执行效率，减少 IO 传输。但是使用时必须不能影响原有的 业务处理结果。</p>
<p> 6）逻辑处理接口：Reducer 用户根据业务需求实现其中三个方法：reduce() setup() cleanup () </p>
<p> 7）输出数据接口：OutputFormat</p>
<ul>
<li>  默认实现类是 TextOutputFormat，功能逻辑是：将每一个 KV 对，向目标文本文件 输出一行。 </li>
<li>  用户还可以自定义 OutputFormat。</li>
</ul>
]]></content>
      <categories>
        <category>数据研发</category>
        <category>Hadoop</category>
        <category>MapReduce</category>
      </categories>
      <tags>
        <tag>数据研发</tag>
        <tag>Hadoop</tag>
        <tag>MapReduce</tag>
      </tags>
  </entry>
  <entry>
    <title>MapReduce并行度决定机制</title>
    <url>/2021/06/06/Hadoop%E4%B9%8BMapReduce%EF%BC%9AMapTask%E5%B9%B6%E8%A1%8C%E5%BA%A6%E5%86%B3%E5%AE%9A%E6%9C%BA%E5%88%B6/</url>
    <content><![CDATA[<p>&ensp;&ensp;&ensp;&ensp;MapTask的并行度决定map阶段的任务处理并发度，进而影响到整个job的处理速度。那么，MapTask并行实例是否越多越好呢？其并行度又是如何决定呢？</p>
<span id="more"></span>

<h3 id="一、MapTask并行度的决定机制"><a href="#一、MapTask并行度的决定机制" class="headerlink" title="一、MapTask并行度的决定机制"></a>一、MapTask并行度的决定机制</h3><p>&ensp;&ensp;&ensp;&ensp;<strong>数据块：</strong>Block 是 HDFS 物理上把数据分成一块一块。数据块是 HDFS 存储数据单位。 </p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>数据切片：</strong>数据切片只是在逻辑上对输入进行分片，并不会在磁盘上将其切分成片进行存储。数据切片是 MapReduce 程序计算输入数据的单位，一个切片会对应启动一个 MapTask。</p>
<p>&ensp;&ensp;&ensp;&ensp;一个job的map阶段并行度由客户端在提交job时决定，而客户端对map阶段并行度的规划的基本逻辑为：将待处理数据执行逻辑切片（即按照一个特定切片大小，将待处理数据划分成逻辑上的多个split），然后每一个split分配一个mapTask并行实例处理。</p>
<p>&ensp;&ensp;&ensp;&ensp;这段逻辑及形成的切片规划描述文件，由FileInputFormat实现类的getSplits()方法完成，其过程如下图：</p>
<p><img src="/2021/06/06/Hadoop%E4%B9%8BMapReduce%EF%BC%9AMapTask%E5%B9%B6%E8%A1%8C%E5%BA%A6%E5%86%B3%E5%AE%9A%E6%9C%BA%E5%88%B6/1.png" alt="img"></p>
<p><strong>数据切片：</strong></p>
<img src="/2021/06/06/Hadoop%E4%B9%8BMapReduce%EF%BC%9AMapTask%E5%B9%B6%E8%A1%8C%E5%BA%A6%E5%86%B3%E5%AE%9A%E6%9C%BA%E5%88%B6/2.png" alt="image-20210526010730103" style="zoom:67%;">



<h3 id="二、FileInputFormat切片机制"><a href="#二、FileInputFormat切片机制" class="headerlink" title="二、FileInputFormat切片机制"></a>二、FileInputFormat切片机制</h3><p>1、切片定义在InputFormat类中的getSplit()方法</p>
<p>2、FileInputFormat中默认的切片机制：</p>
<ul>
<li>  简单地按照文件的内容长度进行切片</li>
<li>  切片大小，默认等于block大小</li>
<li>  切片时不考虑数据集整体，而是逐个针对每一个文件单独切片</li>
</ul>
<p>&ensp;&ensp;&ensp;&ensp;比如待处理数据有两个文件：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">file1.txt   320M </span><br><span class="line">file2.txt   10M</span><br></pre></td></tr></table></figure>

<p>&ensp;&ensp;&ensp;&ensp;经过FileInputFormat的切片机制运算后，形成的切片信息如下：  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">file1.txt.split1--  0~128</span><br><span class="line">file1.txt.split2--  128~256</span><br><span class="line">file1.txt.split3--  256~320</span><br><span class="line">file2.txt.split1--  0~10M</span><br></pre></td></tr></table></figure>

<p>3、FileInputFormat中切片的大小的参数配置</p>
<p>&ensp;&ensp;&ensp;&ensp;通过分析源码，在FileInputFormat中，计算切片大小的逻辑：<code>Math.max(minSize, Math.min(maxSize, blockSize)); </code>切片主要由这几个值来运算决定</p>
<table>
<thead>
<tr>
<th>minsize：默认值：1   配置参数： mapreduce.input.fileinputformat.split.minsize</th>
</tr>
</thead>
<tbody><tr>
<td>maxsize：默认值：Long.MAXValue   配置参数：mapreduce.input.fileinputformat.split.maxsize</td>
</tr>
<tr>
<td>blocksize</td>
</tr>
</tbody></table>
<p>&ensp;&ensp;&ensp;&ensp;因此，<strong>默认情况下，切片大小=blocksize</strong></p>
<p>&ensp;&ensp;&ensp;&ensp;maxsize（切片最大值）：参数如果调得比blocksize小，则会让切片变小，而且就等于配置的这个参数的值</p>
<p>&ensp;&ensp;&ensp;&ensp;minsize （切片最小值）：参数调的比blockSize大，则可以让切片变得比blocksize还大</p>
<blockquote>
<p>  选择并发数的影响因素：</p>
<ol>
<li> 运算节点的硬件配置</li>
<li> 运算任务的类型：CPU密集型还是IO密集型</li>
<li> 运算任务的数据量</li>
</ol>
</blockquote>
<h3 id="三、TextInputFormat-切片机制"><a href="#三、TextInputFormat-切片机制" class="headerlink" title="三、TextInputFormat 切片机制"></a>三、TextInputFormat 切片机制</h3><p>1）FileInputFormat 实现类 </p>
<p>&ensp;&ensp;&ensp;&ensp;思考：在运行 MapReduce 程序时，输入的文件格式包括：基于行的日志文件、二进制 格式文件、数据库表等。那么，针对不同的数据类型，MapReduce 是如何读取这些数据的呢？ FileInputFormat 常见的接口实现类包括：TextInputFormat、KeyValueTextInputFormat、 NLineInputFormat、CombineTextInputFormat 和自定义 InputFormat 等。</p>
<p> 2）TextInputFormat </p>
<p>&ensp;&ensp;&ensp;&ensp;TextInputFormat 是默认的 FileInputFormat 实现类。按行读取每条记录。键是存储该行在整个文件中的起始字节偏移量， LongWritable 类型。值是这行的内容，不包括任何行终止 符（换行符和回车符），Text 类型。 </p>
<p>&ensp;&ensp;&ensp;&ensp;以下是一个示例，比如，一个分片包含了如下 4 条文本记录。 </p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">Rich learning form </span><br><span class="line">Intelligent learning engine </span><br><span class="line">Learning more convenient </span><br><span class="line">From the real demand for more close to the enterprise </span><br></pre></td></tr></table></figure>

<p>&ensp;&ensp;&ensp;&ensp;每条记录表示为以下键/值对： </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(0,Rich learning form)</span><br><span class="line">(20,Intelligent learning engine)</span><br><span class="line">(49,Learning more convenient) </span><br><span class="line">(74,From the real demand for more close to the enterprise)</span><br></pre></td></tr></table></figure>

<p>3）CombineTextInputFormat 切片机制 </p>
<p>&ensp;&ensp;&ensp;&ensp;框架默认的 TextInputFormat 切片机制是对任务按文件规划切片，不管文件多小，都会 是一个单独的切片，都会交给一个 MapTask，这样如果有大量小文件，就会产生大量的 MapTask，处理效率极其低下。</p>
<ol>
<li> 应用场景： CombineTextInputFormat 用于小文件过多的场景，它可以将多个小文件从逻辑上规划到 一个切片中，这样，多个小文件就可以交给一个 MapTask 处理。</li>
<li> 虚拟存储切片最大值设置： CombineTextInputFormat.setMaxInputSplitSize(job, 4194304);// 4m 注意：虚拟存储切片最大值设置最好根据实际的小文件大小情况来设置具体的值。 </li>
<li> 切片机制： 生成切片过程包括：虚拟存储过程和切片过程两部分。</li>
</ol>
<p>4）</p>
<img src="/2021/06/06/Hadoop%E4%B9%8BMapReduce%EF%BC%9AMapTask%E5%B9%B6%E8%A1%8C%E5%BA%A6%E5%86%B3%E5%AE%9A%E6%9C%BA%E5%88%B6/3.png" alt="image-20210531204532096" style="zoom: 67%;">



<p>（1）虚拟存储过程：</p>
<p> &ensp;&ensp;&ensp;&ensp;将输入目录下所有文件大小，依次和设置的 setMaxInputSplitSize 值比较，如果不 大于设置的最大值，逻辑上划分一个块。如果输入文件大于设置的最大值且大于两倍， 那么以最大值切割一块；当剩余数据大小超过设置的最大值且不大于最大值 2 倍，此时 将文件均分成 2 个虚拟存储块（防止出现太小切片）。 </p>
<p>&ensp;&ensp;&ensp;&ensp;例如 setMaxInputSplitSize 值为 4M，输入文件大小为 8.02M，则先逻辑上分成一个 4M。剩余的大小为 4.02M，如果按照 4M 逻辑划分，就会出现 0.02M 的小的虚拟存储 文件，所以将剩余的 4.02M 文件切分成（2.01M 和 2.01M）两个文件。 </p>
<p>（2）切片过程： </p>
<ul>
<li><p>  判断虚拟存储的文件大小是否大于 setMaxInputSplitSize 值，大于等于则单独 形成一个切片。 </p>
</li>
<li><p>  如果不大于则跟下一个虚拟存储文件进行合并，共同形成一个切片。 </p>
</li>
<li><p>测试举例：有 4 个小文件大小分别为 1.7M、5.1M、3.4M 以及 6.8M 这四个小文件，则虚拟存储之后形成 6 个文件块，大小分别为： </p>
<p>  1.7M，（2.55M、2.55M），3.4M 以及（3.4M、3.4M） </p>
<p>  最终会形成 3 个切片，大小分别为： </p>
<p>  （1.7+2.55）M，（2.55+3.4）M，（3.4+3.4）M</p>
</li>
</ul>
<h3 id="四、ReduceTask并行度的决定"><a href="#四、ReduceTask并行度的决定" class="headerlink" title="四、ReduceTask并行度的决定"></a>四、ReduceTask并行度的决定</h3><p>&ensp;&ensp;&ensp;&ensp;reducetask的并行度同样影响整个job的执行并发度和执行效率，但与maptask的并发数由切片数决定不同，Reducetask数量的决定是可以直接手动设置：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;默认值是1，手动设置为4</span><br><span class="line">job.setNumReduceTasks(4);</span><br></pre></td></tr></table></figure>

<p>&ensp;&ensp;&ensp;&ensp;如果数据分布不均匀，就有可能在reduce阶段产生数据倾斜</p>
<p>&ensp;&ensp;&ensp;&ensp;注意： reducetask数量并不是任意设置，还要考虑业务逻辑需求，有些情况下，需要计算全局汇总结果，就只能有1个reducetask</p>
<p>&ensp;&ensp;&ensp;&ensp;尽量不要运行太多的reduce task。对大多数job来说，最好rduce的个数最多和集群中的reduce持平，或者比集群的 reduce slots小。这个对于小集群而言，尤其重要。</p>
<h3 id="五、MapReduce程序演示"><a href="#五、MapReduce程序演示" class="headerlink" title="五、MapReduce程序演示"></a>五、MapReduce程序演示</h3><p>&ensp;&ensp;&ensp;&ensp;Hadoop的发布包中内置了一个hadoop-mapreduce-example-2.4.1.jar，这个jar包中有各种MR示例程序，可以通过以下步骤运行：</p>
<p>&ensp;&ensp;&ensp;&ensp;启动hdfs，yarn</p>
<p>然后在集群中的任意一台服务器上启动执行程序（比如运行wordcount）：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hadoop jar hadoop-mapreduce-example-2.4.1.jar wordcount  /wordcount/data /wordcount/out</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>数据研发</category>
        <category>Hadoop</category>
        <category>MapReduce</category>
      </categories>
      <tags>
        <tag>数据研发</tag>
        <tag>Hadoop</tag>
        <tag>MapReduce</tag>
      </tags>
  </entry>
  <entry>
    <title>shuffle运行机制</title>
    <url>/2021/06/06/Hadoop%E4%B9%8BMapReduce%EF%BC%9Ashuffle%E6%9C%BA%E5%88%B6/</url>
    <content><![CDATA[<p>    Map 方法之后，Reduce 方法之前的数据处理过程称之为 Shuffle。</p>
<span id="more"></span>

<h3 id="一、MapReduce详细工作流程"><a href="#一、MapReduce详细工作流程" class="headerlink" title="一、MapReduce详细工作流程"></a>一、MapReduce详细工作流程</h3><img src="/2021/06/06/Hadoop%E4%B9%8BMapReduce%EF%BC%9Ashuffle%E6%9C%BA%E5%88%B6/1.png" alt="image-20210531210018349" style="zoom:80%;">

<img src="/2021/06/06/Hadoop%E4%B9%8BMapReduce%EF%BC%9Ashuffle%E6%9C%BA%E5%88%B6/2.png" alt="image-20210531210054911" style="zoom: 80%;">

<p>&ensp;&ensp;&ensp;&ensp;上面的流程是整个 MapReduce 最全工作流程，但是 Shuffle 过程只是从第 7 步开始到第 16 步结束，具体 Shuffle 过程详解，如下： </p>
<p>（1）MapTask 收集我们的 map() 方法输出的 kv 对，放到内存缓冲区中 </p>
<p>（2）从内存缓冲区不断溢出本地磁盘文件，可能会溢出多个文件 </p>
<p>（3）多个溢出文件会被合并成大的溢出文件 </p>
<p>（4）在溢出过程及合并的过程中，都要调用 Partitioner 进行分区和针对 key 进行排序 </p>
<p>（5）ReduceTask 根据自己的分区号，去各个 MapTask 机器上取相应的结果分区数据 </p>
<p>（6）ReduceTask 会抓取到同一个分区的来自不同 MapTask 的结果文件，ReduceTask 会将这些文件再进行合并（归并排序） </p>
<p>（7）合并成大文件后，Shuffle 的过程也就结束了，后面进入 ReduceTask 的逻辑运算过 程（从文件中取出一个一个的键值对 Group，调用用户自定义的 reduce()方法） </p>
<p>&ensp;&ensp;&ensp;&ensp;注意：</p>
<p> &ensp;&ensp;&ensp;&ensp;（1）Shuffle 中的缓冲区大小会影响到 MapReduce 程序的执行效率，原则上说，缓冲区 越大，磁盘 io 的次数越少，执行速度就越快。 </p>
<p>&ensp;&ensp;&ensp;&ensp;（2）缓冲区的大小可以通过参数调整，参数：mapreduce.task.io.sort.mb 默认 100M。</p>
<h3 id="二、shuffle机制"><a href="#二、shuffle机制" class="headerlink" title="二、shuffle机制"></a>二、shuffle机制</h3><h4 id="2-1-概述"><a href="#2-1-概述" class="headerlink" title="2.1 概述"></a>2.1 概述</h4><ol>
<li> Map 方法之后，Reduce 方法之前的数据处理过程称之为 Shuffle；</li>
<li> mapreduce中，map阶段处理的数据如何传递给reduce阶段，是mapreduce框架中最关键的一个流程，这个流程就叫shuffle；</li>
<li> shuffle: 洗牌、发牌——（核心机制：数据分区，排序，缓存）；</li>
<li> 具体来说：就是将maptask输出的处理结果数据，分发给reducetask，并在分发的过程中，对数据按key进行了分区和排序；</li>
</ol>
<h4 id="2-2-主要流程"><a href="#2-2-主要流程" class="headerlink" title="2.2 主要流程"></a>2.2 主要流程</h4><p><img src="/2021/06/06/Hadoop%E4%B9%8BMapReduce%EF%BC%9Ashuffle%E6%9C%BA%E5%88%B6/3.png" alt="img"></p>
<p>&ensp;&ensp;&ensp;&ensp;shuffle是MR处理流程中的一个过程，它的每一个处理步骤是分散在各个map task和reduce task节点上完成的，整体来看，分为3个操作：</p>
<ol>
<li> 分区partition</li>
<li> sort根据key排序(快排)</li>
<li> Combiner进行局部value的合并</li>
</ol>
<h4 id="2-3-详细流程"><a href="#2-3-详细流程" class="headerlink" title="2.3 详细流程"></a>2.3 详细流程</h4><img src="/2021/06/06/Hadoop%E4%B9%8BMapReduce%EF%BC%9Ashuffle%E6%9C%BA%E5%88%B6/4.png" alt="image-20210601000918949" style="zoom:67%;">

<ol>
<li> maptask收集我们的map()方法输出的kv对，放到内存缓冲区中</li>
<li> 从内存缓冲区不断溢出本地磁盘文件，可能会溢出多个文件 （默认100M）</li>
<li> 多个溢出文件会被合并成大的溢出文件</li>
<li> 在溢出过程中，及合并的过程中，都要调用partitoner进行分组和针对key进行排序</li>
<li> reducetask根据自己的分区号，去各个maptask机器上取相应的结果分区数据</li>
<li> reducetask会取到同一个分区的来自不同maptask的结果文件，reducetask会将这些文件再进行合并（归并排序）</li>
<li> 合并成大文件后，shuffle的过程也就结束了，后面进入reducetask的逻辑运算过程（从文件中取出一个一个的键值对group，调用用户自定义的reduce()方法）</li>
</ol>
<p>    Shuffle中的缓冲区大小会影响到mapreduce程序的执行效率，原则上说，缓冲区越大，磁盘io的次数越少，执行速度就越快</p>
<p>    缓冲区的大小可以通过参数调整,  参数：io.sort.mb  默认100M</p>
<h4 id="2-4-Partition-分区"><a href="#2-4-Partition-分区" class="headerlink" title="2.4 Partition 分区"></a>2.4 Partition 分区</h4><p><strong>2.4.1 问题引出</strong> </p>
<p>    要求将统计结果按照条件输出到不同文件中（分区）。比如：将统计结果按照手机 归属地不同省份输出到不同文件中（分区）。</p>
<p><strong>2.4.2 默认Partitioner分区</strong> </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HashPartitioner</span> <span class="keyword">extends</span> <span class="title">Partitioner</span> </span>&#123; </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getPartition</span><span class="params">(K key, V value, <span class="keyword">int</span> numReduceTasks)</span> </span>&#123; </span><br><span class="line">        <span class="keyword">return</span> (key.hashCode() &amp; Integer.MAX_VALUE) % numReduceTasks; </span><br><span class="line">    &#125; </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p>    默认分区是根据key的hashCode对ReduceTasks个数取模得到的。用户没法控制哪个 key存储到哪个分区。</p>
<p><strong>2.4.3 自定义Partitioner步骤</strong> </p>
<p>（1）自定义类继承Partitioner，重写getPartition()方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomPartitioner</span> <span class="keyword">extends</span> <span class="title">Partitioner</span> </span>&#123; </span><br><span class="line">    <span class="meta">@Override</span> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getPartition</span><span class="params">(Text key, FlowBean value, <span class="keyword">int</span> numPartitions)</span> </span>&#123; </span><br><span class="line">        <span class="comment">// 控制分区代码逻辑 … … </span></span><br><span class="line">        <span class="keyword">return</span> partition; </span><br><span class="line">    &#125; </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p>（2）在Job驱动中，设置自定义Partitioner </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">job.setPartitionerClass(CustomPartitioner.class); </span><br></pre></td></tr></table></figure>

<p>（3）自定义Partition后，要根据自定义Partitioner的逻辑设置相应数量的ReduceTask </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">job.setNumReduceTasks(<span class="number">5</span>);</span><br></pre></td></tr></table></figure>

<p><strong>2.4.4 分区总结</strong><br>(1)如果ReduceTask的数量 &gt; getPartition的结果数，则会多产生几个空的输出文件part-r-00xx ;</p>
<p>(2)如果 1 &lt; ReduceTask的数量 &lt; getPartition的结果数，则有一部分分区数据无处安放，会Exception ;</p>
<p>(3）如果ReduceTask的数量 = 1，则不管MapTask端输出多少个分区文件，最终结果都交给这一个ReduceTask，最终也就只会产生一个结果文件part-r-O00O0;</p>
<p>(4)分区号必须从零开始，逐一累加。</p>
<p>2.3.5 案例分析</p>
<p>例如∶假设自定义分区数为5，则</p>
<p>( 1 ) job.setNumReduceTasks(1); 会正常运行，只不过会产生一个输出文件</p>
<p>( 2 ) job.setNumReduceTasks(2); 会报错</p>
<p>( 3 ) job.setNumReduceTasks(6); 大于5，程序会正常运行，会产生空文件</p>
<h4 id="2-5-WritableComparable-排序"><a href="#2-5-WritableComparable-排序" class="headerlink" title="2.5 WritableComparable 排序"></a>2.5 WritableComparable 排序</h4><p><strong>2.5.1 排序概述</strong></p>
<p>    排序是MapReduce框架中最重要的操作之一。</p>
<p>    MapTask和ReduceTask均会对数据按照key进行排序。该操作属于Hadoop的默认行为。任何应用程序中的数据均会被排序，而不管逻辑上是否需要。 </p>
<p>    默认排序是按照字典顺序排序，且实现该排序的方法是快速排序。</p>
<p>    对于MapTask ，它会将处理的结果暂时放到环形缓冲区中，当环形缓冲区使用率达到一定阈值后，再对缓冲区中的数据进行一次快速排序，并将这些有序数据溢写到磁盘上，而当数据处理完毕后，它会对磁盘上所有文件进行归并排序。</p>
<p>    对于ReduceTask，它从每个MapTask上远程拷贝相应的数据文件，如果文件大小超过一定阈值，则溢写磁盘上，否则存储在内存中。如果磁盘上文件数目达到一定阈值，则进行一次归并排序以生成一个更大文件；如果内存中文件大小或者数目超过一定阈值，则进行一次合并后将数据溢写到磁盘上。当所有数据拷贝完毕后，ReduceTask统一对内存和磁盘上的所有数据进行一次归并排序。</p>
<p><strong>2.5.2 排序分类</strong></p>
<p>(1)部分排序</p>
<p>    MapReduce根据输入记录的键对数据集排序。保证输出的每个文件内部有序。</p>
<p>(2）全排序</p>
<p>    最终输出结果只有一个文件，且文件内部有序。实现方式是只设置一个ReduceTask。但该方法在处理大型文件时效率极低，因为一台机器处理所有文件，完全丧失了MapReduce所提供的并行架构。</p>
<p>(3）辅助排序∶( GroupingComparator分组)</p>
<p>    在Reduce端对key进行分组。应用于∶在接收的key为bean对象时，想让一个或几个字段相同（全部字段比较不相同）的key进入到同一个reduce方法时，可以采用分组排序。</p>
<p>(4)二次排序</p>
<p>    在自定义排序过程中，如果compareTo中的判断条件为两个即为二次排序。</p>
<h4 id="2-6-Combiner-合并"><a href="#2-6-Combiner-合并" class="headerlink" title="2.6 Combiner 合并"></a>2.6 Combiner 合并</h4><p>( 1 )Combiner是MR程序中Mapper和Reducer之外的一种组件。</p>
<p>( 2 ) Combiner组件的父类就是Reducer。</p>
<p>( 3 )Combiner和Reducer的区别在于运行的位置</p>
<ul>
<li>  Combiner是在每一个MapTask所在的节点运行;</li>
<li>  Reducer是接收全局所有Mapper的输出结果;</li>
</ul>
<p>( 4 ) Combiner的意义就是对每一个MapTask的输出进行局部汇总，以减小网络传输量。</p>
<p>( 5 ) Combiner能够应用的前提是不能影响最终的业务逻辑，而且，Combiner的输出kv应该跟Reducer的输入kv类型要对应起来。</p>
<p><img src="/2021/06/06/Hadoop%E4%B9%8BMapReduce%EF%BC%9Ashuffle%E6%9C%BA%E5%88%B6/5.png" alt="image-20210601003344002"></p>
<p>(6）自定义Combiner 实现步骤</p>
<p>（a）自定义一个Combiner 继承Reducer，重写Reduce方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WordCountCombiner</span> <span class="keyword">extends</span> <span class="title">Reducer</span>&lt;<span class="title">Text</span>, <span class="title">IntWritable</span>, <span class="title">Text</span>, <span class="title">IntWritable</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> IntWritable outV = <span class="keyword">new</span> IntWritable();</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">reduce</span><span class="params">(Text key, Iterable&lt;IntWritable&gt; values, Context context)</span> <span class="keyword">throws</span> IOException, InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (IntWritable value : values) &#123;</span><br><span class="line">    sum += value.get();</span><br><span class="line">    &#125; </span><br><span class="line">    outV.set(sum);</span><br><span class="line">    context.write(key,outV);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（b）在 Job 驱动类中设置： </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">job.setCombinerClass(WordCountCombiner.class);</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>数据研发</category>
        <category>Hadoop</category>
        <category>MapReduce</category>
      </categories>
      <tags>
        <tag>数据研发</tag>
        <tag>Hadoop</tag>
        <tag>MapReduce</tag>
        <tag>shuffle</tag>
      </tags>
  </entry>
  <entry>
    <title>MapReduce环境配置与案例实操</title>
    <url>/2021/06/06/Hadoop%E4%B9%8BMapReduce%EF%BC%9A%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE%E4%B8%8E%E6%A1%88%E4%BE%8B%E5%AE%9E%E6%93%8D/</url>
    <content><![CDATA[<h3 id="一、WordCount-案例实操"><a href="#一、WordCount-案例实操" class="headerlink" title="一、WordCount 案例实操"></a>一、WordCount 案例实操</h3><h4 id="1）需求"><a href="#1）需求" class="headerlink" title="1）需求"></a>1）需求</h4><p>&ensp;&ensp;&ensp;&ensp;在给定的文本文件中统计输出每一个单词出现的总次数 </p>
<span id="more"></span>

<p>（1）输入数据 hello.txt </p>
<p>（2）期望输出数据 atguigu 2 banzhang 1 cls 2 hadoop 1 jiao 1 ss 2 xue 1 </p>
<h4 id="2）需求分析"><a href="#2）需求分析" class="headerlink" title="2）需求分析"></a>2）需求分析</h4><p>&ensp;&ensp;&ensp;&ensp;按照 MapReduce 编程规范，分别编写 Mapper，Reducer，Driver</p>
<img src="/2021/06/06/Hadoop%E4%B9%8BMapReduce%EF%BC%9A%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE%E4%B8%8E%E6%A1%88%E4%BE%8B%E5%AE%9E%E6%93%8D/1.png" alt="image-20210525010300155" style="zoom: 50%;">



<h3 id="二、环境准备"><a href="#二、环境准备" class="headerlink" title="二、环境准备"></a>二、环境准备</h3><p>（1）创建 maven 工程，MapReduceDemo </p>
<p>（2）在 pom.xml 文件中添加如下依赖</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.hadoop<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>hadoop-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.1.3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.12<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.slf4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>slf4j-log4j12<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.7.30<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>（3）在项目的 src/main/resources 目录下，新建一个文件，命名为“log4j.properties”，在 文件中填入。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">log4j.rootLogger&#x3D;INFO, stdout </span><br><span class="line">log4j.appender.stdout&#x3D;org.apache.log4j.ConsoleAppender </span><br><span class="line">log4j.appender.stdout.layout&#x3D;org.apache.log4j.PatternLayout </span><br><span class="line">log4j.appender.stdout.layout.ConversionPattern&#x3D;%d %p [%c] - %m%n </span><br><span class="line">log4j.appender.logfile&#x3D;org.apache.log4j.FileAppender </span><br><span class="line">log4j.appender.logfile.File&#x3D;target&#x2F;spring.log </span><br><span class="line">log4j.appender.logfile.layout&#x3D;org.apache.log4j.PatternLayout </span><br><span class="line">log4j.appender.logfile.layout.ConversionPattern&#x3D;%d %p [%c] - %m%n</span><br></pre></td></tr></table></figure>

<p>（4）创建包名：com.james.mapreduce.wordcount</p>
<h3 id="三、编写程序运行"><a href="#三、编写程序运行" class="headerlink" title="三、编写程序运行"></a>三、编写程序运行</h3><p>（1）编写 Mapper 类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.mapreduce.wordcount;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.io.IntWritable;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.io.LongWritable;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.io.Text;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.mapreduce.Mapper;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WordCountMapper</span> <span class="keyword">extends</span> <span class="title">Mapper</span>&lt;<span class="title">LongWritable</span>, <span class="title">Text</span>, <span class="title">Text</span>, </span></span><br><span class="line"><span class="class"><span class="title">IntWritable</span>&gt;</span>&#123;</span><br><span class="line">    Text k = <span class="keyword">new</span> Text();</span><br><span class="line">    IntWritable v = <span class="keyword">new</span> IntWritable(<span class="number">1</span>);</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">map</span><span class="params">(LongWritable key, Text value, Context context)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> IOException, InterruptedException </span>&#123;</span><br><span class="line">        <span class="comment">// 1 获取一行</span></span><br><span class="line">        String line = value.toString();</span><br><span class="line">        <span class="comment">// 2 切割</span></span><br><span class="line">        String[] words = line.split(<span class="string">&quot; &quot;</span>);</span><br><span class="line">        <span class="comment">// 3 输出</span></span><br><span class="line">        <span class="keyword">for</span> (String word : words) &#123;</span><br><span class="line">            k.set(word);</span><br><span class="line">            context.write(k, v);	</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>（2）编写 Reducer 类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.mapreduce.wordcount;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.io.IntWritable;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.io.Text;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.mapreduce.Reducer;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WordCountReducer</span> <span class="keyword">extends</span> <span class="title">Reducer</span>&lt;<span class="title">Text</span>, <span class="title">IntWritable</span>, <span class="title">Text</span>, </span></span><br><span class="line"><span class="class"><span class="title">IntWritable</span>&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sum;</span><br><span class="line">    IntWritable v = <span class="keyword">new</span> IntWritable();</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">reduce</span><span class="params">(Text key, Iterable&lt;IntWritable&gt; values,Context </span></span></span><br><span class="line"><span class="function"><span class="params">    context)</span> <span class="keyword">throws</span> IOException, InterruptedException </span>&#123;</span><br><span class="line">        <span class="comment">// 1 累加求和</span></span><br><span class="line">        sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (IntWritable count : values) &#123;</span><br><span class="line">        	sum += count.get();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 2 输出</span></span><br><span class="line">        v.set(sum);</span><br><span class="line">        context.write(key,v);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（3）编写 Driver 驱动类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.mapreduce.wordcount;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.conf.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.fs.Path;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.io.IntWritable;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.io.Text;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.mapreduce.Job;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.mapreduce.lib.input.FileInputFormat;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.mapreduce.lib.output.FileOutputFormat;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WordCountDriver</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, </span></span><br><span class="line"><span class="function">    ClassNotFoundException, InterruptedException </span>&#123;</span><br><span class="line">        <span class="comment">// 1 获取配置信息以及获取 job 对象</span></span><br><span class="line">        Configuration conf = <span class="keyword">new</span> Configuration();</span><br><span class="line">        Job job = Job.getInstance(conf);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 2 关联本 Driver 程序的 jar</span></span><br><span class="line">        job.setJarByClass(WordCountDriver.class);</span><br><span class="line">       </span><br><span class="line">        <span class="comment">// 3 关联 Mapper 和 Reducer 的 jar</span></span><br><span class="line">        job.setMapperClass(WordCountMapper.class);</span><br><span class="line">        job.setReducerClass(WordCountReducer.class);</span><br><span class="line">       </span><br><span class="line">        <span class="comment">// 4 设置 Mapper 输出的 kv 类型</span></span><br><span class="line">        job.setMapOutputKeyClass(Text.class);</span><br><span class="line">        job.setMapOutputValueClass(IntWritable.class);</span><br><span class="line">       </span><br><span class="line">        <span class="comment">// 5 设置最终输出 kv 类型</span></span><br><span class="line">        job.setOutputKeyClass(Text.class);</span><br><span class="line">        job.setOutputValueClass(IntWritable.class);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 6 设置输入和输出路径</span></span><br><span class="line">        FileInputFormat.setInputPaths(job, <span class="keyword">new</span> Path(args[<span class="number">0</span>]));</span><br><span class="line">        FileOutputFormat.setOutputPath(job, <span class="keyword">new</span> Path(args[<span class="number">1</span>]));</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 7 提交 job</span></span><br><span class="line">        <span class="keyword">boolean</span> result = job.waitForCompletion(<span class="keyword">true</span>);</span><br><span class="line">        System.exit(result ? <span class="number">0</span> : <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>本地测试 </p>
<p>（1）需要首先配置好 HADOOP_HOME 变量以及 Windows 运行依赖 </p>
<p>（2）在 IDEA/Eclipse 上运行程序</p>
<h3 id="四、提交到集群测试"><a href="#四、提交到集群测试" class="headerlink" title="四、提交到集群测试"></a>四、提交到集群测试</h3><p>（1）用 maven 打 jar 包，需要添加的打包插件依赖</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-compiler-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.6.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">source</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">source</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">target</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">target</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-assembly-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">descriptorRefs</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">descriptorRef</span>&gt;</span>jar-with-dependencies<span class="tag">&lt;/<span class="name">descriptorRef</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">descriptorRefs</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">executions</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">execution</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">id</span>&gt;</span>make-assembly<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">phase</span>&gt;</span>package<span class="tag">&lt;/<span class="name">phase</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">goals</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">goal</span>&gt;</span>single<span class="tag">&lt;/<span class="name">goal</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">goals</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">execution</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">executions</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>注意：如果工程上显示红叉。在项目上右键-&gt;maven-&gt;Reimport 刷新即可。</p>
<p>（2）将程序打成 jar 包</p>
<p><img src="/2021/06/06/Hadoop%E4%B9%8BMapReduce%EF%BC%9A%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE%E4%B8%8E%E6%A1%88%E4%BE%8B%E5%AE%9E%E6%93%8D/2.png" alt="image-20210525011017523"></p>
<p>（3）修改不带依赖的 jar 包名称为 wc.jar，并拷贝该 jar 包到 Hadoop 集群的 /opt/module/hadoop-3.1.3 路径。 </p>
<p>（4）启动 Hadoop 集群</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[atguigu@hadoop102 hadoop-3.1.3]sbin/start-dfs.sh</span><br><span class="line">[atguigu@hadoop103 hadoop-3.1.3]$ sbin/start-yarn.sh </span><br></pre></td></tr></table></figure>

<p>（5）执行 WordCount 程序</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[atguigu@hadoop102 hadoop-3.1.3]$ hadoop jar wc.jar com.atguigu.mapreduce.wordcount.WordCountDriver /user/atguigu/input  /user/atguigu/output</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>数据研发</category>
        <category>Hadoop</category>
        <category>MapReduce</category>
      </categories>
      <tags>
        <tag>数据研发</tag>
        <tag>Hadoop</tag>
        <tag>MapReduce</tag>
      </tags>
  </entry>
  <entry>
    <title>LFU缓存算法</title>
    <url>/2021/06/06/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%9ALFU%E7%BC%93%E5%AD%98/</url>
    <content><![CDATA[<h3 id="一、LFU简介"><a href="#一、LFU简介" class="headerlink" title="一、LFU简介"></a>一、LFU简介</h3><p>    LFU（Least Frequently Used）算法根据数据的历史访问频率来淘汰数据，其核心思想是“如果数据过去被访问多次，那么将来被访问的频率也更高”。</p>
<span id="more"></span>

<p>    LFU的每个数据块都有一个引用计数，所有数据块按照引用计数排序，具有相同引用计数的数据块则按照时间排序。</p>
<ol>
<li><p> 新加入数据插入到队列尾部（因为引用计数为1）；</p>
</li>
<li><p> 队列中的数据被访问后，引用计数增加，队列重新排序；</p>
</li>
<li><p> 当需要淘汰数据时，将已经排序的列表最后的数据块删除。</p>
</li>
</ol>
<h3 id="二、LFU设计"><a href="#二、LFU设计" class="headerlink" title="二、LFU设计"></a>二、LFU设计</h3><p><strong>题目：</strong></p>
<blockquote>
<p>请你为 <a href="https://baike.baidu.com/item/%E7%BC%93%E5%AD%98%E7%AE%97%E6%B3%95">最不经常使用（LFU）</a>缓存算法设计并实现数据结构。</p>
<p>实现 <code>LFUCache</code> 类：</p>
<ul>
<li>  <code>LFUCache(int capacity)</code> - 用数据结构的容量 <code>capacity</code> 初始化对象</li>
<li>  <code>int get(int key)</code> - 如果键存在于缓存中，则获取键的值，否则返回 -1。</li>
<li>  <code>void put(int key, int value)</code> - 如果键已存在，则变更其值；如果键不存在，请插入键值对。当缓存达到其容量时，则应该在插入新项之前，使最不经常使用的项无效。在此问题中，当存在平局（即两个或更多个键具有相同使用频率）时，应该去除 <strong>最久未使用</strong> 的键。</li>
</ul>
<p><strong>注意</strong>「项的使用次数」就是自插入该项以来对其调用 <code>get</code> 和 <code>put</code> 函数的次数之和。使用次数会在对应项被移除后置为 0 。</p>
<p>为了确定最不常使用的键，可以为缓存中的每个键维护一个 <strong>使用计数器</strong> 。使用计数最小的键是最久未使用的键。</p>
<p>当一个键首次插入到缓存中时，它的使用计数器被设置为 <code>1</code> (由于 put 操作)。对缓存中的键执行 <code>get</code> 或 <code>put</code> 操作，使用计数器的值将会递增。</p>
<p><strong>提示：</strong></p>
<ul>
<li>  <code>0 &lt;= capacity, key, value &lt;= 104</code></li>
<li>  最多调用 <code>105</code> 次 <code>get</code> 和 <code>put</code> 方法</li>
</ul>
<p><strong>进阶：</strong>你可以为这两种操作设计时间复杂度为 <code>O(1)</code> 的实现吗？</p>
</blockquote>
<p><strong>例：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：</span><br><span class="line">[&quot;LFUCache&quot;, &quot;put&quot;, &quot;put&quot;, &quot;get&quot;, &quot;put&quot;, &quot;get&quot;, &quot;get&quot;, &quot;put&quot;, &quot;get&quot;, &quot;get&quot;, &quot;get&quot;]</span><br><span class="line">[[2], [1, 1], [2, 2], [1], [3, 3], [2], [3], [4, 4], [1], [3], [4]]</span><br><span class="line">输出：</span><br><span class="line">[null, null, null, 1, null, -1, 3, null, -1, 3, 4]</span><br><span class="line"></span><br><span class="line">解释：</span><br><span class="line">&#x2F;&#x2F; cnt(x) &#x3D; 键 x 的使用计数</span><br><span class="line">&#x2F;&#x2F; cache&#x3D;[] 将显示最后一次使用的顺序（最左边的元素是最近的）</span><br><span class="line">LFUCache lFUCache &#x3D; new LFUCache(2);</span><br><span class="line">lFUCache.put(1, 1);   &#x2F;&#x2F; cache&#x3D;[1,_], cnt(1)&#x3D;1</span><br><span class="line">lFUCache.put(2, 2);   &#x2F;&#x2F; cache&#x3D;[2,1], cnt(2)&#x3D;1, cnt(1)&#x3D;1</span><br><span class="line">lFUCache.get(1);      &#x2F;&#x2F; 返回 1</span><br><span class="line">                      &#x2F;&#x2F; cache&#x3D;[1,2], cnt(2)&#x3D;1, cnt(1)&#x3D;2</span><br><span class="line">lFUCache.put(3, 3);   &#x2F;&#x2F; 去除键 2 ，因为 cnt(2)&#x3D;1 ，使用计数最小</span><br><span class="line">                      &#x2F;&#x2F; cache&#x3D;[3,1], cnt(3)&#x3D;1, cnt(1)&#x3D;2</span><br><span class="line">lFUCache.get(2);      &#x2F;&#x2F; 返回 -1（未找到）</span><br><span class="line">lFUCache.get(3);      &#x2F;&#x2F; 返回 3</span><br><span class="line">                      &#x2F;&#x2F; cache&#x3D;[3,1], cnt(3)&#x3D;2, cnt(1)&#x3D;2</span><br><span class="line">lFUCache.put(4, 4);   &#x2F;&#x2F; 去除键 1 ，1 和 3 的 cnt 相同，但 1 最久未使用</span><br><span class="line">                      &#x2F;&#x2F; cache&#x3D;[4,3], cnt(4)&#x3D;1, cnt(3)&#x3D;2</span><br><span class="line">lFUCache.get(1);      &#x2F;&#x2F; 返回 -1（未找到）</span><br><span class="line">lFUCache.get(3);      &#x2F;&#x2F; 返回 3</span><br><span class="line">                      &#x2F;&#x2F; cache&#x3D;[3,4], cnt(4)&#x3D;1, cnt(3)&#x3D;3</span><br><span class="line">lFUCache.get(4);      &#x2F;&#x2F; 返回 4</span><br><span class="line">                      &#x2F;&#x2F; cache&#x3D;[3,4], cnt(4)&#x3D;2, cnt(3)&#x3D;3</span><br></pre></td></tr></table></figure>

<p><strong>设计思路：</strong></p>
<p>    我们定义两个哈希表，第一个 freq_table 以频率 freq 为索引，每个索引存放一个双向链表，这个链表里存放所有使用频率为 freq 的缓存，缓存里存放三个信息，分别为键 key，值 value，以及使用频率 freq。第二个 key_table 以键值 key 为索引，每个索引存放对应缓存在 freq_table 中链表里的内存地址，这样我们就能利用两个哈希表来使得两个操作的时间复杂度均为 O(1)O(1)。同时需要记录一个当前缓存最少使用的频率 minFreq，这是为了删除操作服务的。</p>
<p>    对于 get(key) 操作，我们能通过索引 key 在 key_table 中找到缓存在 freq_table 中的链表的内存地址，如果不存在直接返回 -1，否则我们能获取到对应缓存的相关信息，这样我们就能知道缓存的键值还有使用频率，直接返回 key 对应的值即可。</p>
<p>    但是我们注意到 get 操作后这个缓存的使用频率加一了，所以我们需要更新缓存在哈希表 freq_table 中的位置。已知这个缓存的键 key，值 value，以及使用频率 freq，那么该缓存应该存放到 freq_table 中 freq + 1 索引下的链表中。所以我们在当前链表中 O(1)O(1) 删除该缓存对应的节点，根据情况更新 minFreq 值，然后将其O(1)O(1) 插入到 freq + 1 索引下的链表头完成更新。这其中的操作复杂度均为 O(1)O(1)。你可能会疑惑更新的时候为什么是插入到链表头，这其实是为了保证缓存在当前链表中从链表头到链表尾的插入时间是有序的，为下面的删除操作服务。</p>
<p>    对于 put(key, value) 操作，我们先通过索引 key在 key_table 中查看是否有对应的缓存，如果有的话，其实操作等价于 get(key) 操作，唯一的区别就是我们需要将当前的缓存里的值更新为 value。如果没有的话，相当于是新加入的缓存，如果缓存已经到达容量，需要先删除最近最少使用的缓存，再进行插入。</p>
<p>    先考虑插入，由于是新插入的，所以缓存的使用频率一定是 1，所以我们将缓存的信息插入到 freq_table 中 1 索引下的列表头即可，同时更新 key_table[key] 的信息，以及更新 minFreq = 1。</p>
<p>    那么剩下的就是删除操作了，由于我们实时维护了 minFreq，所以我们能够知道 freq_table 里目前最少使用频率的索引，同时因为我们保证了链表中从链表头到链表尾的插入时间是有序的，所以 freq_table[minFreq] 的链表中链表尾的节点即为使用频率最小且插入时间最早的节点，我们删除它同时根据情况更新 minFreq ，整个时间复杂度均为 O(1)。</p>
<p><strong>代码：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 缓存的节点信息</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> key, val, freq;</span><br><span class="line">    <span class="built_in">Node</span>(<span class="keyword">int</span> _key,<span class="keyword">int</span> _val,<span class="keyword">int</span> _freq): <span class="built_in">key</span>(_key), <span class="built_in">val</span>(_val), <span class="built_in">freq</span>(_freq)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LFUCache</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> minfreq, capacity;</span><br><span class="line">    unordered_map&lt;<span class="keyword">int</span>, list&lt;Node&gt;::iterator&gt; key_table;</span><br><span class="line">    unordered_map&lt;<span class="keyword">int</span>, list&lt;Node&gt;&gt; freq_table;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">LFUCache</span>(<span class="keyword">int</span> _capacity) </span><br><span class="line">    &#123;</span><br><span class="line">        minfreq = <span class="number">0</span>;</span><br><span class="line">        capacity = _capacity;</span><br><span class="line">        key_table.<span class="built_in">clear</span>();</span><br><span class="line">        freq_table.<span class="built_in">clear</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> key)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (capacity == <span class="number">0</span>) </span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">auto</span> it = key_table.<span class="built_in">find</span>(key);</span><br><span class="line">        <span class="keyword">if</span> (it == key_table.<span class="built_in">end</span>()) </span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        </span><br><span class="line">        list&lt;Node&gt;::iterator node = it -&gt; second;</span><br><span class="line">        <span class="keyword">int</span> val = node -&gt; val, freq = node -&gt; freq;</span><br><span class="line">        freq_table[freq].<span class="built_in">erase</span>(node);</span><br><span class="line">        <span class="comment">// 如果当前链表为空，我们需要在哈希表中删除，且更新minFreq</span></span><br><span class="line">        <span class="keyword">if</span> (freq_table[freq].<span class="built_in">size</span>() == <span class="number">0</span>) </span><br><span class="line">        &#123;</span><br><span class="line">            freq_table.<span class="built_in">erase</span>(freq);</span><br><span class="line">            <span class="keyword">if</span> (minfreq == freq) minfreq += <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 插入到 freq + 1 中</span></span><br><span class="line">        freq_table[freq + <span class="number">1</span>].<span class="built_in">push_front</span>(<span class="built_in">Node</span>(key, val, freq + <span class="number">1</span>));</span><br><span class="line">        key_table[key] = freq_table[freq + <span class="number">1</span>].<span class="built_in">begin</span>();</span><br><span class="line">        <span class="keyword">return</span> val;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">put</span><span class="params">(<span class="keyword">int</span> key, <span class="keyword">int</span> value)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (capacity == <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">auto</span> it = key_table.<span class="built_in">find</span>(key);</span><br><span class="line">        <span class="keyword">if</span> (it == key_table.<span class="built_in">end</span>()) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 缓存已满，需要进行删除操作</span></span><br><span class="line">            <span class="keyword">if</span> (key_table.<span class="built_in">size</span>() == capacity) </span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 通过 minFreq 拿到 freq_table[minFreq] 链表的末尾节点</span></span><br><span class="line">                <span class="keyword">auto</span> it2 = freq_table[minfreq].<span class="built_in">back</span>();</span><br><span class="line">                key_table.<span class="built_in">erase</span>(it2.key);</span><br><span class="line">                freq_table[minfreq].<span class="built_in">pop_back</span>();</span><br><span class="line">                <span class="keyword">if</span> (freq_table[minfreq].<span class="built_in">size</span>() == <span class="number">0</span>) </span><br><span class="line">                &#123;</span><br><span class="line">                    freq_table.<span class="built_in">erase</span>(minfreq);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; </span><br><span class="line">            freq_table[<span class="number">1</span>].<span class="built_in">push_front</span>(<span class="built_in">Node</span>(key, value, <span class="number">1</span>));</span><br><span class="line">            key_table[key] = freq_table[<span class="number">1</span>].<span class="built_in">begin</span>();</span><br><span class="line">            minfreq = <span class="number">1</span>;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 与 get 操作基本一致，除了需要更新缓存的值</span></span><br><span class="line">            list&lt;Node&gt;::iterator node = it -&gt; second;</span><br><span class="line">            <span class="keyword">int</span> freq = node -&gt; freq;</span><br><span class="line">            freq_table[freq].<span class="built_in">erase</span>(node);</span><br><span class="line">            <span class="keyword">if</span> (freq_table[freq].<span class="built_in">size</span>() == <span class="number">0</span>) </span><br><span class="line">            &#123;</span><br><span class="line">                freq_table.<span class="built_in">erase</span>(freq);</span><br><span class="line">                <span class="keyword">if</span> (minfreq == freq) minfreq += <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            freq_table[freq + <span class="number">1</span>].<span class="built_in">push_front</span>(<span class="built_in">Node</span>(key, value, freq + <span class="number">1</span>));</span><br><span class="line">            key_table[key] = freq_table[freq + <span class="number">1</span>].<span class="built_in">begin</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<p><a href="https://mp.weixin.qq.com/s?__biz=MzAxODQxMDM0Mw==&mid=2247486545&idx=1&sn=315ebfafa82c0dd3bcd9197eb270a7b6&chksm=9bd7f259aca07b4f063778509b3803993bc0d6cdaff32c076a102547b0afb82a5eea6119ed1a&cur_album_id=1318892385270808576&scene=189#rd">算法题就像搭乐高：手把手带你拆解 LFU 算法 (qq.com)</a></p>
<p><a href="https://leetcode-cn.com/problems/lfu-cache/solution/lfuhuan-cun-by-leetcode-solution/">LFU缓存 - LFU 缓存 - 力扣（LeetCode） (leetcode-cn.com)</a></p>
]]></content>
      <categories>
        <category>算法</category>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>链表</tag>
        <tag>数据结构</tag>
        <tag>哈希图</tag>
        <tag>LFU缓存</tag>
      </tags>
  </entry>
  <entry>
    <title>LRU缓存算法</title>
    <url>/2021/06/06/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%9ALRU%E7%BC%93%E5%AD%98/</url>
    <content><![CDATA[<h3 id="一、LRU简介"><a href="#一、LRU简介" class="headerlink" title="一、LRU简介"></a>一、LRU简介</h3><p>&ensp;&ensp;&ensp;&ensp;LRU算法全称是最近最少使用算法（Least Recently Use），广泛的应用于缓存机制中。当缓存使用的空间达到上限后，就需要从已有的数据中淘汰一部分以维持缓存的可用性，而淘汰数据的选择就是通过LRU算法完成的。</p>
<span id="more"></span>

<p>&ensp;&ensp;&ensp;&ensp;LRU算法的基本思想是基于局部性原理的时间局部性：</p>
<blockquote>
<p>  如果一个信息项正在被访问，那么在近期它很可能还会被再次访问。</p>
</blockquote>
<p>&ensp;&ensp;&ensp;&ensp;所以顾名思义，LRU算法会选出最近最少使用的数据进行淘汰。</p>
<p><strong>原理：</strong></p>
<p>&ensp;&ensp;&ensp;&ensp;一般来讲，LRU将访问数据的顺序或时间和数据本身维护在一个容器当中。当访问一个数据时：</p>
<ol>
<li> 该数据不在容器当中，则设置该数据的优先级为最高并放入容器中。</li>
<li> 该数据在容器当中，则更新该数据的优先级至最高。</li>
</ol>
<p>&ensp;&ensp;&ensp;&ensp;当数据的总量达到上限后，则移除容器中优先级最低的数据。下图是一个简单的LRU原理示意图：</p>
<p><img src="/2021/06/06/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%9ALRU%E7%BC%93%E5%AD%98/1.png" alt="LRU原理示意图.jpg"></p>
<p>&ensp;&ensp;&ensp;&ensp;如果我们按照<code>7 0 1 2 0 3 0 4</code>的顺序来访问数据，且数据的总量上限为3，则如上图所示，LRU算法会依次淘汰<code>7 1 2</code>这三个数据。</p>
<h3 id="二、设计LRU"><a href="#二、设计LRU" class="headerlink" title="二、设计LRU"></a>二、设计LRU</h3><p><strong>题目：</strong></p>
<blockquote>
<p>&ensp;&ensp;&ensp;&ensp;运用你所掌握的数据结构，设计和实现一个 <a href="https://baike.baidu.com/item/LRU">LRU (最近最少使用) 缓存机制</a> 。</p>
<p>实现 <code>LRUCache</code> 类：</p>
<ul>
<li>  <code>LRUCache(int capacity)</code> 以正整数作为容量 <code>capacity</code> 初始化 LRU 缓存</li>
<li>  <code>int get(int key)</code> 如果关键字 <code>key</code> 存在于缓存中，则返回关键字的值，否则返回 <code>-1</code> 。</li>
<li>  <code>void put(int key, int value)</code> 如果关键字已经存在，则变更其数据值；如果关键字不存在，则插入该组「关键字-值」。当缓存容量达到上限时，它应该在写入新数据之前删除最久未使用的数据值，从而为新的数据值留出空间。</li>
</ul>
<p><strong>进阶</strong>：你是否可以在 <code>O(1)</code> 时间复杂度内完成这两种操作？</p>
<p><strong>提示：</strong></p>
<ul>
<li>  <code>1 &lt;= capacity &lt;= 3000</code></li>
<li>  <code>0 &lt;= key &lt;= 3000</code></li>
<li>  <code>0 &lt;= value &lt;= 104</code></li>
<li>  最多调用 <code>3 * 104</code> 次 <code>get</code> 和 <code>put</code></li>
</ul>
</blockquote>
<p><strong>设计思路：</strong></p>
<p>&ensp;&ensp;&ensp;&ensp;1、显然 <code>cache</code> 中的元素必须有时序，以区分最近使用的和久未使用的数据，当容量满了之后要删除最久未使用的那个元素腾位置。</p>
<p>&ensp;&ensp;&ensp;&ensp;2、我们要在 <code>cache</code> 中快速找某个 <code>key</code> 是否已存在并得到对应的 <code>val</code>；</p>
<p>&ensp;&ensp;&ensp;&ensp;3、每次访问 <code>cache</code> 中的某个 <code>key</code>，需要将这个元素变为最近使用的，也就是说 <code>cache</code> 要支持在任意位置快速插入和删除元素。</p>
<p>&ensp;&ensp;&ensp;&ensp;LRU 缓存算法的核心数据结构就是哈希链表，双向链表和哈希表的结合体。这个数据结构长这样：</p>
<img src="/2021/06/06/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%9ALRU%E7%BC%93%E5%AD%98/2.png" alt="image-20210322145136153" style="zoom:50%;">

<p>&ensp;&ensp;&ensp;&ensp;1、如果我们每次默认从链表尾部添加元素，那么显然越靠尾部的元素就是最近使用的，越靠头部的元素就是最久未使用的。</p>
<p>&ensp;&ensp;&ensp;&ensp;2、对于某一个 <code>key</code>，我们可以通过哈希表快速定位到链表中的节点，从而取得对应 <code>val</code>。</p>
<p>&ensp;&ensp;&ensp;&ensp;3、链表显然是支持在任意位置快速插入和删除的，改改指针就行。只不过传统的链表无法按照索引快速访问某一个位置的元素，而这里借助哈希表，可以通过 <code>key</code> 快速映射到任意一个链表节点，然后进行插入和删除。</p>
<blockquote>
<p>对于 get 操作，首先判断 key 是否存在：</p>
<p>​    如果 key 不存在，则返回 -1−1；</p>
<p>​    如果 key 存在，则 key 对应的节点是最近被使用的节点。通过哈希表定位到该节点在双向链表中的位置，并将其移动到双向链表的头部，最后返回该节点的值。</p>
<p>对于 put 操作，首先判断 key 是否存在：</p>
<p>​    如果 key 不存在，使用 key 和 value 创建一个新的节点，在双向链表的头部添加该节点，并将 key 和该节点添加进哈希表中。然后判断双向链表的节点数是否超出容量，如果超出容量，则删除双向链表的尾部节点，并删除哈希表中对应的项；</p>
<p>​    如果 key 存在，则与 get 操作类似，先通过哈希表定位，再将对应的节点的值更新为 value，并将该节点移到双向链表的头部。</p>
</blockquote>
<p>代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LRUCache</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">LRUCache</span>(<span class="keyword">int</span> capacity) : _capacity(capacity) &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> key)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> it = _hashTable.<span class="built_in">find</span>(key);</span><br><span class="line">        <span class="keyword">if</span>(it != _hashTable.<span class="built_in">end</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            _list.<span class="built_in">splice</span>(_list.<span class="built_in">begin</span>(), _list, it-&gt;second);</span><br><span class="line">            <span class="keyword">return</span> it-&gt;second-&gt;second;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">put</span><span class="params">(<span class="keyword">int</span> key, <span class="keyword">int</span> value)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// it 为 key 对应的迭代器（链表的），即 map 的 value</span></span><br><span class="line">        <span class="keyword">auto</span> it = _hashTable.<span class="built_in">find</span>(key);</span><br><span class="line">        <span class="keyword">if</span>(it != _hashTable.<span class="built_in">end</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            _list.<span class="built_in">splice</span>(_list.<span class="built_in">begin</span>(), _list, it-&gt;second);</span><br><span class="line">            it-&gt;second-&gt;second = value;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        _list.<span class="built_in">emplace_front</span>(key,value);</span><br><span class="line">        _hashTable[key] = _list.<span class="built_in">begin</span>();</span><br><span class="line">        <span class="keyword">if</span>(_hashTable.<span class="built_in">size</span>() &gt; _capacity)</span><br><span class="line">        &#123;</span><br><span class="line">            _hashTable.<span class="built_in">erase</span>(_list.<span class="built_in">back</span>().first);</span><br><span class="line">            _list.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    unordered_map&lt;<span class="keyword">int</span>, list&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt;::iterator&gt; _hashTable;</span><br><span class="line">    list&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; _list;</span><br><span class="line">    <span class="keyword">int</span> _capacity;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your LRUCache object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * LRUCache* obj = new LRUCache(capacity);</span></span><br><span class="line"><span class="comment"> * int param_1 = obj-&gt;get(key);</span></span><br><span class="line"><span class="comment"> * obj-&gt;put(key,value);</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

<p>&ensp;&ensp;&ensp;&ensp;这里主要需要好好理解list的splice这个方法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void splice (iterator position, list&amp; x, iterator i);</span><br></pre></td></tr></table></figure>

<p>&ensp;&ensp;&ensp;&ensp;简单来说就是把 x 这个 list 的 i 处元素插入到 position 的位置。</p>
<p><a href="https://mp.weixin.qq.com/s?__biz=MzAxODQxMDM0Mw==&mid=2247486428&idx=1&sn=3611a14535669ba3372c73e24121247c&chksm=9bd7f5d4aca07cc28c02c3411d0633fc12c94c2555c08cbfaa2ccd50cc2d25160fb23bccce7f&scene=21#wechat_redirect">手把手带你拆解 LRU 算法</a></p>
<p><a href="https://juejin.cn/post/6844904049263771662">LRU算法及其优化策略——算法篇 (juejin.cn)</a></p>
]]></content>
      <categories>
        <category>算法</category>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>链表</tag>
        <tag>数据结构</tag>
        <tag>哈希图</tag>
        <tag>LRU缓存</tag>
      </tags>
  </entry>
  <entry>
    <title>0-1背包系列问题详解</title>
    <url>/2021/06/12/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%EF%BC%9A0-1%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h3 id="一、问题描述："><a href="#一、问题描述：" class="headerlink" title="一、问题描述："></a>一、问题描述：</h3><p>&ensp;&ensp;&ensp;&ensp;有 n 个物品，它们有各自的重量和价值，现有给定容量(m)的背包，如何让背包里装入的物品具有最大的价值总和？</p>
<span id="more"></span>

<h3 id="二、思路与过程"><a href="#二、思路与过程" class="headerlink" title="二、思路与过程"></a>二、思路与过程</h3><p>&ensp;&ensp;&ensp;&ensp;先将原始问题一般化，欲求背包能够获得的总价值，即欲求前 <code>i </code>个物体放入容量为 <code>j</code> 背包的最大价值<code>dp[i][j]</code>——使用一个数组来存储最大价值，当 <code>j</code> 取背包最大容量，<code>i</code> 取物品个数时，即原始问题了。而前<code>i</code>个物体放入容量为<code> j</code> 的背包，又可以转化成前 <code>(i - 1) </code>个物体放入背包的问题。下面使用数学表达式描述它们两者之间的具体关系。</p>
<p>表达式中各个符号的具体含义：</p>
<ul>
<li>  w[i] : 第<code>i</code>个物体的重量；</li>
<li>  v[i] : 第<code>i</code>个物体的价值；</li>
<li>  dp[i][j] ： 前<code>i</code>个物体放入容量为<code>j</code>的背包的最大价值；</li>
<li>  dp[i-1][j] ： 前<code>i-1</code>个物体放入容量为<code>j</code>的背包的最大价值；</li>
<li>  dp[i-1][j-w[i]] ： 前<code>i-1</code>个物体放入容量为<code>j-w[i]</code>的背包的最大价值；</li>
</ul>
<p>由此可得状态转移方程：<br>　　 　dp[i][j] = max{dp[i - 1][j - w[i]] + v[i] , dp[i - 1][j]}</p>
<p><strong>解释：</strong></p>
<p>&ensp;&ensp;&ensp;&ensp;第一，包的容量比该商品体积小，装不下，此时的价值与前<code>i-1</code>个的价值是一样的，即<code>dp[i][j] = dp[i - 1][j]</code>；</p>
<p>&ensp;&ensp;&ensp;&ensp;第二，还有足够的容量可以装该商品，但装了也不一定达到当前最优价值，所以在装与不装之间选择最优的一个，即 <code>dp[i][j] = max｛dp[i - 1][j]，dp[i-1][j-w[i]]+v[i]｝</code>其中<code>dp[i-1][j]</code>表示不装，<code>dp[i-1][j-w[i]]+v[i]</code> 表示装了第<code>i</code>个商品，背包容量减少<code>w(i)</code>但价值增加了<code>v(i)</code>。</p>
<h3 id="三、例题"><a href="#三、例题" class="headerlink" title="三、例题"></a>三、例题</h3><h4 id="3-1-经典背包"><a href="#3-1-经典背包" class="headerlink" title="3.1 经典背包"></a>3.1 经典背包</h4><h5 id="3-1-1-题目描述"><a href="#3-1-1-题目描述" class="headerlink" title="3.1.1 题目描述"></a>3.1.1 题目描述</h5><p>&ensp;&ensp;&ensp;&ensp;物品数量：4，背包容量：8，物品对应的体积和价值如下：</p>
<table>
<thead>
<tr>
<th align="center"><strong>i</strong></th>
<th align="center"><strong>1</strong></th>
<th align="center"><strong>2</strong></th>
<th align="center"><strong>3</strong></th>
<th align="center"><strong>4</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="center"><strong>w(体积)</strong></td>
<td align="center">2</td>
<td align="center">3</td>
<td align="center">4</td>
<td align="center">5</td>
</tr>
<tr>
<td align="center"><strong>v(价值)</strong></td>
<td align="center">3</td>
<td align="center">4</td>
<td align="center">5</td>
<td align="center">6</td>
</tr>
</tbody></table>
<h5 id="3-1-2-思路与代码"><a href="#3-1-2-思路与代码" class="headerlink" title="3.1.2 思路与代码"></a>3.1.2 思路与代码</h5><p>&ensp;&ensp;&ensp;&ensp;运用状态转移方程，可得下表：</p>
<table>
<thead>
<tr>
<th align="center">物品号\背包容量</th>
<th align="center">0</th>
<th align="center">1</th>
<th align="center">2</th>
<th align="center">3</th>
<th align="center">4</th>
<th align="center">5</th>
<th align="center">6</th>
<th align="center">7</th>
<th align="center">8</th>
</tr>
</thead>
<tbody><tr>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">0</td>
</tr>
<tr>
<td align="center">1</td>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">3</td>
<td align="center">3</td>
<td align="center">3</td>
<td align="center">3</td>
<td align="center">3</td>
<td align="center">3</td>
<td align="center">3</td>
</tr>
<tr>
<td align="center">2</td>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">3</td>
<td align="center">4</td>
<td align="center">4</td>
<td align="center">7</td>
<td align="center">7</td>
<td align="center">7</td>
<td align="center">7</td>
</tr>
<tr>
<td align="center">3</td>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">3</td>
<td align="center">4</td>
<td align="center">5</td>
<td align="center">7</td>
<td align="center">8</td>
<td align="center">8</td>
<td align="center">9</td>
</tr>
<tr>
<td align="center">4</td>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">3</td>
<td align="center">4</td>
<td align="center">5</td>
<td align="center">7</td>
<td align="center">8</td>
<td align="center">9</td>
<td align="center">10</td>
</tr>
</tbody></table>
<p>代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; ++j)  </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(j &gt;= w[i])</span><br><span class="line">          dp[i][j] = <span class="built_in">max</span>(dp[i - <span class="number">1</span>][j - w[i]] + v[i], dp[i<span class="number">-1</span>][j]);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">          dp[i][j] = dp[i<span class="number">-1</span>][j];           </span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">return</span> dp[n][m];</span><br></pre></td></tr></table></figure>

<h4 id="3-2-目标和"><a href="#3-2-目标和" class="headerlink" title="3.2 目标和"></a><a href="https://leetcode-cn.com/problems/target-sum/">3.2 目标和</a></h4><h5 id="3-2-1-题目描述"><a href="#3-2-1-题目描述" class="headerlink" title="3.2.1 题目描述"></a>3.2.1 题目描述</h5><p>&ensp;&ensp;&ensp;&ensp;给你一个整数数组 <code>nums</code> 和一个整数 <code>target</code> 。</p>
<p>&ensp;&ensp;&ensp;&ensp;向数组中的每个整数前添加 <code>&#39;+&#39;</code> 或 <code>&#39;-&#39;</code> ，然后串联起所有整数，可以构造一个 <strong>表达式</strong> ：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">例如，&#96;nums &#x3D; [2, 1]&#96; ，可以在 &#96;2&#96; 之前添加 &#96;&#39;+&#39;&#96; ，在 &#96;1&#96; 之前添加 &#96;&#39;-&#39;&#96; ，然后串联起来得到表达式 &#96;&quot;+2-1&quot;&#96; 。</span><br></pre></td></tr></table></figure>

<p>&ensp;&ensp;&ensp;&ensp;返回可以通过上述方法构造的、运算结果等于 <code>target</code> 的不同 <strong>表达式</strong> 的数目。</p>
<p> <strong>示例 1：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：nums &#x3D; [1,1,1,1,1], target &#x3D; 3</span><br><span class="line">输出：5</span><br><span class="line">解释：一共有 5 种方法让最终目标和为 3 。</span><br><span class="line">-1 + 1 + 1 + 1 + 1 &#x3D; 3</span><br><span class="line">+1 - 1 + 1 + 1 + 1 &#x3D; 3</span><br><span class="line">+1 + 1 - 1 + 1 + 1 &#x3D; 3</span><br><span class="line">+1 + 1 + 1 - 1 + 1 &#x3D; 3</span><br><span class="line">+1 + 1 + 1 + 1 - 1 &#x3D; 3</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：nums &#x3D; [1], target &#x3D; 1</span><br><span class="line">输出：1</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li>  <code>1 &lt;= nums.length &lt;= 20</code></li>
<li>  <code>0 &lt;= nums[i] &lt;= 1000</code></li>
<li>  <code>0 &lt;= sum(nums[i]) &lt;= 1000</code></li>
<li>  <code>-1000 &lt;= target &lt;= 100</code></li>
</ul>
<h5 id="3-2-2-思路与代码"><a href="#3-2-2-思路与代码" class="headerlink" title="3.2.2 思路与代码"></a>3.2.2 思路与代码</h5><p>&ensp;&ensp;&ensp;&ensp;（1）回溯算法，找子集加剪枝。</p>
<p>&ensp;&ensp;&ensp;&ensp;先计算所有元素的和，再减去部分子集和的2倍，若等于目标值，即为一个结果。（若子集和过大，就不必延当前路径继续找下去了）。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findTargetSumWays</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> S)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="built_in">accumulate</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>(), <span class="number">0</span>);</span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt; temp;</span><br><span class="line">        <span class="built_in">trackback</span>(nums, temp, <span class="number">0</span>, sum - S);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">trackback</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, vector&lt;<span class="keyword">int</span>&gt;&amp; temp, <span class="keyword">int</span> start, <span class="keyword">const</span> <span class="keyword">int</span> target)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">2</span> * <span class="built_in">accumulate</span>(temp.<span class="built_in">begin</span>(), temp.<span class="built_in">end</span>(), <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (target == sum)</span><br><span class="line">        &#123;</span><br><span class="line">            ++ans;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 若是</span></span><br><span class="line">        <span class="keyword">if</span> (target &lt; sum)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = start; i &lt; nums.<span class="built_in">size</span>(); ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            temp.<span class="built_in">push_back</span>(nums[i]);</span><br><span class="line">            <span class="built_in">trackback</span>(nums, temp, i + <span class="number">1</span>, target);</span><br><span class="line">            temp.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>&ensp;&ensp;&ensp;&ensp;时间复杂度：O(2^n^)，其中 n 是数组 nums 的长度。回溯需要遍历所有不同的表达式，共有 2^n^ 种不同的表达式，每种表达式计算结果需要 O(1) 的时间，因此总时间复杂度是 O(2^n^)。</p>
<p>&ensp;&ensp;&ensp;&ensp;空间复杂度：O(n)，其中 n 是数组 nums 的长度。空间复杂度主要取决于递归调用的栈空间，栈的深度不超过 n。</p>
<p>&ensp;&ensp;&ensp;&ensp;（2）动态规划，按 0-1 背包问题解法。</p>
<p>&ensp;&ensp;&ensp;&ensp;定义二维数组 <code>dp</code>，其中 <code>dp[i][j]</code> 表示在数组 <code>nums</code> 的前 <code>i </code>个数中选取元素，使得这些元素之和等于<code> j</code> 的方案数。假设数组 <code>nums</code> 的长度为 <code>n</code>，则最终答案为 <code>dp[n][neg]</code>。</p>
<p>&ensp;&ensp;&ensp;&ensp;当没有任何元素可以选取时，元素和只能是 0，对应的方案数是 1，因此动态规划的边界条件是：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">p[0][j] &#x3D; 1 ,j &#x3D; 0; p[0][j] &#x3D; 0, j !&#x3D; 0;</span><br></pre></td></tr></table></figure>

<p>遍历 <code>nums</code> 数组，对于每个元素（选或不选）：</p>
<ul>
<li><p>  若当前遍历的元素 <code>nums[i - 1]</code> 不选，则此时满足背包容量 <code>j</code> 的方法数不变，不进行任何操作；</p>
</li>
<li><p>  若当前遍历的元素 <code>nums[i - 1]</code> 选择，则此时背包容量减少了 <code>nums[i - 1]</code>，此时满足背包容量 <code>j</code> 的方法数，应该在 <code>dp[i - 1][j]</code> 的基础上加上背包容量为 <code>j − nums[i]</code> 时的方法数，即状态转移方程：<code>dp[i][j] = dp[i - 1][j] + dp[i - 1][j - nums[i - 1]]</code>;。</p>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findTargetSumWays</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> S)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="built_in">accumulate</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>(), <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">int</span> diff = sum - S;</span><br><span class="line">        <span class="keyword">if</span> (diff &lt; <span class="number">0</span> || diff % <span class="number">2</span> != <span class="number">0</span>) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> n = nums.<span class="built_in">size</span>(), neg = diff / <span class="number">2</span>;</span><br><span class="line">        vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">dp</span>(n + <span class="number">1</span>, vector&lt;<span class="keyword">int</span>&gt;(neg + <span class="number">1</span>));   </span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= neg; ++j)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (j &gt;= nums[i - <span class="number">1</span>])</span><br><span class="line">                &#123;</span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j] + dp[i - <span class="number">1</span>][j - nums[i - <span class="number">1</span>]];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n][neg];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h4 id="3-3-分割等和子集"><a href="#3-3-分割等和子集" class="headerlink" title="3.3 分割等和子集"></a>3.3 <a href="https://leetcode-cn.com/problems/partition-equal-subset-sum/">分割等和子集</a></h4><h5 id="3-3-1-题目描述"><a href="#3-3-1-题目描述" class="headerlink" title="3.3.1 题目描述"></a>3.3.1 题目描述</h5><p>&ensp;&ensp;&ensp;&ensp;给你一个 <strong>只包含正整数</strong> 的 <strong>非空</strong> 数组 <code>nums</code> 。请你判断是否可以将这个数组分割成两个子集，使得两个子集的元素和相等。</p>
<p> <strong>示例 1：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：nums &#x3D; [1,5,11,5]</span><br><span class="line">输出：true</span><br><span class="line">解释：数组可以分割成 [1, 5, 5] 和 [11] 。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：nums &#x3D; [1,2,3,5]</span><br><span class="line">输出：false</span><br><span class="line">解释：数组不能分割成两个元素和相等的子集。</span><br></pre></td></tr></table></figure>

<p> <strong>提示：</strong></p>
<ul>
<li>  <code>1 &lt;= nums.length &lt;= 200</code></li>
<li>  <code>1 &lt;= nums[i] &lt;= 100</code></li>
</ul>
<h5 id="3-3-2-思路和代码"><a href="#3-3-2-思路和代码" class="headerlink" title="3.3.2 思路和代码"></a>3.3.2 思路和代码</h5><p>    作为「0-1 背包问题」，它的特点是：「每个数只能用一次」。解决的基本思路是：物品一个一个选，容量也一点一点增加去考虑，这一点是「动态规划」的思想，特别重要。<br>在实际生活中，我们也是这样做的，一个一个地尝试把候选物品放入「背包」，通过比较得出一个物品要不要拿走。</p>
<p>    具体做法是：画一个 len 行，target + 1 列的表格。这里 len 是物品的个数，target 是背包的容量。len 行表示一个一个物品考虑，target + 1多出来的那 1 列，表示背包容量从 0 开始考虑。很多时候，我们需要考虑这个容量为 0 的数值。</p>
<p><strong>状态与状态转移方程</strong></p>
<p>    状态定义：dp[i][j]表示从数组的 [0, i] 这个子区间内挑选一些正整数，每个数只能用一次，使得这些数的和恰好等于 j。</p>
<p>    状态转移方程：很多时候，状态转移方程思考的角度是「分类讨论」，对于「0-1 背包问题」而言就是「当前考虑到的数字选与不选」。</p>
<ul>
<li>  不选择 nums[i]，如果在 [0, i - 1] 这个子区间内已经有一部分元素，使得它们的和为 j ，那么 dp[i][j] = true；</li>
<li>  选择 nums[i]，如果在 [0, i - 1] 这个子区间内就得找到一部分元素，使得它们的和为 j - nums[i]。</li>
</ul>
<p><strong>状态转移方程：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">dp[i][j] = dp[i - <span class="number">1</span>][j] <span class="keyword">or</span> dp[i - <span class="number">1</span>][j - nums[i]]</span><br></pre></td></tr></table></figure>

<p>    一般写出状态转移方程以后，就需要考虑初始化条件。</p>
<p>    j - nums[i] 作为数组的下标，一定得保证大于等于 0 ，因此 nums[i] &lt;= j；</p>
<p>    注意到一种非常特殊的情况：j 恰好等于 nums[i]，即单独 nums[j] 这个数恰好等于此时「背包的容积」 j，这也是符合题意的。</p>
<p>因此完整的状态转移方程是：</p>
<p><img src="/2021/06/12/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%EF%BC%9A0-1%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/1.png" alt="image-20210612010526469"></p>
<p>    说明：虽然写成花括号，但是它们的关系是 或者 。</p>
<p>    初始化：dp[0][0] = false，因为候选数 nums[0] 是正整数，凑不出和为 0；</p>
<p>    输出：dp[len][target]，这里 len 表示数组的长度，target 是数组的元素之和（必须是偶数）的一半。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">canPartition</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> maxValue = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span>&amp; i : nums)</span><br><span class="line">        &#123;</span><br><span class="line">            maxValue = maxValue &gt; i ? maxValue : i;</span><br><span class="line">            sum += i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 排除一些特殊的情况</span></span><br><span class="line">        <span class="keyword">if</span> (sum % <span class="number">2</span> == <span class="number">1</span> || maxValue * <span class="number">2</span> &gt; sum)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> target = sum / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">int</span> numsLength = nums.<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;vector&lt;<span class="keyword">bool</span>&gt;&gt; <span class="built_in">dp</span>(numsLength + <span class="number">1</span>, vector&lt;<span class="keyword">bool</span>&gt;(target + <span class="number">1</span>));</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= numsLength; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            dp[i][<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= numsLength; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= target; ++j)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums[i - <span class="number">1</span>] &lt;= j)</span><br><span class="line">                &#123;</span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j] || dp[i - <span class="number">1</span>][j - nums[i - <span class="number">1</span>]];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;        </span><br><span class="line">        <span class="keyword">return</span> dp[numsLength][target];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>    进一步优化：上述代码的空间复杂度是 <code>O(n*target)</code>。但是可以发现在计算 <code>dp</code> 的过程中，每一行的 <code>dp</code> 值都只与上一行的 <code>dp</code> 值有关，因此只需要一个一维数组即可将空间复杂度降到 <code>O(target)</code>。此时的转移方程为：</p>
<p><img src="/2021/06/12/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%EF%BC%9A0-1%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/2.png" alt="image-20210612010707868"></p>
<p>    且需要注意的是第二层的循环我们需要从大到小计算，因为如果我们从小到大更新 <code>dp</code> 值，那么在计算 <code>dp[j]</code> 值的时候，<code>dp[j−nums[i - 1]]</code> 已经是被更新过的状态，不再是上一行的 <code>dp</code> 值。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">canPartition</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> maxValue = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span>&amp; i : nums)</span><br><span class="line">        &#123;</span><br><span class="line">            maxValue = maxValue &gt; i ? maxValue : i;</span><br><span class="line">            sum += i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (sum % <span class="number">2</span> == <span class="number">1</span> || maxValue * <span class="number">2</span> &gt; sum)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> target = sum / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">int</span> numsLength = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">bool</span>&gt; <span class="title">dp</span><span class="params">(target + <span class="number">1</span>)</span></span>;</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= numsLength; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = target; j &gt;= nums[i - <span class="number">1</span>]; --j)</span><br><span class="line">            &#123;</span><br><span class="line">                dp[j] = dp[j] || dp[j - nums[i - <span class="number">1</span>]];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;        </span><br><span class="line">        <span class="keyword">return</span> dp[target];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<p><a href="https://blog.csdn.net/yandaoqiusheng/article/details/84782655">背包九讲——全篇详细理解与代码实现_良月澪二的博客-CSDN博客</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/139368825">dd大牛的《背包九讲》 - 知乎 </a></p>
]]></content>
      <categories>
        <category>算法</category>
        <category>动态规划</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>leetcode</tag>
        <tag>动态规划</tag>
        <tag>背包问题</tag>
      </tags>
  </entry>
  <entry>
    <title>根据身高重建队列</title>
    <url>/2021/06/12/%E7%AE%97%E6%B3%95%EF%BC%9A%E6%A0%B9%E6%8D%AE%E8%BA%AB%E9%AB%98%E9%87%8D%E5%BB%BA%E9%98%9F%E5%88%97/</url>
    <content><![CDATA[<h3 id="一、题目描述"><a href="#一、题目描述" class="headerlink" title="一、题目描述"></a>一、题目描述</h3><p>    假设有打乱顺序的一群人站成一个队列，数组 <code>people</code> 表示队列中一些人的属性（不一定按顺序）。每个 <code>people[i] = [hi, ki]</code> 表示第 <code>i</code> 个人的身高为 <code>hi</code> ，前面 <strong>正好</strong> 有 <code>ki</code> 个身高大于或等于 <code>hi</code> 的人。</p>
<p>    请你重新构造并返回输入数组 <code>people</code> 所表示的队列。返回的队列应该格式化为数组 <code>queue</code> ，其中 <code>queue[j] = [hj, kj]</code> 是队列中第 <code>j</code> 个人的属性（<code>queue[0]</code> 是排在队列前面的人）。</p>
<span id="more"></span>

<p> <strong>示例 1：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：people &#x3D; [[7,0],[4,4],[7,1],[5,0],[6,1],[5,2]]</span><br><span class="line">输出：[[5,0],[7,0],[5,2],[6,1],[4,4],[7,1]]</span><br><span class="line">解释：</span><br><span class="line">编号为 0 的人身高为 5 ，没有身高更高或者相同的人排在他前面。</span><br><span class="line">编号为 1 的人身高为 7 ，没有身高更高或者相同的人排在他前面。</span><br><span class="line">编号为 2 的人身高为 5 ，有 2 个身高更高或者相同的人排在他前面，即编号为 0 和 1 的人。</span><br><span class="line">编号为 3 的人身高为 6 ，有 1 个身高更高或者相同的人排在他前面，即编号为 1 的人。</span><br><span class="line">编号为 4 的人身高为 4 ，有 4 个身高更高或者相同的人排在他前面，即编号为 0、1、2、3 的人。</span><br><span class="line">编号为 5 的人身高为 7 ，有 1 个身高更高或者相同的人排在他前面，即编号为 1 的人。</span><br><span class="line">因此 [[5,0],[7,0],[5,2],[6,1],[4,4],[7,1]] 是重新构造后的队列。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：people &#x3D; [[6,0],[5,0],[4,0],[3,2],[2,2],[1,4]]</span><br><span class="line">输出：[[4,0],[5,0],[2,2],[3,2],[1,4],[6,0]]</span><br></pre></td></tr></table></figure>

<p> <strong>提示：</strong></p>
<ul>
<li>  <code>1 &lt;= people.length &lt;= 2000</code></li>
<li>  <code>0 &lt;= hi &lt;= 106</code></li>
<li>  <code>0 &lt;= ki &lt; people.length</code></li>
<li>  题目数据确保队列可以被重建</li>
</ul>
<h3 id="二、思路和代码"><a href="#二、思路和代码" class="headerlink" title="二、思路和代码"></a>二、思路和代码</h3><p>    重新排序，矮的放后面，因为矮的即使放在了高的前面，也不会对之前高的产生影响。但高的放在前面，对矮的结果就会产生影响了。</p>
<p>    身高相同，个数小的在前面，因为相同的身高，后面的个数肯定要大。</p>
<p>身高相同，按照个数升序排序；身高不同，按照身高降序排列</p>
<p>    排序后：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[ 7, 0 ], [ 7, 1 ], [ 6, 1 ], [ 5, 0 ], [ 5, 2 ], [ 4, 4 ]</span><br></pre></td></tr></table></figure>

<p>    第二个数字作为索引位置，把数组放在目标索引位置上。如果原来有数了，会被往后挤</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[[7, 0]]</span><br><span class="line"></span><br><span class="line">[[7, 0], [7, 1]]</span><br><span class="line"></span><br><span class="line">[[7, 0], [6, 1], [7, 1]]</span><br><span class="line"></span><br><span class="line">[[5, 0], [7, 0], [6, 1], [7, 1]]</span><br><span class="line"></span><br><span class="line">[[5, 0], [7, 0], [5, 2], [6, 1], [7, 1]]</span><br><span class="line"></span><br><span class="line">[[5, 0], [7, 0], [5, 2], [6, 1], [4, 4], [7, 1]]</span><br></pre></td></tr></table></figure>



<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">reconstructQueue</span>(vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; people) </span><br><span class="line">    &#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; ans;</span><br><span class="line">        <span class="built_in">sort</span>(people.<span class="built_in">begin</span>(), people.<span class="built_in">end</span>(),</span><br><span class="line">             [](<span class="keyword">const</span> vector&lt;<span class="keyword">int</span>&gt;&amp; a, <span class="keyword">const</span> vector&lt;<span class="keyword">int</span>&gt;&amp; b)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span> ((a[<span class="number">0</span>] &gt; b[<span class="number">0</span>]) || (a[<span class="number">0</span>] == b[<span class="number">0</span>] &amp;&amp; a[<span class="number">1</span>] &lt; b[<span class="number">1</span>]))</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                    <span class="keyword">else</span> </span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> vector&lt;<span class="keyword">int</span>&gt;&amp; person: people) </span><br><span class="line">        &#123;</span><br><span class="line">            ans.<span class="built_in">insert</span>(ans.<span class="built_in">begin</span>() + person[<span class="number">1</span>], person);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><a href="https://leetcode-cn.com/problems/queue-reconstruction-by-height/">题目链接</a></p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>leetcode</tag>
        <tag>排序</tag>
        <tag>lambda表达式</tag>
      </tags>
  </entry>
  <entry>
    <title>最大正方形</title>
    <url>/2021/06/12/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%EF%BC%9A%E6%9C%80%E5%A4%A7%E6%AD%A3%E6%96%B9%E5%BD%A2/</url>
    <content><![CDATA[<h3 id="一、题目"><a href="#一、题目" class="headerlink" title="一、题目"></a>一、题目</h3><p>&ensp;&ensp;&ensp;&ensp;在一个由 <code>&#39;0&#39;</code> 和 <code>&#39;1&#39;</code> 组成的二维矩阵内，找到只包含 <code>&#39;1&#39;</code> 的最大正方形，并返回其面积。</p>
<span id="more"></span>

<p> <strong>示例 1：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1  0  1  0  0 </span><br><span class="line">1  0  1  1  1 </span><br><span class="line">1  1  1  1  1 </span><br><span class="line">1  0  0  1  0</span><br></pre></td></tr></table></figure>

<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">输入：matrix = [[&quot;1&quot;,&quot;0&quot;,&quot;1&quot;,&quot;0&quot;,&quot;0&quot;],[&quot;1&quot;,&quot;0&quot;,&quot;1&quot;,&quot;1&quot;,&quot;1&quot;],[&quot;1&quot;,&quot;1&quot;,&quot;1&quot;,&quot;1&quot;,&quot;1&quot;],[&quot;1&quot;,&quot;0&quot;,&quot;0&quot;,&quot;1&quot;,&quot;0&quot;]]</span><br><span class="line">输出：4</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0  1 </span><br><span class="line">1  0</span><br></pre></td></tr></table></figure>

<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">输入：matrix = [[&quot;0&quot;,&quot;1&quot;],[&quot;1&quot;,&quot;0&quot;]]</span><br><span class="line">输出：1</span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">输入：matrix = [[&quot;0&quot;]]</span><br><span class="line">输出：0</span><br></pre></td></tr></table></figure>


<p>提示：</p>
<ul>
<li>  m == matrix.length</li>
<li>  n == matrix[i].length</li>
<li>  1 &lt;= m, n &lt;= 300</li>
<li>  matrix[i][j] 为 ‘0’ 或 ‘1’</li>
</ul>
<h3 id="二、思路与代码"><a href="#二、思路与代码" class="headerlink" title="二、思路与代码"></a>二、思路与代码</h3><p>&ensp;&ensp;&ensp;&ensp;我们用 dp[i][j] 表示以 (i, j)为右下角，且只包含 1 的正方形的边长最大值。如果我们能计算出所有 dp[i][j] 的值，那么其中的最大值即为矩阵中只包含 1 的正方形的边长最大值，其平方即为最大正方形的面积。</p>
<p>那么如何计算 dp 中的每个元素值？对于每个位置 (i,j)，检查在矩阵中该位置的值：</p>
<ul>
<li><p>  如果该位置的值是 0，则  dp[i][j] =0，因为当前位置不可能在由 1 组成的正方形中；</p>
</li>
<li><p>如果该位置的值是 1，则  dp[i][j]  的值由其上方、左方和左上方的三个相邻位置的 dp 值决定。具体而言，当前位置的元素值等于三个相邻位置的元素中的最小值加 1，状态转移方程如下：</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dp(i, j) &#x3D; min(dp(i − 1, j), dp(i − 1, j − 1), dp(i, j − 1)) + 1</span><br></pre></td></tr></table></figure></li>
</ul>
<p>代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maximalSquare</span><span class="params">(vector&lt;vector&lt;<span class="keyword">char</span>&gt;&gt;&amp; matrix)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (matrix.<span class="built_in">size</span>() == <span class="number">0</span> || matrix[<span class="number">0</span>].<span class="built_in">size</span>() == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> row = matrix.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> col = matrix[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">dp</span>(row, vector&lt;<span class="keyword">int</span>&gt;(col));</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; row; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; col; ++j)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (matrix[i][j] == <span class="string">&#x27;0&#x27;</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (i == <span class="number">0</span> || j == <span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    dp[i][j] = <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    dp[i][j] = <span class="built_in">min</span>(&#123;dp[i - <span class="number">1</span>][j - <span class="number">1</span>], dp[i - <span class="number">1</span>][j], dp[i][j - <span class="number">1</span>]&#125;) + <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                ans = ans &gt; dp[i][j] ? ans : dp[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans * ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法</category>
        <category>动态规划</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>leetcode</tag>
        <tag>动态规划</tag>
        <tag>矩形</tag>
      </tags>
  </entry>
</search>
